// Enhanced Pseudocode for OREGON.EXE with Control Flow and Data Flow Analysis
// Generated with Capstone-based disassembler

// Function declarations
void entry(int, int, int);
int entry(int, int, int);
void sub_102B1(int);
void sub_106BF(int);
void sub_10BCD(int);
void sub_10DC0(int, int);
void sub_10E6D(int, int);
void sub_10E93(void);
void sub_10ECE(int);
void sub_110C1(int);
void sub_11249(int);
void sub_114B2(int);
void sub_114F8(int);
void sub_11576(int);
void sub_117C2(int, int, int);
void sub_1183C(int);
void sub_1193C(int);
void sub_11A23(int);
void sub_11A48(void);
void sub_11A68(int);
void sub_11D00(int);
void sub_11DD9(int);
void sub_11E61(int);
void sub_12166(int);
void sub_12524(int);
void sub_12580(int);
void sub_14286(int);
void sub_1485A(int);
void sub_14D0E(int);
void sub_14E1F(int);
void sub_15048(int);
void sub_15454(int);
void sub_154D0(int);
void sub_156C6(int);
void sub_15798(int);
void sub_15AB6(int);
void sub_15E6E(int);
void sub_16504(int);
void sub_177DA(int);
void sub_17F32(int);
void sub_1867D(int);
void sub_18B44(int);
void sub_19038(int);
void sub_19831(int);
void sub_19B03(int, int);
void sub_19D41(int);
void sub_19F12(int);
void sub_1A25E(int);
void sub_1A2DE(int);
void sub_1A78A(int, int, int);
void sub_1A878(int);
void sub_1A97C(int);
void sub_1ABE3(int);
void sub_1AD1A(void);
void sub_1AE4A(int);
void sub_1AEBF(void);
void sub_1AECB(int);
void sub_1AF10(int, int);
void sub_1AF6D(int, int);
void sub_1AF95(int, int);
void sub_1AFA5(int);
void sub_1B025(int, int);
void sub_1B0F2(int, int);
void sub_1B12B(int, int);
void sub_1B170(int, int, int, int);
void sub_1B264(int, int);
void sub_1B2AE(void);
void sub_1B329(void);
void sub_1B341(int);
int sub_1B37C(int, int, int);
void sub_1B39D(int, int, int, int);
void sub_1B3BB(int, int, int);
void sub_1B3EE(int, int, int);
void sub_1B43F(int);
void sub_1B45D(void);
void sub_1B469(int);
void sub_1B48F(int);
void sub_1B4AB(int);
int sub_1B4B7(int, int);
void sub_1D57(void);
void sub_1D6A(void);
void sub_1D6B(int, int);
void sub_1D7D(int, int);
void sub_1DC0(int);
void sub_1DED(int, int, int, int);
void sub_1E31(int, int);
void sub_1E72(int, int, int, int);
void sub_1F91(int);
void sub_2128(int);
void sub_2495(void);
void sub_2827(void);
void sub_2A03(void);
void sub_2A40(int, int);
void sub_2A52(int, int);
void sub_2A69(int);
void sub_2AC0(int);
void sub_2ACF(int);
void sub_2B2E(void);
void sub_2B71(int, int);
void sub_2C9B(int, int);
void sub_2CBC(void);
void sub_2D1C(int);
void sub_2D44(void);
void sub_2D7D(int);
void sub_2F4E(int, int);
void sub_2F5F(int);
void sub_2FE1(int);
void sub_3001(int, int, int);
void sub_302A(int);
void sub_30E0(int);
void sub_30F7(int);
void sub_3118(int, int);
void sub_3147(void);
void sub_315B(void);
void sub_32DA(int);
void sub_32F5(int, int);
void sub_3319(int, int, int);
void sub_33BE(void);
void sub_363B(int);
void sub_3666(void);
void sub_3808(int, int);
void sub_3905(void);
void sub_391D(void);
void sub_3924(void);
void sub_392D(void);
void sub_3935(void);
void sub_394F(int);
void sub_395C(void);
void sub_3965(int, int, int, int);
void sub_3DF8(int, int);
void sub_3E1D(int, int);
void sub_3E97(int);
void sub_3EF4(int);
void sub_3F21(void);
void sub_3F2F(int);
void sub_3FD7(void);
void sub_40C4(int, int);
int sub_4127(int, int);
void sub_4198(int);
void sub_41C1(int, int);
void sub_41F8(int);
void sub_4221(int, int);
void sub_4285(int, int);
void sub_42DF(int, int, int);
int sub_4302(int);
void sub_430C(int, int, int);
void sub_4389(int);
void sub_4405(int, int);
void sub_44EA(void);
void sub_4560(int, int, int, int);
void sub_459F(int);
void sub_467A(void);
void sub_46D0(void);
void sub_4754(int);
void sub_47B4(int, int);
void sub_47EF(void);
void sub_488C(void);
void sub_4890(void);
void sub_4894(void);
void sub_4898(void);
void sub_489C(int, int);
void sub_48D4(int, int);
void sub_4908(int);
void sub_49D2(int);
void sub_4A0E(int, int, int);
void sub_4A63(int, int, int);
void sub_4A85(void);
int sub_4C86(void);
void sub_4D1C(int, int);
void sub_4D38(int, int);
void sub_4D9B(void);
void sub_4E21(int);
void sub_4E3E(int, int, int);
void sub_4E66(int);
void sub_4E84(int, int);
void sub_4EFB(int, int);
void sub_4FB3(int);
void sub_50E0(void);
void sub_5122(int);
void sub_51DE(int);
void sub_52AF(int, int);
void sub_534A(int, int);
void sub_54CC(int, int);
void sub_554E(int);
void sub_5739(int, int);
void sub_5777(int, int, int);
void sub_57EF(int, int);
void sub_5807(int, int);
void sub_59FF(int, int);
void sub_5A23(int);
void sub_5A3E(int);
void sub_5A50(int);
void sub_5BBF(int);
void sub_5C29(int, int);
void sub_5C45(int, int);
void sub_5DEE(int);
void sub_5FF1(int);
void sub_60C5(int, int);
void sub_61E2(int);
void sub_623B(int);
void sub_629B(int);
void sub_65B8(int, int);
void sub_65F7(int);
void sub_6661(int);
void sub_6680(int, int);
void sub_679C(int);
void sub_68ED(int, int);
void sub_70A0(int);
void sub_715E(int);
void sub_7229(int);
void sub_731C(int, int);
void sub_7353(int);
void sub_7426(int);
void sub_74D9(int);
void sub_756A(int);
void sub_7678(int);
void sub_770A(int);
void sub_7A56(int);
void sub_8346(int);
void sub_85ED(int);
void sub_8791(int);
void sub_893A(int);
void sub_901A(int, int);
void sub_987E(int, int);
void sub_9EBD(int);
void sub_9F7D(int);
void sub_A70D(int, int);
void sub_AE16(int);
void sub_AE65(int);
void sub_AFB5(int);
void sub_B00C(int);
void sub_B316(int);
void sub_B350(int, int);
void sub_B4EC(int);
void sub_B586(int);
void sub_B5BF(int);
void sub_B60A(int);
void sub_B66A(int);
void sub_B6A8(int);
void sub_B995(int, int);
void sub_BFC3(int, int);
void sub_C3B3(int, int);
void sub_CA9B(int);
void sub_CB80(void);
void sub_CBCF(int);
void sub_CBE1(int, int);
void sub_CC23(int);
void sub_CC40(void);
void sub_CC7A(int);
void sub_D552(int);
void sub_DA6E(int);
void sub_DE14(int);
void sub_DFD5(int);
void sub_E3A5(int, int);
void sub_E3CC(int);
void sub_E4E0(int);
void sub_E58D(int, int);
void sub_E9D0(int, int);
void sub_ECFD(int, int);
void sub_ED11(int, int, int);
void sub_ED84(int);
void sub_EFFC(int);
void sub_F03C(int);
void sub_F100(int);
void sub_F40D(int, int);
void sub_F5DB(int, int);
void sub_F768(int);
void sub_F8C1(int);

void entry(int, int, int) {
    // Purpose: Allocates memory and performs calculations

    // Complexity: 11

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x3E
    $1 = $2;
    mov word ptr cs:[0x291], dx;
    $1 = $2;
    INT_21_AH30();  // int 0x21
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    call 0x1d7d;
    // Block 0x1C28
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;

    // Function calls:
    sub_1D7D(); // Unknown function purpose
    sub_1DED(); // Performs arithmetic calculations
    sub_2AC0(); // Unknown function purpose
}

int entry(int, int, int) {
    // Purpose: Opens a file and manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int data_dx; // from parameter 3

    $1 = $2;
    mov word ptr cs:[0x291], dx;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    repne scasb al, byte ptr es:[di]; // Check if values are not equal
    jcxz 0x1c7e; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp byte ptr es:[di], al; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or ch, 0x80; // Bitwise OR
    neg cx; // Negate value
    *($1) = $2;
    $1 = $2;
    shl bx, cl; // Shift left
    $1 += $2; // Add values
    and bx, 0xfff0; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x1c75; // Jump if above or equal (unsigned)
    $1 = $2;
    mov word ptr es:[0x94], di;
    $1 = $2;
    shr di, cl; // Shift right (unsigned)
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    jae 0x1c81; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    shl di, cl; // Shift left
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    sti ; // Set interrupt flag
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x94], di;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    cld ; // Clear direction flag
    rep stosb byte ptr es:[di], al; // Fill memory block
    cmp word ptr [0x74d0], 0x14; // Compare values
    jbe 0x1d0c; // Jump if below or equal (unsigned)
    cmp byte ptr [0x7d], 3; // Compare values
    jb 0x1d0c; // Jump if below (unsigned)
    ja 0x1cd5; // Jump if above (unsigned)
    cmp byte ptr [0x7e], 0x1e; // Compare values
    jb 0x1d0c; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x1d09; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x1d09; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x1d09; // Jump if below (unsigned)
    $1++; // Increment value
    *($1) = $2; // Free memory (DOS)
    $1--; // Decrement value; Free memory (DOS)
    $1 = $2; // Free memory (DOS)
    $1 = $2; // Free memory (DOS)
    int 0x21; // Call interrupt
    jb 0x1d09; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x1d0c; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    int 0x1a; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    or al, al; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], 1;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x4e6, 8;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    int 0x21; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [0x5b];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [0x5f];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [0x63];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [0x67];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[bx], 0xff; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jae 0x1e0c; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    cmp byte ptr es:[bx], 0; // Compare values
    mov byte ptr es:[bx], 0xff;
    push($1); // Push value onto stack
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall es:[bx + 2];
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    ret ; // Return from function
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[bx], 0xff; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cmp byte ptr es:[bx + 1], ah; // Compare values
    jb 0x1e4d; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    cmp byte ptr es:[bx], 0; // Compare values
    mov byte ptr es:[bx], 0xff;
    push($1); // Push value onto stack
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall es:[bx + 2];
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    ret ; // Return from function
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    ret ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    add byte ptr [bx + si], al; // Add values
    $1 += $2; // Add values
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = $2;
    int 0x66; // Call interrupt
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    stosb byte ptr es:[di], al; // Store string byte/word
    $1++; // Increment value
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [bp + 6];
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1(); // Call function
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    lds si, ptr [si];
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp word ptr [si], 0x494d; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp word ptr [si + 2], 0x4944; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    $1 = $2;
    int 0x66; // Call interrupt
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp word ptr [si], 0x454b; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp word ptr [si + 2], 0x4e52; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bp + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    $1 += $2; // Add values
    add byte ptr [bx + si], al; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les dx, ptr [bp + 6];
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr cs:[0x3e7], ax;
    mov word ptr cs:[0x3e9], dx;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp byte ptr es:[3], 0x44; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[4], 0x49; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[5], 0x47; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[6], 0x50; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[7], 0x41; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[8], 0x4b; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    mov word ptr cs:[0x3ef], ax;
    mov word ptr cs:[0x3f3], ax;
    lcall cs:[0x3ed];
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = 0; // Bitwise XOR; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a10, 0x34; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    mov word ptr cs:[0x3eb], ax;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr cs:[0x3eb], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    lcall cs:[0x3f1]; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a10, 0x34; // Call function and clean up stack
    $1 += $2; // Add values
    mov word ptr cs:[0x3eb], 0;
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1(); // Call function
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    lds si, ptr [si];
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp word ptr [si], 0x494d; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp word ptr [si + 2], 0x4944; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    $1 = $2;
    int 0x66; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bp + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    $1 += $2; // Add values
    add byte ptr [bx + si], al; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les dx, ptr [bp + 6];
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr cs:[0x5ae], ax;
    mov word ptr cs:[0x5b0], dx;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp byte ptr es:[3], 0x4d; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[4], 0x49; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[5], 0x44; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[6], 0x50; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[7], 0x41; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    nop ; // No operation; Check if values are not equal
    cmp byte ptr es:[8], 0x4b; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    mov word ptr cs:[0x5b6], ax;
    mov word ptr cs:[0x5ba], ax;
    lcall cs:[0x5b4];
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = 0; // Bitwise XOR; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a10, 0x34; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    mov word ptr cs:[0x5b2], ax;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr cs:[0x5b2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    lcall cs:[0x5b8]; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a10, 0x34; // Call function and clean up stack
    $1 += $2; // Add values
    mov word ptr cs:[0x5b2], 0;
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds dx, ptr [bp + 6];
    $1 = $2;
    or al, al; // Bitwise OR; Open file (DOS)
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Open file (DOS)
    $1 = 0; // Bitwise XOR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    jb 0x230a; // Jump if below (unsigned); Open file (DOS)
    jae 0x22d9; // Jump if above or equal (unsigned); Open file (DOS)
    $1 = $2; // Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    jb 0x230a; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    jb 0x230a; // Jump if below (unsigned)
    lds di, ptr [bp + 0xa];
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    jcxz 0x22f7;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    jb 0x230a; // Jump if below (unsigned)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x2322; // Jump if below (unsigned)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x234e; // Jump if below (unsigned)
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    lds dx, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 0xc], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values; Read from file (DOS)
    jbe 0x2371; // Jump if below or equal (unsigned); Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Check if values are not equal
    int 0x21; // Call interrupt; Check if values are not equal
    jb 0x23ab; // Jump if below (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    sub word ptr [bp + 0xa], cx; // Subtract values
    sbb word ptr [bp + 0xc], 0;
    $1 = $2;
    and ax, 0xf; // Bitwise AND
    $1 += $2; // Add values
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp + 0xc], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    lds dx, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 0xc], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values; Write to file (DOS)
    jbe 0x23cf; // Jump if below or equal (unsigned); Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Check if values are not equal
    int 0x21; // Call interrupt; Check if values are not equal
    jb 0x2409; // Jump if below (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    sub word ptr [bp + 0xa], cx; // Subtract values
    sbb word ptr [bp + 0xc], 0;
    $1 = $2;
    and ax, 0xf; // Bitwise AND
    $1 += $2; // Add values
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp + 0xc], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Open file (DOS)
    lds dx, ptr [bp + 6]; // Open file (DOS)
    $1 = 0; // Bitwise XOR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    jb 0x248c; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    jb 0x2488; // Jump if below (unsigned)
    lds di, ptr [bp + 0xa];
    or di, di; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a10, 0x2f; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    int 0x21; // Call interrupt; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values; Close file (DOS)
    $1 = $2; // Close file (DOS)
    goto $1; // Jump to address; Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Close file (DOS)
    $1 = pop(); // Pop value from stack; Close file (DOS)
    retf ; // Return from function; Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Open file (DOS)
    lds dx, ptr [bp + 6]; // Open file (DOS)
    $1 = 0; // Bitwise XOR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    jae 0x24ab; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    jb 0x2532; // Jump if below (unsigned)
    lds di, ptr [bp + 0xa];
    or di, di; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, 0; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a10, 0x2f; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2; // Read from file (DOS)
    $1 += $2; // Add values; Read from file (DOS)
    and dx, 0xfff0; // Bitwise AND; Check if values are not equal
    $1 = $2; // Check if values are not equal
    int 0x21; // Call interrupt; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values; Close file (DOS)
    $1 = $2; // Close file (DOS)
    goto $1; // Jump to address; Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    lds bx, ptr [bp + 0xe];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Close file (DOS)
    $1 = pop(); // Pop value from stack; Close file (DOS)
    retf ; // Return from function; Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x16; // Call interrupt
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    retf ; // Return from function
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    lodsb al, byte ptr [si]; // Load string byte/word
    stosb byte ptr es:[di], al; // Store string byte/word
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    $1--; // Decrement value
    lds si, ptr [bp + 0xa];
    lodsb al, byte ptr [si]; // Load string byte/word
    stosb byte ptr es:[di], al; // Store string byte/word
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Allocate memory (DOS)
    $1 = $2; // Allocate memory (DOS)
    $1++; // Increment value; Allocate memory (DOS)
    $1 = $2; // Allocate memory (DOS)
    int 0x21; // Call interrupt
    jae 0x25c2; // Jump if above or equal (unsigned)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Free memory (DOS)
    $1 = $2; // Free memory (DOS)
    $1 = $2; // Free memory (DOS)
    $1 = $2; // Free memory (DOS)
    int 0x21; // Call interrupt
    jae 0x25da; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [bp + 6];
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    or al, al; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    cli ; // Clear interrupt flag
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    out 0x43, al; // Output to port
    goto $1; // Jump to address
    $1 = $2;
    out 0x40, al; // Output to port
    goto $1; // Jump to address
    $1 = $2;
    out 0x40, al; // Output to port
    sti ; // Set interrupt flag
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lds dx, ptr [bp + 6];
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x264d; // Jump if above or equal (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1 = $2;
    $1--; // Decrement value
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = 0; // Bitwise XOR
    lds si, ptr [bp + 6];
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    // Compare $1 with $2 // Compare values
    jl 0x2696; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x2696; // Jump if greater (signed)
    $1 -= $2; // Subtract values
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x268b; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    repe cmpsb byte ptr [si], byte ptr es:[di];
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Open file (DOS)
    lds dx, ptr [bp + 6]; // Open file (DOS)
    $1 = 0; // Bitwise XOR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt; Close file (DOS)
    jb 0x26ec; // Jump if below (unsigned); Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    lds si, ptr [bp + 0xc]; // Check if values are not equal
    cmp word ptr [bp + 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    $1 = $2;
    push($1); // Push value onto stack; Initialize counter for string operation
    $1 = pop(); // Pop value from stack; Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    neg cx; // Negate value
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    js 0x2784;
    // Compare $1 with $2 // Compare values
    jg 0x2784; // Jump if greater (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jg 0x2784; // Jump if greater (signed)
    or ax, ax; // Bitwise OR
    jns 0x2745;
    neg ax; // Negate value
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    sub word ptr [bp + 0xa], ax; // Subtract values
    js 0x2784;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp + 6], 0;
    $1 += $2; // Add values
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jle 0x2756; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values
    sub word ptr [bp + 0xa], ax; // Subtract values
    js 0x2784;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp + 8]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    or al, al; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stosw word ptr es:[di], ax; // Store string byte/word
    loop 0x2776; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    rep stosw word ptr es:[di], ax; // Fill memory block
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = $2;
    mul word ptr [bp + 8]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    stosb byte ptr es:[di], al; // Store string byte/word
    $1++; // Increment value
    loop 0x27af; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    lds si, ptr [bp + 0xa]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    shl ax, 1; // Shift left
    rcl dx, 1;
    shl ax, 1; // Shift left
    rcl dx, 1;
    shl ax, 1; // Shift left
    rcl dx, 1;
    shl ax, 1; // Shift left
    rcl dx, 1;
    $1 += $2; // Add values
    adc dx, 0;
    $1 += $2; // Add values
    adc dx, word ptr [bp + 0xc];
    push($1); // Push value onto stack
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    and ax, 0xf; // Bitwise AND
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    les di, ptr [bp + 6];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    int 0x21; // Call interrupt
    $1 += $2; // Add values
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1--; // Decrement value
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x28b7; // Jump if greater or equal (signed)
    repne scasb al, byte ptr es:[di];
    scasb al, byte ptr es:[di];
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg ah, al; // Exchange values
    scasb al, byte ptr es:[di];
    xchg ah, al; // Exchange values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    scasb al, byte ptr es:[di];
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    push($1); // Push value onto stack; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    stosb byte ptr es:[di], al; // Store string byte/word; Initialize counter for string operation
    $1 = pop(); // Pop value from stack; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    std ; // Set direction flag
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    cld ; // Clear direction flag
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les ax, ptr [bp + 6]; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    stosb byte ptr es:[di], al; // Store string byte/word
    $1++; // Increment value
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    lds si, ptr [bp + 6]; // Check if values are not equal
    cmp byte ptr [si + 1], 0x3a; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    // Compare $1 with $2 // Compare values
    jb 0x28ec; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x28ec; // Jump if above (unsigned)
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jb 0x2911; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x2911; // Jump if above (unsigned)
    $1 -= $2; // Subtract values
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x2911; // Jump if below (unsigned)
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x2911; // Jump if below (unsigned)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    lds dx, ptr [bp + 6];
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x2944; // Jump if above or equal (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    lea si, [si + 0x1e]; // Load effective address
    $1 = $2;
    les di, ptr [bp + 0xa];
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x2944; // Jump if above or equal (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    insw word ptr es:[di], dx;
    and byte ptr gs:[bx + 0x76], ch; // Bitwise AND
    jb 0x29e9; // Jump if below (unsigned)
    popaw ;
    jns 0x29a0;
    jb 0x29f5; // Jump if below (unsigned)
    outsw dx, word ptr [si];
    jb 0x2993; // Jump if below (unsigned)
    or bh, byte ptr [bx + di + 0x17]; // Bitwise OR
    $1 = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    retf ; // Return from function; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [0x7230], 0x20; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    shl bx, cl; // Shift left
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    int 0x11; // Call interrupt
    retf ; // Return from function
    int 0x12; // Call interrupt
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x1a; // Call interrupt
    xchg dx, ax; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x29fd; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x2a1d; // Jump if below (unsigned)
    les bx, ptr [bp + 0xa];
    mov word ptr es:[bx], cx;
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x2a3a; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1++; // Increment value
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], ax;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], ax;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1--; // Decrement value
    $1 = $2;
    $1 = $2; // Check if values are not equal
    shl bx, cl; // Shift left; Check if values are not equal
    lcall [bx - 0x78fe]; // Check if values are not equal
    cmp word ptr [0x7230], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    lcall [0x7334];
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    nop ; // No operation; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp word ptr [bp + 6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall [0x7338];
    lcall [0x733c];
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1(); // Call function
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1(); // Call function
    retf ; // Return from function
    push($1); // Push value onto stack
    xchg si, ax; // Exchange values
    xchg dx, ax; // Exchange values
    test ax, ax; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mul bx; // Multiply (unsigned)
    jcxz 0x2b0b;
    xchg cx, ax; // Exchange values
    mul si; // Multiply (unsigned)
    $1 += $2; // Add values
    xchg si, ax; // Exchange values
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    cld ; // Clear direction flag
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    adc cx, cx;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 8];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x2b44; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], cx;
    mov word ptr es:[bx + 2], dx;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], cx;
    mov word ptr es:[bx + 2], dx;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lea ax, [bp - 2]; // Load effective address
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1--; // Decrement value
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lea ax, [bp - 2]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x2bc6; // Jump if below (unsigned)
    les di, ptr [bp + 8];
    mov word ptr es:[di], cx;
    mov word ptr es:[di + 2], dx;
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    xchg bx, ax; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lds dx, ptr [bp + 8];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test di, 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, dx; // Bitwise OR
    jns 0x2c3d;
    neg dx; // Negate value
    neg ax; // Negate value
    sbb dx, 0;
    or di, 0xc; // Bitwise OR
    or cx, cx; // Bitwise OR
    jns 0x2c4b;
    neg cx; // Negate value
    neg bx; // Negate value
    sbb cx, 0;
    xor di, 4; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    shl ax, 1; // Shift left
    rcl dx, 1;
    rcl si, 1;
    rcl di, 1;
    // Compare $1 with $2 // Compare values
    jb 0x2c6c; // Jump if below (unsigned)
    ja 0x2c67; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x2c6c; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    sbb di, bp;
    $1++; // Increment value
    loop 0x2c55; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    test bx, 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    shr bx, 1; // Shift right (unsigned)
    test bx, 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg dx; // Negate value
    neg ax; // Negate value
    sbb dx, 0;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    div bx; // Divide (unsigned)
    test di, 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg dx, ax; // Exchange values
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    jae 0x2cb3; // Jump if above or equal (unsigned)
    $1 = $2;
    shl ax, cl; // Shift left
    shl dx, cl; // Shift left
    neg cl; // Negate value
    $1 += $2; // Add values
    shr bx, cl; // Shift right (unsigned)
    or dx, bx; // Bitwise OR
    retf ; // Return from function
    $1 -= $2; // Subtract values
    xchg dx, ax; // Exchange values
    $1 = 0; // Bitwise XOR
    shl dx, cl; // Shift left
    retf ; // Return from function
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or cx, cx; // Bitwise OR
    jge 0x2ccf; // Jump if greater or equal (signed)
    not bx; // Bitwise NOT
    not cx; // Bitwise NOT
    $1 += $2; // Add values
    adc cx, 0;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x2cd7; // Jump if above or equal (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    shl ch, cl; // Shift left
    $1 += $2; // Add values
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    and ax, 0xf; // Bitwise AND
    retf ; // Return from function
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or cx, cx; // Bitwise OR
    jge 0x2cfe; // Jump if greater or equal (signed)
    not bx; // Bitwise NOT
    not cx; // Bitwise NOT
    $1 += $2; // Add values
    adc cx, 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    jae 0x2d06; // Jump if above or equal (unsigned)
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    shl bh, cl; // Shift left
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    and ax, 0xf; // Bitwise AND
    retf ; // Return from function
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl dx, cl; // Shift left
    shr ch, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    adc ch, 0;
    $1 = $2;
    shl di, cl; // Shift left
    shr ah, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    adc ah, 0;
    $1 -= $2; // Subtract values
    sbb ch, ah;
    $1 = $2;
    cwde ;
    xchg dx, ax; // Exchange values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    or si, si; // Bitwise OR
    jl 0x2d64; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x2d57; // Jump if less or equal (signed)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cwde ;
    $1 = $2;
    goto $1; // Jump to address
    neg si; // Negate value
    // Compare $1 with $2 // Compare values
    jg 0x2d54; // Jump if greater (signed)
    mov word ptr [0x74fe], 0xffff;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0xe; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    cmp word ptr [bp + 6], 0x80; // Compare values
    jae 0x2db0; // Jump if above or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0xc; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0x20; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 2; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x2dff; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x2dff; // Jump if greater (signed)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 8; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x2e2a; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x2e2a; // Jump if greater (signed)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0x40; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 1; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 4; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0x12; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    les bx, ptr [bp + 6];
    $1--; // Decrement value
    jl 0x2e97; // Jump if less (signed)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1--; // Decrement value
    jl 0x2ebc; // Jump if less (signed)
    les bx, ptr [0x734c];
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 8];
    $1++; // Increment value
    jge 0x2ef1; // Jump if greater or equal (signed)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    jge 0x2f20; // Jump if greater or equal (signed)
    les bx, ptr [0x7360];
    $1++; // Increment value
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    and ax, 0x20; // Bitwise AND
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    and ax, 0x10; // Bitwise AND
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    xchg dx, ax; // Exchange values
    and ax, 0x80; // Bitwise AND
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les di, ptr [bp + 0xa];
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0x2fcf; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x2fcf; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2; // Check if values are equal
    or cx, cx; // Bitwise OR; Check if values are equal
    jge 0x2f94; // Jump if greater or equal (signed); Check if values are equal
    cmp byte ptr [bp + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], 0x2d;
    $1++; // Increment value
    neg cx; // Negate value
    neg ax; // Negate value
    sbb cx, 0;
    lea si, [bp - 0x22]; // Load effective address
    jcxz 0x2fa9;
    xchg cx, ax; // Exchange values
    $1 -= $2; // Subtract values
    div bx; // Divide (unsigned)
    xchg cx, ax; // Exchange values
    div bx; // Divide (unsigned)
    mov byte ptr ss:[si], dl;
    $1++; // Increment value
    jcxz 0x2fb1;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    div bx; // Divide (unsigned)
    mov byte ptr ss:[si], dl;
    $1++; // Increment value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lea cx, [bp - 0x22]; // Load effective address
    neg cx; // Negate value
    $1 += $2; // Add values
    cld ; // Clear direction flag
    $1--; // Decrement value
    $1 = $2;
    $1 -= $2; // Subtract values
    jae 0x2fc9; // Jump if above or equal (unsigned)
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 += $2; // Add values
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x2fbd; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    ret 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl bx, 1; // Shift left
    and word ptr [bx + 0x74d2], 0xfdff; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x3023; // Jump if below (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    cdq ;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    mov word ptr [bp + 0xa], 0x8782;
    push($1); // Push value onto stack
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Prepare arguments and call function
    $1 += $2; // Add values; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    les bx, ptr [bp + 4]; // Check if values are not equal
    cmp word ptr es:[bx], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    les bx, ptr [bp + 4];
    add word ptr es:[bx], ax; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 2]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 8; // Return from function
    push($1); // Push value onto stack
    xchg si, ax; // Exchange values
    xchg dx, ax; // Exchange values
    test ax, ax; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mul bx; // Multiply (unsigned)
    jcxz 0x30f0;
    xchg cx, ax; // Exchange values
    mul si; // Multiply (unsigned)
    $1 += $2; // Add values
    xchg si, ax; // Exchange values
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    shr bx, cl; // Shift right (unsigned)
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2; // Check if values are not equal
    and ax, 0xf; // Bitwise AND; Check if values are not equal
    and bx, 0xf; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 8];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x3141; // Jump if below (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 0;
    goto $1; // Jump to address
    les di, ptr [bp + 0x10];
    test byte ptr [bp - 1], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les di, ptr es:[di];
    add word ptr [bp + 0x10], 4; // Add values
    ret ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    add word ptr [bp + 0x10], 2; // Add values
    ret ; // Return from function
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr es:[si]; // Load string byte/word; Check if values are equal
    or al, al; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cwde ;
    xchg di, ax; // Exchange values; Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jl 0x31c6; // Jump if less (signed)
    cwde ; // Check if values are not equal
    or di, di; // Bitwise OR; Check if values are not equal
    js 0x31db; // Check if values are not equal
    cmp byte ptr [di + 0x7564], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg bx, ax; // Exchange values; Check if values are not equal
    or bl, bl; // Bitwise OR; Check if values are not equal
    js 0x31c9; // Check if values are not equal
    cmp byte ptr [bx + 0x7564], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jg 0x31a8; // Jump if greater (signed)
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values; Check if values are equal
    $1--; // Decrement value; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1--; // Decrement value
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 0xa], 0xffff;
    $1 = $2;
    mov byte ptr [bp - 1], 0x20;
    lodsb al, byte ptr es:[si]; // Load string byte/word
    cwde ;
    *($1) = $2;
    xchg di, ax; // Exchange values
    or di, di; // Bitwise OR
    jl 0x3225; // Jump if less (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jbe 0x321a; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    shl bx, 1; // Shift left
    goto $1; // Jump to address
    xchg di, ax; // Exchange values
    goto $1; // Jump to address
    goto $1; // Jump to address
    or byte ptr [bp - 1], 1; // Bitwise OR
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    xchg word ptr [bp - 0xa], di; // Exchange values
    or di, di; // Bitwise OR
    jl 0x3201; // Jump if less (signed)
    $1 = $2;
    mul di; // Multiply (unsigned)
    add word ptr [bp - 0xa], ax; // Add values
    goto $1; // Jump to address
    or byte ptr [bp - 1], 8; // Bitwise OR
    goto $1; // Jump to address
    or byte ptr [bp - 1], 4; // Bitwise OR
    goto $1; // Jump to address
    or byte ptr [bp - 1], 2; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr [bp - 1], 0xdf; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr [bp - 1], 0x20; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR; Check if values are equal
    test di, 0x20; // Test bits (AND without storing); Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr [bp - 1], 4; // Bitwise OR
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    and ax, 0x7fff; // Bitwise AND
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    cmp word ptr [bp - 8], 0; // Compare values
    jle 0x32cf; // Jump if less or equal (signed)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1(); // Call function
    stosw word ptr es:[di], ax; // Store string byte/word
    test byte ptr [bp - 1], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg dx, ax; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    goto $1; // Jump to address
    jl 0x32d4; // Jump if less (signed)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1--; // Decrement value
    and word ptr [bp - 0xa], 0x7fff; // Bitwise AND
    $1(); // Call function; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or ax, ax; // Bitwise OR
    jle 0x3311; // Jump if less or equal (signed); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1--; // Decrement value
    $1 = pop(); // Pop value from stack
    $1 = $2;
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jle 0x3335; // Jump if less or equal (signed)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1--; // Decrement value
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1++; // Increment value
    xchg dx, ax; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    test byte ptr [bp - 1], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg bx, ax; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    goto $1; // Jump to address
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    and ax, word ptr [bp - 0xa]; // Bitwise AND
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    cmp word ptr [bp - 8], 0; // Compare values
    jle 0x33b3; // Jump if less or equal (signed)
    $1 = $2;
    cwde ;
    test ax, 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1++; // Increment value
    test byte ptr [bp - 1], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    test byte ptr [bp - 1], 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address
    $1(); // Call function
    jl 0x334e; // Jump if less (signed)
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1++; // Increment value
    and word ptr [bp - 0xa], 0x7fff; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stosb byte ptr es:[di], al; // Store string byte/word
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jle 0x3401; // Jump if less or equal (signed)
    or al, al; // Bitwise OR
    js 0x33fc;
    xchg bx, ax; // Exchange values
    cmp byte ptr [bx + 0x7564], 1; // Compare values
    xchg bx, ax; // Exchange values
    jle 0x3401; // Jump if less or equal (signed)
    $1--; // Decrement value
    jg 0x33d4; // Jump if greater (signed)
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    goto $1; // Jump to address
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1 = $2;
    or si, si; // Bitwise OR
    jge 0x3432; // Jump if greater or equal (signed)
    $1 = $2;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jl 0x345e; // Jump if less (signed)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    jg 0x3434; // Jump if greater (signed)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    goto $1; // Jump to address
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 -= $2; // Subtract values
    cld ; // Clear direction flag
    push($1); // Push value onto stack; Initialize counter for string operation
    $1 = pop(); // Pop value from stack; Initialize counter for string operation
    lea di, [bp - 0x2a]; // Load effective address; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep stosw word ptr es:[di], ax; // Fill memory block
    $1 = pop(); // Pop value from stack; Check if values are not equal
    lodsb al, byte ptr es:[si]; // Load string byte/word; Check if values are not equal
    and byte ptr [bp - 1], 0xef; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr [bp - 1], 0x10; // Bitwise OR
    lodsb al, byte ptr es:[si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr di, cl; // Shift right (unsigned)
    $1 = $2;
    and cl, dl; // Bitwise AND
    shl ch, cl; // Shift left; Check if values are equal
    or byte ptr [bp + di - 0x2a], ch; // Bitwise OR; Check if values are equal
    lodsb al, byte ptr es:[si]; // Load string byte/word; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    ja 0x3482; // Jump if above (unsigned); Check if values are equal
    cmp byte ptr es:[si], 0x5d; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr es:[si]; // Load string byte/word
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    rol ch, 1; // Rotate left
    adc di, 0;
    or byte ptr [bp + di - 0x2a], ch; // Bitwise OR
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    *($1) = $2;
    and word ptr [bp - 0xa], 0x7fff; // Bitwise AND
    $1 = $2;
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1--; // Decrement value
    jl 0x3535; // Jump if less (signed)
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jl 0x354a; // Jump if less (signed)
    xchg si, ax; // Exchange values
    $1 = $2;
    $1 = $2;
    shr si, cl; // Shift right (unsigned)
    $1 = $2;
    and cl, bl; // Bitwise AND
    shl ch, cl; // Shift left
    test byte ptr [bp + si - 0x2a], ch; // Test bits (AND without storing)
    xchg si, ax; // Exchange values
    xchg bx, ax; // Exchange values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test byte ptr [bp - 1], 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test byte ptr [bp - 1], 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stosb byte ptr es:[di], al; // Store string byte/word
    goto $1; // Jump to address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    jge 0x353e; // Jump if greater or equal (signed)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    goto $1; // Jump to address
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    jge 0x355c; // Jump if greater or equal (signed)
    test byte ptr [bp - 1], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    cmp word ptr [bp - 4], 1; // Compare values
    sbb word ptr [bp - 4], 0;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    goto $1; // Jump to address; Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jle 0x35a0; // Jump if less or equal (signed)
    or al, al; // Bitwise OR
    js 0x359a;
    xchg bx, ax; // Exchange values
    cmp byte ptr [bx + 0x7564], 1; // Compare values
    xchg bx, ax; // Exchange values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1 = $2;
    $1--; // Decrement value
    jl 0x35f8; // Jump if less (signed)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jle 0x35fa; // Jump if less or equal (signed)
    $1--; // Decrement value
    jl 0x35fa; // Jump if less (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    jb 0x35fa; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x35ec; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    jb 0x35fa; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x35e9; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    jb 0x35fa; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jae 0x35fa; // Jump if above or equal (unsigned)
    $1 += $2; // Add values
    shl dx, 1; // Shift left
    shl dx, 1; // Shift left
    shl dx, 1; // Shift left
    shl dx, 1; // Shift left
    $1 += $2; // Add values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    if (ZF) goto $1; // Jump if equal (ZF=1)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and word ptr [0x1628], dx; // Bitwise AND
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    sbb byte ptr [bp + si + 0x16], dh;
    jb 0x3637; // Jump if below (unsigned)
    jl 0x3639; // Jump if less (signed)
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    push($1); // Push value onto stack
    $1--; // Decrement value
    push($1); // Push value onto stack
    $1--; // Decrement value
    push($1); // Push value onto stack
    insw word ptr es:[di], dx;
    push($1); // Push value onto stack
    $1 = $2;
    sbb byte ptr [bx + si + 0x16], ah;
    ja 0x364b; // Jump if above (unsigned)
    xlatb ;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 -= $2; // Subtract values
    jb 0x3663; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x3658; // Jump if below or equal (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x3650; // Jump if above (unsigned)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jbe 0x3663; // Jump if below or equal (unsigned)
    // Compare $1 with $2 // Compare values
    jae 0x3663; // Jump if above or equal (unsigned)
    $1++; // Increment value
    $1++; // Increment value
    clc ; // Clear carry flag
    $1 = $2;
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    stc ; // Set carry flag
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov byte ptr [bp - 1], 0;
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 1; // Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jl 0x36ff; // Jump if less (signed)
    cwde ;
    xchg bx, ax; // Exchange values
    test bl, 0x80; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    test byte ptr [bx + di], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg bx, ax; // Exchange values; Check if values are equal
    $1--; // Decrement value; Check if values are equal
    jl 0x3706; // Jump if less (signed); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1--; // Decrement value
    jl 0x3706; // Jump if less (signed); Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    jl 0x36ff; // Jump if less (signed)
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    jcxz 0x3724;
    // Compare $1 with $2 // Compare values
    ja 0x3706; // Jump if above (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jb 0x3706; // Jump if below (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    jl 0x3721; // Jump if less (signed); Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 6], 0xffff;
    goto $1; // Jump to address
    mov word ptr [bp - 6], 0; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    cdq ;
    goto $1; // Jump to address
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    mov word ptr [bp + 0xc], 0xa;
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    jl 0x3721; // Jump if less (signed); Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    mov word ptr [bp + 0xc], 8; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp + 0xc], 0x10;
    goto $1; // Jump to address
    $1 = $2;
    xchg bx, ax; // Exchange values
    $1(); // Call function
    xchg bx, ax; // Exchange values
    jb 0x3706; // Jump if below (unsigned)
    xchg si, ax; // Exchange values
    goto $1; // Jump to address
    xchg si, ax; // Exchange values
    mul word ptr [bp + 0xc]; // Multiply (unsigned)
    $1 += $2; // Add values
    adc di, dx;
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    jl 0x37c8; // Jump if less (signed); Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    xchg bx, ax; // Exchange values
    $1(); // Call function
    xchg bx, ax; // Exchange values
    jae 0x3761; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    xchg si, ax; // Exchange values
    mul cx; // Multiply (unsigned)
    xchg di, ax; // Exchange values
    xchg dx, cx; // Exchange values
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc ax, cx;
    xchg di, ax; // Exchange values
    adc dl, dh;
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    jl 0x37c8; // Jump if less (signed); Prepare arguments and call function
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    xchg bx, ax; // Exchange values
    $1(); // Call function
    xchg bx, ax; // Exchange values
    jae 0x378a; // Jump if above or equal (unsigned); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1--; // Decrement value; Check if values are equal
    $1 = $2; // Check if values are equal
    xchg si, ax; // Exchange values; Check if values are equal
    cmp byte ptr [bp - 1], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg dx; // Negate value
    neg ax; // Negate value
    sbb dx, 0;
    les di, ptr [bp + 0x10];
    $1 = $2;
    add word ptr es:[di], bx; // Add values
    les di, ptr [bp + 0x14];
    $1 = $2;
    mov word ptr es:[di], bx;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc ah, 0;
    adc dx, 0;
    mov word ptr [bp - 6], 2;
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    les si, ptr [bp + 6];
    mov word ptr es:[si], bx;
    $1 = $2;
    mov word ptr es:[si + 2], ax;
    mov word ptr es:[si + 4], ss;
    mov word ptr es:[si + 6], ds;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x3844; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x388c; // Jump if above or equal (unsigned)
    $1 = $2;
    shl bx, 1; // Shift left
    mov word ptr [bx + 0x74d2], 0;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    mov byte ptr [bx + 0x7344], 0xff;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = pop(); // Pop value from stack; Increment counter and check loop condition
    *($1) = $2; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x3854; // Jump if below (unsigned)
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and word ptr [0x7342], 0xfdff; // Bitwise AND
    $1 = $2;
    push($1); // Push value onto stack
    test word ptr [0x7342], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and word ptr [0x7356], 0xfdff; // Bitwise AND
    $1 = $2;
    push($1); // Push value onto stack
    test word ptr [0x7356], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x3917; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    aam 0x10;
    xchg al, ah; // Exchange values
    $1(); // Call function
    xchg al, ah; // Exchange values
    $1 += $2; // Add values
    daa ;
    adc al, 0x40;
    daa ;
    stosb byte ptr es:[di], al; // Store string byte/word
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr [bp - 0x12], 0;
    mov word ptr [bp - 0x14], 0x50;
    mov word ptr [bp - 0x16], 0;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1--; // Decrement value
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    mov byte ptr ss:[di], al;
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x96]; // Load effective address
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lea ax, [bp - 0x96]; // Load effective address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x16], 1;
    mov word ptr [bp - 0x14], 0x50;
    add word ptr [bp - 0x12], di; // Add values
    lea di, [bp - 0x96]; // Load effective address
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    lea di, [bp - 0x96]; // Load effective address
    *($1) = $2;
    $1 = $2;
    les si, ptr [bp + 6];
    lodsb al, byte ptr es:[si]; // Load string byte/word; Check if values are equal
    or al, al; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr ss:[di], al;
    $1++; // Increment value
    $1--; // Decrement value
    jg 0x39a8; // Jump if greater (signed)
    $1(); // Call function
    goto $1; // Jump to address
    goto $1; // Jump to address; Check if values are equal
    *($1) = $2; // Check if values are equal
    lodsb al, byte ptr es:[si]; // Load string byte/word; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    mov word ptr [bp - 2], 0x20;
    *($1) = $2;
    mov word ptr [bp - 8], 0xffff;
    mov word ptr [bp - 0xa], 0xffff;
    goto $1; // Jump to address
    lodsb al, byte ptr es:[si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jae 0x3a0b; // Jump if above or equal (unsigned)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x3a04; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    shl bx, 1; // Shift left
    goto $1; // Jump to address
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0x3a0b; // Jump if above (unsigned)
    or word ptr [bp - 2], 1; // Bitwise OR
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0x3a0b; // Jump if above (unsigned)
    or word ptr [bp - 2], 2; // Bitwise OR
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    ja 0x3a0b; // Jump if above (unsigned); Check if values are equal
    cmp byte ptr [bp - 0xb], 0x2b; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    and word ptr [bp - 2], 0xffdf; // Bitwise AND
    goto $1; // Jump to address
    or word ptr [bp - 2], 0x20; // Bitwise OR
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0x3a94; // Jump if above (unsigned)
    test word ptr [bp - 2], 2; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or word ptr [bp - 2], 8; // Bitwise OR
    $1 = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    add word ptr [bp + 4], 2; // Add values
    // Compare $1 with $2 // Compare values
    jae 0x3a7a; // Jump if above or equal (unsigned)
    or ax, ax; // Bitwise OR
    jns 0x3a72;
    neg ax; // Negate value
    or word ptr [bp - 2], 2; // Bitwise OR
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    $1++; // Increment value
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jae 0x3a56; // Jump if above or equal (unsigned)
    $1 = $2;
    $1++; // Increment value
    goto $1; // Jump to address
    xchg dx, ax; // Exchange values
    $1 -= $2; // Subtract values
    cwde ;
    // Compare $1 with $2 // Compare values
    ja 0x3ab6; // Jump if above (unsigned)
    $1 = $2;
    xchg word ptr [bp - 8], ax; // Exchange values
    or ax, ax; // Bitwise OR
    jl 0x3a77; // Jump if less (signed)
    shl ax, 1; // Shift left
    $1 = $2;
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    $1 += $2; // Add values; Check if values are not equal
    add word ptr [bp - 8], ax; // Add values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg word ptr [bp - 0xa], ax; // Exchange values
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shl ax, 1; // Shift left
    $1 = $2;
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    add word ptr [bp - 0xa], ax; // Add values
    goto $1; // Jump to address
    or word ptr [bp - 2], 0x10; // Bitwise OR
    goto $1; // Jump to address
    or word ptr [bp - 2], 0x100; // Bitwise OR
    and word ptr [bp - 2], 0xffef; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    mov byte ptr [bp - 0xb], 0;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    mov byte ptr [bp - 6], 1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    cdq ;
    $1++; // Increment value
    $1++; // Increment value
    *($1) = $2;
    test word ptr [bp - 2], 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    *($1) = $2;
    lea di, [bp - 0x45]; // Load effective address
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    or dx, dx; // Bitwise OR; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr ss:[di], 0;
    $1 = $2;
    goto $1; // Jump to address
    or word ptr [bp - 2], 4; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    or dx, dx; // Bitwise OR
    jge 0x3b64; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    lea di, [bp - 0x46]; // Load effective address
    $1 = $2;
    push($1); // Push value onto stack
    $1++; // Increment value
    $1++; // Increment value
    *($1) = $2;
    test word ptr [bp - 2], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    mov byte ptr ss:[di], 0;
    mov byte ptr [bp - 6], 0;
    and word ptr [bp - 2], 0xfffb; // Bitwise AND
    lea cx, [bp - 0x46]; // Load effective address
    $1 -= $2; // Subtract values
    xchg di, cx; // Exchange values
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jg 0x3bb4; // Jump if greater (signed)
    $1 = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [bp + 4], 2; // Add values
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    lea di, [bp - 0x45]; // Load effective address
    $1 = 0; // Bitwise XOR
    mov word ptr ss:[di], ax;
    $1 = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    test word ptr [bp - 2], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    add word ptr [bp + 4], 2; // Add values
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    or di, di; // Bitwise OR
    goto $1; // Jump to address
    les di, ptr ss:[di];
    add word ptr [bp + 4], 4; // Add values
    $1 = $2;
    or ax, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jbe 0x3c11; // Jump if below or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or cx, cx; // Bitwise OR
    jge 0x3c27; // Jump if greater or equal (signed)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea bx, [bp - 0x45]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    and ax, word ptr [bp - 2]; // Bitwise AND
    push($1); // Push value onto stack
    $1 = $2;
    test ax, 0x100; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    add word ptr [bp + 4], 0xa; // Add values
    goto $1; // Jump to address
    add word ptr [bp + 4], 8; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    lea di, [bp - 0x45]; // Load effective address
    test word ptr [bp - 2], 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or dx, dx; // Bitwise OR; Check if values are not equal
    jle 0x3c77; // Jump if less or equal (signed); Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp byte ptr es:[di], 0x2d; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    $1 -= $2; // Subtract values; Check if values are equal
    jle 0x3c77; // Jump if less or equal (signed); Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr es:[di], 0x2d; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or al, al; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    mov byte ptr es:[di], al;
    cmp word ptr [bp - 0xe], 0; // Compare values
    jle 0x3c98; // Jump if less or equal (signed)
    $1 = $2;
    or cx, cx; // Bitwise OR
    jge 0x3c98; // Jump if greater or equal (signed)
    $1--; // Decrement value
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ax, word ptr [bp - 2]; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    cmp word ptr [bp - 0xe], 0; // Compare values
    jg 0x3cc1; // Jump if greater (signed); Check if values are equal
    mov word ptr [bp - 0xe], 1; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or word ptr [bp - 2], 0x40; // Bitwise OR
    $1--; // Decrement value
    $1--; // Decrement value
    sub word ptr [bp - 0xe], 2; // Subtract values
    jge 0x3cde; // Jump if greater or equal (signed)
    mov word ptr [bp - 0xe], 0;
    $1 += $2; // Add values
    test word ptr [bp - 2], 2; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2; // Decrement counter and check loop condition
    $1(); // Call function; Decrement counter and check loop condition
    $1--; // Decrement value; Decrement counter and check loop condition
    // Compare $1 with $2 // Compare values
    jg 0x3cea; // Jump if greater (signed)
    test word ptr [bp - 2], 0x40; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    or dx, dx; // Bitwise OR
    jle 0x3d34; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values; Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr es:[si]; // Load string byte/word
    $1(); // Call function
    $1--; // Decrement value
    $1--; // Decrement value
    xchg dx, cx; // Exchange values
    jcxz 0x3d32;
    $1 = $2;
    $1(); // Call function
    loop 0x3d2b; // Loop (decrement CX and jump if CX!=0)
    xchg dx, cx; // Exchange values
    jcxz 0x3d48;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr es:[si]; // Load string byte/word
    mov byte ptr ss:[di], al;
    $1++; // Increment value
    $1--; // Decrement value
    jg 0x3d46; // Jump if greater (signed)
    $1(); // Call function
    loop 0x3d38; // Loop (decrement CX and jump if CX!=0)
    or bx, bx; // Bitwise OR
    jle 0x3d55; // Jump if less or equal (signed)
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    loop 0x3d4e; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    test word ptr [bp - 2], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    add word ptr [bp + 4], 2; // Add values
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    les di, ptr ss:[di];
    add word ptr [bp + 4], 4; // Add values
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 += $2; // Add values
    mov word ptr es:[di], ax;
    test word ptr [bp - 2], 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1++; // Increment value
    mov word ptr es:[di], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    lodsb al, byte ptr es:[si]; // Load string byte/word
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    cmp byte ptr [bp - 0x14], 0x50; // Compare values
    jge 0x3db1; // Jump if greater or equal (signed); Check if values are equal
    $1(); // Call function; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    cmp word ptr [bp - 0x16], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xc; // Return from function
    and al, 0x1e; // Bitwise AND
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    sbb word ptr [0x1e87], bx;
    xchg sp, ax; // Exchange values
    push($1); // Push value onto stack
    rcr byte ptr [0x1ed9], cl;
    ficomp word ptr [0x1e42];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    in ax, 0x1e; // Input from port
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    adc al, 0x20;
    $1 = $2;
    xlatb ;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    and word ptr [si - 0x6bdf], dx; // Bitwise AND
    and word ptr [si + 0x3421], dx; // Bitwise AND
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    in al, dx; // Input from port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    imul dx; // Multiply (signed)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1--; // Decrement value
    $1 += $2; // Add values
    shl ax, 1; // Shift left
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    jcxz 0x3e8d;
    les di, ptr [bp + 0xa];
    lds si, ptr [bp + 6];
    cld ; // Clear direction flag
    // Compare $1 with $2 // Compare values
    jae 0x3e48; // Jump if above or equal (unsigned)
    $1 = $2;
    $1--; // Decrement value
    shl ax, 1; // Shift left
    $1 += $2; // Add values; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    std ; // Set direction flag; Check if values are not equal
    cmp word ptr [bp - 2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cli ; // Clear interrupt flag
    in al, dx; // Input from port
    ror al, 1; // Rotate right
    jb 0x3e5e; // Jump if below (unsigned)
    in al, dx; // Input from port
    ror al, 1; // Rotate right
    jae 0x3e63; // Jump if above or equal (unsigned)
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    sti ; // Set interrupt flag
    loop 0x3e5d; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    cli ; // Clear interrupt flag
    in al, dx; // Input from port
    ror al, 1; // Rotate right
    jb 0x3e6f; // Jump if below (unsigned)
    in al, dx; // Input from port
    ror al, 1; // Rotate right
    jae 0x3e74; // Jump if above or equal (unsigned)
    lodsw ax, word ptr [si]; // Load string byte/word
    sti ; // Set interrupt flag
    $1 = $2;
    in al, dx; // Input from port
    ror al, 1; // Rotate right
    jb 0x3e7d; // Jump if below (unsigned)
    in al, dx; // Input from port
    ror al, 1; // Rotate right
    jae 0x3e82; // Jump if above or equal (unsigned)
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    sti ; // Set interrupt flag
    loop 0x3e6e; // Loop (decrement CX and jump if CX!=0)
    cld ; // Clear direction flag
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1++; // Increment value
    $1 = $2; // Check if values are equal
    les bx, ptr [bp + 8]; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    les bx, ptr [bp + 4]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 8; // Return from function
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and byte ptr [0x87], 0xfe; // Bitwise AND
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    int 0x10; // Call interrupt
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt; Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr [0x87], 1; // Bitwise OR
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1(); // Call function
    or al, al; // Bitwise OR; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [0x84], 0x18; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = $2;
    $1(); // Call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    and ah, 0x7f; // Bitwise AND
    *($1) = $2;
    *($1) = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are equal
    $1(); // Call function; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    cmp byte ptr [0x7652], 3; // Compare values
    jbe 0x401d; // Jump if below or equal (unsigned); Check if values are equal
    cmp byte ptr [0x7652], 0x40; // Compare values; Check if values are equal
    jae 0x401d; // Jump if above or equal (unsigned); Check if values are equal
    cmp byte ptr [0x7652], 7; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr [0x7652], 0x40; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr [0x7652], 7; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address; Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp byte ptr [0x7652], 7; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x7657], 0;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    goto $1; // Jump to address
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values; Check if values are equal
    add byte ptr [bx + si], al; // Add values; Check if values are equal
    add byte ptr [bx + si], al; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr cs:[0x24ba], ds; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mov word ptr cs:[0x24ba], ax;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr cs:[0x24b8], 0;
    mov word ptr cs:[0x24ba], 0;
    mov word ptr cs:[0x24bc], 0;
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = 0; // Bitwise XOR; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    ret ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    mov word ptr [2], 0; // Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr es:[2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    add word ptr es:[0], ax; // Add values
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[8], cx;
    goto $1; // Jump to address
    mov word ptr es:[2], cx;
    goto $1; // Jump to address
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    ret ; // Return from function
    $1 = $2;
    add word ptr es:[0], ax; // Add values
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2; // Check if values are equal
    mov word ptr es:[2], ax; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[4], ds;
    mov word ptr cs:[0x24bc], ds;
    $1 = $2;
    ret ; // Return from function
    mov word ptr cs:[0x24bc], 0;
    ret ; // Return from function
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    mov word ptr ss:[6], ds;
    *($1) = $2;
    $1 = $2;
    popf ; // Pop flags from stack
    mov word ptr es:[4], ds;
    *($1) = $2;
    ret ; // Return from function
    mov word ptr cs:[0x24bc], ds;
    *($1) = $2;
    *($1) = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr cs:[0x24be], ds;
    $1 = $2; // Check if values are not equal
    or dx, dx; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    goto $1; // Jump to address
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    and ax, 0xf; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    shr bx, cl; // Shift right (unsigned)
    shl ax, cl; // Shift left; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr cs:[0x24b8], dx;
    mov word ptr cs:[0x24ba], dx;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    ret ; // Return from function
    $1 = 0; // Bitwise XOR
    cdq ;
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    shr bx, cl; // Shift right (unsigned)
    shl ax, cl; // Shift left; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and ax, 0xf; // Bitwise AND
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr cs:[0x24ba], dx;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    neg ax; // Negate value
    $1 += $2; // Add values; Prepare arguments and call function
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    cdq ;
    ret ; // Return from function
    $1 = $2;
    sub word ptr [0], ax; // Subtract values
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, dx; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr cs:[0x24be], ds;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    adc dx, 0;
    jb 0x436b; // Jump if below (unsigned)
    test dx, 0xfff0; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shl dx, cl; // Shift left
    or ah, dl; // Bitwise OR
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    cmp word ptr [0], ax; // Compare values; Check if values are not equal
    jae 0x4370; // Jump if above or equal (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    cdq ;
    goto $1; // Jump to address
    ja 0x4366; // Jump if above (unsigned)
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = pop(); // Pop value from stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cld ; // Clear direction flag
    $1--; // Decrement value; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x43d6; // Jump if below or equal (unsigned)
    $1 = $2;
    shl cx, 1; // Shift left
    shl cx, 1; // Shift left
    shl cx, 1; // Shift left
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 -= $2; // Subtract values
    jbe 0x43f4; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    goto $1; // Jump to address; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = $2; // Check if values are equal
    ret ; // Return from function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    mov word ptr es:[0], si;
    mov word ptr es:[2], bx;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    mov word ptr es:[0], ax;
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr es:[2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr es:[2], di;
    goto $1; // Jump to address
    mov word ptr es:[8], di; // Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    mov word ptr es:[0], ax;
    $1 += $2; // Add values
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = 0; // Bitwise XOR; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = $2;
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr cs:[0x24be], ds;
    mov word ptr cs:[0x24c0], dx;
    mov word ptr cs:[0x24c2], ax;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or cx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    adc dx, 0;
    jb 0x44de; // Jump if below (unsigned)
    test dx, 0xfff0; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shl dx, cl; // Shift left
    or ah, dl; // Bitwise OR
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x44c5; // Jump if below (unsigned)
    ja 0x44c0; // Jump if above (unsigned)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address
    $1(); // Call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    cdq ;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1++; // Increment value
    $1 -= $2; // Subtract values
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    shr si, cl; // Shift right (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    shl si, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x452d; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp dx, -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    mov word ptr [0x8f], 0;
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    jb 0x4596; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function; Prepare arguments and call function
    ja 0x4596; // Jump if above (unsigned); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1(); // Call function
    $1 += $2; // Add values
    adc dx, 0;
    $1 += $2; // Add values
    adc dx, word ptr [bp + 6];
    // Compare $1 with $2 // Compare values
    jl 0x45d0; // Jump if less (signed)
    jg 0x45c8; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jbe 0x45d0; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    jb 0x45c8; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    ja 0x45c8; // Jump if above (unsigned)
    $1 = $2;
    $1 = $2;
    *($1) = $2; // Prepare arguments and call function
    *($1) = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    mov word ptr [bp - 2], 0;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp - 2], 0; // Compare values
    jb 0x4668; // Jump if below (unsigned)
    ja 0x4660; // Jump if above (unsigned)
    cmp word ptr [bp - 4], 0x10; // Compare values
    jbe 0x4668; // Jump if below or equal (unsigned)
    sub word ptr [bp - 4], 0x10; // Subtract values
    sbb word ptr [bp - 2], 0;
    and word ptr [bp - 4], 0xfff0; // Bitwise AND
    and word ptr [bp - 2], 0xffff; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    shl ax, 1; // Shift left; Increment counter and check loop condition
    add word ptr [bp + 0xe], ax; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0x46a6; // Jump if less or equal (signed)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    shl ax, 1; // Shift left; Increment counter and check loop condition
    add word ptr [bp + 0xe], ax; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0x46fc; // Jump if less or equal (signed)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [bp + 0xe];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    pushf ; // Push flags onto stack
    pushf ; // Push flags onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [bp + 0xe];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    lds si, ptr [bp + 0xa];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    and word ptr [si + 0xc], 1; // Bitwise AND
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack; Prepare arguments and call function
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lds dx, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    jb 0x47d7; // Jump if below (unsigned); Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp byte ptr [0x7698], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    int 0x21; // Call interrupt
    cwde ;
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 1;
    // Compare $1 with $2 // Compare values
    jge 0x484c; // Jump if greater or equal (signed)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0xffff;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    push($1); // Push value onto stack
    $1(); // Call function
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    goto $1; // Jump to address
    goto $1; // Jump to address
    goto $1; // Jump to address
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    div bx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 8]; // Check if values are equal
    $1 = $2; // Check if values are equal
    les bx, ptr [bp + 4]; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    les bx, ptr [bp + 4]; // Increment counter and check loop condition
    mov word ptr es:[bx], dx; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x48fe; // Jump if below (unsigned)
    $1++; // Increment value
    $1 = $2;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], dx;
    $1 = pop(); // Pop value from stack
    ret 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1(); // Call function
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    or ax, ax; // Bitwise OR; Prepare arguments and call function
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    or ax, ax; // Bitwise OR; Prepare arguments and call function
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function; Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0xc], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lea ax, [bp - 4]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 6]; // Check if values are equal
    $1 = $2; // Check if values are equal
    add word ptr [bp + 6], 2; // Add values; Check if values are equal
    cmp word ptr [bp - 0xa], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lea ax, [bp - 2]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    goto $1; // Jump to address
    les bx, ptr [bp + 0xa];
    mov word ptr es:[bx], si;
    add word ptr [bp + 0xa], 2; // Add values
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    or ax, ax; // Bitwise OR; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [0x765b], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0x4a5b; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x4a5b; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jg 0x4a5b; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    ja 0x4a5b; // Jump if above (unsigned)
    cmp word ptr [bp + 4], dx; // Compare values
    ja 0x4a5b; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jg 0x4a5b; // Jump if greater (signed)
    or bx, bx; // Bitwise OR
    jle 0x4a5b; // Jump if less or equal (signed)
    or di, di; // Bitwise OR
    jle 0x4a5b; // Jump if less or equal (signed)
    or si, si; // Bitwise OR
    jle 0x4a5b; // Jump if less or equal (signed)
    cmp word ptr [bp + 4], 0; // Compare values
    jle 0x4a5b; // Jump if less or equal (signed)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], cx; // Increment counter and check loop condition
    add word ptr [bp + 8], 2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0x4a71; // Jump if less or equal (signed)
    $1 = pop(); // Pop value from stack
    ret 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [0x765b], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp + 4], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1++; // Increment value
    $1++; // Increment value; Check if values are equal
    $1++; // Increment value; Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [bp + 0xe], 6; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lea ax, [bp - 0xa0]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lea ax, [bp - 0xa0]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    lea ax, [bp - 0xa0]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lea ax, [bp - 0xa0]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lea ax, [bp - 0xa0]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    lea ax, [bp - 0xa0]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xc; // Return from function
    add byte ptr [bx + si], al; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    mov word ptr cs:[0x2ff1], ds;
    *($1) = $2;
    *($1) = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lodsb al, byte ptr es:[si]; // Load string byte/word
    $1++; // Increment value
    $1 = $2;
    xchg si, dx; // Exchange values
    xchg bx, ax; // Exchange values
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    $1 = $2;
    cmp byte ptr [0x7d], 3; // Compare values
    jb 0x4c3f; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repne scasb al, byte ptr es:[di];
    jcxz 0x4cae;
    xor cl, 0x7f; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    $1++; // Increment value
    and ax, 0xfffe; // Bitwise AND
    $1 = $2;
    $1 -= $2; // Subtract values
    jb 0x4cae; // Jump if below (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = 0; // Bitwise XOR
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = $2;
    xchg dx, si; // Exchange values
    xchg cx, bx; // Exchange values
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1(); // Call function; Check if values are equal
    ja 0x4c76; // Jump if above (unsigned); Check if values are equal
    jb 0x4cb3; // Jump if below (unsigned); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1(); // Call function; Check if values are equal
    ja 0x4c6b; // Jump if above (unsigned); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    stosb byte ptr es:[di], al; // Store string byte/word
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    xchg al, ah; // Exchange values
    $1 = 0; // Bitwise XOR
    stc ; // Set carry flag
    jcxz 0x4cad;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1--; // Decrement value
    $1 -= $2; // Subtract values; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr [si], 0x22; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1--; // Decrement value
    or si, si; // Bitwise OR
    ret ; // Return from function
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    $1++; // Increment value
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jb 0x4cae; // Jump if below (unsigned)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    jcxz 0x4ce9;
    *($1) = $2;
    *($1) = $2;
    $1 += $2; // Add values
    lodsb al, byte ptr ss:[si]; // Load string byte/word
    or al, al; // Bitwise OR
    loopne 0x4ce1;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x4d30; // Jump if below (unsigned)
    $1 = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    ret ; // Return from function
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    retf ; // Return from function
    $1(); // Call function
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp dx, -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test word ptr [bp + 0xa], 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test dx, 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    mov word ptr [0x7f], 5;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les si, ptr [bp + 6];
    cld ; // Clear direction flag
    $1 -= $2; // Subtract values
    cdq ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    test byte ptr [bx + di], 1; // Test bits (AND without storing); Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1 = $2;
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    ja 0x4e00; // Jump if above (unsigned)
    $1 -= $2; // Subtract values
    jb 0x4e00; // Jump if below (unsigned)
    mul cx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dl, dh;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mul cx; // Multiply (unsigned)
    xchg di, ax; // Exchange values
    xchg cx, dx; // Exchange values
    mul dx; // Multiply (unsigned)
    xchg dx, ax; // Exchange values
    xchg di, ax; // Exchange values
    $1 += $2; // Add values
    adc dx, cx;
    $1 = $2;
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    ja 0x4e00; // Jump if above (unsigned)
    $1 -= $2; // Subtract values
    jae 0x4de0; // Jump if above or equal (unsigned)
    $1--; // Decrement value
    jl 0x4e0a; // Jump if less (signed)
    neg dx; // Negate value
    neg ax; // Negate value
    sbb dx, 0;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x4e38; // Jump if below (unsigned)
    xchg cx, ax; // Exchange values
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x4e53; // Jump if below (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    $1 = $2;
    shl bx, 1; // Shift left
    mov word ptr [bx + 0x74d2], 0;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x4e7e; // Jump if below (unsigned)
    shl bx, 1; // Shift left
    mov word ptr [bx + 0x74d2], 0;
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x4e99; // Jump if below (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    goto $1; // Jump to address
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x4ef3; // Jump if below (unsigned)
    test dl, 0x80; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x4ef3; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    int 0x21; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jb 0x4ef3; // Jump if below (unsigned)
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x4ef3; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x4eef; // Jump if below (unsigned)
    ja 0x4eed; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x4eef; // Jump if below (unsigned)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address; Check if values are equal
    les bx, ptr [bp + 6]; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    les bx, ptr [bp + 6]; // Check if values are equal
    cmp word ptr es:[bx + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cmp word ptr es:[bx], 0; // Compare values
    jge 0x4f3b; // Jump if greater or equal (signed)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    les bx, ptr [bp + 6];
    cmp byte ptr es:[bx + 4], 0; // Compare values
    jl 0x4f6d; // Jump if less (signed)
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = $2;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx + 2], 0;
    mov word ptr es:[bx + 6], 0; // Check if values are equal
    mov word ptr es:[bx], 0; // Check if values are equal
    mov byte ptr es:[bx + 4], 0xff; // Check if values are equal
    cmp word ptr es:[bx + 0x10], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    les bx, ptr [bp + 6];
    mov word ptr es:[bx + 0x10], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address; Check if values are equal
    les bx, ptr [bp + 6]; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0; // Compare values
    jl 0x5033; // Jump if less (signed)
    test word ptr es:[bx + 2], 8; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr es:[bx + 0xc], dx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], 0;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr es:[bx + 0xc], dx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    goto $1; // Jump to address
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    $1 = $2;
    $1 += $2; // Add values
    $1++; // Increment value
    $1 = $2;
    sub word ptr es:[bx], si; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 0x200; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or word ptr es:[bx + 2], 0x10; // Bitwise OR
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [bp + 0xa];
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    pushf ; // Push flags onto stack
    $1 = pop(); // Pop value from stack
    xchg bx, ax; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    popf ; // Pop flags from stack
    $1 = pop(); // Pop value from stack
    jb 0x50ad; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    $1 = $2;
    int 0x21; // Call interrupt
    pushf ; // Push flags onto stack
    $1 = pop(); // Pop value from stack
    xchg bx, ax; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    popf ; // Pop flags from stack
    $1 = pop(); // Pop value from stack
    jb 0x50da; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    goto $1; // Jump to address
    les bx, ptr [bp - 4];
    test word ptr es:[bx + 2], 3; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    add word ptr [bp - 4], 0x14; // Add values
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    les bx, ptr [bp + 0xc];
    $1++; // Increment value; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    les bx, ptr [bp + 0xc]; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    les bx, ptr [bp + 0xc]; // Check if values are equal
    cmp byte ptr es:[bx], 0x2b; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 0xc];
    $1 = $2;
    and dx, 0xfffc; // Bitwise AND
    or dx, 4; // Bitwise OR; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    or dx, 0x4000; // Bitwise OR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, 0x8000; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ax, 0xc000; // Bitwise AND
    or dx, ax; // Bitwise OR
    $1 = $2;
    test ax, 0x8000; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, 0x40; // Bitwise OR
    mov word ptr [0x733a], 0;
    mov word ptr [0x7338], 0x4d2c;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], dx;
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], di;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 2]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 4]; // Load effective address
    push($1); // Push value onto stack
    $1(); // Call function
    les bx, ptr [bp + 0xe];
    mov word ptr es:[bx + 2], ax;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cmp byte ptr es:[bx + 4], 0; // Compare values
    jge 0x5240; // Jump if greater or equal (signed)
    push($1); // Push value onto stack
    $1 = $2;
    or ax, word ptr [bp + 4]; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    les bx, ptr [bp + 0xe];
    mov byte ptr es:[bx + 4], al;
    or al, al; // Bitwise OR
    jge 0x5240; // Jump if greater or equal (signed)
    les bx, ptr [bp + 0xe];
    mov byte ptr es:[bx + 4], 0xff;
    mov word ptr es:[bx + 2], 0;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    les bx, ptr [bp + 0xe];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 0xe];
    or word ptr es:[bx + 2], 0x200; // Bitwise OR
    $1 = $2;
    push($1); // Push value onto stack
    les bx, ptr [bp + 0xe];
    test word ptr es:[bx + 2], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    les bx, ptr [bp + 0xe];
    mov word ptr es:[bx + 0x10], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx + 4], 0; // Compare values
    jl 0x52df; // Jump if less (signed)
    $1 = $2;
    add word ptr [bp - 4], 0x14; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jb 0x52bd; // Jump if below (unsigned)
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx + 4], 0; // Compare values
    jl 0x52ef; // Jump if less (signed)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    or ax, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 0xe]; // Load effective address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    goto $1; // Jump to address
    $1++; // Increment value
    les bx, ptr [bp + 4];
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x5366; // Jump if below or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 4]; // Check if values are equal
    test word ptr es:[bx + 2], 0x40; // Test bits (AND without storing); Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr es:[bx + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jae 0x53e9; // Jump if above or equal (unsigned); Check if values are not equal
    cmp word ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1 += $2; // Add values
    $1 = $2;
    sub word ptr [bp + 8], ax; // Subtract values
    les bx, ptr [bp + 4];
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x5397; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    add word ptr [bp + 0xa], dx; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    add word ptr [bp + 8], ax; // Add values
    les bx, ptr [bp + 4];
    or word ptr es:[bx + 2], 0x20; // Bitwise OR
    goto $1; // Jump to address
    les bx, ptr [bp + 0xa];
    mov byte ptr es:[bx], dl;
    $1++; // Increment value
    $1--; // Decrement value
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 4];
    $1--; // Decrement value
    jl 0x5413; // Jump if less (signed)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp dx, -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    ja 0x548d; // Jump if above (unsigned)
    jb 0x546e; // Jump if below (unsigned)
    or ax, ax; // Bitwise OR
    jae 0x548d; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    div di; // Divide (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx], 0; // Compare values
    jge 0x54e8; // Jump if greater or equal (signed)
    $1 = $2;
    $1 += $2; // Add values
    $1++; // Increment value
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1 = $2;
    cdq ;
    xor ax, dx; // Bitwise XOR
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x40; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr es:[bx], 0; // Compare values
    jge 0x553e; // Jump if greater or equal (signed)
    goto $1; // Jump to address; Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    cmp byte ptr es:[bx], 0xa; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp byte ptr es:[bx], 0xa; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0; // Compare values; Prepare arguments and call function
    jle 0x5587; // Jump if less or equal (signed); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    cdq ;
    sub word ptr [bp + 0xa], ax; // Subtract values
    sbb word ptr [bp + 0xc], dx;
    les bx, ptr [bp + 6];
    and word ptr es:[bx + 2], 0xfe5f; // Bitwise AND
    mov word ptr es:[bx], 0;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp dx, -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp dx, -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0; // Compare values
    jl 0x560e; // Jump if less (signed)
    goto $1; // Jump to address
    $1 = $2;
    cwde ;
    shl ax, 1; // Shift left
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are equal
    cmp dx, -1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp dx, -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2; // Prepare arguments and call function
    *($1) = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    cdq ;
    add word ptr [bp - 4], ax; // Add values
    adc word ptr [bp - 2], dx; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    cdq ;
    sub word ptr [bp - 4], ax; // Subtract values
    sbb word ptr [bp - 2], dx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    or di, di; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1(); // Call function
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    ja 0x56f2; // Jump if above (unsigned)
    jb 0x56da; // Jump if below (unsigned)
    or ax, ax; // Bitwise OR
    jae 0x56f2; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = 0; // Bitwise XOR
    div di; // Divide (unsigned)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jae 0x5730; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = 0; // Bitwise XOR; Check if values are equal
    or dx, dx; // Bitwise OR; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    *($1) = $2; // Increment counter and check loop condition
    *($1) = $2; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x56f9; // Jump if below (unsigned)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    goto $1; // Jump to address
    les bx, ptr [bp - 4]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ax, 0x300; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    add word ptr [bp - 4], 0x14; // Add values
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    les bx, ptr [bp + 4];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], ax;
    or ax, ax; // Bitwise OR
    jle 0x57c2; // Jump if less or equal (signed)
    and word ptr es:[bx + 2], 0xffdf; // Bitwise AND
    $1 = 0; // Bitwise XOR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    les bx, ptr [bp + 4]; // Check if values are not equal
    cmp word ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and ax, 0xfe7f; // Bitwise AND
    or ax, 0x20; // Bitwise OR
    mov word ptr es:[bx + 2], ax;
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], 0;
    or word ptr es:[bx + 2], 0x10; // Bitwise OR
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 6];
    $1++; // Increment value; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0; // Compare values
    jle 0x583c; // Jump if less or equal (signed)
    les bx, ptr [bp + 6];
    $1--; // Decrement value
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0; // Compare values
    jl 0x58b4; // Jump if less (signed)
    test word ptr es:[bx + 2], 0x110; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr es:[bx + 2], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    les bx, ptr [bp + 6]; // Check if values are equal
    or word ptr es:[bx + 2], 0x80; // Bitwise OR; Check if values are equal
    cmp word ptr es:[bx + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 6];
    or word ptr es:[bx + 2], 0x10; // Bitwise OR
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    $1 = $2;
    and ax, 0xfe7f; // Bitwise AND
    or ax, 0x20; // Bitwise OR; Check if values are not equal
    mov word ptr es:[bx + 2], ax; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp byte ptr [0x8790], 0xd; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 0x40; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 6];
    and word ptr es:[bx + 2], 0xffdf; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 += $2; // Add values
    *($1) = $2;
    mov byte ptr [bp - 0x43], 0x3a;
    mov byte ptr [bp - 0x42], 0x5c;
    push($1); // Push value onto stack
    lea ax, [bp - 0x41]; // Load effective address
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 0x44]; // Load effective address
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jb 0x5950; // Jump if below (unsigned)
    mov word ptr [0x7f], 0x22;
    goto $1; // Jump to address
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    *($1) = $2;
    or ax, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [0x7f], 8;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 0x44]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    cdq ;
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    cld ; // Clear direction flag
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    jae 0x5a17; // Jump if above or equal (unsigned)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x5a36; // Jump if below (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    ret 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Write to file (DOS)
    $1 -= $2; // Subtract values; Write to file (DOS)
    $1 -= $2; // Subtract values; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    ret 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    test si, 0xc000; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and ax, 0xc000; // Bitwise AND
    or si, ax; // Bitwise OR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    *($1) = $2;
    test si, 0x100; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    and di, word ptr [0x74fc]; // Bitwise AND
    $1 = $2;
    test ax, 0x180; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are equal
    cmp word ptr [bp - 2], -1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [0x74fe], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    test di, 0x80; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test si, 0x400; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    goto $1; // Jump to address
    test si, 0xf0; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x5aeb; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x5b84; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    or ax, ax; // Bitwise OR
    jl 0x5b84; // Jump if less (signed)
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    test ax, 0x80; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, 0x2000; // Bitwise OR
    test si, 0x8000; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and ax, 0xff; // Bitwise AND
    or ax, 0x20; // Bitwise OR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    test si, 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 2], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test si, 0x100; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test si, 0xf0; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    or di, di; // Bitwise OR
    jl 0x5bb7; // Jump if less (signed)
    test si, 0x300; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    and dx, 0xf8ff; // Bitwise AND
    or dx, ax; // Bitwise OR
    push($1); // Push value onto stack
    test word ptr [bp - 2], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    or dx, ax; // Bitwise OR
    $1 = $2;
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    test cx, 2; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    test cx, 4; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    lds dx, ptr [bp + 6];
    $1 = $2; // Open file (DOS)
    and cl, byte ptr [bp + 0xa]; // Bitwise AND; Open file (DOS)
    or al, cl; // Bitwise OR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x5c06; // Jump if below (unsigned)
    *($1) = $2;
    $1 = $2;
    and ax, 0xb8ff; // Bitwise AND
    or ax, 0x8000; // Bitwise OR
    $1 = $2;
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 0xa]; // Load effective address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 8];
    $1--; // Decrement value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 8];
    cmp word ptr es:[bx], -1; // Compare values
    jge 0x5cac; // Jump if greater or equal (signed)
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    test word ptr es:[bx + 2], 8; // Test bits (AND without storing); Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [0x8792], 0xa; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [0x8792], 0xd; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    les bx, ptr [bp + 8];
    test word ptr es:[bx + 2], 0x90; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr es:[bx + 2], 2; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 8];
    or word ptr es:[bx + 2], 0x10; // Bitwise OR
    goto $1; // Jump to address; Check if values are equal
    les bx, ptr [bp + 8]; // Check if values are equal
    or word ptr es:[bx + 2], 0x100; // Bitwise OR; Check if values are equal
    cmp word ptr es:[bx + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 8];
    $1 = $2;
    neg ax; // Negate value
    mov word ptr es:[bx], ax;
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    test word ptr es:[bx + 2], 8; // Test bits (AND without storing); Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [0x8792], 0xa; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [0x8792], 0xd; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    goto $1; // Jump to address
    les bx, ptr [bp + 8];
    $1 = $2;
    cwde ;
    shl ax, 1; // Shift left
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp byte ptr [0x8792], 0xa; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 8];
    test word ptr es:[bx + 2], 0x40; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    les bx, ptr [bp + 8];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 8];
    test word ptr es:[bx + 2], 0x200; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 0xa];
    $1++; // Increment value
    $1 = $2; // Prepare arguments and call function
    cwde ; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x40; // Test bits (AND without storing); Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr es:[bx + 6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr es:[bx + 6], di; // Compare values; Check if values are equal
    jae 0x5ebc; // Jump if above or equal (unsigned); Check if values are equal
    cmp word ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    shl ax, 1; // Shift left
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    jl 0x5eec; // Jump if less (signed); Check if values are not equal
    cmp word ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    mov word ptr es:[bx], ax;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[bx], ax;
    add word ptr es:[bx + 0xc], di; // Add values
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    shl ax, 1; // Shift left
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    les bx, ptr [bp + 4]; // Check if values are equal
    cmp word ptr es:[bx + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    les bx, ptr [bp + 4];
    $1++; // Increment value
    jge 0x5f9f; // Jump if greater or equal (signed)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    les bx, ptr [bp + 0xa];
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 0xa];
    $1++; // Increment value; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x600c; // Jump if below (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address; Increment counter and check loop condition
    $1 = $2; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x6022; // Jump if below (unsigned)
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 0x200; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values; Increment counter and check loop condition
    *($1) = $2; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x6051; // Jump if below (unsigned)
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 0x4000; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    les si, ptr [bp + 8];
    $1 = $2;
    $1 = $2; // Check if values are equal
    cld ; // Clear direction flag; Check if values are equal
    lodsb al, byte ptr es:[si]; // Load string byte/word; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x6061; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    loop 0x6061; // Loop (decrement CX and jump if CX!=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 3]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    cld ; // Clear direction flag; Check if values are not equal
    $1 = $2; // Check if values are not equal
    stosb byte ptr es:[di], al; // Store string byte/word; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    neg cx; // Negate value
    sbb ax, ax;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    shl bx, 1; // Shift left
    or word ptr [bx + 0x74d2], 0x200; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 -= $2; // Subtract values
    xchg di, ax; // Exchange values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    les bx, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jg 0x60e7; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jbe 0x60ed; // Jump if below or equal (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [0x76ae], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp + 6], 0x7354; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [0x76ae], 1; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [0x76ac], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp + 6], 0x7340; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    mov word ptr [0x76ac], 1; // Check if values are equal
    les bx, ptr [bp + 6]; // Check if values are equal
    cmp word ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    les bx, ptr [bp + 6];
    and word ptr es:[bx + 2], 0xfff3; // Bitwise AND
    mov word ptr es:[bx + 6], 0;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[bx + 0xa], ax;
    mov word ptr es:[bx + 8], dx; // Check if values are equal
    mov word ptr es:[bx + 0xe], ax; // Check if values are equal
    mov word ptr es:[bx + 0xc], dx; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    jbe 0x61dc; // Jump if below or equal (unsigned)
    mov word ptr [0x7336], 0;
    mov word ptr [0x7334], 0x4d69;
    $1 = $2;
    or ax, word ptr [bp + 0xc]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    *($1) = $2;
    or ax, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    or word ptr es:[bx + 2], 4; // Bitwise OR
    goto $1; // Jump to address
    goto $1; // Jump to address
    les bx, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    mov word ptr es:[bx + 0xa], ax; // Check if values are not equal
    mov word ptr es:[bx + 8], dx; // Check if values are not equal
    mov word ptr es:[bx + 6], si; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or word ptr es:[bx + 2], 8; // Bitwise OR
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jb 0x6222; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    les bx, ptr [bp + 0xa];
    $1 += $2; // Add values
    mov byte ptr es:[bx], 0;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    les bx, ptr [bp + 4]; // Check if values are not equal
    cmp byte ptr es:[bx - 1], 0x2e; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    $1--; // Decrement value
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    *($1) = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    loop 0x6261; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    les bx, ptr [bp + 4]; // Check if values are not equal
    cmp byte ptr es:[bx - 2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = pop(); // Pop value from stack
    ret 4; // Return from function
    add byte ptr [bx + si], al; // Add values
    das ;
    add byte ptr [bp + si], bh; // Add values
    add byte ptr [si], bl; // Add values
    jle 0x62db; // Jump if less or equal (signed)
    jle 0x62dd; // Jump if less or equal (signed)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jle 0x62e1; // Jump if less or equal (signed)
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    or ax, word ptr [bp + 0xc]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 0xa];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    or ax, word ptr [bp + 0x10]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 0xe];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    or ax, word ptr [bp + 0x14]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 0x12];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    or ax, word ptr [bp + 0x18]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    les bx, ptr [bp + 0x16];
    mov byte ptr es:[bx], 0;
    lea ax, [bp - 0x58]; // Load effective address
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1++; // Increment value; Check if values are equal
    les bx, ptr [bp + 6]; // Check if values are equal
    cmp byte ptr es:[bx], 0x20; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0x630d; // Jump if less or equal (signed)
    $1 = $2;
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    add word ptr [bp - 4], si; // Add values
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1 = 0; // Bitwise XOR
    $1--; // Decrement value
    les bx, ptr [bp - 4];
    $1 = $2;
    cwde ;
    *($1) = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    loop 0x634b; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    or si, si; // Bitwise OR; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    cmp byte ptr es:[bx + 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test di, 2; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or di, 2; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    lea dx, [bp - 0x56]; // Load effective address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1++; // Increment value; Check if values are equal
    les bx, ptr [bp - 4]; // Check if values are equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, 8; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1--; // Decrement value
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1++; // Increment value; Check if values are equal
    $1++; // Increment value; Check if values are equal
    les bx, ptr [bp - 4]; // Check if values are equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, 4; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0; // Check if values are equal
    $1--; // Decrement value; Check if values are equal
    les bx, ptr [bp - 4]; // Check if values are equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[bx], 0x3a; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    lea dx, [bp - 0x56]; // Load effective address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    or di, 1; // Bitwise OR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are equal
    cmp byte ptr es:[bx], 0x3a; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr [bp - 0x57], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, 0x10; // Bitwise OR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x57]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [bx + si], al; // Add values
    $1 -= $2; // Subtract values
    add byte ptr cs:[bx], ch; // Add values
    add byte ptr [bp + si], bh; // Add values
    add byte ptr [bx], bh; // Add values
    add byte ptr [si], bl; // Add values
    lodsw ax, word ptr [si]; // Load string byte/word
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    fild word ptr [bx - 0x62];
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    fild word ptr [bx + 0x55];
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    les bx, ptr [bp + 4];
    add word ptr es:[bx], si; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 6];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 0xe]; // Load effective address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 6];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 6]; // Load effective address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    les bx, ptr [bp + 6];
    $1--; // Decrement value
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp + 0xe]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 6]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp + 6]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    les di, ptr [bp + 6]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    push($1); // Push value onto stack; Initialize counter for string operation
    lea si, [di - 1]; // Load effective address; Initialize counter for string operation
    les di, ptr [bp + 0xa]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    xchg di, si; // Exchange values
    test si, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1--; // Decrement value
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    jae 0x65ef; // Jump if above or equal (unsigned)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    xchg dx, ax; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    les di, ptr [bp + 0xa]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    cld ; // Clear direction flag
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or al, al; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    scasb al, byte ptr es:[di];
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x664a; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x664a; // Jump if above (unsigned)
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jb 0x6655; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values; Check if values are equal
    ja 0x6655; // Jump if above (unsigned); Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (ZF) goto $1; // Jump if equal (ZF=1); Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    xchg cx, ax; // Exchange values
    not ax; // Bitwise NOT
    $1--; // Decrement value
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    les di, ptr [bp + 0xa];
    $1 = $2; // Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6]; // Initialize counter for string operation
    xchg bx, cx; // Exchange values; Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    les bx, ptr [bp - 4]; // Check if values are equal
    $1 = $2; // Check if values are equal
    les bx, ptr [0x8794]; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    les bx, ptr [bp - 4]; // Check if values are equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [0x8794]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    les bx, ptr [0x8794]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    les bx, ptr [bp - 4]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    les bx, ptr [0x8794]; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[bx], 0;
    $1++; // Increment value
    goto $1; // Jump to address; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [0x8794]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    lds si, ptr [bp + 6];
    $1 = $2;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    ja 0x6790; // Jump if above (unsigned)
    $1 += $2; // Add values
    *($1) = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, al; // Bitwise AND
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg dx, ax; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x67b8; // Jump if below (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    $1 = $2;
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    jae 0x67c6; // Jump if above or equal (unsigned)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 0x800; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 0x4000; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 = $2;
    shl bx, 1; // Shift left
    and word ptr [bx + 0x74d2], 0xfdff; // Bitwise AND
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1--; // Decrement value
    les bx, ptr [bp - 0xc];
    $1++; // Increment value; Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0xd;
    $1++; // Increment value
    les bx, ptr [bp - 4];
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1++; // Increment value
    lea ax, [bp - 0x8e]; // Load effective address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values
    sbb bx, 0;
    or bx, bx; // Bitwise OR
    jl 0x68a3; // Jump if less (signed)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jb 0x68a3; // Jump if below (unsigned)
    lea ax, [bp - 0x8e]; // Load effective address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values
    sbb dx, 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp dx, -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    lea ax, [bp - 0x8e]; // Load effective address; Check if values are equal
    *($1) = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    lea ax, [bp - 0x8e]; // Load effective address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values
    sbb dx, 0;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jbe 0x68e4; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x8e]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    nop ; // No operation; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1(); // Call function; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp dx, -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 += $2; // Add values
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl bx, 1; // Shift left
    test word ptr [bx + 0x74d2], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 8];
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x6923; // Jump if below (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    shl bx, 1; // Shift left
    or word ptr [bx + 0x74d2], 0x1000; // Bitwise OR
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    // Compare $1 with $2 // Compare values
    jae 0x6964; // Jump if above or equal (unsigned)
    les bx, ptr [bp - 4];
    test word ptr es:[bx + 2], 3; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Increment counter and check loop condition
    add word ptr [bp - 4], 0x14; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x6943; // Jump if below (unsigned)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    goto $1; // Jump to address
    les bx, ptr [bp - 4];
    test word ptr es:[bx + 2], 3; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    add word ptr [bp - 4], 0x14; // Add values
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    les bx, ptr [bp - 4]; // Check if values are equal
    $1 = $2; // Check if values are equal
    les bx, ptr [0x8798]; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    les bx, ptr [bp - 4]; // Check if values are equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [0x8798]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    les bx, ptr [0x8798]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    les bx, ptr [bp - 4]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    les bx, ptr [0x8798]; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[bx], 0;
    $1++; // Increment value
    goto $1; // Jump to address; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [bp - 4]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    les bx, ptr [0x8798]; // Check if values are not equal
    cmp byte ptr es:[bx], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 0;
    mov word ptr [bp - 8], 0;
    lcall 0, 0xf71;
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x3d01; // Call function and clean up stack
    $1 += $2; // Add values
    cmp word ptr [bp + 6], 1; // Compare values
    jg 0x6aa2; // Jump if greater (signed)
    goto $1; // Jump to address
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x6abb; // Jump if less (signed)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x4b78; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1; // Jump if equal (ZF=1)
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x4b78; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1; // Jump if equal (ZF=1)
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 8], 1;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    les di, ptr es:[bx];
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1; // Jump if equal (ZF=1)
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    les di, ptr es:[bx];
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1; // Jump if equal (ZF=1)
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 6], 1;
    add word ptr [bp - 0x24], 4; // Add values
    $1++; // Increment value
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x6b71; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 0x22]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x1c]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x80]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x12]; // Load effective address
    push($1); // Push value onto stack
    les bx, ptr [bp + 8]; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x4891; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = $2;
    cwde ; // Call function and clean up stack
    $1 += $2; // Add values; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0xf8b; // Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack; Initialize counter for string operation
    lea di, [bp - 0x80]; // Load effective address; Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    not cx; // Bitwise NOT
    $1--; // Decrement value
    $1--; // Decrement value
    lea ax, [bp - 0x80]; // Load effective address
    $1 += $2; // Add values
    $1 = $2;
    mov byte ptr ss:[bx], 0; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0xdeb; // Call function and clean up stack
    $1 += $2; // Add values; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Check if values are equal
    lcall 0x19fe, 0x2f; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr [bp - 8], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    lcall 0, 0x38d;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x3e]; // Load effective address
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x80c, 0x2bd;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc ax, 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1a10, 0x20;
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x7f4, 0xa;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [0x7736], 0x2328;
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x2bb; // Call function and clean up stack
    $1 += $2; // Add values
    mov word ptr [0x772a], 1;
    mov word ptr [0x7728], 1;
    lcall 0x1a05, 0x20;
    lcall 0x1a7e, 0x20;
    goto $1; // Jump to address; Check if values are equal
    lcall 0x1a08, 0x20; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    jg 0x6c8e; // Jump if greater (signed); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    lcall 0x1a92, 0x20; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 4], 1;
    goto $1; // Jump to address; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a1b, 0x20; // Call function and clean up stack
    $1 += $2; // Add values
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 4], 1;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1a10, 0x20;
    *($1) = $2;
    *($1) = $2;
    lcall 0x1a7e, 0x25;
    lcall 0x1a7e, 0x20; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a43, 0x25; // Call function and clean up stack
    $1 += $2; // Add values
    *($1) = $2;
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are not equal
    jg 0x6d00; // Jump if greater (signed); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a2b, 0x20; // Call function and clean up stack
    $1 += $2; // Add values
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0xeec, 0x789;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x10b4, 0x136;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x104d, 0x96;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x185d, 4;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x183e, 2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x183e, 0x47;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x17b8, 0x50;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x183e, 0x47;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x54a, 0x1c5;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xeec, 0x789;
    lcall 0x1a83, 0x20; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a8b, 0x20; // Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    lcall 0x1a83, 0x25;
    goto $1; // Jump to address
    lcall 0x1a83, 0x20; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0x1a8b, 0x20; // Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    lcall 0x1a83, 0x25; // Check if values are not equal
    mov word ptr [bp - 4], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 4], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 0;
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    lcall 0x1a10, 0x25; // Check if values are not equal
    cmp word ptr [bp - 4], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lcall 0x1a7e, 0x25;
    lcall 0, 0x38d;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1a10, 0x25;
    goto $1; // Jump to address
    mov word ptr [0x772a], 0;
    mov word ptr [0x7728], 0;
    lcall 0x1a05, 0x20;
    lcall 0x1aab, 0x20;
    lcall 0x19fe, 0x2a;
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0xfcd; // Call function and clean up stack
    $1 += $2; // Add values
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0xfdc; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0xfdc; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    and al, 0xff; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    and al, 1; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    and al, 0xff; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    and al, 0xff; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    and al, 1; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    sar ax, 1; // Shift right (signed)
    and al, 3; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    and al, 8; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    and al, 0x10; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    and al, 0x20; // Bitwise AND
    *($1) = $2; // Check if values are not equal
    mov word ptr [0xe4], 0; // Check if values are not equal
    mov word ptr [0xe2], 0; // Check if values are not equal
    cmp byte ptr [0x7c59], 0xc; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    cdq ; // Check if values are equal
    idiv bx; // Divide (signed); Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [0xe0], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    add word ptr [0xe2], 1; // Add values
    adc word ptr [0xe4], 0;
    // Compare $1 with $2 // Compare values
    jb 0x6f2a; // Jump if below (unsigned)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jb 0x6f2a; // Jump if below (unsigned)
    mov word ptr [bp + 0x10], 1;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    iret ;
    mov word ptr [0xe0], 0;
    mov byte ptr [0x7bda], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    or ax, ax; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x48fb; // Call function and clean up stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x48fb; // Call function and clean up stack
    $1 += $2; // Add values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    mov word ptr [0x7c5b], 1; // Check if values are equal
    cmp word ptr [0xde], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x48fb; // Call function and clean up stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp + 0x10], 3;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    iret ;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Call function and clean up stack
    $1 = $2; // Call function and clean up stack
    push($1); // Push value onto stack; Call function and clean up stack
    lcall 0, 0x48fb; // Call function and clean up stack
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x10b4, 0x136;
    push($1); // Push value onto stack
    lcall 0x10b4, 0x343;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x104d, 0x96;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x185d, 4;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x183e, 2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x17b8, 0x50;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x17b8, 0x50;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x17b8, 0x50;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x17b8, 0x50;
    lcall 0, 0x2bdd;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp + 0x10], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    iret ;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    nop ; // No operation
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    sti ; // Set interrupt flag; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [bp + 6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2; // Prepare arguments and call function
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0x710b; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x710b; // Jump if above (unsigned)
    $1 = $2;
    mul cx; // Multiply (unsigned)
    $1 = $2;
    div cx; // Divide (unsigned)
    *($1) = $2;
    mov word ptr [0x54d2], 0;
    goto $1; // Jump to address
    cli ; // Clear interrupt flag
    $1 = $2;
    out 0x43, al; // Output to port
    $1 = 0; // Bitwise XOR
    out 0x40, al; // Output to port
    out 0x40, al; // Output to port
    sti ; // Set interrupt flag
    mov word ptr [0x54d2], 1;
    mov word ptr [bp - 2], 0;
    popf ; // Pop flags from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    pushf ; // Push flags onto stack; Check if values are not equal
    cmp word ptr [0x54d2], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    cli ; // Clear interrupt flag
    $1 = $2;
    out 0x43, al; // Output to port
    $1 = 0; // Bitwise XOR
    out 0x40, al; // Output to port
    out 0x40, al; // Output to port
    sti ; // Set interrupt flag
    mov word ptr [0x54d2], 1;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    cli ; // Clear interrupt flag
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    sti ; // Set interrupt flag; Check if values are not equal
    cmp word ptr [0x54d2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 0;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    out 0x43, al; // Output to port
    in al, 0x40; // Input from port
    xchg al, ah; // Exchange values
    in al, 0x40; // Input from port
    xchg al, ah; // Exchange values
    not ax; // Bitwise NOT; Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cmp word ptr [bp - 4], 0x8000; // Compare values
    ja 0x71d0; // Jump if above (unsigned)
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    sti ; // Set interrupt flag
    cmp word ptr [0x54ce], dx; // Compare values
    ja 0x71de; // Jump if above (unsigned)
    jb 0x71e4; // Jump if below (unsigned)
    cmp word ptr [0x54cc], ax; // Compare values
    jbe 0x71e4; // Jump if below or equal (unsigned)
    $1 += $2; // Add values
    adc dx, 0x18;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [0x54ce];
    $1 = $2;
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    mul word ptr [bp - 4]; // Multiply (unsigned)
    $1 = $2;
    lcall 0x7ff, 0x32;
    $1 = $2;
    lcall 0x7ff, 0x32;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    adc dx, bx;
    *($1) = $2;
    popf ; // Pop flags from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    cmp word ptr [bp + 8], dx; // Compare values
    ja 0x7248; // Jump if above (unsigned)
    jb 0x724f; // Jump if below (unsigned)
    cmp word ptr [bp + 6], ax; // Compare values
    jbe 0x724f; // Jump if below or equal (unsigned)
    $1 += $2; // Add values
    adc dx, 0x526;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp + 8];
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [0x54d8], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    int 0x16; // Call interrupt
    $1 = pop(); // Pop value from stack
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    int 0x16; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    sub word ptr [bp + 6], 1; // Subtract values
    sbb word ptr [bp + 8], 0; // Prepare arguments and call function
    jl 0x72ce; // Jump if less (signed); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    ja 0x72ce; // Jump if above (unsigned)
    jb 0x7289; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x7289; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    clc ; // Clear carry flag
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffec;
    stc ; // Set carry flag
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    imul al; // Multiply (signed)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    imul al; // Multiply (signed)
    $1 += $2; // Add values
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    imul al; // Multiply (signed)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jae 0x7348; // Jump if above or equal (unsigned)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 0x3f; // Bitwise AND; Check if values are equal
    and dx, 0x3f3f; // Bitwise AND; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1(); // Call function
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and al, 0x3f; // Bitwise AND
    $1 = $2;
    and ah, al; // Bitwise AND
    $1 = $2;
    and bh, al; // Bitwise AND
    $1 = $2;
    and ch, al; // Bitwise AND
    $1 = 0; // Bitwise XOR
    or ah, ah; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    or bh, bh; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    or ch, ch; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    lodsb al, byte ptr [si]; // Load string byte/word; Access element in an array of words
    $1 = 0; // Bitwise XOR; Access element in an array of words
    $1 = $2; // Access element in an array of words
    shl bx, 1; // Shift left
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 += $2; // Add values; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    lds si, ptr [bp + 0xa];
    $1 = $2;
    and bl, 3; // Bitwise AND
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (ZF) goto $1; // Jump if equal (ZF=1); Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa]; // Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    $1 = 0; // Bitwise XOR; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep stosb byte ptr es:[di], al; // Fill memory block
    lodsb al, byte ptr [si]; // Load string byte/word; Access element in an array of words
    $1 = 0; // Bitwise XOR; Access element in an array of words
    $1 = $2; // Access element in an array of words
    shl bx, 1; // Shift left
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 += $2; // Add values; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xfff6;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jbe 0x7504; // Jump if below or equal (unsigned)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    and dh, al; // Bitwise AND
    $1 = $2;
    and dl, al; // Bitwise AND
    $1 = $2;
    and ah, al; // Bitwise AND
    $1 = 0; // Bitwise XOR
    or dh, dh; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = 0; // Bitwise XOR
    or dl, dl; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = 0; // Bitwise XOR
    or ah, ah; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x7504; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    lds si, ptr [bp + 0xa]; // Check if values are not equal
    cmp word ptr [bp + 0xe], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xfff6;
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    push($1); // Push value onto stack; Prepare arguments and call function
    lodsb al, byte ptr [si]; // Load string byte/word; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    cmp word ptr [bp + 0xe], 3; // Compare values
    jbe 0x75b0; // Jump if below or equal (unsigned)
    mov word ptr [bp + 0xe], 3;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    mov word ptr [bp - 6], 0xffff;
    $1 = $2;
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    imul al; // Multiply (signed)
    *($1) = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    imul al; // Multiply (signed)
    add word ptr [bp - 4], ax; // Add values
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    imul al; // Multiply (signed); Increment counter and check loop condition
    add word ptr [bp - 4], ax; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x75da; // Jump if below (unsigned)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    cmp word ptr [bp - 6], ax; // Compare values
    jb 0x7620; // Jump if below (unsigned)
    *($1) = $2;
    *($1) = $2;
    or ax, ax; // Bitwise OR; Increment counter and check loop condition
    if (ZF) goto $1; // Jump if equal (ZF=1); Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x75b0; // Jump if below (unsigned)
    les di, ptr [bp + 6];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 += $2; // Add values
    les di, ptr [bp + 6];
    $1 = $2;
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    push($1); // Push value onto stack; Prepare arguments and call function
    lodsb al, byte ptr [si]; // Load string byte/word; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    stosb byte ptr es:[di], al; // Store string byte/word
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 5], 8;
    mov byte ptr [bp - 4], 1;
    mov byte ptr [bp - 3], 9;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xfff6;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jbe 0x76b5; // Jump if below or equal (unsigned)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl dh, 1; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or al, dh; // Bitwise OR
    or al, dl; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x76b5; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    mul dh; // Multiply (unsigned)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    mul dl; // Multiply (unsigned)
    $1 += $2; // Add values
    lodsb al, byte ptr [si]; // Load string byte/word
    mul ch; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    div bl; // Divide (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    adc al, 0; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0x7747; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xe];
    les di, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0x77a1; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x7798; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    lea di, [bp - 0x32]; // Load effective address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Initialize counter for string operation
    $1(); // Call function; Initialize counter for string operation
    goto $1; // Jump to address; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = $2;
    $1 = $2;
    lea di, [bp - 0x32]; // Load effective address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    *($1) = $2; // Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jb 0x77f0; // Jump if below (unsigned); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Initialize counter for string operation
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    *($1) = $2; // Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x7872; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    lds si, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    *($1) = $2; // Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x7913; // Jump if below (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    mov byte ptr es:[di], al;
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jb 0x7939; // Jump if below (unsigned); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    *($1) = $2; // Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x796e; // Jump if below (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    mov byte ptr es:[di], al;
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x7994; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function; Check if values are not equal
    mov byte ptr es:[di + 0x10], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 0x10];
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x7a80; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di], 0xca00;
    mov byte ptr es:[di + 2], 2;
    mov byte ptr es:[di + 3], 2;
    $1 = $2;
    mov word ptr es:[di + 4], ax;
    $1 = 0; // Bitwise XOR
    mov word ptr es:[di + 6], ax;
    mov word ptr es:[di + 8], ax;
    $1 = $2;
    mov word ptr es:[di + 0x2c], ax;
    $1--; // Decrement value
    mov word ptr es:[di + 0xa], ax;
    $1 = $2;
    mov word ptr es:[di + 0x2e], ax;
    $1--; // Decrement value
    mov word ptr es:[di + 0xc], ax;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mov byte ptr es:[di + 0x12], al;
    mul word ptr [bp + 6]; // Multiply (unsigned)
    mov word ptr es:[di + 0x34], ax;
    $1 = $2;
    mov word ptr es:[di + 0xe], ax;
    $1 = $2;
    mov word ptr es:[di + 0x10], ax;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mov byte ptr es:[di + 0x13], al;
    mul word ptr [bp + 8]; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    mov word ptr es:[di + 0x30], ax;
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    mov word ptr es:[di + 0x14], ax;
    $1 = $2;
    xor cl, 7; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    not ch; // Bitwise NOT
    mov word ptr es:[di + 0x32], cx;
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mov word ptr es:[di + 0x16], ax; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr es:[di + 0x22], dx;
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di + 0x24], bx;
    mov word ptr es:[di + 0x26], 0;
    $1 = $2;
    int 0x67; // Call interrupt
    and ax, 0xff00; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffea; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr es:[di + 0x22], dx;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di + 0x24], bx;
    mov word ptr es:[di + 0x26], 0;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffdb; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr es:[di + 0x22], dx;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di + 0x24], bx;
    mov word ptr es:[di + 0x26], 0;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr es:[di + 0x1a], bx;
    mov word ptr es:[di + 0x18], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1c], ax;
    $1 = 0; // Bitwise XOR
    mov word ptr es:[di + 0x1e], ax;
    mov word ptr es:[di + 0x20], ax;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mov word ptr es:[di + 0x74], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 0xc];
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0x2e7;
    or dx, dx; // Bitwise OR
    jge 0x7c32; // Jump if greater or equal (signed)
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jae 0x7c4d; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are not equal
    mov word ptr [bp - 2], 0xffe6; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jb 0x7c82; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe9;
    goto $1; // Jump to address; Check if values are not equal
    mov word ptr [bp - 2], 0xffea; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jb 0x7cc6; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffda;
    goto $1; // Jump to address; Check if values are not equal
    mov word ptr [bp - 2], 0xffdb; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jb 0x7d0b; // Jump if below (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe1;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    xchg dx, ax; // Exchange values
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0xffe8; // Check if values are equal
    les di, ptr [bp + 6]; // Check if values are equal
    cmp word ptr es:[di], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffe7; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffea; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffdb; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe2;
    goto $1; // Jump to address
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    rep stosb byte ptr es:[di], al; // Fill memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    cmp byte ptr [0x54e3], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe3;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp byte ptr [0x54e3], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [si + 1], 0x3a; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    and byte ptr es:[di - 1], 0xdf; // Bitwise AND
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    goto $1; // Jump to address
    $1 = $2;
    int 0x21; // Call interrupt
    $1 += $2; // Add values
    mov byte ptr es:[di], al;
    $1++; // Increment value; Check if values are equal
    mov byte ptr es:[di], 0x3a; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 0x5c; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], 0x5c;
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jae 0x7ed3; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe0;
    goto $1; // Jump to address; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    or cx, cx; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1--; // Decrement value; Check if values are equal
    cmp byte ptr es:[di - 1], 0x5c; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], 0x5c;
    $1++; // Increment value
    cld ; // Clear direction flag
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr es:[di - 1], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1--; // Decrement value; Check if values are equal
    cmp byte ptr es:[di - 1], 0x5c; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], 0x5c;
    $1++; // Increment value
    mov byte ptr es:[di], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x7f33; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe0; // Close file (DOS)
    goto $1; // Jump to address; Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    jb 0x7f44; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x7f4b; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xffe6;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr [si], 0xffff;
    mov word ptr [si + 2], 0xffff;
    mov word ptr [si + 4], 0xffff;
    mov word ptr [si + 6], 0;
    $1 += $2; // Add values
    loop 0x7f9b; // Loop (decrement CX and jump if CX!=0)
    mov byte ptr [0x54e3], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    cmp byte ptr [0x54e3], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr [0x4283], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe7;
    goto $1; // Jump to address
    mov byte ptr [0x54e3], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mov byte ptr [bp + 7], 0; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [0x54e3], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffe3; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Check if values are not equal
    $1 = $2; // Check if values are not equal
    mov word ptr [bp - 0xe], 0xffff; // Check if values are not equal
    cmp word ptr es:[di], dx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr es:[di + 2], bx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    cmp word ptr es:[di + 4], cx; // Compare values
    jle 0x80c0; // Jump if less or equal (signed)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2; // Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values; Check if values are equal
    jb 0x809e; // Jump if below (unsigned); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp ax, -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp + 6], al; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are equal
    mul bl; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr es:[di + 4], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 4], cx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr es:[di + 4], cx;
    mov word ptr es:[di + 6], 1;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    mul byte ptr [bp + 6]; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr es:[di], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr es:[di + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mul word ptr es:[di + 2]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x8147; // Jump if below (unsigned)
    $1 = $2;
    mul word ptr [bp + 6]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jae 0x814a; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr es:[di], dx;
    $1 = $2;
    mov word ptr es:[di + 2], bx;
    $1 = $2; // Check if values are not equal
    mov word ptr es:[di + 4], cx; // Check if values are not equal
    mov word ptr es:[di + 6], cx; // Check if values are not equal
    cmp byte ptr [bp - 0xe], 0xff; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jb 0x8197; // Jump if below (unsigned)
    $1 = $2;
    mul word ptr [bp + 6]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack; Check if values are not equal
    jae 0x8206; // Jump if above or equal (unsigned); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 0x12], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx; // Multiply (unsigned)
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp - 0xe]; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0xe], 0xffff; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr es:[di + 4], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr es:[di + 4], cx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di], 0xffff;
    mov word ptr es:[di + 2], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 6], 0;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe2;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [0x54e3], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    int 0x21; // Call interrupt
    $1++; // Increment value
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    and dl, 0xdf; // Bitwise AND
    $1 -= $2; // Subtract values; Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    cmp ax, -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mul cx; // Multiply (unsigned)
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe2;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    mov byte ptr [si], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x82a3; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jb 0x82dc; // Jump if below (unsigned)
    loop 0x82a8; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp - 0xc];
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si], dx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    $1 += $2; // Add values; Close file (DOS)
    loop 0x82ef; // Loop (decrement CX and jump if CX!=0); Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    jb 0x8333; // Jump if below (unsigned)
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp - 0xc];
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x8333; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffe2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x8364; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0xe], 0;
    mov word ptr [bp - 0xc], 4;
    mov word ptr [bp - 0xa], 4;
    mov word ptr [bp - 8], 0x10;
    mov word ptr [bp - 6], 0x10;
    mov word ptr [bp - 4], 0x100;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR; Prepare arguments and call function
    jl 0x83d0; // Jump if less (signed); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jl 0x83d0; // Jump if less (signed)
    $1 = $2;
    shl si, 1; // Shift left
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0xe], 0;
    mov word ptr [bp - 0xc], 4;
    mov word ptr [bp - 0xa], 4;
    mov word ptr [bp - 8], 0x10;
    mov word ptr [bp - 6], 0x10;
    mov word ptr [bp - 4], 0x100;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR; Prepare arguments and call function
    jl 0x8434; // Jump if less (signed); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jl 0x8434; // Jump if less (signed)
    $1 = $2;
    shl si, 1; // Shift left
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x8461; // Jump if greater or equal (signed)
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jge 0x846f; // Jump if greater or equal (signed); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    lea ax, [bp + 6]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x84b9; // Jump if greater or equal (signed)
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jge 0x84c7; // Jump if greater or equal (signed); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    lea ax, [bp - 4]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x851c; // Jump if greater or equal (signed)
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jge 0x852a; // Jump if greater or equal (signed); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    lea ax, [bp - 6]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x858b; // Jump if greater or equal (signed)
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jge 0x8599; // Jump if greater or equal (signed); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    lea ax, [bp - 6]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    les di, ptr [bp + 0xe];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    les di, ptr [bp + 0xa];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    les di, ptr [bp + 6];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [bp + 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x8634; // Jump if less (signed)
    $1 -= $2; // Subtract values
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR; Check if values are not equal
    or dh, 0x10; // Bitwise OR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    or dh, 0x10; // Bitwise OR
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 3; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x8696; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0x86ae; // Jump if below (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value; Check if values are not equal
    loop 0x86ae; // Loop (decrement CX and jump if CX!=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 4; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x86da; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    out dx, al; // Output to port
    $1 += $2; // Add values
    $1 = $2;
    in al, dx; // Input from port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    loop 0x86da; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 5; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x8735; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    $1 = $2;
    cmp word ptr [bp + 0xa], ax; // Compare values
    jae 0x8748; // Jump if above or equal (unsigned)
    $1 = $2;
    sub word ptr [bp + 0xa], ax; // Subtract values
    $1 = $2;
    shl cx, 1; // Shift left
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    loop 0x875b; // Loop (decrement CX and jump if CX!=0)
    cmp word ptr [bp + 0xa], 0; // Compare values
    jg 0x873d; // Jump if greater (signed)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are not equal
    cmp word ptr [bp + 0xe], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 0xe], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 0xe], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and bl, 0xf; // Bitwise AND
    mov byte ptr es:[di], bl;
    $1 = $2;
    and bl, 0x20; // Bitwise AND
    $1 = $2;
    shr bl, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    and bl, 0x10; // Bitwise AND
    $1 = $2;
    shr bl, cl; // Shift right (unsigned)
    $1 += $2; // Add values; Check if values are not equal
    mov byte ptr es:[di + 1], bl; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 3; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0x98e, 0x35e;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x8807; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    lds si, ptr [0xa8];
    lds si, ptr [si + 4];
    $1 = $2;
    or ax, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    lea si, [bp - 0x18]; // Load effective address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x882e; // Jump if less (signed); Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [bp - 6], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Increment counter and check loop condition
    add byte ptr [bx + si], 0xe; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jl 0x8826; // Jump if less (signed)
    mov byte ptr [bp - 8], 0;
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block; Check if values are not equal
    cmp word ptr [bp + 0xa], 0x10; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 4; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2;
    shl bl, 1; // Shift left
    $1 -= $2; // Subtract values
    $1 = $2;
    shl bl, cl; // Shift left
    $1 = $2;
    shl bh, cl; // Shift left
    not bh; // Bitwise NOT
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x888b; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2;
    and bh, ah; // Bitwise AND
    or bh, al; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value; Check if values are not equal
    loop 0x888b; // Loop (decrement CX and jump if CX!=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xe], 5; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x88ce; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 0x36], 0x78;
    mov byte ptr [bp - 0x35], 0x7e;
    mov byte ptr [bp - 0x34], 0x28;
    mov byte ptr [bp - 0x33], 0x28;
    mov byte ptr [bp - 0x32], 0x28;
    mov byte ptr [bp - 0x31], 0x28;
    mov byte ptr [bp - 0x30], 0x18;
    mov byte ptr [bp - 0x2f], 8;
    mov byte ptr [bp - 0x2e], 0x18;
    mov byte ptr [bp - 0x2d], 7;
    mov byte ptr [bp - 0x2c], 8;
    mov byte ptr [bp - 0x2b], 8;
    mov byte ptr [bp - 0x2a], 8;
    mov byte ptr [bp - 0x29], 8;
    mov byte ptr [bp - 0x28], 8;
    mov byte ptr [bp - 0x27], 8;
    mov byte ptr [bp - 0x26], 8;
    mov byte ptr [bp - 0x25], 8;
    mov byte ptr [bp - 0x24], 8;
    mov byte ptr [bp - 0x23], 8;
    mov byte ptr [bp - 0x22], 8;
    mov byte ptr [bp - 0x21], 8;
    mov byte ptr [bp - 0x20], 8;
    mov byte ptr [bp - 0x1f], 8;
    mov byte ptr [bp - 0x1e], 8;
    mov byte ptr [bp - 0x1d], 8;
    mov byte ptr [bp - 0x1c], 8;
    mov byte ptr [bp - 0x1b], 8;
    mov byte ptr [bp - 0x1a], 8;
    mov byte ptr [bp - 0x19], 8;
    mov byte ptr [bp - 0x18], 8;
    mov byte ptr [bp - 0x17], 8;
    mov byte ptr [bp - 0x16], 8;
    mov byte ptr [bp - 0x15], 8;
    mov byte ptr [bp - 0x14], 8;
    mov byte ptr [bp - 0x13], 8;
    mov byte ptr [bp - 0x12], 8;
    mov byte ptr [bp - 0x11], 8;
    mov byte ptr [bp - 0x10], 8;
    mov byte ptr [bp - 0xf], 8;
    mov byte ptr [bp - 0xe], 8;
    mov byte ptr [bp - 0x60], 0x78;
    mov byte ptr [bp - 0x5f], 0x78;
    mov byte ptr [bp - 0x5e], 0x38;
    mov byte ptr [bp - 0x5d], 0x38;
    mov byte ptr [bp - 0x5c], 0x98;
    mov byte ptr [bp - 0x5b], 0x38;
    mov byte ptr [bp - 0x5a], 0x18;
    mov byte ptr [bp - 0x59], 0x18;
    mov byte ptr [bp - 0x58], 0x18;
    mov byte ptr [bp - 0x57], 0xa0;
    mov byte ptr [bp - 0x56], 0x18;
    mov byte ptr [bp - 0x55], 0x18;
    mov byte ptr [bp - 0x54], 0x18;
    mov byte ptr [bp - 0x53], 0x18;
    mov byte ptr [bp - 0x52], 0x18;
    mov byte ptr [bp - 0x51], 0x98;
    mov byte ptr [bp - 0x50], 0x18;
    mov byte ptr [bp - 0x4f], 0x18;
    mov byte ptr [bp - 0x4e], 0x18;
    mov byte ptr [bp - 0x4d], 0x18;
    mov byte ptr [bp - 0x4c], 0x18;
    mov byte ptr [bp - 0x4b], 0x18;
    mov byte ptr [bp - 0x4a], 0x18;
    mov byte ptr [bp - 0x49], 0x18;
    mov byte ptr [bp - 0x48], 0x18;
    mov byte ptr [bp - 0x47], 0x18;
    mov byte ptr [bp - 0x46], 0x18;
    mov byte ptr [bp - 0x45], 0x18;
    mov byte ptr [bp - 0x44], 0x18;
    mov byte ptr [bp - 0x43], 0x18;
    mov byte ptr [bp - 0x42], 0x18;
    mov byte ptr [bp - 0x41], 0x18;
    mov byte ptr [bp - 0x40], 0x18;
    mov byte ptr [bp - 0x3f], 0x18;
    mov byte ptr [bp - 0x3e], 0x18;
    mov byte ptr [bp - 0x3d], 0x18;
    mov byte ptr [bp - 0x3c], 0x18;
    mov byte ptr [bp - 0x3b], 0x18;
    mov byte ptr [bp - 0x3a], 0x18;
    mov byte ptr [bp - 0x39], 0x18;
    mov byte ptr [bp - 0x38], 0x18;
    mov byte ptr [bp - 0x80], 0x88;
    mov byte ptr [bp - 0x7f], 0x88;
    mov byte ptr [bp - 0x7e], 0x88;
    mov byte ptr [bp - 0x7d], 0x88;
    mov byte ptr [bp - 0x7c], 0x40;
    mov byte ptr [bp - 0x7b], 0x40;
    mov byte ptr [bp - 0x7a], 0x40;
    mov byte ptr [bp - 0x79], 0x40;
    mov byte ptr [bp - 0x78], 0x20;
    mov byte ptr [bp - 0x77], 0x20;
    mov byte ptr [bp - 0x76], 0x20;
    mov byte ptr [bp - 0x75], 0x20;
    mov byte ptr [bp - 0x74], 0x10;
    mov byte ptr [bp - 0x73], 0x10;
    mov byte ptr [bp - 0x72], 0x10;
    mov byte ptr [bp - 0x71], 0x10;
    mov byte ptr [bp - 0x70], 8;
    mov byte ptr [bp - 0x6f], 0x40;
    mov byte ptr [bp - 0x6e], 0x40;
    mov byte ptr [bp - 0x6d], 0x20;
    mov byte ptr [bp - 0x6c], 0x10;
    mov byte ptr [bp - 0x6b], 4;
    mov byte ptr [bp - 0x6a], 4;
    mov byte ptr [bp - 0x69], 4;
    mov byte ptr [bp - 0x68], 4;
    mov byte ptr [bp - 0x67], 4;
    mov byte ptr [bp - 0x66], 0xfc;
    mov byte ptr [bp - 0x65], 0xfc;
    mov byte ptr [bp - 0x64], 0xfc;
    mov byte ptr [bp - 0x63], 0xfc;
    mov byte ptr [bp - 0x62], 0xfc;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x8b19; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0xae3, 0;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr [bp - 4], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    cmp byte ptr [bp - 6], 0x80; // Compare values
    jb 0x8b4a; // Jump if below (unsigned)
    sub byte ptr [bp - 6], 0x7a; // Subtract values
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    shl al, cl; // Shift left
    jb 0x8b58; // Jump if below (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    shl al, cl; // Shift left
    jb 0x8b66; // Jump if below (unsigned)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jae 0x8b6e; // Jump if above or equal (unsigned); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    lcall 0x921, 0x1a5; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jae 0x8b80; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lcall 0x98e, 0xdf;
    jae 0x8b8e; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffd8;
    goto $1; // Jump to address
    test word ptr es:[di], 1; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jg 0x8bca; // Jump if greater (signed)
    lcall 0x921, 0x55;
    // Compare $1 with $2 // Compare values
    jg 0x8bca; // Jump if greater (signed)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0xc]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x921, 0x1fc;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    shl al, cl; // Shift left
    jb 0x8bec; // Jump if below (unsigned)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0x8c05; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x98e, 0xc;
    $1 = $2;
    or si, si; // Bitwise OR
    jge 0x8c05; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0x8c11; // Jump if above (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [0x54d4], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 3; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 4; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 6], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 6], 4; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 6], 8; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    mov byte ptr [bp - 8], 1;
    mov byte ptr [bp - 7], 4;
    mov byte ptr [bp - 6], 6;
    mov byte ptr [bp - 5], 9;
    mov byte ptr [bp - 4], 0xf;
    mov byte ptr [bp - 0x12], 5;
    mov byte ptr [bp - 0x11], 7;
    mov byte ptr [bp - 0x10], 0xa;
    mov byte ptr [bp - 0xf], 0xe;
    mov byte ptr [bp - 0xe], 0x12;
    mov byte ptr [bp - 0xd], 0x16;
    mov byte ptr [bp - 0xc], 0x1f;
    mov byte ptr [bp - 0xb], 0x26;
    mov byte ptr [bp - 0x26], 8;
    mov byte ptr [bp - 0x25], 0xb;
    mov byte ptr [bp - 0x24], 0xd;
    mov byte ptr [bp - 0x23], 0x1a;
    mov byte ptr [bp - 0x22], 0x10;
    mov byte ptr [bp - 0x21], 0x1b;
    mov byte ptr [bp - 0x20], 0x1c;
    mov byte ptr [bp - 0x1f], 0x13;
    mov byte ptr [bp - 0x1e], 0x15;
    mov byte ptr [bp - 0x1d], 0x1d;
    mov byte ptr [bp - 0x1c], 0x17;
    mov byte ptr [bp - 0x1b], 0x19;
    mov byte ptr [bp - 0x1a], 0x1e;
    mov byte ptr [bp - 0x19], 0x20;
    mov byte ptr [bp - 0x18], 0x22;
    mov byte ptr [bp - 0x17], 0x23;
    mov byte ptr [bp - 0x16], 0x24; // Check if values are equal
    mov byte ptr [bp - 0x15], 0x27; // Check if values are equal
    mov byte ptr [bp - 0x14], 0x28; // Check if values are equal
    cmp word ptr [bp + 8], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 3; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 4; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 6], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 6], 4; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 6], 8; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    jge 0x8d3b; // Jump if greater or equal (signed)
    goto $1; // Jump to address; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value; Check if values are equal
    jge 0x8d61; // Jump if greater or equal (signed); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    jge 0x8d81; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [0x55f3], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x8ddb; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x8dee; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr [si], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff9;
    goto $1; // Jump to address
    les di, ptr [bp + 0xa];
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x8e39; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp + 8], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jb 0x8e46; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x8e55; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0x8e61; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 8], ax; // Compare values
    jbe 0x8e72; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0x8e83; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x8ead; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp + 6], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jb 0x8eba; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x8ec9; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0x8ed5; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 6], ax; // Compare values
    jbe 0x8ee6; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0x8ef7; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2; // Check if values are not equal
    mov word ptr [bp - 0x2c], 0xffff; // Check if values are not equal
    mov word ptr [bp - 0x2e], 0; // Check if values are not equal
    cmp byte ptr [bp - 0xe], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    shr dl, cl; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    shr dh, cl; // Shift right (unsigned)
    not dh; // Bitwise NOT
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0x8f5c; // Jump if less (signed)
    $1 = $2;
    *($1) = $2;
    or dh, dh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and byte ptr [bp - 0x2c], dh; // Bitwise AND
    mov byte ptr [bp - 0x2b], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    *($1) = $2;
    mov word ptr [bp - 0x32], 1;
    $1 = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    // Compare $1 with $2 // Compare values
    jle 0x8f8b; // Jump if less or equal (signed)
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 0x2b], 0;
    mov word ptr [bp - 0x36], 0;
    // Compare $1 with $2 // Compare values
    jbe 0x8fb0; // Jump if below or equal (unsigned)
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [bp - 0x2b], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    neg ax; // Negate value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    cld ; // Clear direction flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x5ab;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x637;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2; // Add values
    mov byte ptr [0x55f3], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    and al, 1; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x32], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    not bl; // Bitwise NOT
    and byte ptr es:[di], bl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0x912b; // Jump if below or equal (unsigned)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x911e; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x9143; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    or bh, bh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x916b; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0x36], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and al, bh; // Bitwise AND
    not bh; // Bitwise NOT
    and byte ptr es:[di], bh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x919d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    xor byte ptr [bp - 6], 1; // Bitwise XOR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1 += $2; // Add values
    jae 0x91c7; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x91c7; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 0x26], 0x100;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0x10], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x26], 0x400;
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    les di, ptr [bp - 0xa]; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x32], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    not bl; // Bitwise NOT
    and byte ptr es:[di], bl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0x9278; // Jump if below or equal (unsigned)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x926b; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x9290; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    or bh, bh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x92b8; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0x36], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and al, bh; // Bitwise AND
    not bh; // Bitwise NOT
    and byte ptr es:[di], bh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x92ea; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 -= $2; // Subtract values
    $1++; // Increment value
    // Compare $1 with $2 // Compare values
    ja 0x9303; // Jump if above (unsigned)
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 += $2; // Add values
    jae 0x9326; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x9326; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x9386; // Jump if below or equal (unsigned)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x9381; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0x936a; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x93a8; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0x93c3; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x93c3; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    and al, 3; // Bitwise AND; Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x32], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    not bl; // Bitwise NOT
    and byte ptr es:[di], bl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0x9455; // Jump if below or equal (unsigned)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x9448; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x946d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    or bh, bh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x9495; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0x36], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and al, bh; // Bitwise AND
    not bh; // Bitwise NOT
    and byte ptr es:[di], bh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x94c7; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    cmp byte ptr [bp - 6], 4; // Compare values
    jb 0x94dd; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 0;
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0x94f9; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x94f9; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    les di, ptr [bp - 0xa];
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0x956b; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0x956b; // Jump if above (unsigned)
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x956b; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0x9542; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1 += $2; // Add values
    jae 0x95a0; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x95b7; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x95cf; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x95cf; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    goto $1; // Jump to address
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Allocate memory (DOS)
    $1++; // Increment value; Allocate memory (DOS)
    $1 = $2; // Allocate memory (DOS)
    $1 = $2; // Allocate memory (DOS)
    int 0x21; // Call interrupt
    jae 0x9629; // Jump if above or equal (unsigned)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Free memory (DOS)
    mov word ptr [bp - 2], 0xffe7; // Free memory (DOS)
    goto $1; // Jump to address; Free memory (DOS)
    $1 = $2; // Free memory (DOS)
    int 0x21; // Call interrupt
    jae 0x9675; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe7;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall [si]; // Allocate memory (DOS)
    goto $1; // Jump to address; Allocate memory (DOS)
    $1 = $2; // Allocate memory (DOS)
    $1 = $2; // Allocate memory (DOS)
    int 0x21; // Call interrupt
    $1 = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [0x55f1], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp + 0x10];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x977b; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x978e; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr [si], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff9; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 0xe], ax; // Compare values
    jb 0x97e1; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    cmp word ptr [bp + 0xa], ax; // Compare values
    jb 0x97ea; // Jump if below (unsigned)
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    or ax, ax; // Bitwise OR
    jg 0x9803; // Jump if greater (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jge 0x981d; // Jump if greater or equal (signed)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0xc], ax; // Compare values
    jb 0x982c; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    cmp word ptr [bp + 8], ax; // Compare values
    jb 0x9835; // Jump if below (unsigned)
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    or ax, ax; // Bitwise OR
    jg 0x984e; // Jump if greater (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jge 0x9857; // Jump if greater or equal (signed)
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    cld ; // Clear direction flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x2dd;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x31e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2; // Add values
    mov byte ptr [0x55f1], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    shl ax, cl; // Shift left
    and al, 7; // Bitwise AND
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    les di, ptr es:[di + 0x18];
    push($1); // Push value onto stack
    $1 = $2;
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    rol ax, cl; // Rotate left
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    and al, 7; // Bitwise AND
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    les di, ptr es:[di + 0x18];
    $1 = $2;
    push($1); // Push value onto stack
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    rol ax, cl; // Rotate left
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 += $2; // Add values; Increment counter and check loop condition
    $1 = pop(); // Pop value from stack; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x99f1; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    les di, ptr es:[di + 0x18];
    push($1); // Push value onto stack
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    $1 = $2;
    and al, 7; // Bitwise AND
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    and al, 3; // Bitwise AND
    mov byte ptr [bp - 6], 4;
    sub byte ptr [bp - 6], al; // Subtract values
    $1 = $2;
    les di, ptr es:[di + 0x18];
    $1 = $2;
    push($1); // Push value onto stack
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    rol ax, cl; // Rotate left
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    not ax; // Bitwise NOT
    *($1) = $2;
    les di, ptr es:[di + 0x18];
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x9b0a; // Jump if below or equal (unsigned)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x9af3; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0x9b28; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x9b75; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, 0;
    jae 0x9b8b; // Jump if above or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0x9ba1; // Jump if below (unsigned)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jbe 0x9ba1; // Jump if below or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0x9bc1; // Jump if above or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jae 0x9bda; // Jump if above or equal (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = pop(); // Pop value from stack
    cdq ;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    xchg cx, ax; // Exchange values
    xchg dx, ax; // Exchange values
    mul bx; // Multiply (unsigned)
    xchg cx, ax; // Exchange values
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    xchg cx, ax; // Exchange values
    xchg dx, ax; // Exchange values
    mul bx; // Multiply (unsigned)
    xchg cx, ax; // Exchange values
    or bx, bx; // Bitwise OR
    jns 0x9c19;
    $1 -= $2; // Subtract values
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jb 0x9c35; // Jump if below (unsigned)
    xchg cx, ax; // Exchange values
    xchg dx, ax; // Exchange values
    div bx; // Divide (unsigned)
    xchg cx, ax; // Exchange values
    div bx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xor ah, dh; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    or dx, dx; // Bitwise OR
    jns 0x9c5b;
    neg dx; // Negate value
    neg ax; // Negate value
    sbb dx, 0;
    or cx, cx; // Bitwise OR
    jns 0x9c66;
    neg cx; // Negate value
    neg bx; // Negate value
    sbb cx, 0;
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    xchg dx, ax; // Exchange values
    $1 = 0; // Bitwise XOR
    div cx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 -= $2; // Subtract values
    sbb cx, dx;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    or cx, cx; // Bitwise OR
    jns 0x9cac;
    $1 += $2; // Add values
    adc cx, di;
    $1 -= $2; // Subtract values
    sbb dx, 0;
    goto $1; // Jump to address
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jb 0x9ca4; // Jump if below (unsigned)
    xchg cx, ax; // Exchange values
    xchg dx, ax; // Exchange values
    div bx; // Divide (unsigned)
    xchg cx, ax; // Exchange values
    div bx; // Divide (unsigned)
    xchg cx, dx; // Exchange values
    $1 = 0; // Bitwise XOR
    xchg bx, cx; // Exchange values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    shl bh, 1; // Shift left
    jae 0x9cba; // Jump if above or equal (unsigned)
    neg dx; // Negate value
    neg ax; // Negate value
    sbb dx, 0;
    shl bl, 1; // Shift left
    $1 = $2;
    jae 0x9cc7; // Jump if above or equal (unsigned)
    neg cx; // Negate value
    neg bx; // Negate value
    sbb cx, 0;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4;
    goto $1; // Jump to address
    les di, ptr [bp + 0xc];
    $1 = $2;
    mov byte ptr es:[di], al;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 -= $2; // Subtract values
    les di, ptr [bp + 0xc];
    $1 += $2; // Add values
    cld ; // Clear direction flag; Check if values are equal
    $1 = $2; // Check if values are equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are equal
    cmp byte ptr es:[di - 1], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    loop 0x9d40; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[di], al;
    $1 = 0; // Bitwise XOR
    mov word ptr es:[di + 0x48], ax;
    mov word ptr es:[di + 0x46], ax;
    push($1); // Push value onto stack
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jbe 0x9d6a; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack; Open file (DOS)
    $1 = $2; // Open file (DOS)
    or al, ah; // Bitwise OR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    mov word ptr es:[di + 0x42], ax;
    jae 0x9d8b; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffff;
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 0x14], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    jae 0x9db0; // Jump if above or equal (unsigned); Check if values are equal
    mov word ptr [bp - 2], 0xfffd; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [si], 0x5a4d; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [si + 2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    mov word ptr es:[di + 0x48], dx;
    mov word ptr es:[di + 0x46], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    jae 0x9dff; // Jump if above or equal (unsigned); Check if values are equal
    mov word ptr [bp - 2], 0xfffd; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [si], 0xca01; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4;
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr es:[di + 0x44], ax;
    mov word ptr es:[di + 0x4e], 6;
    $1 = $2;
    mov word ptr es:[di + 0x52], ax;
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[di + 0x50], ax;
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    div bx; // Divide (unsigned)
    mov word ptr es:[di + 0x4e], ax;
    $1 = $2;
    mov word ptr es:[di + 0x52], ax;
    $1 = $2;
    mov word ptr es:[di + 0x50], ax;
    mov word ptr es:[di + 0x4a], 0xffff;
    mov word ptr es:[di + 0x4c], 0xffff;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    les di, ptr [bp + 6]; // Check if values are equal
    cmp byte ptr es:[di], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[di], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[di], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4; // Close file (DOS)
    goto $1; // Jump to address; Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    jae 0x9eab; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffdf;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    les di, ptr [bp + 8]; // Check if values are equal
    cmp byte ptr es:[di], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[di], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jbe 0x9efb; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0x9f07;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jb 0x9f0d; // Jump if below (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, word ptr es:[di + 0x48];
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x9f3f; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    lds si, ptr es:[di + 0x50];
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    jae 0x9f5d; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr es:[di + 0x4a], ax;
    $1 = $2;
    mov word ptr es:[di + 0x4c], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 0x10]; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4;
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lea dx, [bp - 0x96]; // Load effective address
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    cmp word ptr [bp + 6], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0xa031; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfff2;
    goto $1; // Jump to address
    $1 = $2;
    int 0x21; // Call interrupt
    jae 0xa031; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfff2;
    goto $1; // Jump to address
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    les di, ptr [bp + 8];
    mov byte ptr es:[di], 0;
    $1 = 0; // Bitwise XOR
    mov word ptr es:[di + 0xe], ax;
    mov word ptr es:[di + 0x10], ax;
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x14], ax;
    $1 = $2;
    mov word ptr es:[di + 0x16], ax;
    $1 = $2;
    mov word ptr es:[di + 0x18], ax;
    $1 += $2; // Add values; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 0x2e; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], 0x20;
    $1++; // Increment value
    loop 0xa07d; // Loop (decrement CX and jump if CX!=0)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0xa073; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    mov byte ptr es:[di], 0x20;
    $1++; // Increment value
    loop 0xa08e; // Loop (decrement CX and jump if CX!=0)
    mov byte ptr es:[di - 4], 0x2e;
    mov byte ptr es:[di], 0;
    mov word ptr [bp - 2], 0;
    lds dx, ptr [bp - 8];
    $1 = $2;
    int 0x21; // Call interrupt
    goto $1; // Jump to address
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are not equal
    les di, ptr [bp + 0x10]; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp + 6], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    lea di, [bp - 0x16]; // Load effective address
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    or al, al; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    ja 0xa113; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0xa113; // Jump if below (unsigned)
    and al, 0xdf; // Bitwise AND
    *($1) = $2;
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2; // Check if values are equal
    or al, al; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[bx + di], 0x3f;
    goto $1; // Jump to address
    mov byte ptr es:[bx + di], 0x20;
    goto $1; // Jump to address
    mov byte ptr es:[bx + di], al;
    $1++; // Increment value
    $1++; // Increment value
    loop 0xa11e; // Loop (decrement CX and jump if CX!=0)
    // Compare $1 with $2 // Compare values
    jae 0xa15c; // Jump if above or equal (unsigned); Check if values are equal
    mov byte ptr es:[bx + di], 0x2e; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 0x2e; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    goto $1; // Jump to address
    $1++; // Increment value
    $1 = $2;
    goto $1; // Jump to address; Check if values are not equal
    lds si, ptr [bp + 0x10]; // Check if values are not equal
    les di, ptr [si + 0x50]; // Check if values are not equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    mov word ptr [si + 0x4c], 0; // Check if values are equal
    cmp word ptr [si + 0x44], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [si + 0x4a], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [si + 0x50];
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    lds si, ptr [bp + 0xc];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    loope 0xa1b4;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lds si, ptr [bp + 0x10];
    $1++; // Increment value
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xa1dc; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xfff2;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jb 0xa19c; // Jump if below (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2; // Initialize counter for string operation
    les di, ptr [bp + 8]; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    lds si, ptr [bp + 0x10];
    les di, ptr [bp + 8];
    $1 = $2;
    $1 = $2; // Check if values are equal
    add word ptr es:[di + 0xe], ax; // Add values; Check if values are equal
    adc word ptr es:[di + 0x10], dx; // Check if values are equal
    cmp word ptr [bp + 6], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    lds si, ptr [bp + 0xe]; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jbe 0xa2b3; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack; Open file (DOS)
    $1 = $2; // Open file (DOS)
    or al, ah; // Bitwise OR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jae 0xa2cf; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffff;
    goto $1; // Jump to address
    lds si, ptr [bp + 0xe];
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 6]; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4; // Close file (DOS)
    goto $1; // Jump to address; Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    jae 0xa338; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffdf;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 0xa]; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Open file (DOS)
    $1 = $2; // Open file (DOS)
    $1 = pop(); // Pop value from stack; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jae 0xa3bc; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffff;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffff;
    goto $1; // Jump to address
    lds si, ptr [bp + 0xa];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 0xa]; // Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [si], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff4;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lea dx, [bp - 0x7e]; // Load effective address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jae 0xa43e; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffc;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfffc;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    xchg al, ah; // Exchange values
    shr ax, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, ah; // Bitwise AND
    xor cl, ah; // Bitwise XOR
    shl cl, 1; // Shift left
    retf ; // Return from function
    $1 = $2;
    xchg al, ah; // Exchange values
    shr bx, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    rcr bx, 1;
    shr ax, 1; // Shift right (unsigned)
    rcr bx, 1;
    shr bx, 1; // Shift right (unsigned)
    $1 = $2;
    mul ah; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    shr dx, 1; // Shift right (unsigned)
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    xchg al, ah; // Exchange values
    $1 += $2; // Add values
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = $2;
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [0x55f0], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xe];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0xa63f; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0xa652; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr es:[di], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff9;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jg 0xa691; // Jump if greater (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jge 0xa6be; // Jump if greater or equal (signed)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    xor cl, 7; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jg 0xa6d4; // Jump if greater (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jge 0xa6dc; // Jump if greater or equal (signed)
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    cld ; // Clear direction flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x4ba;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x548;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2; // Add values
    mov byte ptr [0x55f0], 1; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [si + 0x13], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shl ax, 1; // Shift left
    and al, 7; // Bitwise AND
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    test word ptr [bp + 8], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    lds si, ptr [si + 0x18]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    ror dx, cl; // Rotate right
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and word ptr es:[di], dx; // Bitwise AND
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    not al; // Bitwise NOT
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1--; // Decrement value; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1--; // Decrement value; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ch; // Bitwise NOT
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lodsb al, byte ptr [si]; // Load string byte/word
    or al, ch; // Bitwise OR
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    xor al, 7; // Bitwise XOR
    $1++; // Increment value
    and al, 7; // Bitwise AND
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 0x14], 1;
    mov word ptr [bp - 0x16], 0xf;
    mov byte ptr [bp - 0x12], 0xf;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0x10], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x16], 1;
    mov byte ptr [bp - 0x12], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 0x14], 8;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl bx, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port; Check if values are not equal
    $1 = $2; // Check if values are not equal
    lds si, ptr [si + 0x18]; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    loop 0xa99b; // Loop (decrement CX and jump if CX!=0); Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp byte ptr [bp - 0x10], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    shl byte ptr [bp - 0x12], 1; // Shift left
    cmp byte ptr [bp - 0x12], dl; // Compare values
    jbe 0xa9c8; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cwde ; // Check if values are not equal
    cmp word ptr [bp - 0xa], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    shl ax, cl; // Shift left
    shl bx, cl; // Shift left
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    test cl, cl; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    rol ax, cl; // Rotate left
    and byte ptr es:[di], ah; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    jle 0xaa2b; // Jump if less or equal (signed)
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    rol ax, cl; // Rotate left
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bl; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di + 1], bh; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    shl byte ptr [bp - 0x12], 1; // Shift left
    cmp byte ptr [bp - 0x12], dl; // Compare values
    jbe 0xaa65; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    lds si, ptr [si + 0x18]; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value
    loop 0xaaec; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    loop 0xab01; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    loop 0xab16; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    and al, 7; // Bitwise AND
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    and al, 3; // Bitwise AND
    mov byte ptr [bp - 6], 4;
    sub byte ptr [bp - 6], al; // Subtract values
    $1 = $2; // Check if values are equal
    lds si, ptr [si + 0x18]; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    ror dx, cl; // Rotate right
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    and word ptr es:[di], dx; // Bitwise AND
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    not al; // Bitwise NOT
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ch; // Bitwise NOT
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lodsb al, byte ptr [si]; // Load string byte/word
    or al, ch; // Bitwise OR
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    test bx, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    lds si, ptr [si + 0x18]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xad3a; // Jump if below or equal (unsigned)
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0xad23; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0xad56; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0xad61; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0xad8c; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0xad96; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0xadc1; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0xadcb; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0xadf6; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffd9;
    les di, ptr [bp + 6];
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    int 0x10; // Call interrupt; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di], 0x56; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 1], 0x45; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 2], 0x53; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 3], 0x41; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    lcall 0xae3, 0; // Check if values are equal
    cmp byte ptr [bp - 6], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp byte ptr es:[di], 0x33; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 1], 0x31; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 4;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    int 0x10; // Call interrupt; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 3;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    $1 = $2;
    out dx, al; // Output to port
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port; Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are not equal
    in al, dx; // Input from port; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    out dx, al; // Output to port; Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are not equal
    in al, dx; // Input from port; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    out dx, al; // Output to port
    mov word ptr [bp - 2], 2;
    goto $1; // Jump to address
    $1 = $2;
    in al, dx; // Input from port
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    in al, dx; // Input from port; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    in al, dx; // Input from port; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    out dx, al; // Output to port
    mov word ptr [bp - 2], 1;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value; Check if values are not equal
    in al, dx; // Input from port; Check if values are not equal
    and al, 0xf; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value; Check if values are not equal
    in al, dx; // Input from port; Check if values are not equal
    and al, 0xf; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 5;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    test al, 0xe; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 6;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffde;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xafa8; // Jump if above (unsigned)
    jb 0xaf9f; // Jump if below (unsigned)
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffd9;
    goto $1; // Jump to address
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0; // Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xc0; // Bitwise AND; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    int 0x10; // Call interrupt
    and ah, 0x7f; // Bitwise AND
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xb089; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xb089; // Jump if above or equal (unsigned)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xb0ba; // Jump if above or equal (unsigned)
    cli ; // Clear interrupt flag
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    sti ; // Set interrupt flag
    test al, 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    cli ; // Clear interrupt flag
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    sti ; // Set interrupt flag
    test al, 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xb0d8; // Jump if below (unsigned)
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 3; // Bitwise AND; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 3; // Bitwise AND; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xb179; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xb179; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffde;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr es:[di + 2], bx;
    mov word ptr es:[di + 4], cx;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    mov byte ptr [bp - 0xe], 0;
    mov byte ptr [bp - 0xd], 0x55;
    mov byte ptr [bp - 0xc], 0xaa;
    mov byte ptr [bp - 0xb], 0xff;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR; Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 0x13], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp byte ptr es:[di + 0x13], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and ax, 3; // Bitwise AND
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    mov byte ptr [bp + si - 0xe], 0xff;
    rcr ax, 1;
    jb 0xb238; // Jump if below (unsigned); Increment counter and check loop condition
    not byte ptr [bp + si - 0xe]; // Bitwise NOT; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0xb22d; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    not bx; // Bitwise NOT
    les di, ptr [bp - 6];
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xb272; // Jump if above (unsigned)
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jae 0xb272; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0xb257; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    $1 = $2; // Increment counter and check loop condition
    rep stosw word ptr es:[di], ax; // Fill memory block; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0xb285; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    jae 0xb2a3; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jae 0xb2ed; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x54c1], 0x44bf;
    mov word ptr [0x54bf], 0x1000;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov byte ptr [0x54c5], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    cmp word ptr [0x54c6], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stc ; // Set carry flag
    mov word ptr [bp - 2], 0xffff;
    goto $1; // Jump to address
    les di, ptr [0x54c1];
    $1 = $2;
    $1 -= $2; // Subtract values
    add word ptr [0x54ca], ax; // Add values
    adc word ptr [0x54c8], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    cmp word ptr [0x54c6], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stc ; // Set carry flag
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    les di, ptr [0x54c1];
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack; Check if values are equal
    clc ; // Clear carry flag; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stc ; // Set carry flag
    mov word ptr [bp - 2], 0xfffc;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [bp + 0xe], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb45e; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [0x54c6], 0xffff;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp byte ptr [0x54c5], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    mov byte ptr [0x54c5], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov byte ptr [0x54c5], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xb508; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0xb50f; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    loop 0xb518; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xb560; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xfffa; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb56c; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb5a5; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xb5de; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    stc ; // Set carry flag
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    loop 0xb5e4; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0xfc19;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ; // Clear carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xb629; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    stc ; // Set carry flag; Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb636; // Jump if above or equal (unsigned)
    *($1) = $2;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr es:[di + 3]; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc19;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ; // Clear carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [0x43b9], 7; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    xchg bx, ax; // Exchange values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    and ax, 0x7f; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    or ah, ah; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [0x43b9], 7; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffd8;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xb74d; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    ja 0xb75b; // Jump if above (unsigned)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jg 0xb772; // Jump if greater (signed)
    lcall 0x921, 0x55;
    // Compare $1 with $2 // Compare values
    jg 0xb772; // Jump if greater (signed)
    mov word ptr [bp - 2], 0xffde; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jae 0xb7a1; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0xb7a1; // Jump if below (unsigned); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xb7a1; // Jump if greater or equal (signed)
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb7ae; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp - 4], 7; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffd8;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    div cl; // Divide (unsigned)
    *($1) = $2;
    $1 = $2; // Prepare arguments and call function
    *($1) = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb7f6; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[di + 0x16], al;
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr es:[di + 0x1c], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Prepare arguments and call function
    *($1) = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xb85d; // Jump if above (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb885; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ; // Clear direction flag
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xb8d3; // Jump if below (unsigned); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    jge 0xb8d3; // Jump if greater or equal (signed)
    *($1) = $2; // Prepare arguments and call function
    goto $1; // Jump to address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xb8e0; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    mov word ptr [0x43b5], 1; // Check if values are equal
    mov word ptr [0x43b7], 0; // Check if values are equal
    cmp byte ptr es:[di], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [0x54d4], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    mov word ptr [0x43b5], 0; // Check if values are equal
    mov word ptr [0x43b7], 0; // Check if values are equal
    cmp byte ptr es:[di], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff9;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf ; // Return from function; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = 0; // Bitwise XOR
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    loop 0xb9bf; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    rep stosw word ptr es:[di], ax; // Fill memory block
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xbabe; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0xbb05; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xbb00; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0xbae8; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xc];
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0xbb68; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0xbbaf; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0xbbaa; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0xbb92; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jg 0xbbe6; // Jump if greater (signed)
    xchg bx, ax; // Exchange values
    *($1) = $2;
    div bx; // Divide (unsigned)
    lds si, ptr [bp + 0xa];
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbbf9; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    lds si, ptr [bp + 0xe];
    add word ptr [si], ax; // Add values
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x14];
    les di, ptr [bp + 6];
    mov word ptr [bp - 6], 0;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mov word ptr [bp - 8], 1;
    // Compare $1 with $2 // Compare values
    jge 0xbc43; // Jump if greater or equal (signed)
    xchg bx, ax; // Exchange values
    mov word ptr [bp - 8], 0; // Check if values are equal
    *($1) = $2; // Check if values are equal
    div bx; // Divide (unsigned); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    *($1) = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1 = $2;
    and bx, 1; // Bitwise AND; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 8], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rol al, cl; // Rotate left
    and al, 0x80; // Bitwise AND
    $1 = $2;
    ror al, cl; // Rotate right; Check if values are not equal
    or dl, al; // Bitwise OR; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1++; // Increment value
    $1 += $2; // Add values
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbcec; // Jump if below (unsigned); Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0xbcfe; // Jump if below (unsigned)
    push($1); // Push value onto stack
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    and cx, 7; // Bitwise AND
    $1 = $2;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    and al, 0x80; // Bitwise AND; Check if values are not equal
    rol ah, 1; // Rotate left; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp word ptr [bp - 4], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 0;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbd4a; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    ror al, cl; // Rotate right
    or dl, al; // Bitwise OR; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    loop 0xbd4a; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], dl;
    $1++; // Increment value; Check if values are equal
    $1++; // Increment value; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    goto $1; // Jump to address; Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 8], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl cl, 1; // Shift left
    rol al, cl; // Rotate left
    and al, 0xc0; // Bitwise AND
    $1 = $2;
    ror al, cl; // Rotate right
    or dl, al; // Bitwise OR; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1++; // Increment value
    $1 += $2; // Add values
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbde9; // Jump if below (unsigned); Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0xbdf9; // Jump if below (unsigned)
    push($1); // Push value onto stack
    shr cx, 1; // Shift right (unsigned)
    shr cx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    and cx, 3; // Bitwise AND
    $1 = $2;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    and al, 0xc0; // Bitwise AND
    rol ah, 1; // Rotate left; Check if values are not equal
    rol ah, 1; // Rotate left; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp word ptr [bp - 4], 4; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 0;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbe4d; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    ror al, cl; // Rotate right
    or dl, al; // Bitwise OR
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    loop 0xbe4d; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], dl;
    $1++; // Increment value; Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 8], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1 += $2; // Add values
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbe9a; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    $1++; // Increment value
    loop 0xbe8a; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    stosb byte ptr es:[di], al; // Store string byte/word
    // Compare $1 with $2 // Compare values; Initialize counter for string operation
    jl 0xbeba; // Jump if less (signed); Initialize counter for string operation
    push($1); // Push value onto stack; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = pop(); // Pop value from stack
    $1 -= $2; // Subtract values
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0xbecc; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jl 0xbecc; // Jump if less (signed)
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    loop 0xbea9; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x5ab0], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    mul word ptr [0x5aae]; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 += $2; // Add values
    adc dx, 0xc;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    and ah, 0x7f; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, ax; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf3; // Bitwise AND
    or al, 4; // Bitwise OR
    out dx, al; // Output to port; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shl ah, 1; // Shift left
    shl ah, 1; // Shift left
    shl ah, 1; // Shift left
    or al, ah; // Bitwise OR
    or al, 0x40; // Bitwise OR
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    and bl, 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    and bl, 2; // Bitwise AND
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    $1 = $2;
    in al, dx; // Input from port
    and al, 0xdf; // Bitwise AND
    or bl, al; // Bitwise OR
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    and bh, 0xc; // Bitwise AND
    $1 = $2;
    shr bl, 1; // Shift right (unsigned)
    shr bl, 1; // Shift right (unsigned)
    or al, bh; // Bitwise OR
    or al, bl; // Bitwise OR
    out dx, al; // Output to port; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    and ah, 0xe1; // Bitwise AND
    shl ch, 1; // Shift left
    or ah, ch; // Bitwise OR
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    sti ; // Set interrupt flag; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    and ah, 0xf; // Bitwise AND
    $1 = $2;
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    or al, ah; // Bitwise OR
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and al, 0xf; // Bitwise AND
    xor al, 2; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    or al, ah; // Bitwise OR; Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffde;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr [0x55f2], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0xc16f; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0xc182; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr es:[di], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff9;
    goto $1; // Jump to address
    lds si, ptr [bp + 0x14];
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xc1cf; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp + 0x12], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jb 0xc1dd; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xc1ec; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0xc1fa; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0x12], ax; // Compare values
    jbe 0xc20a; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0xc21b; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xc245; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp + 0x10], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jb 0xc253; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xc262; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0xc270; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0x10], ax; // Compare values
    jbe 0xc280; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0xc291; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2; // Check if values are not equal
    mov word ptr [bp - 0x2a], 0xffff; // Check if values are not equal
    mov word ptr [bp - 0x2c], 0; // Check if values are not equal
    cmp byte ptr [bp - 0xe], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    shr dl, cl; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    shr dh, cl; // Shift right (unsigned)
    not dh; // Bitwise NOT
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xc2f5; // Jump if less (signed)
    $1 = $2;
    *($1) = $2;
    or dh, dh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and byte ptr [bp - 0x2a], dh; // Bitwise AND
    mov byte ptr [bp - 0x29], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    *($1) = $2;
    mov word ptr [bp - 0x30], 1;
    $1 = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0xe]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    // Compare $1 with $2 // Compare values
    jle 0xc324; // Jump if less or equal (signed)
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 0x29], 0;
    mov word ptr [bp - 0x34], 0;
    // Compare $1 with $2 // Compare values
    jbe 0xc349; // Jump if below or equal (unsigned)
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [bp - 0x29], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    neg ax; // Negate value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    cld ; // Clear direction flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x639;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x6ce;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2; // Add values
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2; // Add values
    mov byte ptr [0x55f2], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    and al, 1; // Bitwise AND
    *($1) = $2;
    $1 = $2; // Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing); Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc49d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    not bl; // Bitwise NOT
    and byte ptr es:[di], bl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0xc4e7; // Jump if below or equal (unsigned)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc4da; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc4ff; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2; // Check if values are equal
    or bh, bh; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc52d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and al, bh; // Bitwise AND
    not bh; // Bitwise NOT
    and byte ptr es:[di], bh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc559; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0xc571; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc571; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    xor byte ptr [bp - 6], 1; // Bitwise XOR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 0x26], 0x10f;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0x10], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x26], 0x801;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp - 0xa]; // Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc62f; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0xc677; // Jump if below or equal (unsigned)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc66a; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc68f; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc6c3; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc6e8; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0xc700; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc700; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 -= $2; // Subtract values
    shl dl, 1; // Shift left
    // Compare $1 with $2 // Compare values
    jae 0xc719; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2; // Check if values are equal
    lds si, ptr [bp - 0xa]; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xc79d; // Jump if below or equal (unsigned)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc798; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0xc781; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc7bf; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0xc7d7; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc7d7; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    $1 = 0; // Bitwise XOR; Check if values are equal
    and al, 3; // Bitwise AND; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing); Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc846; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    not bl; // Bitwise NOT
    and byte ptr es:[di], bl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0xc890; // Jump if below or equal (unsigned)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc883; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc8a8; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2; // Check if values are equal
    or bh, bh; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc8d6; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and al, bh; // Bitwise AND
    not bh; // Bitwise NOT
    and byte ptr es:[di], bh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc902; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0xc91a; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc91a; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    cmp byte ptr [bp - 6], 4; // Compare values
    jb 0xc930; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 0;
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe; // Check if values are equal
    lds si, ptr [bp - 0xa]; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xc9af; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    ja 0xc9af; // Jump if above (unsigned)
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc99d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    loop 0xc986; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc9d6; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0xc9ee; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xc9ee; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1 += $2; // Add values
    jae 0xca13; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 0;
    mov word ptr es:[di + 2], 0;
    mov byte ptr [bp - 4], 1;
    mov byte ptr [bp - 6], 1; // Check if values are not equal
    mov byte ptr [bp - 8], 1; // Check if values are not equal
    mov byte ptr [bp - 0xa], 1; // Check if values are not equal
    cmp byte ptr [bp - 4], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp byte ptr [bp - 6], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp byte ptr [bp - 8], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp byte ptr [bp - 0xa], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    $1(); // Call function
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    or bl, bl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 0; // Check if values are not equal
    mov byte ptr es:[di + 1], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 1; // Check if values are not equal
    mov byte ptr es:[di + 1], 1; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 2; // Check if values are not equal
    mov byte ptr es:[di + 1], 2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 3; // Check if values are not equal
    mov byte ptr es:[di + 1], 3; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 3; // Check if values are not equal
    mov byte ptr es:[di + 1], 1; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 5; // Check if values are not equal
    mov byte ptr es:[di + 1], 4; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 5; // Check if values are not equal
    mov byte ptr es:[di + 1], 5; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 4; // Check if values are not equal
    mov byte ptr es:[di + 1], 3; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 4; // Check if values are not equal
    mov byte ptr es:[di + 1], 4; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 4;
    mov byte ptr es:[di + 1], 5;
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 8], 0; // Check if values are equal
    mov byte ptr [bp - 0xa], 0; // Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    cmp byte ptr es:[di], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp byte ptr es:[di], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 0xa], 1;
    mov word ptr es:[di], 0;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    int 0x10; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xcb97; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0xcb9f; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0xcba7; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0xcbaf; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    ja 0xcbb7; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr [bp - 8], 0;
    goto $1; // Jump to address
    mov byte ptr [bp - 0xa], 0;
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    jb 0xcbe0; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    retf ; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    jb 0xcc22; // Jump if below (unsigned)
    $1 = $2;
    in al, dx; // Input from port
    and al, 0x80; // Bitwise AND
    $1 = $2;
    $1 = $2;
    in al, dx; // Input from port
    and al, 0x80; // Bitwise AND
    // Compare $1 with $2 // Compare values
    loope 0xcbf5;
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    in al, dx; // Input from port
    $1 = $2;
    and dl, 0x70; // Bitwise AND; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    retf ; // Return from function
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2; // Initialize loop counter and loop
    $1 = $2; // Initialize loop counter and loop
    out dx, al; // Output to port; Initialize loop counter and loop
    $1 = $2; // Initialize loop counter and loop
    loop 0xcc30; // Loop (decrement CX and jump if CX!=0)
    in al, dx; // Input from port; Check if values are equal
    xchg al, ah; // Exchange values; Check if values are equal
    out dx, al; // Output to port; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stc ; // Set carry flag
    goto $1; // Jump to address; Check if values are equal
    clc ; // Clear carry flag; Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp byte ptr es:[di + 2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cmp byte ptr es:[di], 4; // Compare values
    jge 0xcc79; // Jump if greater or equal (signed)
    cmp byte ptr es:[di + 2], 4; // Compare values
    jge 0xcc79; // Jump if greater or equal (signed); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    and al, 7; // Bitwise AND; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr es:[di + 1], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr es:[di + 1], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    xchg word ptr es:[di + 2], ax; // Exchange values; Check if values are not equal
    mov word ptr es:[di], ax; // Check if values are not equal
    retf ; // Return from function; Check if values are not equal
    cmp byte ptr es:[di], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di], ax;
    goto $1; // Jump to address
    mov word ptr es:[di + 2], ax;
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    les di, ptr [bp + 0xc]; // Check if values are equal
    cmp word ptr es:[di], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    goto $1; // Jump to address
    cmp word ptr es:[di + 0x16], 3; // Compare values
    jbe 0xccba; // Jump if below or equal (unsigned)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 0xa], ax; // Compare values
    ja 0xcccc; // Jump if above (unsigned)
    $1 = $2;
    cmp word ptr [bp + 8], ax; // Compare values
    jbe 0xccd4; // Jump if below or equal (unsigned)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mul word ptr [bp + 0xa]; // Multiply (unsigned)
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mul word ptr es:[di + 0x14]; // Multiply (unsigned)
    mul word ptr [bp + 8]; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    adc dx, 0; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x16], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    div bx; // Divide (unsigned)
    xchg dx, ax; // Exchange values
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0xcd16; // Jump if above or equal (unsigned)
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    shl ax, 1; // Shift left
    rcl dx, 1;
    shl ax, 1; // Shift left
    rcl dx, 1;
    mov word ptr es:[di + 0x26], dx;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    ja 0xcd45; // Jump if above (unsigned)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0xcd4f; // Jump if below or equal (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x16], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    loope 0xcd56;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR; Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr es:[di + 0x16], 3; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ah, ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    loope 0xcd80;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ah, ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    loope 0xcdac;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    mov word ptr [bp - 2], 0xffe2;
    goto $1; // Jump to address
    $1 = $2;
    mul word ptr es:[di + 0x28]; // Multiply (unsigned)
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    jae 0xce0d; // Jump if above or equal (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    goto $1; // Jump to address; Check if values are not equal
    add word ptr [bp - 8], 0x1000; // Add values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mul bx; // Multiply (unsigned); Check if values are not equal
    cmp word ptr [bp - 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    sub word ptr [bp - 6], ax; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    ja 0xce5e; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jbe 0xce6d; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    loope 0xce6d;
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mul bx; // Multiply (unsigned); Check if values are not equal
    cmp word ptr [bp - 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    sub word ptr [bp - 6], ax; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    ja 0xceba; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jbe 0xcec9; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ah, ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    loope 0xcec9;
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mul bx; // Multiply (unsigned); Check if values are not equal
    cmp word ptr [bp - 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    sub word ptr [bp - 6], ax; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    ja 0xcf1a; // Jump if above (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jbe 0xcf29; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ah, ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    loope 0xcf29;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    stc ; // Set carry flag
    goto $1; // Jump to address
    clc ; // Clear carry flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0xcf87; // Jump if above or equal (unsigned)
    $1 = $2;
    cdq ;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    lcall 0x79e, 0xa7; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    int 0x67; // Call interrupt
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mul bx; // Multiply (unsigned)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    cdq ; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb95, 0x179;
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mul bx; // Multiply (unsigned)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    cdq ; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x620, 0x219;
    or ah, ah; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mul bx; // Multiply (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    cdq ;
    goto $1; // Jump to address
    $1 = $2;
    cdq ;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0x16], 0;
    mov word ptr [bp - 0x20], 0;
    lds si, ptr [bp + 0x18]; // Check if values are equal
    les di, ptr [bp + 0xc]; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xd0a4; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp + 0xa], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xd0b1; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xd0c0; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jbe 0xd0cb; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0xa], ax; // Compare values
    jbe 0xd0dc; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0xd0ed; // Jump if below or equal (unsigned)
    $1 = $2;
    mul word ptr [bp - 4]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 = 0; // Bitwise XOR
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x28], 1;
    $1--; // Decrement value
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xd123; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp + 8], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xd130; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0xd13f; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jbe 0xd14a; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 8], ax; // Compare values
    jbe 0xd15b; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0xd16c; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Check if values are not equal
    mul bx; // Multiply (unsigned); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    lea di, [bp - 0xb2]; // Load effective address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    *($1) = $2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2; // Check if values are not equal
    mov word ptr [bp - 0x22], 0xff; // Check if values are not equal
    mov word ptr [bp - 0x24], 0; // Check if values are not equal
    cmp byte ptr [bp - 4], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    mul word ptr [bp - 4]; // Multiply (unsigned)
    push($1); // Push value onto stack
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    shr al, cl; // Shift right (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    shr ah, cl; // Shift right (unsigned)
    not ah; // Bitwise NOT
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xd21d; // Jump if less (signed)
    $1 = $2;
    *($1) = $2;
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and byte ptr [bp - 0x22], ah; // Bitwise AND
    mov byte ptr [bp - 0x21], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    mul word ptr [bp - 4]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    *($1) = $2;
    mov word ptr [bp - 0x28], 1;
    $1 = $2;
    mul word ptr [bp - 4]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 4]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    // Compare $1 with $2 // Compare values
    jle 0xd24c; // Jump if less or equal (signed)
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 0x21], 0;
    mov word ptr [bp - 0x2c], 0;
    // Compare $1 with $2 // Compare values
    jbe 0xd271; // Jump if below or equal (unsigned)
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [bp - 0x21], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x2e], 0x34a;
    mov word ptr [bp - 0x30], 0x3bc;
    mov word ptr [bp - 0x32], 0x45f;
    goto $1; // Jump to address
    mov word ptr [bp - 0x2e], 0x337;
    mov word ptr [bp - 0x30], 0x3ad;
    mov word ptr [bp - 0x32], 0x44e;
    goto $1; // Jump to address
    mov word ptr [bp - 0x2e], 0x33c;
    mov word ptr [bp - 0x30], 0x3b2;
    mov word ptr [bp - 0x32], 0x453;
    goto $1; // Jump to address
    mov word ptr [bp - 0x2e], 0x345;
    mov word ptr [bp - 0x30], 0x3b7;
    mov word ptr [bp - 0x32], 0x45a;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    cld ; // Clear direction flag; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x28], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xd368; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    not bl; // Bitwise NOT
    or al, bl; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    not bl; // Bitwise NOT
    and byte ptr es:[di], bl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or cl, cl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    ja 0xd3b1; // Jump if above (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0xd405; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0xd3ca; // Jump if above or equal (unsigned); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xd3e3; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    $1++; // Increment value
    $1--; // Decrement value; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0xd41e; // Jump if above or equal (unsigned); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xd437; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2; // Check if values are not equal
    or bh, bh; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0xd461; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0x2c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xd480; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    not dx; // Bitwise NOT
    and al, bh; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    or al, dh; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value; Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0xd4c3; // Jump if above or equal (unsigned); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xd4db; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0xd4eb; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x16], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0xd4fe; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0xd4fe; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0xd50e; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x20], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0xd521; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0xd521; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp + 0x18];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xc];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x16; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x2f; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffdc;
    goto $1; // Jump to address
    $1 = $2;
    int 0x2f; // Call interrupt
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    lcall [0x5ab2];
    // Compare $1 with $2 // Compare values
    jae 0xd590; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffdc;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    cmp byte ptr [0x54e2], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffdc;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp byte ptr [0x54e2], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffdc;
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xffe6;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr [si], 0xffff;
    mov word ptr [si + 2], 0xffff;
    mov word ptr [si + 4], 0xffff;
    mov word ptr [si + 6], 0;
    $1 += $2; // Add values
    loop 0xd63e; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 2], 0;
    mov byte ptr [0x54e2], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    cmp byte ptr [0x54e2], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr [0x5ab6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe7;
    goto $1; // Jump to address
    mov byte ptr [0x54e2], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mov byte ptr [bp + 7], 0; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [0x54e2], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    mov word ptr [bp - 2], 0xffdc; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffdb;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR; Check if values are not equal
    $1 = $2; // Check if values are not equal
    mov word ptr [bp - 0xa], 0xffff; // Check if values are not equal
    cmp word ptr es:[di], dx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr es:[di + 2], bx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    cmp word ptr es:[di + 4], cx; // Compare values
    jle 0xd76b; // Jump if less or equal (signed)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2; // Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values; Check if values are equal
    jb 0xd749; // Jump if below (unsigned); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp ax, -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp + 6], al; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are equal
    mul bl; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr es:[di + 4], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 4], cx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr es:[di + 4], cx;
    mov word ptr es:[di + 6], 1;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    mul byte ptr [bp + 6]; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr es:[di], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr es:[di + 6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [si + 4], 0;
    $1 = $2;
    mul word ptr [si]; // Multiply (unsigned)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mul word ptr [si]; // Multiply (unsigned)
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr es:[di], dx;
    $1 = $2;
    mov word ptr es:[di + 2], bx;
    $1 = $2; // Check if values are not equal
    mov word ptr es:[di + 4], cx; // Check if values are not equal
    mov word ptr es:[di + 6], cx; // Check if values are not equal
    cmp byte ptr [bp - 0xa], 0xff; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    $1 = $2;
    mul word ptr [si]; // Multiply (unsigned)
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0xa], 0;
    $1 = $2;
    mul word ptr [si]; // Multiply (unsigned)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax; // Bitwise OR; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx; // Multiply (unsigned)
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp - 0xa]; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0xa], 0xffff; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr es:[di + 4], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr es:[di + 4], cx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di], 0xffff;
    mov word ptr es:[di + 2], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 6], 0;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffdb;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [0x54e2], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    lcall [0x5ab2];
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr dx, cl; // Shift right (unsigned)
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    shr dx, cl; // Shift right (unsigned)
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffdb;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    shl dx, cl; // Shift left
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffda;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si], dx; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    $1 += $2; // Add values
    loop 0xd93e; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xffdb;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [0x6d35], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or bx, word ptr [si + 0x32]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    add word ptr [bp + 0xc], ax; // Add values
    add word ptr [bp + 0xa], bx; // Add values; Check if values are not equal
    add word ptr [bp + 8], ax; // Add values; Check if values are not equal
    add word ptr [bp + 6], bx; // Add values; Check if values are not equal
    cmp word ptr [si + 0x18], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xc6c, 0x220;
    jae 0xda00; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xda25;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xa], ax; // Exchange values
    *($1) = $2; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xda47; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0xda4e; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    ljmp [si + 0xa];
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    mov word ptr [bx + 0xa], 0x275;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x335;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x61a;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x3e9;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    $1 = $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2; // Add values
    mov byte ptr [0x6d35], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Increment counter and check loop condition
    lcall 0xd9f, 0x178; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0xdbae; // Jump if less or equal (signed)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0x55;
    mov byte ptr [0x5af0], 0xaa;
    mov byte ptr [0x5af1], 0xff;
    $1 = $2;
    mov word ptr [bp - 4], 0xe050;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xdc14;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 3; // Bitwise AND
    xor cl, 3; // Bitwise XOR
    shl cl, 1; // Shift left
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    and al, 3; // Bitwise AND
    xlatb ;
    $1 = $2;
    test si, di; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg word ptr [bp - 4], si; // Exchange values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or dh, dh; // Bitwise OR
    js 0xdc78;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = $2;
    and ah, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    xchg word ptr [bp - 4], si; // Exchange values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0xff;
    $1 = $2;
    mov word ptr [bp - 4], 0xe050;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xdcca;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND
    xlatb ;
    $1 = $2;
    test si, di; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg word ptr [bp - 4], si; // Exchange values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or dh, dh; // Bitwise OR
    js 0xdd2c;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = $2;
    and ah, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    xchg word ptr [bp - 4], si; // Exchange values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0xff;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0x805a;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xdd87;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND
    xlatb ;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or dh, dh; // Bitwise OR
    js 0xdde5;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = $2;
    and ah, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    jns 0xddfd;
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xde62;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or bh, bh; // Bitwise OR
    js 0xdeb1;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and bl, bh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    out dx, ax; // Output to port
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    out dx, ax; // Output to port
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    $1 = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    out dx, ax; // Output to port
    $1++; // Increment value
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0xff;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xdf06;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND
    xlatb ;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or dh, dh; // Bitwise OR
    js 0xdf60;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = $2;
    and ah, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xdfa0;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xdffd;
    neg cx; // Negate value
    $1 = $2;
    xchg word ptr [bp + 0xc], bx; // Exchange values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    jb 0xe03f; // Jump if below (unsigned)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0xe027; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    jae 0xe020; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xe0af; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0xe0c5; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    shr ch, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 += $2; // Add values
    and dl, 7; // Bitwise AND
    $1 = $2;
    xor cl, 7; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = 0; // Bitwise XOR
    or word ptr [bp - 0x24], cx; // Bitwise OR
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xe146; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0xe15c; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    mov byte ptr [bp - 0x28], 0;
    mov byte ptr [bp - 0x27], 0x55; // Check if values are not equal
    mov byte ptr [bp - 0x26], 0xaa; // Check if values are not equal
    mov byte ptr [bp - 0x25], 0xff; // Check if values are not equal
    cmp word ptr [bp - 0x1a], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 0x13], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp byte ptr es:[di + 0x13], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and ax, 3; // Bitwise AND
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    mov byte ptr [bp + si - 0x28], 0xff;
    rcr ax, 1;
    jb 0xe1b6; // Jump if below (unsigned); Increment counter and check loop condition
    not byte ptr [bp + si - 0x28]; // Bitwise NOT; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0xe1ab; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 -= $2; // Subtract values
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xe1fc; // Jump if above (unsigned)
    and dh, dl; // Bitwise AND
    goto $1; // Jump to address
    push($1); // Push value onto stack
    and al, dl; // Bitwise AND
    not dl; // Bitwise NOT
    $1 = $2;
    and ah, dl; // Bitwise AND
    or al, ah; // Bitwise OR
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jae 0xe22a; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jbe 0xe253; // Jump if below or equal (unsigned)
    stosb byte ptr es:[di], al; // Store string byte/word
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jb 0xe2be; // Jump if below (unsigned)
    loop 0xe232; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    test cx, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr cx, 1; // Shift right (unsigned)
    $1 = $2;
    rep stosw word ptr es:[di], ax; // Fill memory block
    and al, dh; // Bitwise AND
    not dh; // Bitwise NOT
    $1 = $2;
    and ah, dh; // Bitwise AND
    or al, ah; // Bitwise OR
    stosb byte ptr es:[di], al; // Store string byte/word
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Increment counter and check loop condition
    jb 0xe2be; // Jump if below (unsigned); Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0xe293; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    jae 0xe2af; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jb 0xe2be; // Jump if below (unsigned)
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jl 0xe3c8; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jl 0xe3c8; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xe3c8; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0xe3c8; // Jump if greater (signed)
    clc ; // Clear carry flag
    goto $1; // Jump to address
    stc ; // Set carry flag
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    or ah, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    and ah, al; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    test al, 0xf; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    xchg word ptr [bp + 8], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    mov word ptr [bp - 6], 1;
    test al, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    imul bx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    idiv bx; // Divide (signed)
    add word ptr [bp + 0xa], ax; // Add values
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test al, 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    imul bx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    idiv bx; // Divide (signed)
    add word ptr [bp + 0xc], ax; // Add values
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test al, 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    imul bx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    idiv bx; // Divide (signed)
    add word ptr [bp + 0xa], ax; // Add values
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    imul bx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    idiv bx; // Divide (signed)
    add word ptr [bp + 0xc], ax; // Add values
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp - 6], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg cx, ax; // Exchange values
    xchg dx, bx; // Exchange values; Check if values are equal
    *($1) = $2; // Check if values are equal
    clc ; // Clear carry flag; Check if values are equal
    cmp word ptr [bp - 4], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stc ; // Set carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    or ah, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    and ah, al; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    test al, 0xf; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    xchg word ptr [bp + 8], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    mov word ptr [bp - 6], 1;
    test al, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test al, 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test al, 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp - 6], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg cx, ax; // Exchange values
    xchg dx, bx; // Exchange values; Check if values are equal
    *($1) = $2; // Check if values are equal
    clc ; // Clear carry flag; Check if values are equal
    cmp word ptr [bp - 4], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stc ; // Set carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xe59c; // Jump if greater or equal (signed)
    or al, 1; // Bitwise OR
    // Compare $1 with $2 // Compare values
    jge 0xe5a3; // Jump if greater or equal (signed)
    or al, 2; // Bitwise OR
    // Compare $1 with $2 // Compare values
    jle 0xe5aa; // Jump if less or equal (signed)
    or al, 4; // Bitwise OR
    // Compare $1 with $2 // Compare values
    jle 0xe5b1; // Jump if less or equal (signed)
    or al, 8; // Bitwise OR
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xe5bf; // Jump if greater or equal (signed)
    or ah, 1; // Bitwise OR
    // Compare $1 with $2 // Compare values
    jge 0xe5c7; // Jump if greater or equal (signed)
    or ah, 2; // Bitwise OR
    // Compare $1 with $2 // Compare values
    jle 0xe5cf; // Jump if less or equal (signed)
    or ah, 4; // Bitwise OR
    // Compare $1 with $2 // Compare values
    jle 0xe5d7; // Jump if less or equal (signed)
    or ah, 8; // Bitwise OR
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xe5fa; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    push($1); // Push value onto stack
    les di, ptr [bp + 0xe];
    push($1); // Push value onto stack
    les di, ptr [bp + 0xa];
    push($1); // Push value onto stack; Prepare arguments and call function
    les di, ptr [bp + 6]; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xe640; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    les di, ptr [bp + 0x12];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    mov word ptr es:[di], bx;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    push($1); // Push value onto stack
    les di, ptr [bp + 0xe];
    push($1); // Push value onto stack
    les di, ptr [bp + 0xa];
    push($1); // Push value onto stack; Prepare arguments and call function
    les di, ptr [bp + 6]; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xe69e; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    les di, ptr [bp + 0x12];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    mov word ptr es:[di], bx;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xe71a; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0xe], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xe728; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0x10], ax; // Exchange values
    *($1) = $2;
    mov word ptr [bp - 0x36], 0;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    *($1) = $2;
    mov word ptr [bp - 0x2c], 0;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xe774; // Jump if greater or equal (signed)
    *($1) = $2;
    mov word ptr [bp + 6], 0x168;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    add word ptr [bp - 0x20], ax; // Add values; Check if values are not equal
    add word ptr [bp - 0x22], bx; // Add values; Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xe7a9; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    lcall 0xc6c, 0x3e;
    *($1) = $2;
    mov word ptr [bp - 0x2e], 0x169;
    mov word ptr [bp - 0x30], 0xffff;
    $1 = $2;
    mul ax; // Multiply (unsigned)
    *($1) = $2;
    *($1) = $2;
    shl ax, 1; // Shift left
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    mul ax; // Multiply (unsigned)
    *($1) = $2;
    *($1) = $2;
    shl ax, 1; // Shift left
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xe805; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x14];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    sub word ptr [bp - 6], ax; // Subtract values
    sbb word ptr [bp - 4], dx;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0xc];
    jns 0xe88f;
    push($1); // Push value onto stack
    $1(); // Call function
    cmp word ptr [bp - 4], 0; // Compare values
    js 0xe86e;
    $1--; // Decrement value
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    sub word ptr [bp - 6], ax; // Subtract values
    sbb word ptr [bp - 4], dx;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x14];
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0x14];
    $1 = $2;
    $1 = $2;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    $1 += $2; // Add values
    adc dx, cx;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 8];
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0xc];
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1(); // Call function
    cmp word ptr [bp - 4], 0; // Compare values
    jns 0xe8e4;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0xc];
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx; // Check if values are equal
    $1--; // Decrement value; Check if values are equal
    jns 0xe8c1; // Check if values are equal
    cmp word ptr [bp - 0x2c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0x36], 1;
    mov word ptr [bp + 8], 0;
    $1 = $2;
    *($1) = $2; // Check if values are not equal
    mov word ptr [bp - 0x2c], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 0x36], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [0x5af2], ax; // Add values
    add word ptr [0x5af4], bx; // Add values
    add word ptr [0x5af6], ax; // Add values
    add word ptr [0x5af8], bx; // Add values
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xea2d; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xea2d; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jge 0xe9ff; // Jump if greater or equal (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xea0f; // Jump if less (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xea2d; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    neg bx; // Negate value
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xea7f; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xea7f; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0xea51; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jle 0xea61; // Jump if less or equal (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xea7f; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    neg cx; // Negate value
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xead9; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xead9; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0xeaab; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jle 0xeabb; // Jump if less or equal (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xead9; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    neg bx; // Negate value
    neg cx; // Negate value
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xeb2d; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xeb2d; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jge 0xeaff; // Jump if greater or equal (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xeb0f; // Jump if less (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xeb2d; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xeb70; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xeb70; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xeb70; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    neg cx; // Negate value
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jge 0xeb8a; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jle 0xeb92; // Jump if less or equal (signed)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jge 0xeba2; // Jump if greater or equal (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xebb2; // Jump if less (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jae 0xebca; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xec1e; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xec1e; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0xebf2; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xec02; // Jump if less (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xec1e; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg bx; // Negate value
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jl 0xec72; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0xec72; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0xec46; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0xec56; // Jump if less (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xec72; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    $1 -= $2; // Subtract values
    test word ptr [si + 0x3c], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lcall 0x1214, 0x307;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 -= $2; // Subtract values
    test word ptr [si + 0x3c], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lcall 0x1214, 0x346;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 -= $2; // Subtract values
    test word ptr [si + 0x3c], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lcall 0x1214, 0x307;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 -= $2; // Subtract values
    test word ptr [si + 0x3c], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    lcall 0x1214, 0x346;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    mul cx; // Multiply (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    stc ; // Set carry flag
    goto $1; // Jump to address
    xchg cx, ax; // Exchange values
    $1 = pop(); // Pop value from stack
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    neg cx; // Negate value
    // Compare $1 with $2 // Compare values
    jl 0xed26; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jl 0xed2b; // Jump if less (signed)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xed7c; // Jump if greater or equal (signed)
    neg ax; // Negate value
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    xor cx, bx; // Bitwise XOR
    jge 0xed49; // Jump if greater or equal (signed)
    $1--; // Decrement value
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    jge 0xed51; // Jump if greater or equal (signed)
    neg ax; // Negate value
    // Compare $1 with $2 // Compare values
    jge 0xed58; // Jump if greater or equal (signed)
    neg bx; // Negate value
    $1 = $2;
    mul dx; // Multiply (unsigned)
    div bx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xed6d; // Jump if below or equal (unsigned)
    $1++; // Increment value
    $1++; // Increment value
    loop 0xed65; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    shr ax, 1; // Shift right (unsigned)
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jge 0xed7c; // Jump if greater or equal (signed)
    neg ax; // Negate value
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 -= $2; // Subtract values
    jge 0xedbb; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    *($1) = $2; // Check if values are not equal
    mov word ptr [bp - 0x14], 0; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xee06; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0x10], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0xee14; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0x12], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    add word ptr [bp + 0x12], ax; // Add values
    add word ptr [bp + 0xe], ax; // Add values
    $1 = $2;
    *($1) = $2;
    add word ptr [bp + 0x10], ax; // Add values
    add word ptr [bp + 0xc], ax; // Add values
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jg 0xee83; // Jump if greater (signed)
    $1 += $2; // Add values
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    *($1) = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    *($1) = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jg 0xef41; // Jump if greater (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xeefe; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    *($1) = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    *($1) = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    test word ptr [bp + 6], 0x8000; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1 = $2;
    shl bx, 1; // Shift left
    shl bx, 1; // Shift left
    sub word ptr [0x54bf], bx; // Subtract values
    add word ptr [0x54c1], bx; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    and ax, 0x7fff; // Bitwise AND
    push($1); // Push value onto stack
    lcall 0xfe6, 0x5c3;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    // Compare $1 with $2 // Compare values
    jl 0xf004; // Jump if less (signed)
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jle 0xf012; // Jump if less or equal (signed)
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values
    neg ax; // Negate value
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jle 0xf02b; // Jump if less or equal (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0xf024; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    neg ax; // Negate value
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shl bx, 1; // Shift left
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg ax; // Negate value
    ret ; // Return from function
    // Compare $1 with $2 // Compare values
    jl 0xf044; // Jump if less (signed)
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jle 0xf05c; // Jump if less or equal (signed)
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jle 0xf057; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values
    neg ax; // Negate value
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0xf069; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values
    neg ax; // Negate value
    $1 = $2;
    $1 -= $2; // Subtract values
    shl bx, 1; // Shift left
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg ax; // Negate value
    ret ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [si + 0x3c], 0;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    lcall 0x10b4, 0x84;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [bp + 0xe], ax; // Add values
    add word ptr [bp + 0xc], bx; // Add values
    $1 = $2;
    and dx, 2; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0xf1c0; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    lcall 0xc6c, 0x3e;
    *($1) = $2;
    $1 = $2;
    mul ax; // Multiply (unsigned)
    *($1) = $2;
    *($1) = $2;
    shl ax, 1; // Shift left
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    mul ax; // Multiply (unsigned)
    *($1) = $2;
    *($1) = $2;
    shl ax, 1; // Shift left
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    jae 0xf212; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x14];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    sub word ptr [bp - 6], ax; // Subtract values
    sbb word ptr [bp - 4], dx;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0xc];
    jae 0xf2a2; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1(); // Call function
    cmp word ptr [bp - 4], 0; // Compare values
    js 0xf281;
    $1--; // Decrement value
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    sub word ptr [bp - 6], ax; // Subtract values
    sbb word ptr [bp - 4], dx;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x14];
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0x14];
    $1 = $2;
    $1 = $2;
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    $1 += $2; // Add values
    adc dx, cx;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 8];
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0xc];
    sar dx, 1; // Shift right (signed)
    rcr ax, 1;
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1(); // Call function
    cmp word ptr [bp - 4], 0; // Compare values
    jns 0xf2f7;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [bp - 0xc];
    add word ptr [bp - 6], ax; // Add values
    adc word ptr [bp - 4], dx;
    $1--; // Decrement value
    jns 0xf2d4;
    cmp word ptr [bp + 6], 2; // Compare values
    jge 0xf327; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    and word ptr [bp + 6], 1; // Bitwise AND
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    test word ptr [bp + 6], 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    or ax, 0x8000; // Bitwise OR
    push($1); // Push value onto stack
    lcall 0xcac, 0x6c4;
    $1 = $2;
    test word ptr [bp + 6], 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    cmp word ptr [bp + 6], 2; // Compare values; Check if values are not equal
    jge 0xf418; // Jump if greater or equal (signed); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bx + 0x26], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bx + 0x22], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bx + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    and cx, 7; // Bitwise AND
    and bx, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    rol ax, cl; // Rotate left
    $1 = $2;
    *($1) = $2;
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    and cx, 7; // Bitwise AND
    and bx, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    rol ax, cl; // Rotate left
    $1 = $2;
    *($1) = $2; // Check if values are not equal
    lcall 0xd9f, 0x178; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x24], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xf521; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x24], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xf543; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp word ptr [bp - 0x24], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xf56d; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp word ptr [bp - 0x24], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xf5d2; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x24], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xf5ad; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    cmp word ptr [bp - 0x24], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5;
    jb 0xf5d2; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [si];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    *($1) = $2;
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    mul cx; // Multiply (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    stc ; // Set carry flag
    goto $1; // Jump to address
    xchg cx, ax; // Exchange values
    $1 = pop(); // Pop value from stack
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    add word ptr [si + 0x12], ax; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    neg ax; // Negate value
    add word ptr [si + 0x14], ax; // Add values
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    *($1) = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 += $2; // Add values; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg word ptr [bp + 6]; // Negate value
    $1 += $2; // Add values
    push($1); // Push value onto stack
    *($1) = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cld ; // Clear direction flag; Check if values are equal
    cmp byte ptr [0x6d33], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    mov byte ptr [bp - 0x4e], 0;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or bx, word ptr [si + 0x32]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    add word ptr [bp + 0xc], ax; // Add values
    add word ptr [bp + 0xa], bx; // Add values
    add word ptr [bp + 8], ax; // Add values
    add word ptr [bp + 6], bx; // Add values
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0xf7f6; // Jump if less or equal (signed)
    xchg word ptr [bp + 8], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], ax; // Exchange values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    mov byte ptr [bp - 0x4e], 1; // Check if values are not equal
    cmp word ptr [si + 0x18], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xc6c, 0x10c;
    jae 0xf817; // Jump if above or equal (unsigned); Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    and cl, 7; // Bitwise AND
    ror word ptr [bp - 0x2a], cl; // Rotate right
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0xf86d; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0xf874; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    mul dx; // Multiply (unsigned); Check if values are not equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr [bp - 0x2c], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [bp - 0x2a], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    ljmp [si + 4];
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    mov word ptr [bx + 4], 0x7b9;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x968;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xff1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xb0f;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    $1 = $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2; // Add values
    mov byte ptr [0x6d33], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    or bx, bx; // Bitwise OR
    jge 0xfa21; // Jump if greater or equal (signed)
    neg bx; // Negate value
    *($1) = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jl 0xfa2f; // Jump if less (signed)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    neg di; // Negate value
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Increment counter and check loop condition
    $1(); // Call function; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0xfa39; // Jump if less or equal (signed)
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    or bx, bx; // Bitwise OR
    jge 0xfa64; // Jump if greater or equal (signed)
    neg bx; // Negate value
    *($1) = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jl 0xfa72; // Jump if less (signed)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    neg di; // Negate value
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Increment counter and check loop condition
    $1(); // Call function; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0xfa7c; // Jump if less or equal (signed)
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xfaa4; // Jump if above (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0xfac5; // Jump if above (unsigned)
    $1 = $2;
    neg si; // Negate value
    $1 = 0; // Bitwise XOR
    mov word ptr [bp - 4], 1;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    neg di; // Negate value
    mov word ptr [bp - 4], 0;
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    $1 += $2; // Add values; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp word ptr [bp - 4], 1; // Compare values; Increment counter and check loop condition
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0xfad1; // Jump if less or equal (signed); Increment counter and check loop condition
    goto $1; // Jump to address; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jl 0xfad1; // Jump if less (signed)
    goto $1; // Jump to address
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1++; // Increment value
    $1 += $2; // Add values
    $1 += $2; // Add values
    mov word ptr [bp - 0x10], 0;
    // Compare $1 with $2 // Compare values
    jle 0xfb3c; // Jump if less or equal (signed)
    mov word ptr [bp - 0x10], 1;
    $1 -= $2; // Subtract values
    $1 = $2;
    add word ptr [bp - 0x12], ax; // Add values
    // Compare $1 with $2 // Compare values
    jle 0xfb4f; // Jump if less or equal (signed)
    mov word ptr [bp - 0x10], 1;
    $1 -= $2; // Subtract values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    add word ptr [bp - 0x14], ax; // Add values; Check if values are not equal
    cmp word ptr [bp - 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    rol word ptr [bp - 0x2a], 1; // Rotate left
    jae 0xfb97; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0xfb7f; // Jump if less (signed)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    $1 += $2; // Add values; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack; Check if values are not equal
    retf 8; // Return from function; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp - 0x4e], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    rol si, 1; // Rotate left
    jae 0xfc23; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Increment counter and check loop condition
    lcall [bp - 0x4c]; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0xfc19; // Jump if less or equal (signed)
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xfc48;
    neg ax; // Negate value
    $1 = $2;
    xchg word ptr [bp + 8], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], bx; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jns 0xfc53;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jl 0xfca7; // Jump if less (signed)
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp - 0x4e], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    rol word ptr [bp - 0x2a], 1; // Rotate left
    jae 0xfc91; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [bx];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    or dx, dx; // Bitwise OR
    jns 0xfc9e;
    $1 += $2; // Add values
    loop 0xfc7f; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1++; // Increment value
    $1 += $2; // Add values
    loop 0xfc7f; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shl ax, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp - 0x4e], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    rol word ptr [bp - 0x2a], 1; // Rotate left
    jae 0xfce1; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [bx];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    or dx, dx; // Bitwise OR
    jns 0xfcee;
    $1 += $2; // Add values
    loop 0xfccf; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1++; // Increment value
    $1 += $2; // Add values
    loop 0xfccf; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    neg bx; // Negate value
    // Compare $1 with $2 // Compare values
    jge 0xfd4b; // Jump if greater or equal (signed)
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp - 0x4e], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    rol word ptr [bp - 0x2a], 1; // Rotate left
    jae 0xfd37; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [bx];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    or dx, dx; // Bitwise OR
    jns 0xfd43;
    $1 += $2; // Add values
    loop 0xfd25; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1--; // Decrement value
    $1 += $2; // Add values
    loop 0xfd25; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    shl ax, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1++; // Increment value
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x28], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [bp - 0x4e], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    rol word ptr [bp - 0x2a], 1; // Rotate left
    jae 0xfd85; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall [bx];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    or dx, dx; // Bitwise OR
    jns 0xfd91;
    $1 += $2; // Add values
    loop 0xfd73; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1++; // Increment value
    $1 += $2; // Add values
    loop 0xfd73; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf 8; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0x55;
    mov byte ptr [0x5c66], 0xaa;
    mov byte ptr [0x5c67], 0xff;
    and byte ptr [bp - 0x26], 3; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    jns 0xfdef;
    neg bx; // Negate value
    neg si; // Negate value
    neg di; // Negate value
    xchg di, si; // Exchange values
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0xfe02; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    shl ax, cl; // Shift left
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    test bx, 0x2000; // Test bits (AND without storing); Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    xchg word ptr [bp - 0xa], si; // Exchange values; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0xfe4c; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x885, 0;
    $1 = $2;
    shl ax, cl; // Shift left
    not ah; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    test si, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg di, si; // Exchange values
    and byte ptr es:[bx], ah; // Bitwise AND
    or byte ptr es:[bx], al; // Bitwise OR
    $1 += $2; // Add values
    xchg di, si; // Exchange values
    loop 0xfe64; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 3; // Bitwise AND
    xor cl, 3; // Bitwise XOR
    shl cl, 1; // Shift left
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh; // Bitwise OR
    js 0xfec8;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    and al, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    or ah, dl; // Bitwise OR
    ror dl, 1; // Rotate right
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    ror dh, 1; // Rotate right
    jae 0xff04; // Jump if above or equal (unsigned)
    or di, di; // Bitwise OR
    jns 0xfef5;
    $1 += $2; // Add values
    loop 0xfed9; // Loop (decrement CX and jump if CX!=0)
    mov byte ptr es:[bx], ah;
    goto $1; // Jump to address
    $1 += $2; // Add values
    mov byte ptr es:[bx], ah;
    $1 += $2; // Add values
    xchg word ptr [bp - 0xa], si; // Exchange values
    loop 0xfed6; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    mov byte ptr es:[bx], ah;
    $1++; // Increment value
    or di, di; // Bitwise OR
    jns 0xff13;
    $1 += $2; // Add values
    loop 0xfed6; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    xchg word ptr [bp - 0xa], si; // Exchange values
    loop 0xfed6; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], dh; // Bitwise AND
    or byte ptr es:[bx], dl; // Bitwise OR
    $1 += $2; // Add values
    xchg word ptr [bp - 0xa], si; // Exchange values
    or di, di; // Bitwise OR
    jns 0xff35;
    $1 += $2; // Add values
    loop 0xff1f; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    ror dl, 1; // Rotate right
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    ror dh, 1; // Rotate right
    cmc ;
    adc bx, 0;
    loop 0xff1f; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf 8; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0xff;
    and byte ptr [bp - 0x26], 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    jns 0xff94;
    neg bx; // Negate value
    neg si; // Negate value
    neg di; // Negate value
    xchg di, si; // Exchange values
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0xffa7; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    shl ax, cl; // Shift left
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    test bx, 0x2000; // Test bits (AND without storing); Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    xchg word ptr [bp - 0xa], si; // Exchange values; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0xfff1; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x885, 0x24;
    $1 = $2;
    shl ax, cl; // Shift left
    not ah; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    test si, bx; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg di, si; // Exchange values
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    $1 += $2; // Add values
    xchg di, si; // Exchange values
    loop 0x1000d; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], ah; // Bitwise AND
    $1 += $2; // Add values
    xchg di, si; // Exchange values
    loop 0x10018; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh; // Bitwise OR
    js 0x10077;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    and al, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    or ah, dl; // Bitwise OR
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    jae 0x100af; // Jump if above or equal (unsigned)
    or di, di; // Bitwise OR
    jns 0x100a0;
    $1 += $2; // Add values
    loop 0x10088; // Loop (decrement CX and jump if CX!=0)
    mov byte ptr es:[bx], ah;
    goto $1; // Jump to address
    $1 += $2; // Add values
    mov byte ptr es:[bx], ah;
    $1 += $2; // Add values
    xchg word ptr [bp - 0xa], si; // Exchange values
    loop 0x10085; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    mov byte ptr es:[bx], ah;
    $1++; // Increment value
    or di, di; // Bitwise OR
    jns 0x100be;
    $1 += $2; // Add values
    loop 0x10085; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    xchg word ptr [bp - 0xa], si; // Exchange values
    loop 0x10085; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], dh; // Bitwise AND
    or byte ptr es:[bx], dl; // Bitwise OR
    $1 += $2; // Add values
    xchg word ptr [bp - 0xa], si; // Exchange values
    or di, di; // Bitwise OR
    jns 0x100e0;
    $1 += $2; // Add values
    loop 0x100ca; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    cmc ;
    adc bx, 0;
    loop 0x100ca; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf 8; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0xff;
    and byte ptr [bp - 0x26], 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    jns 0x10142;
    neg bx; // Negate value
    neg si; // Negate value
    neg di; // Negate value
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0x10155; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 += $2; // Add values
    $1 = $2;
    shl ax, cl; // Shift left
    $1 = $2;
    not dh; // Bitwise NOT; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0x10199; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x885, 0x4a;
    $1 += $2; // Add values
    $1 = $2;
    shl ax, cl; // Shift left
    not ah; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    $1 += $2; // Add values
    jns 0x101bb;
    $1 += $2; // Add values
    loop 0x101b2; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], ah; // Bitwise AND
    $1 += $2; // Add values
    jns 0x101c8;
    $1 += $2; // Add values
    loop 0x101bf; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh; // Bitwise OR
    js 0x10223;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    and al, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    or ah, dl; // Bitwise OR
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    jae 0x1025d; // Jump if above or equal (unsigned)
    or di, di; // Bitwise OR
    jns 0x1024c;
    $1 += $2; // Add values
    loop 0x10234; // Loop (decrement CX and jump if CX!=0)
    mov byte ptr es:[bx], ah;
    goto $1; // Jump to address
    $1 += $2; // Add values
    mov byte ptr es:[bx], ah;
    $1 += $2; // Add values
    jns 0x10259;
    $1 += $2; // Add values
    loop 0x10231; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    mov byte ptr es:[bx], ah;
    $1++; // Increment value
    or di, di; // Bitwise OR
    jns 0x1026c;
    $1 += $2; // Add values
    loop 0x10231; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    jns 0x10276;
    $1 += $2; // Add values
    loop 0x10231; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], dh; // Bitwise AND
    or byte ptr es:[bx], dl; // Bitwise OR
    $1 += $2; // Add values
    jns 0x10287;
    $1 += $2; // Add values
    or di, di; // Bitwise OR
    jns 0x10292;
    $1 += $2; // Add values
    loop 0x1027a; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    cmc ;
    adc bx, 0;
    loop 0x1027a; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    shl ah, cl; // Shift left
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jns 0x10314;
    neg bx; // Negate value
    neg si; // Negate value
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0x10327; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    shl ah, cl; // Shift left
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0x10366; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    shl ah, cl; // Shift left
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    or byte ptr es:[bx], al; // Bitwise OR
    $1 += $2; // Add values
    loop 0x10375; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    and cx, 7; // Bitwise AND
    ror byte ptr [bp - 0x2a], cl; // Rotate right
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    and dh, byte ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    shl dl, cl; // Shift left
    and dl, byte ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    or bh, bh; // Bitwise OR
    js 0x103dc;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and bl, bh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    out dx, ax; // Output to port
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    out dx, ax; // Output to port
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1 = $2;
    or ah, bl; // Bitwise OR
    ror bl, 1; // Rotate right
    jb 0x1040e; // Jump if below (unsigned)
    or si, si; // Bitwise OR
    jns 0x10400;
    $1 += $2; // Add values
    loop 0x103eb; // Loop (decrement CX and jump if CX!=0)
    out dx, ax; // Output to port
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 += $2; // Add values
    out dx, ax; // Output to port
    or byte ptr es:[di], al; // Bitwise OR
    $1 += $2; // Add values
    loop 0x103e9; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    out dx, ax; // Output to port
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    or si, si; // Bitwise OR
    jns 0x1041e;
    $1 += $2; // Add values
    loop 0x103e9; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    loop 0x103e9; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    out dx, ax; // Output to port
    or byte ptr es:[di], al; // Bitwise OR
    $1 += $2; // Add values
    or si, si; // Bitwise OR
    jns 0x1043c;
    $1 += $2; // Add values
    loop 0x1042b; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    ror ah, 1; // Rotate right
    adc di, 0;
    loop 0x1042b; // Loop (decrement CX and jump if CX!=0)
    $1 = 0; // Bitwise XOR
    out dx, ax; // Output to port
    $1++; // Increment value
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf 8; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0xff;
    and byte ptr [bp - 0x26], 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    jns 0x10498;
    neg bx; // Negate value
    neg si; // Negate value
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0x104a8; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    shl ax, cl; // Shift left
    $1 = $2;
    not dh; // Bitwise NOT; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0x104e8; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    shl ax, cl; // Shift left
    not ah; // Bitwise NOT
    $1 = pop(); // Pop value from stack
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    $1 += $2; // Add values
    loop 0x104fd; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], ah; // Bitwise AND
    $1 += $2; // Add values
    loop 0x10506; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    shl dh, cl; // Shift left
    not dh; // Bitwise NOT
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    shl dl, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    shr bx, cl; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh; // Bitwise OR
    js 0x10562;
    or cx, cx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and dl, dh; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    not dh; // Bitwise NOT
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], ah; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    rep stosb byte ptr es:[di], al; // Fill memory block
    and al, dl; // Bitwise AND
    not dl; // Bitwise NOT
    and byte ptr es:[di], dl; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ah, dh; // Bitwise AND
    or ah, dl; // Bitwise OR
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    jae 0x10597; // Jump if above or equal (unsigned)
    or di, di; // Bitwise OR
    jns 0x1058b;
    $1 += $2; // Add values
    loop 0x10573; // Loop (decrement CX and jump if CX!=0)
    mov byte ptr es:[bx], ah;
    goto $1; // Jump to address
    $1 += $2; // Add values
    mov byte ptr es:[bx], ah;
    $1 += $2; // Add values
    loop 0x10570; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    mov byte ptr es:[bx], ah;
    $1++; // Increment value
    or di, di; // Bitwise OR
    jns 0x105a6;
    $1 += $2; // Add values
    loop 0x10570; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    loop 0x10570; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    and byte ptr es:[bx], dh; // Bitwise AND
    or byte ptr es:[bx], dl; // Bitwise OR
    $1 += $2; // Add values
    or di, di; // Bitwise OR
    jns 0x105c2;
    $1 += $2; // Add values
    loop 0x105af; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    ror dl, 1; // Rotate right
    ror dh, 1; // Rotate right
    cmc ;
    adc bx, 0;
    loop 0x105af; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf 8; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jns 0x10605;
    neg bx; // Negate value
    neg si; // Negate value
    push($1); // Push value onto stack
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0x10616; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0x1064f; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x885, 0xaa;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1--; // Decrement value
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 += $2; // Add values
    loop 0x10660; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    $1 = $2;
    rep stosb byte ptr es:[di], al; // Fill memory block
    goto $1; // Jump to address
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    or si, si; // Bitwise OR
    jns 0x1068d;
    $1 += $2; // Add values
    loop 0x10681; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    loop 0x10681; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 += $2; // Add values
    or si, si; // Bitwise OR
    jns 0x106a8;
    $1 += $2; // Add values
    $1--; // Decrement value
    loop 0x10699; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    loop 0x10699; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    jns 0x106f8;
    neg bx; // Negate value
    neg si; // Negate value
    push($1); // Push value onto stack
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2 // Compare values
    jle 0x10709; // Jump if less or equal (signed)
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx; // Exchange values
    shl bx, 1; // Shift left
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jge 0x1074f; // Jump if greater or equal (signed)
    neg cx; // Negate value
    $1 = $2;
    $1++; // Increment value; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mov byte ptr es:[di], dl;
    $1 += $2; // Add values
    jae 0x1077f; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x1076a; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x107be; // Jump if below (unsigned)
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x107a8; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    rep stosb byte ptr es:[di], al; // Fill memory block
    goto $1; // Jump to address
    $1 = $2;
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    or si, si; // Bitwise OR
    jns 0x107e8;
    $1 += $2; // Add values
    loop 0x107c8; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 += $2; // Add values
    jae 0x10803; // Jump if above or equal (unsigned)
    or bx, bx; // Bitwise OR
    js 0x1081b;
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    goto $1; // Jump to address; Check if values are equal
    or bx, bx; // Bitwise OR; Check if values are equal
    jns 0x1081b; // Check if values are equal
    cmp word ptr [bp - 0x1e], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x107c8; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    mov byte ptr es:[di], dl;
    $1 += $2; // Add values
    jae 0x1083d; // Jump if above or equal (unsigned)
    or bx, bx; // Bitwise OR
    js 0x10855;
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    goto $1; // Jump to address; Check if values are equal
    or bx, bx; // Bitwise OR; Check if values are equal
    jns 0x10855; // Check if values are equal
    cmp word ptr [bp - 0x1e], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    or si, si; // Bitwise OR
    jns 0x10860;
    $1 += $2; // Add values
    loop 0x10822; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x10822; // Loop (decrement CX and jump if CX!=0)
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    retf 8; // Return from function; Check if values are not equal
    cmp word ptr [bp - 0x24], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x108dd; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0x108f3; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 = $2;
    $1 = $2;
    shr ch, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    adc dx, 0;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 += $2; // Add values
    and dl, 7; // Bitwise AND
    $1 = $2;
    xor cl, 7; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = 0; // Bitwise XOR
    or word ptr [bp - 0x3c], cx; // Bitwise OR
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x10974; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    mov byte ptr [bp - 0x42], 0;
    mov byte ptr [bp - 0x41], 0x55; // Check if values are not equal
    mov byte ptr [bp - 0x40], 0xaa; // Check if values are not equal
    mov byte ptr [bp - 0x3f], 0xff; // Check if values are not equal
    cmp word ptr [bp - 0x38], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp byte ptr es:[di + 0x13], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp byte ptr es:[di + 0x13], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and ax, 3; // Bitwise AND
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    mov byte ptr [bp + si - 0x42], 0xff;
    rcr ax, 1;
    jb 0x109c6; // Jump if below (unsigned); Increment counter and check loop condition
    not byte ptr [bp + si - 0x42]; // Bitwise NOT; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x109bb; // Jump if below (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 -= $2; // Subtract values
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0x10a06; // Jump if above (unsigned)
    and dh, dl; // Bitwise AND
    goto $1; // Jump to address
    push($1); // Push value onto stack
    and al, dl; // Bitwise AND
    not dl; // Bitwise NOT
    $1 = $2;
    and ah, dl; // Bitwise AND
    or al, ah; // Bitwise OR
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jae 0x10a32; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jbe 0x10a59; // Jump if below or equal (unsigned)
    stosb byte ptr es:[di], al; // Store string byte/word
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jb 0x10ab9; // Jump if below (unsigned)
    loop 0x10a3a; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    test cx, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr cx, 1; // Shift right (unsigned)
    $1 = $2;
    rep stosw word ptr es:[di], ax; // Fill memory block
    and al, dh; // Bitwise AND
    not dh; // Bitwise NOT
    $1 = $2;
    and ah, dh; // Bitwise AND
    or al, ah; // Bitwise OR
    stosb byte ptr es:[di], al; // Store string byte/word
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jb 0x10ab9; // Jump if below (unsigned)
    $1++; // Increment value
    $1 += $2; // Add values
    jae 0x10aaa; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jb 0x10ab9; // Jump if below (unsigned)
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    xchg word ptr [0x5c70], ax; // Exchange values
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test ax, 0x1e; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    test ax, 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    test ax, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    test ax, 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    test ax, 2; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    int 0x33; // Call interrupt
    add word ptr [0x5c82], si; // Add values
    add word ptr [0x5c84], di; // Add values; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr [0x5ce6], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp word ptr [0x5c76], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1 = $2;
    and ax, 0x1f; // Bitwise AND
    and ax, word ptr [0x6d37]; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lcall 0x107c, 0x1c0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    mov word ptr [0x5c70], 0; // Update game state variable
    $1 = $2;
    $1 = $2;
    $1 = $2;
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 6;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 6;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 6;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 6;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jbe 0x10c91; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jbe 0x10cb6; // Jump if below or equal (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1++; // Increment value
    loop 0x10c95; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1++; // Increment value
    loop 0x10caa; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    cld ; // Clear direction flag
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    shl dx, 1; // Shift left
    rcl ax, 1;
    shl dx, 1; // Shift left
    rcl ax, 1;
    rol bx, 1; // Rotate left
    jae 0x10cd3; // Jump if above or equal (unsigned)
    or dx, 3; // Bitwise OR
    loop 0x10cc4; // Loop (decrement CX and jump if CX!=0)
    xchg al, ah; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    xchg al, ah; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    and ax, 3; // Bitwise AND
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    shl dx, 1; // Shift left
    rcl ax, 1;
    shl dx, 1; // Shift left
    rcl ax, 1;
    rol bx, 1; // Rotate left
    jae 0x10d11; // Jump if above or equal (unsigned)
    or dx, word ptr [bp - 4]; // Bitwise OR
    loop 0x10d02; // Loop (decrement CX and jump if CX!=0)
    xchg al, ah; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    xchg al, ah; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1++; // Increment value
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    rep stosw word ptr es:[di], ax; // Fill memory block
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    ror bl, 1; // Rotate right
    jb 0x10d53; // Jump if below (unsigned)
    $1 = 0; // Bitwise XOR
    mov word ptr es:[di], ax;
    $1++; // Increment value
    $1++; // Increment value
    loop 0x10d49; // Loop (decrement CX and jump if CX!=0)
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rol ax, 1; // Rotate left
    jae 0x10d74; // Jump if above or equal (unsigned)
    mov byte ptr es:[di], 0xff;
    goto $1; // Jump to address
    mov byte ptr es:[di], 0;
    $1++; // Increment value
    loop 0x10d6a; // Loop (decrement CX and jump if CX!=0)
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rol ax, 1; // Rotate left
    jae 0x10d9e; // Jump if above or equal (unsigned)
    mov byte ptr es:[di], bl;
    goto $1; // Jump to address
    mov byte ptr es:[di], 0;
    $1++; // Increment value
    loop 0x10d95; // Loop (decrement CX and jump if CX!=0)
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2; // Update game state variable
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x71a, 0xc;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa52, 0xe;
    *($1) = $2; // Update game state variable
    *($1) = $2; // Update game state variable
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa52, 0xe;
    ret ; // Return from function
    // Compare $1 with $2 // Compare values
    jge 0x10e9f; // Jump if greater or equal (signed)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jle 0x10ea9; // Jump if less or equal (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x10eb5; // Jump if greater or equal (signed)
    $1 = $2;
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jle 0x10ebf; // Jump if less or equal (signed)
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    *($1) = $2; // Update game state variable
    *($1) = $2;
    popf ; // Pop flags from stack
    $1(); // Call function
    ret ; // Return from function; Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    cmp word ptr [0x5c74], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x98e, 0x53a;
    *($1) = $2;
    test byte ptr [0x5c7a], 0xff; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = $2;
    xchg word ptr [0x5cd4], bx; // Exchange values
    or ax, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    cmp word ptr [0x5c86], si; // Compare values
    jg 0x10f33; // Jump if greater (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Update game state variable
    // Compare $1 with $2 // Compare values
    jle 0x10f1f; // Jump if less or equal (signed)
    goto $1; // Jump to address
    *($1) = $2; // Update game state variable
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Update game state variable
    // Compare $1 with $2 // Compare values
    jle 0x10f44; // Jump if less or equal (signed)
    goto $1; // Jump to address
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2; // Update game state variable
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [0x5c88], di; // Compare values
    jg 0x10f82; // Jump if greater (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Update game state variable
    // Compare $1 with $2 // Compare values
    jle 0x10f6e; // Jump if less or equal (signed)
    goto $1; // Jump to address
    *($1) = $2; // Update game state variable
    $1 = 0; // Bitwise XOR
    *($1) = $2; // Update game state variable
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Update game state variable
    // Compare $1 with $2 // Compare values
    jle 0x10f93; // Jump if less or equal (signed)
    goto $1; // Jump to address
    *($1) = $2; // Update game state variable
    $1 = 0; // Bitwise XOR
    *($1) = $2; // Update game state variable
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x71a, 0xc;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa52, 0xe;
    *($1) = $2; // Update game state variable
    *($1) = $2; // Update game state variable
    goto $1; // Jump to address
    or bx, bx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    test byte ptr [0x5cd4], 0xff; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    push($1); // Push value onto stack
    lcall 0x98e, 0x53a;
    test byte ptr [0x5c7a], 0xff; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    ret ; // Return from function
    $1 = 0; // Bitwise XOR
    mov word ptr [0x5c70], 0; // Update game state variable
    mov word ptr [0x5c80], 0xffff; // Update game state variable
    mov word ptr [0x5c74], 0xffff; // Update game state variable
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2; // Update game state variable
    *($1) = $2; // Update game state variable
    mov word ptr [0x5c8a], 0xf;
    mov word ptr [0x5c8c], 0xf;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [0x5ce6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    goto $1; // Jump to address
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    shr ax, 1; // Shift right (unsigned); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2; // Check if values are not equal
    or ax, bx; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr es:[bx], 0xcf; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xf05e;
    mov word ptr [0x5c78], 0; // Update game state variable
    goto $1; // Jump to address
    $1 = $2;
    int 0x33; // Call interrupt
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xf05d;
    mov word ptr [0x5c78], 0; // Update game state variable
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    mov word ptr [0x5c78], 1; // Update game state variable
    mov word ptr [0x5ce6], 1;
    mov word ptr [0x5c76], 0; // Update game state variable
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp word ptr [0x5c78], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    int 0x33; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33; // Call interrupt
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [0x5c78], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf05e; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    mov word ptr [0x5c76], 1; // Update game state variable; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    mov word ptr [0x5c76], 0; // Update game state variable
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [0x5ce6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    int 0x33; // Call interrupt
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    int 0x33; // Call interrupt; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2; // Update game state variable
    or ax, word ptr [0x5cd4]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1(); // Call function; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [0x5c74], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1++; // Increment value
    push($1); // Push value onto stack
    or bx, ax; // Bitwise OR
    xchg word ptr [0x5cd4], ax; // Exchange values
    or bx, ax; // Bitwise OR; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    *($1) = $2; // Update game state variable
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2; // Update game state variable
    *($1) = $2; // Update game state variable
    popf ; // Pop flags from stack
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33; // Call interrupt
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    les di, ptr [bp + 0xe];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    les di, ptr [bp + 0xa];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    les di, ptr [bp + 6];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    $1 = pop(); // Pop value from stack
    mov word ptr [si], 0;
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    les di, ptr [bp + 0xe];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    les di, ptr [bp + 0xa];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    les di, ptr [bp + 6];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    $1 = pop(); // Pop value from stack
    mov word ptr [si], 0;
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [0x5ce6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    int 0x33; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33; // Call interrupt; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [0x5ce6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    int 0x33; // Call interrupt
    goto $1; // Jump to address
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    popf ; // Pop flags from stack
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [0x5ce6], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33; // Call interrupt
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1(); // Call function; Check if values are not equal
    pushf ; // Push flags onto stack; Check if values are not equal
    cli ; // Clear interrupt flag; Check if values are not equal
    cmp word ptr [0x5c74], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x11592; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x11599; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf05c;
    goto $1; // Jump to address; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    $1(); // Call function; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x115ea; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x115f1; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf05c;
    goto $1; // Jump to address
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    cld ; // Clear direction flag
    les di, ptr [bp + 0x12];
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word
    les di, ptr [bp + 0xe]; // Initialize counter for string operation
    movsw word ptr es:[di], word ptr [si]; // Move string byte/word; Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block; Initialize counter for string operation
    les di, ptr [bp + 0xa]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x12; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x11642; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x11649; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf05c;
    goto $1; // Jump to address
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax; // Initialize counter for string operation
    $1 += $2; // Add values; Initialize counter for string operation
    lds si, ptr [bp + 6]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block; Initialize counter for string operation
    lds si, ptr [bp + 0xa]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [0x5c78], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1(); // Call function
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x11727; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0xa], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x11735; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0xc], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1(); // Call function
    test byte ptr [0x5cd2], 0xff; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1(); // Call function
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    $1(); // Call function
    goto $1; // Jump to address
    mov word ptr [0x5cd2], 0;
    $1 = 0; // Bitwise XOR
    $1(); // Call function
    popf ; // Pop flags from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jb 0x1183b; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    $1 += $2; // Add values
    $1++; // Increment value
    jge 0x117eb; // Jump if greater or equal (signed)
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    and ax, 0xfff8; // Bitwise AND
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    $1 += $2; // Add values
    $1++; // Increment value
    jge 0x11808; // Jump if greater or equal (signed)
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x11819; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    and ax, 0xfff8; // Bitwise AND
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jb 0x11838; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2; // Check if values are equal
    ret ; // Return from function; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    ja 0x118a2; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jae 0x11856; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    in al, dx; // Input from port; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1--; // Decrement value
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    *($1) = $2;
    $1 = $2;
    in al, dx; // Input from port; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    in al, dx; // Input from port; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    xor al, 2; // Bitwise XOR; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    *($1) = $2; // Check if values are equal
    ret ; // Return from function; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    ja 0x11990; // Jump if above (unsigned)
    // Compare $1 with $2 // Compare values
    jae 0x11956; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, ax; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, ax; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, al; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    out dx, ax; // Output to port; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    ret ; // Return from function; Check if values are not equal
    $1 = $2; // Check if values are not equal
    int 0x10; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    ret ; // Return from function
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jl 0x11a63; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jl 0x11a63; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x11a63; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0x11a63; // Jump if greater (signed)
    $1++; // Increment value
    and ax, word ptr [0x5cd2]; // Bitwise AND
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    or bx, ax; // Bitwise OR
    $1 = $2;
    *($1) = $2;
    or bx, ax; // Bitwise OR
    or bx, bx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lds si, ptr [bp + 0x10];
    lds si, ptr [si];
    $1 = $2;
    $1++; // Increment value
    $1++; // Increment value
    lodsw ax, word ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    $1++; // Increment value
    $1++; // Increment value
    lodsw ax, word ptr [si]; // Load string byte/word
    // Compare $1 with $2 // Compare values
    jge 0x11abb; // Jump if greater or equal (signed)
    $1 = $2;
    loop 0x11aae; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jle 0x11ac1; // Jump if less or equal (signed)
    $1 = $2;
    loop 0x11aae; // Loop (decrement CX and jump if CX!=0)
    *($1) = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = $2;
    shl bx, 1; // Shift left
    shl bx, 1; // Shift left
    $1 = $2;
    les di, ptr [0x54c1];
    lds si, ptr [bp + 0x10];
    lds si, ptr [si];
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    $1 += $2; // Add values
    $1 -= $2; // Subtract values
    *($1) = $2;
    *($1) = $2;
    sub word ptr [bp - 0x22], bx; // Subtract values
    jae 0x11b00; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    lodsw ax, word ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    lodsw ax, word ptr [si]; // Load string byte/word; Check if values are not equal
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    lcall 0x1214, 0x26c;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jge 0x11b3f; // Jump if greater or equal (signed)
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jle 0x11b47; // Jump if less or equal (signed)
    *($1) = $2;
    xchg bx, ax; // Exchange values
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    loop 0x11b13; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    shl dx, 1; // Shift left
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [0x54c1];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    rep stosw word ptr es:[di], ax; // Fill memory block
    $1 = $2;
    lds si, ptr [bp + 0x10];
    lds si, ptr [si];
    $1 = $2;
    $1 -= $2; // Subtract values
    shl bx, 1; // Shift left
    shl bx, 1; // Shift left
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    shl bx, 1; // Shift left
    shl bx, 1; // Shift left
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x11bd5; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[bx + di + 0xa], 0;
    $1 += $2; // Add values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mov word ptr es:[bx + di + 6], ax;
    mov word ptr es:[bx + di + 8], ax;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    cdq ;
    $1 = $2;
    $1 -= $2; // Subtract values
    idiv cx; // Divide (signed)
    push($1); // Push value onto stack
    $1 = $2;
    imul dx; // Multiply (signed)
    $1 = $2;
    mov word ptr es:[bx + di + 6], ax;
    mov word ptr es:[bx + di + 8], dx;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    imul dx; // Multiply (signed)
    idiv cx; // Divide (signed)
    cdq ;
    add word ptr es:[bx + di + 6], ax; // Add values
    adc word ptr es:[bx + di + 8], dx;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0x11c58; // Jump if less or equal (signed)
    cmp word ptr [bp - 0x16], ax; // Compare values
    jl 0x11c3a; // Jump if less (signed)
    $1--; // Decrement value
    $1 = $2;
    mov word ptr es:[bx + di], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    mov word ptr es:[bx + di + 4], dx;
    mov word ptr es:[bx + di + 2], ax;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp - 0xa], ax; // Compare values
    jl 0x11c61; // Jump if less (signed)
    $1--; // Decrement value
    $1 = $2;
    mov word ptr es:[bx + di], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx; // Multiply (signed)
    mov word ptr es:[bx + di + 4], dx;
    mov word ptr es:[bx + di + 2], ax;
    $1 = $2; // Check if values are not equal
    $1 -= $2; // Subtract values; Check if values are not equal
    shl bx, 1; // Shift left; Check if values are not equal
    cmp word ptr es:[bx + di], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov word ptr es:[bx + di], ax; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr es:[bx + di + 0xa], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1++; // Increment value
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x11cdc; // Jump if greater or equal (signed)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [0x54c1];
    mov word ptr [bp - 6], 0; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [bp - 4], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr es:[bx + di + 0xa], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    ja 0x11d5f; // Jump if above (unsigned)
    jb 0x11d56; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jae 0x11d5f; // Jump if above or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    mov word ptr es:[bx + di + 0xa], ax; // Check if values are not equal
    cmp word ptr [bp - 6], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0x11df9; // Jump if less or equal (signed); Check if values are equal
    xchg word ptr [bp + 6], ax; // Exchange values; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [si + 0x26], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    and bx, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    rol ax, cl; // Rotate left
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    les di, ptr [0x54c1];
    lea ax, [bp + 8]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x14]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x16]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [si + 0x3c], 0;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are equal
    shl bx, 1; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr es:[bx + di + 0xa], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address; Prepare arguments and call function
    mov word ptr es:[bx + di + 0xa], dx; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function; Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    idiv cx; // Divide (signed)
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    idiv cx; // Divide (signed)
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    cmp word ptr [si + 0x22], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = pop(); // Pop value from stack; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[bx + di], ax; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr es:[bx + di + 0xa], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[bx + di], ax; // Compare values
    $1 = pop(); // Pop value from stack
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[bx + di + 0xa], dx;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    add word ptr es:[bx + di + 2], ax; // Add values
    adc word ptr es:[bx + di + 4], dx;
    $1 = $2;
    goto $1; // Jump to address
    $1++; // Increment value
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jg 0x11fed; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0x11fed; // Jump if greater (signed)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 8], 1; // Compare values
    ja 0x12040; // Jump if above (unsigned)
    mov word ptr [bp - 2], 0xf056;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 6], 2; // Compare values
    jae 0x1204b; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    and ax, 1; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [si + 0x10], 0;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1--; // Decrement value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    cmp word ptr [bp + 6], 2; // Compare values
    jl 0x120c1; // Jump if less (signed); Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    mov word ptr [si + 0x10], 1;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [si + 0x3c], 0;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    lcall 0x10b4, 0x84;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x121b8; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0xc], ax; // Exchange values
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x121c6; // Jump if greater or equal (signed)
    xchg word ptr [bp + 0xe], ax; // Exchange values
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    mov word ptr [si + 0x3c], 0; // Check if values are not equal
    cmp word ptr [bp + 6], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jl 0x121fa; // Jump if less (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jge 0x12229; // Jump if greater or equal (signed)
    $1 = $2;
    shr bx, 1; // Shift right (unsigned)
    sub word ptr [bp + 0xe], bx; // Subtract values
    sub word ptr [bp + 0xc], bx; // Subtract values
    add word ptr [bp + 0xa], bx; // Add values
    add word ptr [bp + 8], bx; // Add values
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [si + 0x28], -1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [si + 0x16], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    shr di, 1; // Shift right (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    test word ptr [bp + 6], 2; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    add word ptr [bp + 0xe], di; // Add values
    add word ptr [bp + 0xc], di; // Add values
    sub word ptr [bp + 0xa], di; // Subtract values; Check if values are not equal
    sub word ptr [bp + 8], di; // Subtract values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x22], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [si + 0x16], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xbd7, 8;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Increment counter and check loop condition
    lcall 0xd9f, 0x178; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0x122f5; // Jump if less or equal (signed)
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2; // Check if values are equal
    and bx, 7; // Bitwise AND; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [si + 0x26], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    rol ax, cl; // Rotate left
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xd9f, 0x178;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value; Increment counter and check loop condition
    and bx, 7; // Bitwise AND; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jle 0x12341; // Jump if less or equal (signed)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov word ptr [si + 0x10], 1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xor bx, word ptr [0x6d37]; // Bitwise XOR
    and bx, 0x8000; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test ax, 0x8000; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    mov word ptr cs:[0x37b], bx;
    mov word ptr cs:[0x37d], es;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    mov word ptr [0x6ab4], 0;
    lds si, ptr [bp + 0xa];
    *($1) = $2;
    lds si, ptr [bp + 6];
    *($1) = $2;
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    test word ptr [0x6d37], 0xffff; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf049;
    goto $1; // Jump to address
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or bx, word ptr [bp + 8]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    div cx; // Divide (unsigned)
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 -= $2; // Subtract values
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mov word ptr [0x6aaa], 0x6c06;
    mov word ptr [0x6ab0], 0x19;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    test word ptr [0x6ab2], 0xffff; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xf04c;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ; // Clear direction flag
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x12566; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1--; // Decrement value
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    pushf ; // Push flags onto stack
    cli ; // Clear interrupt flag
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x125a7; // Jump if below (unsigned)
    popf ; // Pop flags from stack
    mov word ptr [bp - 2], 0xf04b;
    $1++; // Increment value
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x125c8; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1++; // Increment value
    popf ; // Pop flags from stack
    push($1); // Push value onto stack
    $1 = $2;
    lds si, ptr [bp + 6];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    cld ; // Clear direction flag
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    test word ptr [0x6ab2], 0xffff; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1); Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x12648; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xf04a;
    goto $1; // Jump to address
    les di, ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x12667; // Jump if below or equal (unsigned)
    $1 = $2;
    loop 0x1265e; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    cld ; // Clear direction flag
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    xchg word ptr [0x6d37], ax; // Exchange values
    $1 = $2;
    mov word ptr [0x6ab2], 0;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2; // Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x126eb; // Jump if below (unsigned)
    $1 = $2;
    mov word ptr es:[0x1a], si;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    mov word ptr [bp - 0xe], 0x8000;
    lcall 0xeec, 0x85f;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Prepare arguments and call function
    $1 -= $2; // Subtract values; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    loop 0x126c5; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ljmp cs:[0x37b];
    iret ;
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x12780; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x1278f; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x127a3; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xfff8;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x11fc, 0;
    jae 0x127e3; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x11fc, 0;
    jae 0x1281a; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[di + 1], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x128b6; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x128b6; // Jump if greater (signed)
    *($1) = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xf05f;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x128e7; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x128ee; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf05f;
    goto $1; // Jump to address
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    les di, ptr [bp + 6];
    $1 = $2;
    cld ; // Clear direction flag
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x12934; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x1293b; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf05f;
    goto $1; // Jump to address
    $1 = $2;
    mul bx; // Multiply (unsigned)
    $1 += $2; // Add values
    lds si, ptr [bp + 6];
    $1 = $2;
    cld ; // Clear direction flag
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    or ax, 1; // Bitwise OR
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ; // Clear direction flag
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di], 0;
    mov word ptr es:[di + 8], 0;
    mov word ptr es:[di + 0xa], 0;
    mov word ptr es:[di + 0xc], 1;
    mov word ptr es:[di + 0xe], 0;
    mov word ptr es:[di + 0x10], 1;
    mov word ptr es:[di + 0x12], 0;
    mov word ptr es:[di + 0x14], 0;
    mov word ptr es:[di + 0x16], 0;
    mov word ptr es:[di + 0x18], 0;
    mov word ptr es:[di + 0x1a], 0;
    mov word ptr es:[di + 0x1c], 0;
    mov word ptr es:[di + 0x1e], 0x3ff;
    mov word ptr es:[di + 0x20], 0x3ff;
    mov word ptr es:[di + 0x22], 0;
    mov word ptr es:[di + 0x24], 0;
    mov word ptr es:[di + 0x26], 1;
    mov word ptr es:[di + 0x28], 0xffff;
    mov word ptr es:[di + 0x2a], 1;
    mov word ptr es:[di + 0x2c], 0;
    mov word ptr es:[di + 0x2e], 0;
    mov word ptr es:[di + 0x30], 0;
    mov word ptr es:[di + 0x32], 0;
    mov word ptr es:[di + 0x34], 0;
    mov word ptr es:[di + 0x36], 0;
    mov word ptr es:[di + 0x38], 0x3ff;
    mov word ptr es:[di + 0x3a], 0x3ff;
    mov word ptr es:[di + 0x3c], 0;
    mov word ptr es:[di + 0x4e], 1;
    mov word ptr es:[di + 0x50], 3;
    mov word ptr es:[di + 0x52], 1;
    mov word ptr es:[di + 0x54], 1;
    mov word ptr es:[di + 0x56], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test word ptr [si + 0x3c], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1214, 0x346;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1214, 0x307;
    $1 = pop(); // Pop value from stack
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    mov word ptr es:[di], bx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x12c62; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr [si + 0x17]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    shl ax, cl; // Shift left
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x12ca1; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x12cd6; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x3c], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or bx, word ptr [si + 0x32]; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    add word ptr [bp + 0xa], ax; // Add values
    add word ptr [bp + 8], bx; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x18], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0xc6c, 0xe5; // Check if values are not equal
    jb 0x12d74; // Jump if below (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x12d63; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    shl dx, 1; // Shift left
    shl dx, 1; // Shift left
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    and al, 3; // Bitwise AND
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    or al, ah; // Bitwise OR
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    or byte ptr es:[bx], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    and al, 1; // Bitwise AND
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    or byte ptr es:[bx], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 = $2;
    and al, 1; // Bitwise AND
    shl ax, cl; // Shift left
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    or byte ptr es:[bx], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x6a;
    shl ah, cl; // Shift left
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    shl ah, cl; // Shift left
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x8b;
    shl ah, cl; // Shift left
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    shl ah, cl; // Shift left
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], ah;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x8b;
    $1 = $2;
    and al, 1; // Bitwise AND
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[bx], ah; // Bitwise AND
    or byte ptr es:[bx], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xba;
    shl ah, cl; // Shift left
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl ah, cl; // Shift left
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    lcall 0x885, 0xd9; // Check if values are not equal
    cmp word ptr [0x43b9], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shl ah, 1; // Shift left
    shl ah, 1; // Shift left
    shl ah, 1; // Shift left
    or al, ah; // Bitwise OR
    or al, 0x40; // Bitwise OR
    $1 = $2;
    out dx, al; // Output to port
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    and ah, 0xf; // Bitwise AND
    $1 = $2;
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    or al, ah; // Bitwise OR
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    lcall 0x885, 0xf3; // Check if values are not equal
    cmp word ptr [0x43b9], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shl ah, 1; // Shift left
    shl ah, 1; // Shift left
    shl ah, 1; // Shift left
    or al, ah; // Bitwise OR
    or al, 0x40; // Bitwise OR
    $1 = $2;
    out dx, al; // Output to port
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    and ah, 0xf; // Bitwise AND
    $1 = $2;
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    or al, ah; // Bitwise OR
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    and bl, 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    and bl, 2; // Bitwise AND
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    $1 = $2;
    in al, dx; // Input from port
    and al, 0xdf; // Bitwise AND
    or bl, al; // Bitwise OR
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    and bh, 0xc; // Bitwise AND
    $1 = $2;
    shr bl, 1; // Shift right (unsigned)
    shr bl, 1; // Shift right (unsigned)
    or al, bh; // Bitwise OR
    or al, bl; // Bitwise OR
    out dx, al; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    and bl, 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    and bl, 2; // Bitwise AND
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    $1 = $2;
    in al, dx; // Input from port
    and al, 0xdf; // Bitwise AND
    or bl, al; // Bitwise OR
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    and bh, 0xc; // Bitwise AND
    $1 = $2;
    shr bl, 1; // Shift right (unsigned)
    shr bl, 1; // Shift right (unsigned)
    or al, bh; // Bitwise OR
    or al, bl; // Bitwise OR
    out dx, al; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1); // Push value onto stack
    $1 = $2;
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    and ah, 0xe1; // Bitwise AND
    shl ch, 1; // Shift left
    or ah, ch; // Bitwise OR
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    sti ; // Set interrupt flag
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1); // Push value onto stack
    $1 = $2;
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    and ah, 0xe1; // Bitwise AND
    shl ch, 1; // Shift left
    or ah, ch; // Bitwise OR
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    sti ; // Set interrupt flag
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    and ah, 0xf; // Bitwise AND
    $1 = $2;
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    or al, ah; // Bitwise OR
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    and bl, 1; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    and bl, 2; // Bitwise AND
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    shl bl, 1; // Shift left
    $1 = $2;
    in al, dx; // Input from port
    and al, 0xdf; // Bitwise AND
    or bl, al; // Bitwise OR
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    and bh, 0xc; // Bitwise AND
    $1 = $2;
    shr bl, 1; // Shift right (unsigned)
    shr bl, 1; // Shift right (unsigned)
    or al, bh; // Bitwise OR
    or al, bl; // Bitwise OR
    out dx, al; // Output to port
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1); // Push value onto stack
    $1 = $2;
    cli ; // Clear interrupt flag
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    $1 = $2;
    and ah, 0xe1; // Bitwise AND
    shl ch, 1; // Shift left
    or ah, ch; // Bitwise OR
    $1--; // Decrement value
    $1 = $2;
    out dx, ax; // Output to port
    sti ; // Set interrupt flag
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    $1 = $2;
    and al, 0xf; // Bitwise AND
    xor al, 2; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    or al, ah; // Bitwise OR
    out dx, al; // Output to port
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    $1 = $2;
    and al, 0xf; // Bitwise AND
    xor al, 2; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    or al, ah; // Bitwise OR
    out dx, al; // Output to port
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    $1 = $2;
    and al, 0xf; // Bitwise AND
    xor al, 2; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al; // Output to port
    $1++; // Increment value
    in al, dx; // Input from port
    and al, 0xf0; // Bitwise AND
    or al, ah; // Bitwise OR
    out dx, al; // Output to port
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[bx], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[bx], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[bx], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND; Check if values are equal
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, ah; // Bitwise AND
    xor cl, ah; // Bitwise XOR
    shl cl, 1; // Shift left
    $1 = $2;
    and al, ah; // Bitwise AND; Check if values are equal
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    or al, ah; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    lds si, ptr [si + 4];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND
    shl ax, cl; // Shift left
    or dl, dl; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    $1 = $2;
    $1 = $2;
    and dh, ah; // Bitwise AND
    or dh, al; // Bitwise OR
    mov byte ptr es:[di], dh;
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    or bl, bl; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr es:[di], al; // Bitwise XOR
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shl al, cl; // Shift left
    not al; // Bitwise NOT
    and byte ptr es:[di], al; // Bitwise AND
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    $1 += $2; // Add values
    goto $1; // Jump to address
    test bl, bl; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    or byte ptr es:[di], al; // Bitwise OR
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left
    $1 += $2; // Add values
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x13bdc; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x13be4; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa;
    stc ; // Set carry flag; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ; // Clear carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 6]; // Check if values are equal
    cmp word ptr [si], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    // Compare $1 with $2 // Compare values; Check if values are equal
    jbe 0x13cb7; // Jump if below or equal (unsigned); Check if values are equal
    shr ax, 1; // Shift right (unsigned); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1--; // Decrement value
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    mov word ptr es:[di + 4], si;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [si], 0; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    les di, ptr [si + 4]; // Check if values are equal
    cmp word ptr es:[di], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4;
    goto $1; // Jump to address
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    lcall 0xbd7, 8;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0x13ee7; // Jump if less or equal (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jg 0x13eee; // Jump if greater (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    imul bx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    lcall 0x7ff, 0x32;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    imul bx; // Multiply (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    lcall 0x7ff, 0x32;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jbe 0x13f87; // Jump if below or equal (unsigned)
    xchg cx, bx; // Exchange values
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    or si, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    neg ax; // Negate value
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jbe 0x13fd7; // Jump if below or equal (unsigned)
    xchg cx, bx; // Exchange values
    $1--; // Decrement value
    $1 -= $2; // Subtract values
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    or di, di; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    neg ax; // Negate value; Check if values are equal
    cmp byte ptr [si + 0x4e], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cdq ;
    $1 = $2;
    lcall 0x7ff, 0x1a;
    $1 = $2;
    $1 = $2;
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [si + 0x4e], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 += $2; // Add values
    cdq ;
    $1 = $2;
    lcall 0x7ff, 0x1a;
    $1 = $2;
    $1 = $2;
    lcall 0x7ff, 0x50;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], ax;
    $1 = $2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [0x6f01], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xe];
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value; Check if values are equal
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x141ed; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x141fc; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfc7c;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x1420b; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 4], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr es:[di], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff9;
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x1423d; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0xa6;
    or ax, ax; // Bitwise OR
    jge 0x14266; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    shl bx, 1; // Shift left
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    mov word ptr [bx], 0x166;
    $1 += $2; // Add values
    mov word ptr [bx], 0x166;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x402;
    $1 += $2; // Add values
    mov word ptr [bx], 0x4b1;
    $1 += $2; // Add values
    mov word ptr [bx], 0x5c6;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x5c6;
    $1 += $2; // Add values
    mov word ptr [bx], 0x5c6;
    $1 += $2; // Add values
    mov word ptr [bx], 0x27b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x5c6;
    $1 += $2; // Add values
    mov word ptr [bx], 0x5c6;
    $1 += $2; // Add values
    mov byte ptr [0x6f01], 1;
    retf ; // Return from function
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x1431f; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bl; // Divide (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1--; // Decrement value
    mov word ptr [bp - 0xe], 0;
    or cl, cl; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1--; // Decrement value
    sar al, cl; // Shift right (signed)
    *($1) = $2;
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x14367; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    and dx, 1; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 += $2; // Add values
    cld ; // Clear direction flag
    $1 = 0; // Bitwise XOR
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ah, 0xc0; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr [si]; // Load string byte/word
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jb 0x143ca; // Jump if below (unsigned); Check if values are not equal
    ja 0x143cd; // Jump if above (unsigned); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    or ah, byte ptr [bp - 0xc]; // Bitwise OR
    $1 -= $2; // Subtract values
    and al, byte ptr [bp - 0xc]; // Bitwise AND
    or al, ah; // Bitwise OR
    mov byte ptr es:[di], al;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    mov byte ptr es:[di], al; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    xor dx, 1; // Bitwise XOR; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    loop 0x143a8; // Loop (decrement CX and jump if CX!=0)
    // Compare $1 with $2 // Compare values
    jbe 0x14407; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14407; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    *($1) = $2;
    mov word ptr [bp - 0xe], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jb 0x1444c; // Jump if below (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    test al, 7; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    and al, 0xf8; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bl; // Divide (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1--; // Decrement value
    or cl, cl; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1--; // Decrement value
    sar al, cl; // Shift right (signed)
    *($1) = $2;
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x1448f; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov byte ptr [bp - 0x18], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port; Check if values are not equal
    mov word ptr [bp - 0x1c], 1; // Check if values are not equal
    mov word ptr [bp - 0x1a], 8; // Check if values are not equal
    cmp byte ptr [si + 0x41], 3; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x1a], 4; // Check if values are not equal
    cmp byte ptr [si + 0x41], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x1c], 0xf;
    mov word ptr [bp - 0x1a], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    cld ; // Clear direction flag
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ah, 0xc0; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr [si]; // Load string byte/word
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jb 0x1453e; // Jump if below (unsigned); Check if values are not equal
    ja 0x14541; // Jump if above (unsigned); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = pop(); // Pop value from stack
    mov byte ptr es:[bx + di], al;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address; Check if values are not equal
    mov byte ptr es:[bx + di], al; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shl byte ptr [bp - 0x18], 1; // Shift left
    cmp byte ptr [bp - 0x18], dl; // Compare values
    jbe 0x14562; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = pop(); // Pop value from stack
    loop 0x14514; // Loop (decrement CX and jump if CX!=0)
    // Compare $1 with $2 // Compare values
    jbe 0x14585; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14585; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x145c2; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x145df; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    cld ; // Clear direction flag
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ah, 0xc0; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr [si]; // Load string byte/word
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    ja 0x14615; // Jump if above (unsigned); Check if values are not equal
    mov byte ptr es:[bx + di], al; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    loop 0x1460d; // Loop (decrement CX and jump if CX!=0)
    // Compare $1 with $2 // Compare values
    jbe 0x1463d; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x1463d; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x1466a; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    div bl; // Divide (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1--; // Decrement value
    mov word ptr [bp - 0xe], 0;
    or cl, cl; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1--; // Decrement value
    sar al, cl; // Shift right (signed)
    *($1) = $2;
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x146b1; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    and al, 3; // Bitwise AND
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 += $2; // Add values
    cld ; // Clear direction flag
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ah, 0xc0; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr [si]; // Load string byte/word
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jb 0x14718; // Jump if below (unsigned); Check if values are not equal
    ja 0x1471b; // Jump if above (unsigned); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    or ah, byte ptr [bp - 0xc]; // Bitwise OR
    $1 -= $2; // Subtract values
    and al, byte ptr [bp - 0xc]; // Bitwise AND
    or al, ah; // Bitwise OR
    mov byte ptr es:[bx + di], al;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address; Check if values are not equal
    mov byte ptr es:[bx + di], al; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1--; // Decrement value; Increment counter and check loop condition
    if (ZF) goto $1; // Jump if equal (ZF=1); Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x14736; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1 += $2; // Add values
    loop 0x146f6; // Loop (decrement CX and jump if CX!=0)
    // Compare $1 with $2 // Compare values
    jbe 0x14752; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14752; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x14786; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jbe 0x147a6; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    sub word ptr [bp - 0x16], ax; // Subtract values
    $1 += $2; // Add values
    cld ; // Clear direction flag
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ah, 0xc0; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr [si]; // Load string byte/word
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    ja 0x14803; // Jump if above (unsigned)
    mov byte ptr es:[di], al;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    jae 0x14820; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    loop 0x147e8; // Loop (decrement CX and jump if CX!=0)
    // Compare $1 with $2 // Compare values
    jbe 0x1483d; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x1483d; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 6]; // Check if values are equal
    cmp byte ptr [si], 0xa; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address; Initialize counter for string operation
    lds si, ptr [bp + 0xa]; // Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address; Initialize counter for string operation
    lds si, ptr [bp + 6]; // Initialize counter for string operation
    les di, ptr [bp + 0xa]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    les di, ptr [bp + 6]; // Check if values are equal
    cmp byte ptr es:[di], 0xa; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1++; // Increment value; Check if values are equal
    $1++; // Increment value; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    $1++; // Increment value; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10]; // Check if values are equal
    les di, ptr [bp + 0xa]; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x14b10; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffa; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jbe 0x14b86; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 = 0; // Bitwise XOR
    mul bx; // Multiply (unsigned)
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    xor cl, 7; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = $2;
    not ch; // Bitwise NOT
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jbe 0x14bca; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 += $2; // Add values
    les di, ptr [bp - 0x20];
    cld ; // Clear direction flag
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ah, 0xc0; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    lodsb al, byte ptr [si]; // Load string byte/word
    or cx, cx; // Bitwise OR; Increment counter and check loop condition
    if (ZF) goto $1; // Jump if equal (ZF=1); Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x14c14; // Jump if below (unsigned)
    ja 0x14c37; // Jump if above (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    and byte ptr es:[di], ch; // Bitwise AND
    and cl, al; // Bitwise AND
    or byte ptr es:[di], cl; // Bitwise OR
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    stosb byte ptr es:[di], al; // Store string byte/word
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    jae 0x14c37; // Jump if above or equal (unsigned); Check if values are equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jge 0x14c3f; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    jae 0x14c64; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    jae 0x14c64; // Jump if above or equal (unsigned); Check if values are equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1--; // Decrement value
    or dx, dx; // Bitwise OR; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stosb byte ptr es:[di], al; // Store string byte/word
    goto $1; // Jump to address
    and byte ptr es:[di], ah; // Bitwise AND
    $1++; // Increment value
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    jae 0x14cad; // Jump if above or equal (unsigned); Check if values are equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    loop 0x14c80; // Loop (decrement CX and jump if CX!=0)
    $1 += $2; // Add values
    jae 0x14cd2; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    jae 0x14cd2; // Jump if above or equal (unsigned); Check if values are equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    // Compare $1 with $2 // Compare values
    jb 0x14cf9; // Jump if below (unsigned)
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14cf9; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x14d30; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    lds si, ptr [bp + 0xa]; // Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shr al, cl; // Shift right (unsigned)
    mov byte ptr es:[di], al;
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    shr al, cl; // Shift right (unsigned)
    mov byte ptr es:[di], al; // Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shr al, cl; // Shift right (unsigned)
    mov byte ptr es:[di], al; // Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 5], 0x20;
    mov byte ptr [bp - 4], 4;
    mov byte ptr [bp - 3], 0x24;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    and bl, 0xc0; // Bitwise AND
    shr bl, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    or al, bl; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    and bl, 0xc0; // Bitwise AND
    shr bl, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    shr bl, 1; // Shift right (unsigned)
    or al, bl; // Bitwise OR
    $1++; // Increment value
    $1 = $2;
    and bl, 0xc0; // Bitwise AND
    shr bl, cl; // Shift right (unsigned)
    $1 = $2;
    $1 = $2;
    shr bl, 1; // Shift right (unsigned)
    shr bl, 1; // Shift right (unsigned)
    or al, bl; // Bitwise OR
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    stosb byte ptr es:[di], al; // Store string byte/word
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 0; // Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    shr al, 1; // Shift right (unsigned)
    mov byte ptr es:[di], al;
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 2], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x14e41; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    les di, ptr [bp + 0xa]; // Check if values are equal
    lds si, ptr [bp + 6]; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    shl al, cl; // Shift left
    mov byte ptr es:[di], al;
    mov byte ptr es:[di + 1], 0;
    mov byte ptr es:[di + 2], 0;
    $1 = $2;
    $1 = $2;
    shl al, cl; // Shift left
    mov byte ptr es:[di + 3], al;
    mov byte ptr es:[di + 4], 0;
    mov byte ptr es:[di + 5], 0;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    shl al, cl; // Shift left
    mov byte ptr es:[di], al;
    mov byte ptr es:[di + 1], 0;
    mov byte ptr es:[di + 2], 0;
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    shl ah, 1; // Shift left; Check if values are not equal
    $1 = $2; // Check if values are not equal
    and al, 0x48; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov byte ptr es:[di], 0; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov byte ptr es:[di], 0x55; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr es:[di], 0xaa;
    goto $1; // Jump to address
    mov byte ptr es:[di], 0xff;
    $1++; // Increment value
    loop 0x14ed5; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    loop 0x14ecf; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    shl al, 1; // Shift left
    shl al, 1; // Shift left
    mov byte ptr es:[di], al;
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x14f56; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 0xc]; // Check if values are equal
    les di, ptr [bp + 6]; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [si + 1], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff6;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7; // Initialize counter for string operation
    goto $1; // Jump to address; Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x14fe0; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    les di, ptr [bp + 0xc]; // Check if values are equal
    cmp byte ptr es:[di + 1], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff6;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    $1 -= $2; // Subtract values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    mov byte ptr es:[bx + di - 1], 0xc;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x1507b; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 0xe]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x10]; // Load effective address; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    lcall 0x96b, 0x66; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0xe];
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    jae 0x150bd; // Jump if above or equal (unsigned); Check if values are equal
    mov word ptr [bp - 2], 0xfffd; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [si + 1], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff6;
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x150de; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    lds si, ptr [bp - 0xe]; // Check if values are equal
    les di, ptr [bp + 6]; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, 0;
    $1 -= $2; // Subtract values
    sbb dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt; Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jbe 0x15214; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack; Open file (DOS)
    $1 = $2; // Open file (DOS)
    or al, ah; // Bitwise OR; Open file (DOS)
    $1 = $2; // Open file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jae 0x15231; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xffff;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x15246; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    mov word ptr [bp - 6], 0x30;
    goto $1; // Jump to address
    mov word ptr [bp - 6], 0x300;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    cmp byte ptr es:[di + 1], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di + 1], 5;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    mov byte ptr es:[di], 0xc;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff7;
    goto $1; // Jump to address
    mov byte ptr es:[di], 0xc;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    $1 = $2; // Write to file (DOS)
    int 0x21; // Call interrupt; Close file (DOS)
    $1 = pop(); // Pop value from stack; Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x153ec; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    lcall 0x96b, 0x166; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x125a, 0;
    *($1) = $2;
    lcall 0x96b, 0x1c0;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x15486; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf448;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2; // Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x12c5, 0xc0;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x15598; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    lcall 0x96b, 0x166; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x12ed, 0xc;
    *($1) = $2;
    lcall 0x96b, 0x1c0;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 5;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x66;
    les di, ptr [bp - 6];
    lds si, ptr [bp + 0xc];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mul bx; // Multiply (unsigned)
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jle 0x15680; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x9e7, 0xa;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x9e7, 0xb0;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    les di, ptr [bp + 0x10]; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    mul word ptr [bp + 0xa]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    shl ax, cl; // Shift left
    $1--; // Decrement value
    and word ptr [bp + 8], ax; // Bitwise AND
    and word ptr [bp + 6], ax; // Bitwise AND
    $1 = $2;
    div byte ptr [bp + 0xa]; // Divide (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    shl ax, cl; // Shift left
    $1--; // Decrement value
    $1 = $2;
    not ah; // Bitwise NOT
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [bp + 0xc], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    shl ax, cl; // Shift left; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    or al, ah; // Bitwise OR
    loop 0x15728; // Loop (decrement CX and jump if CX!=0)
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = pop(); // Pop value from stack
    loop 0x1571f; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    rol byte ptr es:[di], 1; // Rotate left
    rcl al, 1;
    shl al, cl; // Shift left
    or ah, al; // Bitwise OR; Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x15749; // Jump if below (unsigned); Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, cl; // Shift right (unsigned)
    and al, dl; // Bitwise AND
    and byte ptr es:[di], dh; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR; Increment counter and check loop condition
    $1 += $2; // Add values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jb 0x15768; // Jump if below (unsigned)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    loop 0x15743; // Loop (decrement CX and jump if CX!=0)
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    loop 0x1573f; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    lds si, ptr [bp + 0xa]; // Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are equal
    cmp word ptr [si], 0xca00; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr es:[di], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf82d;
    goto $1; // Jump to address
    les di, ptr [bp + 0xe];
    mov word ptr es:[di], 0xca20;
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    mov word ptr es:[di + 4], si;
    lcall 0x1535, 0x2d;
    mov word ptr es:[di + 2], ax;
    mov word ptr es:[di + 0x8c], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr es:[di + 0x8c], 1;
    lds si, ptr [bp + 6];
    $1 += $2; // Add values
    $1 = $2;
    cld ; // Clear direction flag
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0;
    lds si, ptr [bp + 8]; // Check if values are equal
    les di, ptr [bp + 0xc]; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr [si], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [si + 0x12], 4; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr [si + 0x13], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    les di, ptr [bp + 8];
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 0x1b0;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 1;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x13d3, 2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 4], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 0x2fa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    les di, ptr [bp + 6]; // Check if values are equal
    cmp word ptr es:[di], 0xca20; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    mov word ptr [bp - 2], 0xffe4; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr es:[di + 0x8c], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lcall 0x5e5, 0x2fa;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    rep stosb byte ptr es:[di], al; // Fill memory block
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    lds si, ptr [bp + 0xa]; // Check if values are not equal
    les di, ptr [bp + 6]; // Check if values are equal
    cmp word ptr [si], 0xca00; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr es:[di], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf82d;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x66;
    shr word ptr [bp - 8], 1; // Shift right (unsigned)
    $1 = $2;
    mul word ptr [bp - 0xc]; // Multiply (unsigned)
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jbe 0x159c4; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfffe; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    lcall 0x1535, 0x2d;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp - 0xc]; // Multiply (unsigned)
    $1 = $2;
    $1 = $2;
    shl ax, cl; // Shift left
    $1--; // Decrement value
    and bx, ax; // Bitwise AND
    *($1) = $2;
    lds si, ptr [bp - 6];
    les di, ptr [bp - 6];
    $1 += $2; // Add values
    mov word ptr [bp - 0x14], 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x9e7, 0xa;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x9e7, 0xb0; // Check if values are equal
    or ax, ax; // Bitwise OR; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [bp - 0x10], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x13a3, 0x96;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x9e7, 0xb0;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 6];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x12];
    les di, ptr [bp + 0xe];
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cld ; // Clear direction flag; Check if values are equal
    cmp word ptr [bp + 0xa], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 0xa], 4; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 8], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 8], 8; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    ror dl, 1; // Rotate right
    not dl; // Bitwise NOT
    cwde ;
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    lodsw ax, word ptr [si]; // Load string byte/word
    xor ax, dx; // Bitwise XOR
    stosw word ptr es:[di], ax; // Store string byte/word
    loop 0x15aff; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = 0; // Bitwise XOR
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    xor ah, dl; // Bitwise XOR
    $1 = $2;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    or al, ah; // Bitwise OR
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x15b09; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = 0; // Bitwise XOR; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not al; // Bitwise NOT
    stosb byte ptr es:[di], al; // Store string byte/word; Check if values are equal
    loop 0x15b25; // Loop (decrement CX and jump if CX!=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 8], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    not dh; // Bitwise NOT
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    ror al, 1; // Rotate right
    cwde ;
    xor ah, byte ptr [si]; // Bitwise XOR
    and dl, ah; // Bitwise AND
    $1 += $2; // Add values
    loop 0x15b4c; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    mov byte ptr es:[di], dl;
    $1++; // Increment value
    $1++; // Increment value
    loop 0x15b43; // Loop (decrement CX and jump if CX!=0)
    lds si, ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    mov word ptr [bp - 0x36], 0; // Check if values are equal
    mov word ptr [bp - 0x38], 0; // Check if values are equal
    cmp byte ptr [0x6f51], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack; Check if values are equal
    $1(); // Call function; Check if values are equal
    lds si, ptr [bp + 0xe]; // Check if values are equal
    cmp word ptr [si], 0xca20; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xf82c;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    *($1) = $2;
    lds si, ptr [si + 4];
    les di, ptr [bp + 0xa];
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    mov word ptr [bp - 0x3a], 0;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x15c18; // Jump if greater or equal (signed)
    neg ax; // Negate value
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x15c26; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp - 0x3a], ax; // Compare values
    jbe 0x15c36; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0x15c48; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    *($1) = $2;
    mul word ptr [bp - 0xc]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x3c], 0;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x15c80; // Jump if greater or equal (signed)
    neg ax; // Negate value
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x15c8e; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp - 0x3c], ax; // Compare values
    jbe 0x15c9e; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2; // Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    // Compare $1 with $2 // Compare values
    jbe 0x15cb0; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    *($1) = $2;
    mul word ptr [bp - 0x24]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jae 0x15cd0; // Jump if above or equal (unsigned)
    goto $1; // Jump to address; Check if values are not equal
    lds si, ptr [bp - 0xa]; // Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    *($1) = $2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2; // Check if values are not equal
    mov word ptr [bp - 0x2a], 0xff; // Check if values are not equal
    mov word ptr [bp - 0x2c], 0; // Check if values are not equal
    cmp byte ptr [bp - 0xc], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 0x48]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x4a]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x66;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x15d32; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    $1 = $2;
    mul word ptr [bp - 0xc]; // Multiply (unsigned)
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    shr dl, cl; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    shr dh, cl; // Shift right (unsigned)
    not dh; // Bitwise NOT
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0x15d73; // Jump if less (signed)
    $1 = $2;
    *($1) = $2;
    or dh, dh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and byte ptr [bp - 0x2a], dh; // Bitwise AND
    mov byte ptr [bp - 0x29], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    mul word ptr [bp - 0xc]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    *($1) = $2;
    mov word ptr [bp - 0x30], 1;
    $1 = $2;
    mul word ptr [bp - 0xc]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0xc]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    // Compare $1 with $2 // Compare values
    jle 0x15da2; // Jump if less or equal (signed)
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 0x29], 0;
    mov word ptr [bp - 0x34], 0;
    // Compare $1 with $2 // Compare values
    jbe 0x15dc7; // Jump if below or equal (unsigned)
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [bp - 0x29], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    $1 = $2;
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    $1 = $2;
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    cld ; // Clear direction flag
    $1 = $2;
    shl bx, 1; // Shift left
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    mov word ptr [bx], 0x34c;
    $1 += $2; // Add values
    mov word ptr [bx], 0x34c;
    $1 += $2; // Add values
    mov word ptr [bx], 0x38b;
    $1 += $2; // Add values
    mov word ptr [bx], 0x55b;
    $1 += $2; // Add values
    mov byte ptr [0x6f51], 1;
    retf ; // Return from function
    lds si, ptr [bp + 0xe];
    lds si, ptr [si + 4];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb44, 0xc;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    mov byte ptr [bp - 0x22], 0; // Check if values are not equal
    cmp byte ptr [bp - 0x22], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    les di, ptr [bp - 0x48];
    lds si, ptr [bp - 0x44];
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x15f5f; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    xchg bx, cx; // Exchange values
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x15f5f; // Jump if above or equal (unsigned)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    goto $1; // Jump to address
    shr cx, 1; // Shift right (unsigned)
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Check if values are equal
    lds si, ptr [bp - 0x48]; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    and al, bl; // Bitwise AND
    not bl; // Bitwise NOT
    or al, bl; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1 = $2; // Check if values are not equal
    or bx, bx; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x15fb2; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    or bh, bh; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x15fe0; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    $1 = $2;
    not dx; // Bitwise NOT
    and al, bh; // Bitwise AND
    or al, dh; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x16018; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x16028; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x1603b; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x1603b; // Jump if above or equal (unsigned)
    *($1) = $2; // Increment counter and check loop condition
    goto $1; // Jump to address; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    cmp byte ptr [bp - 0x22], 3; // Compare values
    jbe 0x1608e; // Jump if below or equal (unsigned); Check if values are not equal
    mov byte ptr [bp - 0x22], 0; // Check if values are not equal
    lds si, ptr [bp - 0x44]; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16063; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x16073; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x36], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x16086; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16086; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    nop ; // No operation
    nop ; // No operation
    goto $1; // Jump to address
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack; Check if values are not equal
    jae 0x16101; // Jump if above or equal (unsigned); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jae 0x1611c; // Jump if above or equal (unsigned); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], al;
    $1++; // Increment value
    loop 0x160e6; // Loop (decrement CX and jump if CX!=0); Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x16142; // Jump if above or equal (unsigned); Check if values are not equal
    *($1) = $2; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x1615a; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x1616a; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x36], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x1617d; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x1617d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x1618d; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x38], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x161a0; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    jae 0x161a0; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0x52], 0;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr [0x6f50], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    lcall 0x98e, 0x35e;
    or ax, ax; // Bitwise OR
    jge 0x16218; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x1622b; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [0x54d4], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp byte ptr es:[di], 9; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    lcall 0x98e, 0x18a; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfff9; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    lds si, ptr [bp + 0xc]; // Check if values are equal
    cmp word ptr [si], 0xca20; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4;
    goto $1; // Jump to address
    lds si, ptr [si + 4];
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    *($1) = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    mov word ptr [bp - 4], 0;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x16295; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp - 4], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jb 0x162a3; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp - 4], ax; // Compare values
    jbe 0x162b3; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jbe 0x162c4; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    mul word ptr [bp - 0x10]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    or ax, ax; // Bitwise OR
    jge 0x162f3; // Jump if greater or equal (signed)
    neg ax; // Negate value
    add word ptr [bp - 6], ax; // Add values
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jb 0x16301; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp - 6], ax; // Compare values
    jbe 0x16311; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jbe 0x16322; // Jump if below or equal (unsigned)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    mul bx; // Multiply (unsigned)
    *($1) = $2;
    les di, ptr [bp + 0xc];
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe5; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address; Check if values are not equal
    mov word ptr [bp - 0x2a], 0xffff; // Check if values are not equal
    mov word ptr [bp - 0x2c], 0; // Check if values are not equal
    cmp byte ptr [bp - 0x10], 8; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2;
    $1 = $2;
    mul word ptr [bp - 0x10]; // Multiply (unsigned)
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    shr dl, cl; // Shift right (unsigned)
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    and cx, 7; // Bitwise AND
    $1 = $2;
    shr dh, cl; // Shift right (unsigned)
    not dh; // Bitwise NOT
    *($1) = $2;
    // Compare $1 with $2 // Compare values
    jl 0x163df; // Jump if less (signed)
    $1 = $2;
    *($1) = $2;
    or dh, dh; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and byte ptr [bp - 0x2a], dh; // Bitwise AND
    mov byte ptr [bp - 0x29], 0;
    $1 = $2;
    $1 -= $2; // Subtract values
    mul word ptr [bp - 0x10]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    *($1) = $2;
    mov word ptr [bp - 0x30], 1;
    $1 = $2;
    mul word ptr [bp - 0x10]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0x10]; // Multiply (unsigned)
    and ax, 7; // Bitwise AND
    // Compare $1 with $2 // Compare values
    jle 0x1640e; // Jump if less or equal (signed)
    $1++; // Increment value
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    $1 = 0; // Bitwise XOR
    div bx; // Divide (unsigned)
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 0x29], 0;
    mov word ptr [bp - 0x34], 0;
    // Compare $1 with $2 // Compare values
    jbe 0x16433; // Jump if below or equal (unsigned)
    $1++; // Increment value
    $1 = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp byte ptr [bp - 0x29], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    *($1) = $2;
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    *($1) = $2;
    *($1) = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 0x38];
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    mov byte ptr [bp - 0xa], 0;
    push($1); // Push value onto stack
    lcall 0x98e, 0xa6;
    or ax, ax; // Bitwise OR
    jge 0x164cd; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    cld ; // Clear direction flag
    $1 = $2;
    shl bx, 1; // Shift left
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    $1 = $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2; // Add values
    mov word ptr [bx], 0x3b4;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x78d;
    $1 += $2; // Add values
    mov word ptr [bx], 0x83b;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa10;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa10;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa10;
    $1 += $2; // Add values
    mov word ptr [bx], 0x57d;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa10;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa10;
    $1 += $2; // Add values
    mov byte ptr [0x6f50], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are equal
    shl word ptr [bp - 0x1a], 1; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x5c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr [bp - 0xa], 1; // Bitwise XOR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x4c];
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16636; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror al, cl; // Rotate right
    $1 = $2;
    goto $1; // Jump to address
    not bl; // Bitwise NOT
    or al, bl; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    and al, bl; // Bitwise AND
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value
    $1 = $2; // Check if values are not equal
    or bx, bx; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16672; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are equal
    or bh, bh; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x166ad; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    goto $1; // Jump to address
    not bh; // Bitwise NOT
    or al, bh; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    and al, bh; // Bitwise AND
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value; Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x166e1; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x166f1; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x52], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x16704; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16704; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0xa], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr [bp - 9], 1; // Bitwise XOR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    mov word ptr [bp - 0x26], 0x10f; // Check if values are equal
    cmp byte ptr [bp - 0x12], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x26], 0x801;
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    add word ptr [bp - 0x1a], ax; // Add values; Check if values are equal
    mov byte ptr [bp - 0xa], 1; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x5c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port; Check if values are equal
    test al, 8; // Test bits (AND without storing); Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [bp - 0xa], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test byte ptr [bp - 0x26], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Decrement counter and check loop condition
    shl al, 1; // Shift left; Decrement counter and check loop condition
    $1--; // Decrement value; Decrement counter and check loop condition
    // Compare $1 with $2 // Compare values
    jae 0x167f6; // Jump if above or equal (unsigned)
    $1 = $2;
    $1++; // Increment value
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x4c];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16854; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1 = $2;
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    out dx, ax; // Output to port; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16887; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    or ah, ah; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x168c0; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    and byte ptr es:[di], al; // Bitwise AND
    $1++; // Increment value; Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x168e6; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x168f6; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x52], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x16909; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16909; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26]; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x5c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jae 0x1699b; // Jump if above or equal (unsigned); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], al;
    $1++; // Increment value
    loop 0x16982; // Loop (decrement CX and jump if CX!=0)
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x169c0; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x169d8; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x169d8; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    $1 = $2;
    $1 = $2;
    mul dx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    and al, 3; // Bitwise AND
    *($1) = $2; // Check if values are equal
    shl word ptr [bp - 0x1a], 1; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x5c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr [bp - 0xa], 1; // Bitwise XOR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x4c];
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp byte ptr [bp - 0x30], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16ac1; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror al, cl; // Rotate right
    $1 = $2;
    goto $1; // Jump to address
    not bl; // Bitwise NOT
    or al, bl; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    and al, bl; // Bitwise AND
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value
    $1 = $2; // Check if values are not equal
    or bx, bx; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16afd; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are equal
    or bh, bh; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr [bp - 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16b38; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    ror ax, cl; // Rotate right
    goto $1; // Jump to address
    not bh; // Bitwise NOT
    or al, bh; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    and al, bh; // Bitwise AND
    xor byte ptr es:[di], al; // Bitwise XOR
    $1++; // Increment value; Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16b6c; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x16b7c; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x52], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x16b8f; // Jump if below (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16b8f; // Jump if above or equal (unsigned); Check if values are equal
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 0xa], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Increment counter and check loop condition
    $1 -= $2; // Subtract values; Increment counter and check loop condition
    $1++; // Increment value; Increment counter and check loop condition
    cmp byte ptr [bp - 9], 4; // Compare values
    jb 0x16bab; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 9], 0;
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    lcall 0xa36, 0xe; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x5c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    in al, dx; // Input from port
    test al, 8; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    jae 0x16c2c; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    push($1); // Push value onto stack
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63; // Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[di], al;
    $1++; // Increment value
    loop 0x16c13; // Loop (decrement CX and jump if CX!=0)
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or si, si; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16c65; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x16c7d; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    clc ; // Clear carry flag
    lcall 0xb08, 0x17e;
    jae 0x16c7d; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1 += $2; // Add values
    jae 0x16ca2; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 3;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x16d29; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x16d32; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf830;
    cdq ;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    mul bx; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp byte ptr es:[di], bl; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc19;
    cdq ;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ; // Clear carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x16d83; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jle 0x16d8c; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xf824;
    cdq ;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    mul bx; // Multiply (unsigned); Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    cmp word ptr es:[di], bx; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc19;
    cdq ;
    stc ; // Set carry flag
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ; // Clear carry flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xf830;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x16dea; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x16dea; // Jump if greater (signed)
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xf82f;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x16e64; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x16e64; // Jump if greater (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x16e64; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x16e64; // Jump if greater (signed)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x16e64; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x16e64; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 6; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xe];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    les di, ptr [bp + 0xa];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    les di, ptr [bp + 6];
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xf82e;
    $1 = $2;
    $1 = $2;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    jg 0x16ed6; // Jump if greater (signed)
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    $1 += $2; // Add values
    les di, ptr [bp + 6];
    les di, ptr es:[di + 0xa4];
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    and bx, 7; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    mov word ptr es:[di + 2], dx;
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    loop 0x16fca; // Loop (decrement CX and jump if CX!=0)
    les di, ptr [bp + 6];
    mov word ptr es:[di + 0xa], dx;
    lds si, ptr [bp + 0xc];
    $1 += $2; // Add values
    les di, ptr es:[di + 0xa8];
    $1++; // Increment value
    $1++; // Increment value
    $1 = $2;
    lodsw ax, word ptr [si]; // Load string byte/word
    $1 -= $2; // Subtract values
    stosw word ptr es:[di], ax; // Store string byte/word
    loop 0x17006; // Loop (decrement CX and jump if CX!=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jl 0x1706d; // Jump if less (signed)
    cmp word ptr [si + 0x2a], 0; // Compare values
    jl 0x1706d; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jl 0x1706d; // Jump if less (signed)
    cmp word ptr [si + 0x2e], 0; // Compare values
    jl 0x1706d; // Jump if less (signed)
    $1 = $2;
    $1 += $2; // Add values; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    jg 0x1706d; // Jump if greater (signed); Check if values are equal
    cmp word ptr [si + 0x34], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x1706d; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jl 0x17074; // Jump if less (signed)
    mov word ptr [bp - 2], 0xfc18;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    *($1) = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1542, 0;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr es:[di + 8], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov word ptr es:[di + 0xc], ax;
    $1 = $2;
    mov word ptr es:[di + 0xe], ax;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 0x10], ax;
    mov word ptr es:[di + 0x12], 1;
    mov word ptr es:[di + 0x14], 0;
    mov word ptr es:[di + 0x16], 0;
    mov word ptr es:[di + 0x18], 0;
    mov word ptr es:[di + 0x1a], 0;
    mov word ptr es:[di + 0x1c], 0;
    mov word ptr es:[di + 0x20], 0;
    $1 = $2;
    mov word ptr es:[di + 0x22], ax;
    mov word ptr es:[di + 0x1e], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 4], ax;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 6], ax;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    $1 += $2; // Add values
    les di, ptr [bp + 6];
    les di, ptr es:[di + 0xa4];
    *($1) = $2;
    *($1) = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1++; // Increment value
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    lds si, ptr [bp + 0xc];
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lcall 0x96b, 0xa0;
    jae 0x17178; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfffd;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    lds si, ptr [bp + 6];
    lds si, ptr [si + 0xa4];
    *($1) = $2;
    *($1) = $2;
    les di, ptr [bp + 6];
    $1 += $2; // Add values
    *($1) = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    les di, ptr [bp - 0x16];
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    and ax, 7; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    and dx, 7; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1 = $2;
    xor cl, 7; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    $1 = 0; // Bitwise XOR; Check if values are equal
    or cx, word ptr [bp - 0x24]; // Bitwise OR; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x12];
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    shl ax, cl; // Shift left
    mov byte ptr es:[di], ah;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stc ; // Set carry flag
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    jae 0x1723a; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1++; // Increment value
    shl ax, cl; // Shift left
    and ah, ch; // Bitwise AND
    mov byte ptr es:[di], ah;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stc ; // Set carry flag
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    jae 0x17260; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 0xe];
    $1++; // Increment value
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x12];
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 0xc], 0; // Compare values
    jge 0x17300; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    cmp word ptr [bp + 0xa], 0; // Compare values
    jge 0x1730d; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x1731c; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x1732b; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jl 0x173c0; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jl 0x173c0; // Jump if less (signed)
    // Compare $1 with $2 // Compare values
    jg 0x173c0; // Jump if greater (signed)
    // Compare $1 with $2 // Compare values
    jg 0x173c0; // Jump if greater (signed)
    clc ; // Clear carry flag
    goto $1; // Jump to address
    stc ; // Set carry flag
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x15a7, 6;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xa; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0xa], 8;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x12], 1;
    mov word ptr [si + 0x14], 0;
    mov word ptr [si + 0x16], 0;
    mov word ptr [si + 0x18], 0;
    mov word ptr [si + 0x1a], 0;
    mov word ptr [si + 0x1c], 0;
    mov word ptr [si + 0x20], 0; // Check if values are not equal
    mov word ptr [si + 0x22], 8; // Check if values are not equal
    mov word ptr [si + 0x1e], 8; // Check if values are not equal
    cmp word ptr [bp + 0xa], 6; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 0x10;
    mov word ptr [bp - 0xe], 0x100;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0xff;
    mov word ptr [si + 0xc], 0xc;
    mov word ptr [si + 0xe], 4;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xa], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 4], 0xe;
    mov word ptr [bp - 0xe], 0x100;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0xff;
    mov word ptr [si + 0xc], 0xa;
    mov word ptr [si + 0xe], 4;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    mov word ptr [bp - 4], 8;
    mov word ptr [bp - 0xe], 0x80;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0x7f;
    mov word ptr [si + 0xc], 6;
    mov word ptr [si + 0xe], 2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    lcall 0xae3, 0; // Check if values are equal
    cmp byte ptr es:[di], 3; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp byte ptr es:[di], 5; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 0xe], 0x100;
    mov word ptr [si + 6], 0xff;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10; // Call interrupt
    $1 = $2;
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    *($1) = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 0x1b0;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x95a, 6;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xffe6;
    goto $1; // Jump to address
    lds si, ptr [bp + 6];
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xffe6;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    les di, ptr [bp + 6];
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp - 8];
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov byte ptr es:[di], al;
    $1 = $2;
    $1 += $2; // Add values
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    stc ; // Set carry flag
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    jae 0x17603; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lds si, ptr [bp + 6];
    les di, ptr [si + 0xa8]; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep stosw word ptr es:[di], ax; // Fill memory block
    les di, ptr [si + 0xa4];
    $1 = 0; // Bitwise XOR
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 += $2; // Add values
    $1++; // Increment value
    $1++; // Increment value
    loop 0x17627; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 6];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    lds si, ptr [bp + 6];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    lds si, ptr [bp + 6];
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 0x2fa;
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x15bd, 0xa;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0xa]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x18c7, 8;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 6];
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 0x1b0;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    lcall 0x95a, 6;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 6];
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xffe6;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x79e, 0xc;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0xffe6;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x15c8, 0xe;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    push($1); // Push value onto stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lcall 0x5e5, 0x2fa;
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x79e, 0x5d;
    push($1); // Push value onto stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lcall 0x5e5, 0x2fa;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x17808; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    $1 = $2;
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    int 0x21; // Call interrupt; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc18;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1542, 0;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2; // Initialize counter for string operation
    les di, ptr [bp + 6]; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    *($1) = $2;
    or ax, ax; // Bitwise OR
    jge 0x178c0; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x166;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1548, 6;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lcall 0x96b, 0x1c0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x166;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1539, 0xe;
    *($1) = $2;
    lcall 0x96b, 0x1c0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    $1 -= $2; // Subtract values
    shl bx, 1; // Shift left
    lds si, ptr [bp - 0x60];
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [si + 0xa8];
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lds si, ptr [si + 0xa4];
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    cmp word ptr [bp - 0x24], 0; // Compare values
    jg 0x179a0; // Jump if greater (signed)
    mov word ptr [bp - 2], 0xfc16;
    goto $1; // Jump to address
    $1 += $2; // Add values
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 4], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp - 0x48], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 0x48], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp - 0x48], 3; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x84], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are equal
    sub word ptr [bp + 6], dx; // Subtract values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x84], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    sub word ptr [bp + 8], dx; // Subtract values
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    mov word ptr [bp - 0x9c], 0xff; // Check if values are equal
    cmp word ptr [bp - 0x92], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0x17a71; // Jump if less or equal (signed)
    goto $1; // Jump to address; Decrement counter and check loop condition
    $1 += $2; // Add values; Decrement counter and check loop condition
    $1--; // Decrement value; Decrement counter and check loop condition
    // Compare $1 with $2 // Compare values
    jge 0x17a7e; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jle 0x17a8a; // Jump if less or equal (signed)
    goto $1; // Jump to address; Decrement counter and check loop condition
    $1 += $2; // Add values; Decrement counter and check loop condition
    $1--; // Decrement value; Decrement counter and check loop condition
    // Compare $1 with $2 // Compare values
    jge 0x17a97; // Jump if greater or equal (signed)
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 8], ax; // Compare values
    jge 0x17ab9; // Jump if greater or equal (signed)
    $1 -= $2; // Subtract values
    $1 = $2;
    and ax, 0xf8; // Bitwise AND
    and cx, 7; // Bitwise AND
    ror word ptr [bp - 0x9c], cl; // Rotate right
    add word ptr [bp + 8], ax; // Add values
    add word ptr [bp - 0x98], ax; // Add values
    sub word ptr [bp - 0x7a], ax; // Subtract values
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jle 0x17acd; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values
    sub word ptr [bp - 0x7a], ax; // Subtract values
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x17ae7; // Jump if greater or equal (signed)
    $1 = $2;
    $1 -= $2; // Subtract values
    add word ptr [bp + 6], ax; // Add values
    add word ptr [bp - 0x9a], ax; // Add values
    sub word ptr [bp - 0x7c], ax; // Subtract values
    $1 = $2;
    $1 += $2; // Add values
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    jle 0x17afb; // Jump if less or equal (signed)
    $1 -= $2; // Subtract values
    sub word ptr [bp - 0x7c], ax; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    div bx; // Divide (unsigned)
    or dx, dx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xor cl, al; // Bitwise XOR
    $1++; // Increment value
    and cl, 7; // Bitwise AND
    $1 = $2;
    shl ch, cl; // Shift left
    *($1) = $2;
    les di, ptr [bp - 0x58];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl bx, 1; // Shift left
    shl bx, 1; // Shift left
    ljmp es:[bx + di];
    ljmp 0x189a:8;
    mov word ptr [bp - 2], 0;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr [bx], 0;
    mov word ptr [bx + 2], 0x1641;
    $1 += $2; // Add values
    mov word ptr [bx], 0x77a;
    mov word ptr [bx + 2], 0x1641;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 6;
    mov word ptr [bx + 2], 0x1805;
    $1 += $2; // Add values
    mov word ptr [bx], 6;
    mov word ptr [bx + 2], 0x1705;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2; // Add values
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2; // Add values
    mov byte ptr [0x712c], 1;
    retf ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 0x1e], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 0x20], 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    mov word ptr es:[0x712e], 1;
    mov word ptr es:[0x7130], 1;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1--; // Decrement value; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1++; // Increment value
    mov word ptr [si + 0x18], 0x20;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x17b8, 0x342;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mov word ptr es:[di + 0x1e], dx;
    $1 = $2;
    mov word ptr es:[di + 0x20], dx;
    retf ; // Return from function
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x17d05; // Jump if greater or equal (signed)
    $1 += $2; // Add values
    $1 = $2;
    xor al, 7; // Bitwise XOR
    $1++; // Increment value
    and al, 7; // Bitwise AND
    *($1) = $2;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl bx, cl; // Shift left
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    out dx, ax; // Output to port; Check if values are equal
    cmp byte ptr [bp - 0xa2], 1; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr [bp - 0x2a], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    mov word ptr [bp - 0x2a], 0xf; // Check if values are equal
    cmp word ptr [bp - 0x2c], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x2c], 0xf; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [bp - 0xa], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], 0xff; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    out dx, ax; // Output to port
    and byte ptr es:[di], bl; // Bitwise AND
    $1++; // Increment value
    $1++; // Increment value
    loop 0x17d92; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cwde ; // Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and bl, ch; // Bitwise AND
    $1 = $2;
    and ah, byte ptr [bp - 0x9c]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    shl ax, cl; // Shift left
    shl bx, cl; // Shift left
    *($1) = $2;
    *($1) = $2;
    *($1) = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp byte ptr [bp - 0xa0], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    rol bx, cl; // Rotate left
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    test cl, cl; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    rol ax, cl; // Rotate left
    cmp word ptr [bp + 8], 0; // Compare values
    jl 0x17e3a; // Jump if less (signed)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    and ah, byte ptr [bp - 0xa0]; // Bitwise AND
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and ah, byte ptr [bp - 0xa0]; // Bitwise AND
    out dx, ax; // Output to port
    and byte ptr es:[di], bl; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    $1--; // Decrement value
    $1--; // Decrement value
    jg 0x17e47; // Jump if greater (signed)
    $1 = $2;
    and byte ptr [bp - 0x1e], bl; // Bitwise AND
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    and ah, byte ptr [bp - 0x9f]; // Bitwise AND
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and ah, byte ptr [bp - 0x9f]; // Bitwise AND
    out dx, ax; // Output to port
    and byte ptr es:[di], bl; // Bitwise AND
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    out dx, ax; // Output to port
    and byte ptr es:[di], bl; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    lodsw ax, word ptr [si]; // Load string byte/word
    $1--; // Decrement value
    rol ax, cl; // Rotate left
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    xchg al, ah; // Exchange values
    and ah, byte ptr [bp - 0x1e]; // Bitwise AND
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and ah, byte ptr [bp - 0x1e]; // Bitwise AND
    out dx, ax; // Output to port
    and byte ptr es:[di], bl; // Bitwise AND
    $1 = pop(); // Pop value from stack
    and ah, byte ptr [bp - 0x20]; // Bitwise AND
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di + 1], bh; // Bitwise AND
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and ah, byte ptr [bp - 0x20]; // Bitwise AND
    out dx, ax; // Output to port
    and byte ptr es:[di + 1], bl; // Bitwise AND
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port; Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x17f66; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x17f69; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x17f81; // Jump if greater or equal (signed)
    $1 += $2; // Add values
    $1 = $2;
    $1 += $2; // Add values
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack; Check if values are not equal
    $1 += $2; // Add values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp - 0xa], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], 0xff; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    $1++; // Increment value
    loop 0x17fae; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test bl, bl; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    cmp word ptr [bp + 8], 0; // Compare values
    jl 0x17fe0; // Jump if less (signed)
    and ah, byte ptr [bp - 0xa0]; // Bitwise AND
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    $1 = $2;
    $1++; // Increment value
    $1--; // Decrement value
    $1--; // Decrement value
    jg 0x17fed; // Jump if greater (signed)
    $1 = $2;
    and byte ptr [bp - 0x1e], ah; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    $1 = $2;
    out dx, ax; // Output to port
    goto $1; // Jump to address
    and byte ptr es:[di], bh; // Bitwise AND
    $1++; // Increment value
    loop 0x17ffa; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di], bh; // Bitwise AND
    $1 = $2;
    out dx, ax; // Output to port
    and byte ptr es:[di + 1], bh; // Bitwise AND
    retf ; // Return from function
    $1 = $2;
    shl cx, 1; // Shift left
    and cl, 7; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    loop 0x18028; // Loop (decrement CX and jump if CX!=0)
    not dx; // Bitwise NOT
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    loop 0x1803e; // Loop (decrement CX and jump if CX!=0)
    *($1) = $2; // Check if values are not equal
    not dx; // Bitwise NOT; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and word ptr [bp - 0xa0], ax; // Bitwise AND
    not ax; // Bitwise NOT
    or word ptr [bp - 0x9e], ax; // Bitwise OR
    and byte ptr [bp - 9], bl; // Bitwise AND
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xlatb ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    xlatb ;
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2; // Check if values are equal
    cld ; // Clear direction flag; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    not dx; // Bitwise NOT
    xchg dl, dh; // Exchange values
    and word ptr es:[di], dx; // Bitwise AND
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    xchg al, ah; // Exchange values
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or ax, dx; // Bitwise OR
    xchg al, ah; // Exchange values
    mov word ptr es:[di], ax;
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    loop 0x180d6; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    and al, byte ptr [bp - 0x9b]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    and al, byte ptr [bp - 0x9c]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di + 1], ax; // Bitwise AND
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    and dx, word ptr [bp - 0x9c]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    not ax; // Bitwise NOT
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    not ax; // Bitwise NOT
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    and dx, word ptr [bp - 0x9c]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di + 1], ax; // Bitwise AND
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di + 1], ax; // Bitwise AND
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    and dx, word ptr [bp - 0xa0]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    $1++; // Increment value
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    and al, byte ptr [bp - 0x9b]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 = $2;
    and al, byte ptr [bp - 0x9c]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di + 1], ax; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    and dx, word ptr [bp - 0x9c]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di + 1], ax; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di + 1], ax; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di + 1], ax; // Bitwise XOR
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di + 1], ax; // Bitwise XOR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    and dx, word ptr [bp - 0xa0]; // Bitwise AND
    or dx, ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di + 1], ax; // Bitwise XOR
    $1++; // Increment value
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    not word ptr [bp - 0x9c]; // Bitwise NOT
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    or dx, word ptr [bp - 0x9c]; // Bitwise OR
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    or dx, word ptr [bp - 0x9c]; // Bitwise OR
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    or dx, word ptr [bp - 0x9e]; // Bitwise OR
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    or dx, word ptr [bp - 0x9e]; // Bitwise OR
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1++; // Increment value
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    and dx, word ptr [bp - 0x9c]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    and dx, word ptr [bp - 0x9c]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    $1++; // Increment value
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and al, ch; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    shr al, 1; // Shift right (unsigned)
    rcr dx, 1;
    sar dx, 1; // Shift right (signed)
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    not dx; // Bitwise NOT
    and dx, word ptr [bp - 0x2c]; // Bitwise AND
    or dx, ax; // Bitwise OR
    and dx, word ptr [bp - 0xa0]; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    $1++; // Increment value
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x186b1; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x186b4; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    lcall es:[di + 0x26];
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], -1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    and ax, word ptr [bp - 0x2a]; // Bitwise AND
    mov word ptr es:[di], ax;
    $1++; // Increment value
    $1++; // Increment value
    loop 0x186e1; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    and dx, word ptr [bp - 0x9c]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    not ax; // Bitwise NOT
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = 0; // Bitwise XOR
    $1 = $2;
    not ax; // Bitwise NOT
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    and dx, word ptr [bp - 0x2a]; // Bitwise AND
    and dx, word ptr [bp - 0xa0]; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di + 1], ax; // Bitwise AND
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di + 1], ax; // Bitwise OR
    retf ; // Return from function
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x18795; // Jump if greater or equal (signed)
    $1 += $2; // Add values
    push($1); // Push value onto stack
    and cl, 7; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    ror ax, cl; // Rotate right
    xchg al, ah; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    or word ptr [bp - 0x9e], ax; // Bitwise OR; Check if values are equal
    and byte ptr [bp - 9], bl; // Bitwise AND; Check if values are equal
    mov word ptr [bp - 8], 0xffff; // Check if values are equal
    cmp word ptr [bp - 0x2a], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 8], 0;
    mov word ptr [bp - 0x2a], 0xffff;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0xa], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    mov byte ptr es:[di], al;
    $1++; // Increment value
    $1++; // Increment value
    loop 0x18841; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    ror dx, cl; // Rotate right
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    or ax, word ptr [bp - 0x9c]; // Bitwise OR
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x188c4; // Jump if greater or equal (signed)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x188e1; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x188f4; // Jump if greater or equal (signed)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x1890f; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    and word ptr es:[di], dx; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    or ax, word ptr [bp - 0x9e]; // Bitwise OR; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x1896d; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x1898d; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = 0; // Bitwise XOR
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x189a6; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x189c5; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18a00; // Jump if greater or equal (signed)
    xor byte ptr es:[di], ah; // Bitwise XOR
    goto $1; // Jump to address
    xor word ptr es:[di], ax; // Bitwise XOR
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18a31; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xor byte ptr es:[di], ah; // Bitwise XOR
    goto $1; // Jump to address
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = $2;
    ror ax, cl; // Rotate right
    or ax, word ptr [bp - 0x9c]; // Bitwise OR
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18a6a; // Jump if greater or equal (signed)
    and byte ptr es:[di], ah; // Bitwise AND
    goto $1; // Jump to address
    and word ptr es:[di], ax; // Bitwise AND
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = $2;
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right
    or ax, word ptr [bp - 0x9e]; // Bitwise OR; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18a9d; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and byte ptr es:[di], ah; // Bitwise AND
    goto $1; // Jump to address
    and word ptr es:[di], ax; // Bitwise AND
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18ad5; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18b04; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    xor word ptr [bp - 4], 0xc050; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x18b78; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x18b7b; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x18b93; // Jump if greater or equal (signed)
    $1 += $2; // Add values
    $1 = $2;
    $1 += $2; // Add values
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [bp - 0xa], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    loop 0x18bb9; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    ror dx, cl; // Rotate right
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18bec; // Jump if greater or equal (signed)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18c07; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    and word ptr es:[di], dx; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18c33; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18c52; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    retf ; // Return from function
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x18c61; // Jump if greater or equal (signed)
    $1 += $2; // Add values
    push($1); // Push value onto stack
    and cl, 7; // Bitwise AND
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    ror ax, cl; // Rotate right
    xchg al, ah; // Exchange values
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    *($1) = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT; Check if values are not equal
    *($1) = $2; // Check if values are not equal
    $1 = pop(); // Pop value from stack; Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    or word ptr [bp - 0x9e], ax; // Bitwise OR; Check if values are equal
    and byte ptr [bp - 9], bl; // Bitwise AND; Check if values are equal
    mov word ptr [bp - 8], 0xffff; // Check if values are equal
    cmp word ptr [bp - 0x2a], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 8], 0;
    mov word ptr [bp - 0x2a], 0xffff;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    and al, 3; // Bitwise AND
    mov byte ptr [bp - 6], 4;
    sub byte ptr [bp - 6], al; // Subtract values; Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0xa], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    mov byte ptr es:[di], al;
    $1++; // Increment value
    $1++; // Increment value
    loop 0x18d08; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    ror dx, cl; // Rotate right
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    or ax, word ptr [bp - 0x9c]; // Bitwise OR
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18d94; // Jump if greater or equal (signed)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18db1; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18dc4; // Jump if greater or equal (signed)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18ddf; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    and word ptr es:[di], dx; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    not ax; // Bitwise NOT
    or ax, word ptr [bp - 0x9e]; // Bitwise OR; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18e3d; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    and al, byte ptr [si]; // Bitwise AND
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18e5d; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = 0; // Bitwise XOR
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18e76; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18e95; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18ed9; // Jump if greater or equal (signed)
    xor byte ptr es:[di], ah; // Bitwise XOR
    goto $1; // Jump to address
    xor word ptr es:[di], ax; // Bitwise XOR
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    xor word ptr es:[di], ax; // Bitwise XOR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    and al, ch; // Bitwise AND
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18f0a; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xor byte ptr es:[di], ah; // Bitwise XOR
    goto $1; // Jump to address
    xor word ptr es:[di], ax; // Bitwise XOR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = $2;
    ror ax, cl; // Rotate right
    or ax, word ptr [bp - 0x9c]; // Bitwise OR
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18f4c; // Jump if greater or equal (signed)
    and byte ptr es:[di], ah; // Bitwise AND
    goto $1; // Jump to address
    and word ptr es:[di], ax; // Bitwise AND
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = $2;
    ror ax, cl; // Rotate right
    and word ptr es:[di], ax; // Bitwise AND
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = $2;
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right
    or ax, word ptr [bp - 0x9e]; // Bitwise OR; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18f7f; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    and byte ptr es:[di], ah; // Bitwise AND
    goto $1; // Jump to address
    and word ptr es:[di], ax; // Bitwise AND
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x18fc0; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x18fef; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 6], 4;
    $1 = pop(); // Pop value from stack
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x1906c; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x1906f; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x19087; // Jump if greater or equal (signed)
    $1 += $2; // Add values
    $1 = $2;
    $1 += $2; // Add values
    lcall es:[di + 0x26];
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [bp - 0xa], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr [bp - 0x9c], 0xff00; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 = $2;
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    or byte ptr es:[di], al; // Bitwise OR
    $1++; // Increment value
    loop 0x190ad; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    ror dx, cl; // Rotate right
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x190e0; // Jump if greater or equal (signed)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    and ax, word ptr [bp - 0xa0]; // Bitwise AND
    cmp word ptr [bp + 8], 0; // Compare values
    jge 0x190fb; // Jump if greater or equal (signed)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    goto $1; // Jump to address
    and word ptr es:[di], dx; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    ror ax, cl; // Rotate right
    or word ptr es:[di], ax; // Bitwise OR
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x19127; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg al, ah; // Exchange values
    $1 = $2;
    and word ptr es:[di], ax; // Bitwise AND
    $1 = $2;
    xor al, byte ptr [bp - 8]; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    and al, ch; // Bitwise AND
    ror ax, cl; // Rotate right; Check if values are not equal
    cmp word ptr [bp + 8], 0; // Compare values; Check if values are not equal
    jge 0x19146; // Jump if greater or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0xe], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    or byte ptr es:[di], ah; // Bitwise OR
    goto $1; // Jump to address
    or word ptr es:[di], ax; // Bitwise OR
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 8]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x66;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 8], ax;
    *($1) = $2;
    $1 = $2;
    mov word ptr es:[di + 0xc], ax;
    $1 = $2;
    mov word ptr es:[di + 0xe], ax;
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x14], ax;
    $1 = $2;
    mov word ptr es:[di + 0x16], ax;
    $1 = $2;
    mov word ptr es:[di + 0x18], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1a], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1c], ax;
    $1 = $2;
    mov word ptr es:[di + 0x20], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1e], ax;
    mov word ptr es:[di + 0xa], ax;
    *($1) = $2; // Check if values are not equal
    test word ptr [si + 0x18], 0x10; // Test bits (AND without storing); Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address; Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    mov word ptr [bp - 0xe], 0; // Check if values are equal
    cmp word ptr [si + 0x16], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [si + 0x16], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xb08, 0x2e7;
    // Compare $1 with $2 // Compare values
    jb 0x1923f; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xfffe;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 0xa6], ax;
    mov word ptr es:[di + 0xaa], ax;
    $1 = $2;
    $1 += $2; // Add values
    $1++; // Increment value
    mov word ptr es:[di + 0xa4], ax;
    $1++; // Increment value
    $1++; // Increment value
    mov word ptr es:[di + 0xa8], ax;
    lds si, ptr es:[di + 0xa4];
    mov word ptr [si], 0; // Check if values are equal
    lds si, ptr es:[di + 0xa8]; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0xe], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1++; // Increment value
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 6;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x95a, 6;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [bp + 0xa], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x27c; // Check if values are not equal
    mov word ptr [bp - 0xe], 0x30c; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xa], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x284; // Check if values are not equal
    mov word ptr [bp - 0xe], 0x311; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp + 0xa], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x28c; // Check if values are equal
    mov word ptr [bp - 0xe], 0x313; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp + 0xa], 3; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc15;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x294;
    mov word ptr [bp - 0xe], 0x315;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x185d, 4;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 0x10];
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xc];
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test word ptr [si + 0x18], 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 -= $2; // Subtract values
    les di, ptr es:[di + 0xa8];
    mov word ptr es:[di], bx;
    goto $1; // Jump to address; Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp + 0xa], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp + 0xa], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    add word ptr [bp - 0x10], bx; // Add values
    goto $1; // Jump to address
    $1 = $2;
    sub word ptr [bp - 0x12], bx; // Subtract values
    goto $1; // Jump to address
    $1 = $2;
    sub word ptr [bp - 0x10], bx; // Subtract values
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    add word ptr [bp - 0x12], bx; // Add values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 8], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 0x18], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x1e], 0;
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    mov word ptr [si + 0x20], 0; // Check if values are not equal
    cmp word ptr [0x7132], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x18], 1;
    mov word ptr [0x7132], 0;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x17b8, 0x342;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x185d, 4;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    goto $1; // Jump to address
    goto $1; // Jump to address
    $1 += $2; // Add values
    goto $1; // Jump to address
    les di, ptr [bp + 0x10];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xc];
    mov word ptr es:[di], bx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xe; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr [si + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lcall 0x1568, 0x11d; // Check if values are equal
    jb 0x194c8; // Jump if below (unsigned); Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [si + 4], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    lcall [si + 4];
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    and al, 1; // Bitwise AND; Check if values are equal
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, ah; // Bitwise AND
    xor cl, ah; // Bitwise XOR
    shl cl, 1; // Shift left
    $1 = $2;
    and al, ah; // Bitwise AND; Check if values are equal
    shl ax, cl; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    or al, ah; // Bitwise OR
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    and byte ptr es:[di], ah; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7; // Bitwise AND
    xor cl, 7; // Bitwise XOR
    $1 = $2;
    lds si, ptr [si + 6];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are not equal
    and al, 1; // Bitwise AND; Check if values are not equal
    shl ax, cl; // Shift left; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    or byte ptr es:[di], al; // Bitwise OR
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left
    $1 += $2; // Add values
    jae 0x1965c; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    and byte ptr es:[di], al; // Bitwise AND
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left
    $1 += $2; // Add values
    jae 0x1968d; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    goto $1; // Jump to address
    test al, al; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    xor byte ptr es:[di], al; // Bitwise XOR
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left
    $1 += $2; // Add values
    jae 0x196bc; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    goto $1; // Jump to address
    not ah; // Bitwise NOT
    $1 = $2;
    $1 = $2;
    and byte ptr es:[di], ah; // Bitwise AND
    or byte ptr es:[di], al; // Bitwise OR
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    shr bl, 1; // Shift right (unsigned)
    $1 = $2;
    and al, 1; // Bitwise AND
    shl al, cl; // Shift left
    $1 += $2; // Add values
    jae 0x196e7; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    mov word ptr [0x7132], 1; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [0x7132], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x82]; // Load effective address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp byte ptr [0x712c], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    lcall 0x15d6, 0x216; // Check if values are not equal
    cmp word ptr [0x7132], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mul word ptr [bp + 8]; // Multiply (unsigned)
    *($1) = $2;
    $1 = $2;
    mul word ptr [bp + 6]; // Multiply (unsigned)
    *($1) = $2;
    lcall 0x98e, 0x35e;
    // Compare $1 with $2 // Compare values
    jge 0x1989d; // Jump if greater or equal (signed)
    // Compare $1 with $2 // Compare values
    jle 0x1987d; // Jump if less or equal (signed)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr es:[di + 4], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfffa;
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    lcall 0x98e, 0x249;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0x12a;
    jae 0x198b0; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x98e, 0xa6;
    or ax, ax; // Bitwise OR
    jge 0x198cb; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xfc19;
    goto $1; // Jump to address
    *($1) = $2;
    les di, ptr [bp - 0x58];
    push($1); // Push value onto stack
    lea ax, [bp - 0x60]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1 += $2; // Add values
    *($1) = $2;
    test word ptr [si + 0x18], 0x10; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x32], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr es:[di + 0x1e], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    $1 = $2; // Check if values are equal
    add word ptr [bp + 8], ax; // Add values; Check if values are equal
    cmp word ptr es:[di + 0x20], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    add word ptr [bp + 6], ax; // Add values
    push($1); // Push value onto stack
    lea ax, [bp - 0x4c]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x4e]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x66;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    lds si, ptr [si + 0xa8]; // Initialize counter for string operation
    push($1); // Push value onto stack; Initialize counter for string operation
    les di, ptr [bp - 0x4c]; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    les di, ptr [bp + 0xa]; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di]; // Decrement counter and check loop condition
    $1 -= $2; // Subtract values; Decrement counter and check loop condition
    $1--; // Decrement value; Decrement counter and check loop condition
    // Compare $1 with $2 // Compare values
    ja 0x199e8; // Jump if above (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x44], 0;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jb 0x19a28; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values; Check if values are not equal
    ja 0x19a28; // Jump if above (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values; Check if values are equal
    shl bx, 1; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    add word ptr [bp - 0x44], ax; // Add values
    $1++; // Increment value
    loop 0x199fa; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jbe 0x19a47; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1754, 0xa;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    push($1); // Push value onto stack
    lcall 0x1865, 0x1cd;
    // Compare $1 with $2 // Compare values
    jle 0x19aaa; // Jump if less or equal (signed)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x15d6, 8;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cmp word ptr [bp - 0x42], 1; // Compare values
    jbe 0x19aaa; // Jump if below or equal (unsigned)
    push($1); // Push value onto stack
    lea ax, [bp - 0x8a]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x8c]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1754, 0x18b;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1++; // Increment value
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 4]; // Load effective address
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack; Check if values are equal
    retf 6; // Return from function; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 0x48], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    add word ptr [bp + 6], ax; // Add values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    $1 = $2; // Check if values are not equal
    add word ptr [bp + 6], ax; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1--; // Decrement value; Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 0x48], 2; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    add word ptr [bp + 8], ax; // Add values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    add word ptr [bp + 8], ax; // Add values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    cmp word ptr [bp - 0x48], 3; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned); Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 6], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    sub word ptr [bp + 8], ax; // Subtract values; Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    sub word ptr [bp + 8], ax; // Subtract values
    goto $1; // Jump to address
    retf ; // Return from function
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x94; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x85; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x5c], 0x8a;
    goto $1; // Jump to address
    mov word ptr [bp - 0x5c], 0x8f;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    jbe 0x19cb5; // Jump if below or equal (unsigned)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    rcl bh, 1;
    jb 0x19cc4; // Jump if below (unsigned)
    shl ah, 1; // Shift left
    goto $1; // Jump to address
    shl ah, 1; // Shift left
    jb 0x19cd2; // Jump if below (unsigned)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    $1++; // Increment value
    loop 0x19cb8; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jbe 0x19cf5; // Jump if below or equal (unsigned)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x19d10; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    clc ; // Clear carry flag
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jae 0x19d10; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1--; // Decrement value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x19d6c; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x19d6e; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x193; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x184; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x5c], 0x189;
    goto $1; // Jump to address
    mov word ptr [bp - 0x5c], 0x18e;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    rcl bh, 1;
    jae 0x19de6; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    $1++; // Increment value
    loop 0x19dcc; // Loop (decrement CX and jump if CX!=0)
    retf ; // Return from function
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x97; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x9c; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x5c], 0xa1;
    goto $1; // Jump to address
    mov word ptr [bp - 0x5c], 0xa6;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    jbe 0x19e57; // Jump if below or equal (unsigned)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    rcl bh, 1;
    jb 0x19e66; // Jump if below (unsigned)
    shl ah, 1; // Shift left
    goto $1; // Jump to address
    shl ah, 1; // Shift left
    jb 0x19e74; // Jump if below (unsigned)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x19e5a; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jbe 0x19ea9; // Jump if below or equal (unsigned)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x19ec4; // Jump if above or equal (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    clc ; // Clear carry flag
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jae 0x19ec4; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1 += $2; // Add values
    jae 0x19ed7; // Jump if above or equal (unsigned)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0;
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lcall 0xa36, 0x1a5; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    retf ; // Return from function; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x28], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp word ptr es:[di + 0x10], 1; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jb 0x19f46; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x19f49; // Jump if below or equal (unsigned)
    goto $1; // Jump to address
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0xe;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2; // Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x1eb; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    mov word ptr [bp - 0x5c], 0x1dc; // Check if values are not equal
    goto $1; // Jump to address; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp - 0x5c], 0x1e1;
    goto $1; // Jump to address
    mov word ptr [bp - 0x5c], 0x1e6;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ; // Set carry flag
    rcl bh, 1;
    jae 0x19fce; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    xor byte ptr es:[di], al; // Bitwise XOR
    goto $1; // Jump to address
    and byte ptr es:[di], al; // Bitwise AND
    goto $1; // Jump to address
    or byte ptr es:[di], al; // Bitwise OR
    goto $1; // Jump to address
    mov byte ptr es:[di], al;
    $1++; // Increment value
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1++; // Increment value
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xa36, 0x63;
    loop 0x19fb4; // Loop (decrement CX and jump if CX!=0)
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x14], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    $1 = $2;
    xchg al, ah; // Exchange values
    or ax, bx; // Bitwise OR
    mov word ptr es:[di + 0x10], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x18], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x1e], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x20], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x1c], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x1a], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 3;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 6]; // Check if values are equal
    cmp word ptr [si], 0xca10; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc17;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr es:[di], si;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    les di, ptr [si]; // Check if values are equal
    cmp word ptr es:[di], 0xca10; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc17;
    goto $1; // Jump to address
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6]; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 0x16]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 0x16];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 8], 0;
    test word ptr [si + 0x18], 0x10; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 0x10]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x12]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x66;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 6];
    les di, ptr [bp - 0x10]; // Initialize counter for string operation
    push($1); // Push value onto stack; Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    rep movsb byte ptr es:[di], byte ptr [si]; // Copy string/memory block
    $1 = pop(); // Pop value from stack
    $1 = $2;
    push($1); // Push value onto stack; Prepare arguments and call function
    $1 = $2; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    ja 0x1a366; // Jump if above (unsigned)
    mov word ptr [bp - 2], 0;
    goto $1; // Jump to address
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    lds si, ptr [si + 0xa8];
    les di, ptr [bp + 6];
    $1 = $2;
    lds si, ptr [bp - 0x16];
    lds si, ptr [si + 0xa8];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jb 0x1a3b2; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values; Check if values are not equal
    ja 0x1a3b2; // Jump if above (unsigned); Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 -= $2; // Subtract values; Check if values are equal
    shl bx, 1; // Shift left; Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jle 0x1a3b2; // Jump if less or equal (signed)
    $1 += $2; // Add values
    add word ptr [bp - 2], ax; // Add values
    $1++; // Increment value
    loop 0x1a37f; // Loop (decrement CX and jump if CX!=0)
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack; Prepare arguments and call function
    lea ax, [bp - 0x82]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 6];
    $1 = $2;
    $1 = 0; // Bitwise XOR
    // Compare $1 with $2 // Compare values
    jb 0x1a451; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jbe 0x1a458; // Jump if below or equal (unsigned)
    mov word ptr [bp - 2], 0xfc16;
    goto $1; // Jump to address
    $1 -= $2; // Subtract values
    shl bx, 1; // Shift left
    lds si, ptr [si + 0xa8];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    lds si, ptr [bp + 6]; // Check if values are equal
    cmp word ptr [si], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    mul bl; // Multiply (unsigned)
    // Compare $1 with $2 // Compare values; Check if values are equal
    jbe 0x1a51a; // Jump if below or equal (unsigned); Check if values are equal
    shr ax, 1; // Shift right (unsigned); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1--; // Decrement value
    mov word ptr es:[di + 0xa], ax;
    $1 = $2;
    mov word ptr es:[di + 8], ax;
    mov word ptr es:[di + 6], si;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [si + 4], 0; // Check if values are equal
    mov word ptr [bp - 2], 0; // Check if values are equal
    les di, ptr [si + 6]; // Check if values are equal
    cmp word ptr es:[di], 0xca00; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xffe4;
    goto $1; // Jump to address
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 2; // Return from function
    mov word ptr [bp - 0x66], 0;
    mov word ptr [bp - 0x70], 0;
    push($1); // Push value onto stack
    lea ax, [bp - 0x6e]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x188a, 0xa;
    lds si, ptr [bp - 0x64]; // Check if values are not equal
    les di, ptr [bp - 0x6e]; // Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    *($1) = $2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp - 0x48], 2; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    *($1) = $2; // Check if values are equal
    cmp word ptr [bp - 0x48], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    cmp word ptr [bp - 0x48], 3; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address; Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [bp - 0x84], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Check if values are equal
    sub word ptr [bp + 6], dx; // Subtract values; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x84], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    sub word ptr [bp + 8], dx; // Subtract values
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0xb08, 0xa;
    or dx, dx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    les di, ptr [bp - 0x6e];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    *($1) = $2;
    shl ax, 1; // Shift left; Check if values are equal
    shl ax, 1; // Shift left; Check if values are equal
    shl ax, 1; // Shift left; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cld ; // Clear direction flag
    $1 = $2;
    push($1); // Push value onto stack
    // Compare $1 with $2 // Compare values
    jbe 0x1a6cc; // Jump if below or equal (unsigned)
    $1 = $2;
    $1 = 0; // Bitwise XOR
    lodsb al, byte ptr [si]; // Load string byte/word
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 = $2;
    shl al, 1; // Shift left
    *($1) = $2;
    jb 0x1a6eb; // Jump if below (unsigned)
    test word ptr [bp - 0x2e], 0x20; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1787, 8;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    loop 0x1a6d2; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    // Compare $1 with $2 // Compare values
    jbe 0x1a70e; // Jump if below or equal (unsigned)
    $1 -= $2; // Subtract values
    goto $1; // Jump to address; Check if values are equal
    $1 += $2; // Add values; Check if values are equal
    jb 0x1a71d; // Jump if below (unsigned); Check if values are equal
    cmp word ptr [bp - 0x66], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    // Compare $1 with $2 // Compare values
    jb 0x1a732; // Jump if below (unsigned)
    push($1); // Push value onto stack
    clc ; // Clear carry flag
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    $1 = pop(); // Pop value from stack
    jae 0x1a732; // Jump if above or equal (unsigned)
    *($1) = $2;
    goto $1; // Jump to address
    $1++; // Increment value
    $1 = $2;
    *($1) = $2;
    $1--; // Decrement value
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    test word ptr [bp - 0x2e], 5; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1(); // Call function
    test word ptr [bp - 0x2e], 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lcall 0x15d6, 0x2f0;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x64];
    les di, ptr [bp - 0x6e];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    mov word ptr es:[di + 0x28], 0; // Check if values are not equal
    mov word ptr es:[di + 0x2a], 4; // Check if values are not equal
    retf ; // Return from function; Check if values are not equal
    cmp word ptr [bp - 0x48], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x1787, 8;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1++; // Increment value
    loop 0x1a79c; // Loop (decrement CX and jump if CX!=0)
    retf ; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 0xc], 0; // Compare values
    jge 0x1a81b; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    cmp word ptr [bp + 0xa], 0; // Compare values
    jge 0x1a828; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x1a837; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jge 0x1a846; // Jump if greater or equal (signed)
    mov word ptr [bp - 2], 0xffe5;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0; // Bitwise XOR
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    lcall 0x80c, 0x56c;
    or ax, ax; // Bitwise OR
    jge 0x1a8a8; // Jump if greater or equal (signed)
    *($1) = $2;
    goto $1; // Jump to address
    *($1) = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0xe]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 0x10]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x96b, 0x166;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp - 0xe];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], ax;
    $1 += $2; // Add values
    jae 0x1a8f2; // Jump if above or equal (unsigned)
    mov word ptr [bp - 2], 0xfc18;
    goto $1; // Jump to address
    $1 = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    $1 = 0; // Bitwise XOR
    $1 = $2;
    $1 -= $2; // Subtract values
    $1 = $2;
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    and bx, 7; // Bitwise AND
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1++; // Increment value
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    shl ax, 1; // Shift left
    $1 += $2; // Add values
    $1++; // Increment value
    $1++; // Increment value
    loop 0x1a8fb; // Loop (decrement CX and jump if CX!=0)
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    lcall 0x96b, 0x1c0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x10; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lea ax, [bp - 4]; // Load effective address
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    lea ax, [bp - 6]; // Load effective address; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0xb08, 0x2e7;
    test dx, 0x8000; // Test bits (AND without storing)
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 += $2; // Add values
    $1 += $2; // Add values
    adc dx, 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 4; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x16];
    mov word ptr [si], 0xca10;
    mov word ptr [si + 2], 0;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0;
    mov word ptr [si + 8], 0;
    mov word ptr [si + 0xa], 0;
    mov word ptr [si + 0xc], 0;
    mov word ptr [si + 0xe], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x12], 1;
    mov word ptr [si + 0x14], 0;
    mov word ptr [si + 0x16], 0;
    mov word ptr [si + 0x18], 0;
    mov word ptr [si + 0x1a], 0;
    mov word ptr [si + 0x1c], 0;
    mov word ptr [si + 0x1e], 0;
    mov word ptr [si + 0x20], 0;
    mov word ptr [si + 0x22], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x5e5, 6;
    *($1) = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0x16; // Return from function
    add byte ptr [di - 0x75], dl; // Add values
    in al, dx; // Input from port
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    cld ; // Clear direction flag
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    *($1) = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    movsb byte ptr es:[di], byte ptr [si]; // Move string byte/word; Check if values are not equal
    cmp byte ptr [si - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    lds si, ptr [bp + 0xa];
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp + 0xe];
    $1 = $2; // Initialize counter for string operation
    cld ; // Clear direction flag; Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    $1 = $2; // Initialize counter for string operation
    repne scasb al, byte ptr es:[di];
    $1 -= $2; // Subtract values
    $1--; // Decrement value
    *($1) = $2;
    cmp word ptr [bp - 0xe], 0x80; // Compare values
    jb 0x1ab28; // Jump if below (unsigned)
    mov word ptr [bp - 2], 0xfc13;
    goto $1; // Jump to address
    cmp word ptr [bp - 0xe], 0; // Compare values
    ja 0x1ab30; // Jump if above (unsigned)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    lea ax, [bp - 6]; // Load effective address
    push($1); // Push value onto stack
    lcall 0x185d, 0x46;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    lds si, ptr [bp - 6]; // Check if values are equal
    cmp word ptr [si + 0x16], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov word ptr [bp - 2], 0xfc15;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2; // Subtract values
    $1++; // Increment value
    *($1) = $2;
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    goto $1; // Jump to address
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 0xc; // Return from function
    lds si, ptr [bp + 0xe];
    les di, ptr [bp + 0xe];
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cx, cx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    *($1) = $2;
    mov byte ptr es:[di - 1], 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack; Check if values are not equal
    lcall 0x1865, 0x8e; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp byte ptr es:[di - 1], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    mov byte ptr es:[di - 1], al;
    $1 = $2;
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jle 0x1ac3b; // Jump if less or equal (signed); Check if values are not equal
    cmp word ptr [bp - 0x1c], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    mov word ptr [bp - 0x1c], 0;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xe];
    $1 += $2; // Add values
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    $1++; // Increment value
    std ; // Set direction flag
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cl, cl; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    *($1) = $2;
    $1++; // Increment value
    $1++; // Increment value
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x22], 0;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jl 0x1ac78; // Jump if less (signed)
    goto $1; // Jump to address
    mov word ptr [bp - 0x24], 0;
    $1 = $2;
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jle 0x1ac8b; // Jump if less or equal (signed)
    goto $1; // Jump to address
    push($1); // Push value onto stack
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    *($1) = $2;
    mov byte ptr es:[bx + di], 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    lcall 0x1865, 0x8e;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mov byte ptr es:[bx + di], dl;
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    jle 0x1acc4; // Jump if less or equal (signed); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1++; // Increment value
    goto $1; // Jump to address
    $1++; // Increment value
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov byte ptr es:[bx + di], 0;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0x17b8, 0xb1;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mov byte ptr es:[bx + di], dl;
    *($1) = $2;
    $1++; // Increment value
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x1ad0b; // Jump if above or equal (unsigned)
    mov word ptr [bp - 0x1c], 0;
    $1 = $2;
    $1 += $2; // Add values
    *($1) = $2;
    goto $1; // Jump to address
    $1 = $2;
    retf ; // Return from function
    cmpsb byte ptr [si], byte ptr es:[di];
    sbb word ptr [di + 0x501a], si;
    $1++; // Increment value
    push($1); // Push value onto stack
    $1--; // Decrement value
    // Compare $1 with $2 // Compare values
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    push($1); // Push value onto stack; Check if values are not equal
    cld ; // Clear direction flag; Check if values are not equal
    cmp word ptr [0xa0], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    $1(); // Call function
    jae 0x1ad64; // Jump if above or equal (unsigned)
    $1 = $2;
    or ax, word ptr [bp + 8]; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov word ptr [bp + 6], 0x4a8;
    mov word ptr [bp + 8], 0x19b2;
    $1(); // Call function
    jae 0x1ad64; // Jump if above or equal (unsigned)
    $1(); // Call function
    jae 0x1ad64; // Jump if above or equal (unsigned); Close file (DOS)
    $1 = $2; // Close file (DOS)
    goto $1; // Jump to address; Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    jb 0x1ad5a; // Jump if below (unsigned); Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    $1 = 0; // Bitwise XOR; Check if values are equal
    cmp word ptr [bp - 0x14], 0x5a4d; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 = $2;
    jcxz 0x1ad8e;
    $1--; // Decrement value
    $1 = $2;
    mul dx; // Multiply (unsigned)
    $1 += $2; // Add values
    $1 += $2; // Add values
    adc dx, 0;
    and ax, 0xfff0; // Bitwise AND
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = $2;
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    jb 0x1ad5a; // Jump if below (unsigned)
    $1 += $2; // Add values
    adc dx, 0;
    cmp word ptr [bp - 0x14], 0x4246; // Compare values
    $1 = $2; // Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp word ptr [bp - 0x12], 0x564f; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    adc dx, word ptr [bp - 0xe];
    goto $1; // Jump to address
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x722a], ax; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    mov word ptr es:[0x722c], ax; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    mov word ptr [0xb8], 0;
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1++; // Increment value
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1(); // Call function
    $1 = $2;
    $1 -= $2; // Subtract values
    // Compare $1 with $2 // Compare values
    jae 0x1ae28; // Jump if above or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    shr bx, 1; // Shift right (unsigned)
    shr bx, 1; // Shift right (unsigned)
    *($1) = $2;
    $1(); // Call function
    jae 0x1ae3f; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    nop ; // No operation
    $1 = 0; // Bitwise XOR
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf 8; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    cmp word ptr [0xb8], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Close file (DOS)
    $1 = $2; // Close file (DOS)
    $1 = $2; // Close file (DOS)
    int 0x21; // Call interrupt
    mov word ptr [0xb8], 0;
    goto $1; // Jump to address
    lea dx, [0x1c]; // Load effective address
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2; // Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    $1 = $2; // Check if values are equal
    cmp word ptr [0xb8], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    $1(); // Call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    lea di, [0x1c]; // Load effective address
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = $2;
    int 0x21; // Call interrupt
    // Compare $1 with $2 // Compare values
    jb 0x1af0f; // Jump if below (unsigned)
    mov byte ptr [6], 0x20;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    cld ; // Clear direction flag
    lodsb al, byte ptr [si]; // Load string byte/word
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsb al, byte ptr [si]; // Load string byte/word
    or al, al; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    lodsw ax, word ptr [si]; // Load string byte/word
    lea di, [0x1c]; // Load effective address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    stosb byte ptr es:[di], al; // Store string byte/word; Check if values are not equal
    or al, al; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    push($1); // Push value onto stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    cld ; // Clear direction flag
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1--; // Decrement value
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are not equal
    or al, al; // Bitwise OR; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack; Check if values are equal
    stc ; // Set carry flag; Check if values are equal
    ret ; // Return from function; Check if values are equal
    cmp byte ptr [si], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    lea di, [0x1c]; // Load effective address
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word; Check if values are equal
    or al, al; // Bitwise OR; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    stosb byte ptr es:[di], al; // Store string byte/word; Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    $1--; // Decrement value; Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2; // Prepare arguments and call function
    stosb byte ptr es:[di], al; // Store string byte/word; Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    jb 0x1af36; // Jump if below (unsigned)
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    lds si, ptr [bp + 6];
    $1 = $2;
    or ax, si; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    lodsb al, byte ptr [si]; // Load string byte/word
    stosb byte ptr es:[di], al; // Store string byte/word
    or al, al; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    loop 0x1af79; // Loop (decrement CX and jump if CX!=0)
    $1 -= $2; // Subtract values
    stosb byte ptr es:[di], al; // Store string byte/word
    lea dx, [0x1c]; // Load effective address
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    ret ; // Return from function
    push($1); // Push value onto stack
    lea dx, [bp - 0x14]; // Load effective address; Read from file (DOS)
    push($1); // Push value onto stack; Read from file (DOS)
    $1 = pop(); // Pop value from stack; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    jb 0x1afa4; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    ret ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    mov word ptr cs:[0x18], ax;
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 = 0; // Bitwise XOR
    lea si, [0xc0]; // Load effective address; Check if values are not equal
    test word ptr [si + 4], 2; // Test bits (AND without storing); Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr [si + 2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    nop ; // No operation
    $1 = $2;
    push($1); // Push value onto stack; Check if values are not equal
    mov word ptr es:[0x12], ax; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    cmp byte ptr es:[0x1a], 0xff; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    mov word ptr es:[0x12], 0;
    goto $1; // Jump to address
    nop ; // No operation
    $1 = pop(); // Pop value from stack
    mov word ptr es:[0x18], 0x4d0;
    $1 = $2;
    $1 = $2;
    add word ptr es:[4], ax; // Add values
    adc word ptr es:[6], dx;
    $1(); // Call function
    // Compare $1 with $2 // Compare values
    jae 0x1b010; // Jump if above or equal (unsigned)
    xchg dx, bx; // Exchange values
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    jae 0x1b01b; // Jump if above or equal (unsigned)
    goto $1; // Jump to address
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    *($1) = $2;
    ret ; // Return from function
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    jcxz 0x1b06e;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    sbb dx, word ptr [6];
    $1 = $2;
    div cx; // Divide (unsigned)
    $1 += $2; // Add values
    // Compare $1 with $2 // Compare values
    ja 0x1b06e; // Jump if above (unsigned)
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    mov word ptr [0x1c], 0;
    $1 = pop(); // Pop value from stack
    *($1) = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    goto $1; // Jump to address
    nop ; // No operation
    $1 = $2;
    rol si, cl; // Rotate left
    $1 = $2;
    and di, 0xf; // Bitwise AND
    and si, 0xfff0; // Bitwise AND
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    jb 0x1b0e4; // Jump if below (unsigned)
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are equal
    jcxz 0x1b0b4; // Check if values are equal
    $1(); // Call function; Check if values are equal
    cmp word ptr es:[0xc], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    $1 = $2;
    $1--; // Decrement value
    $1 = $2;
    *($1) = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall [0x16];
    $1 = pop(); // Pop value from stack
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    clc ; // Clear carry flag
    ret ; // Return from function
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    ror dx, cl; // Rotate right
    and dx, 0xf000; // Bitwise AND
    or ax, dx; // Bitwise OR
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    int 0x21; // Call interrupt
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    goto $1; // Jump to address
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    or di, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    $1 = 0; // Bitwise XOR; Read from file (DOS)
    $1 = $2; // Read from file (DOS)
    int 0x21; // Call interrupt
    jb 0x1b129; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jb 0x1b129; // Jump if below (unsigned)
    $1 -= $2; // Subtract values
    sbb di, 0;
    $1 = $2;
    or ax, di; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    and si, 0xf; // Bitwise AND
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    shr ax, 1; // Shift right (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    $1 = $2;
    shr cx, 1; // Shift right (unsigned)
    cld ; // Clear direction flag
    lodsw ax, word ptr [si]; // Load string byte/word
    $1 = $2;
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and di, 0xfff8; // Bitwise AND
    $1 = $2;
    mov word ptr es:[bx], dx;
    test ax, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    loop 0x1b14c; // Loop (decrement CX and jump if CX!=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ax, 0xf807; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ax, 0xf807; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ax, 0xf807; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    and ax, 0xf807; // Bitwise AND; Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 += $2; // Add values
    loop 0x1b1bc; // Loop (decrement CX and jump if CX!=0)
    goto $1; // Jump to address
    mov word ptr es:[bx + 4], di;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1 += $2; // Add values
    adc di, 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    jb 0x1b1fd; // Jump if below (unsigned)
    $1 = $2;
    jcxz 0x1b1fc;
    $1(); // Call function
    clc ; // Clear carry flag
    ret ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    test bp, 1; // Test bits (AND without storing)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    ljmp 0:0xd87;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    sti ; // Set interrupt flag
    les bx, ptr [bp + 2];
    push($1); // Push value onto stack
    sub word ptr [bp + 2], 2; // Subtract values
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    goto $1; // Jump to address
    $1 += $2; // Add values
    $1 = $2;
    xchg word ptr [bp - 6], ax; // Exchange values
    *($1) = $2;
    $1(); // Call function
    $1 = $2;
    xchg word ptr [bp - 6], ax; // Exchange values
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = $2;
    and al, 8; // Bitwise AND
    and byte ptr es:[0x1a], 0xf7; // Bitwise AND
    cwde ;
    $1 = $2;
    lcall [0x16];
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    iret ;
    push($1); // Push value onto stack
    $1++; // Increment value
    $1(); // Call function
    goto $1; // Jump to address
    popf ; // Pop flags from stack
    push($1); // Push value onto stack
    jae 0x1b275; // Jump if above or equal (unsigned)
    $1(); // Call function
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    cmp byte ptr es:[0x1b], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    $1(); // Call function
    goto $1; // Jump to address
    $1--; // Decrement value
    $1(); // Call function
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    pushf ; // Push flags onto stack
    // Compare $1 with $2 // Compare values
    ja 0x1b26e; // Jump if above (unsigned)
    popf ; // Pop flags from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    mov word ptr es:[0x10], ax; // Check if values are equal
    ret ; // Return from function; Check if values are equal
    $1++; // Increment value; Check if values are equal
    cmp word ptr es:[0x10], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    mov byte ptr es:[0x1b], 1;
    or byte ptr es:[0x1a], 4; // Bitwise OR
    goto $1; // Jump to address
    nop ; // No operation
    or byte ptr es:[0x1a], 8; // Bitwise OR
    $1(); // Call function
    push($1); // Push value onto stack
    $1--; // Decrement value
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1(); // Call function
    jb 0x1b324; // Jump if below (unsigned)
    $1(); // Call function
    $1(); // Call function
    $1 = $2;
    and al, 3; // Bitwise AND
    add byte ptr es:[0x1b], al; // Add values
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    jcxz 0x1b322;
    // Compare $1 with $2 // Compare values
    jae 0x1b322; // Jump if above or equal (unsigned); Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    push($1); // Push value onto stack; Check if values are equal
    cmp byte ptr es:[0x1b], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    goto $1; // Jump to address
    $1(); // Call function
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 += $2; // Add values
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    ret ; // Return from function; Check if values are not equal
    ljmp 0:0xd87; // Check if values are not equal
    $1(); // Call function; Check if values are not equal
    cmp word ptr es:[0x18], 0x4d0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1(); // Call function
    mov word ptr es:[0x10], 0;
    ret ; // Return from function
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    push($1); // Push value onto stack
    $1 = $2;
    mov word ptr es:[0x1c], ax;
    *($1) = $2;
    $1(); // Call function
    sub word ptr [0xb0], ax; // Subtract values
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    loop 0x1b35b; // Loop (decrement CX and jump if CX!=0)
    $1 = $2; // Check if values are not equal
    *($1) = $2; // Check if values are not equal
    ret ; // Return from function; Check if values are not equal
    cmp word ptr es:[0xc], 0; // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    ret ; // Return from function; Check if values are equal
    cmp byte ptr es:[0x20], 0xea; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    jcxz 0x1b39d;
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    stosb byte ptr es:[di], al; // Store string byte/word
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word; Check if values are equal
    loop 0x1b3ab; // Loop (decrement CX and jump if CX!=0); Check if values are equal
    ret ; // Return from function; Check if values are equal
    cmp byte ptr es:[0x20], 0xcd; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 = 0; // Bitwise XOR
    $1(); // Call function
    mov word ptr es:[2], cx;
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    $1 = $2;
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = $2;
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 = 0; // Bitwise XOR
    stosb byte ptr es:[di], al; // Store string byte/word
    loop 0x1b3dd; // Loop (decrement CX and jump if CX!=0)
    ret ; // Return from function
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x10], ax;
    $1 = $2;
    $1++; // Increment value
    shr cx, 1; // Shift right (unsigned)
    $1 = 0; // Bitwise XOR
    cld ; // Clear direction flag
    // Compare $1 with $2 // Compare values
    jb 0x1b40f; // Jump if below (unsigned)
    $1 = $2;
    $1--; // Decrement value
    shl si, 1; // Shift left
    std ; // Set direction flag
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si]; // Copy string/memory block
    cld ; // Clear direction flag
    $1--; // Decrement value
    $1 = $2;
    $1 = pop(); // Pop value from stack
    *($1) = $2; // Check if values are equal
    $1++; // Increment value; Check if values are equal
    $1 = pop(); // Pop value from stack; Check if values are equal
    cmp byte ptr es:[0x20], 0xcd; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    cld ; // Clear direction flag
    stosw word ptr es:[di], ax; // Store string byte/word
    $1 += $2; // Add values
    loop 0x1b438; // Loop (decrement CX and jump if CX!=0)
    ret ; // Return from function
    $1(); // Call function
    add word ptr [0xb0], ax; // Add values
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    mov word ptr es:[0x1c], ax;
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1(); // Call function
    or bx, bx; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    xchg word ptr ss:[bx + 2], cx; // Exchange values
    ret ; // Return from function
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    goto $1; // Jump to address
    shl cx, 1; // Shift left
    $1 = $2;
    $1 = $2;
    shr cx, 1; // Shift right (unsigned); Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    jb 0x1b46f; // Jump if below (unsigned); Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    *($1) = $2;
    or bx, bx; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = $2;
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    ret ; // Return from function
    $1 = $2;
    or ax, ax; // Bitwise OR
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = $2;
    $1 = $2;
    $1 -= $2; // Subtract values
    jae 0x1b4aa; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 -= $2; // Subtract values
    stc ; // Set carry flag
    ret ; // Return from function
    $1 = $2;
    $1 += $2; // Add values
    $1 = $2;
    shr ax, cl; // Shift right (unsigned)
    ret ; // Return from function
    $1 = $2;
    $1 = $2;
    $1 += $2; // Add values
    shr ax, cl; // Shift right (unsigned)
    $1 = $2;
    $1 += $2; // Add values
    shr dx, cl; // Shift right (unsigned)
    $1 += $2; // Add values
    ret ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jb 0x1b4ff; // Jump if below (unsigned)
    // Compare $1 with $2 // Compare values
    jae 0x1b4ff; // Jump if above or equal (unsigned)
    $1--; // Decrement value
    $1 = $2;
    $1 = $2; // Check if values are not equal
    $1++; // Increment value; Check if values are not equal
    $1 = $2; // Check if values are not equal
    // Compare $1 with $2 // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    // Compare $1 with $2 // Compare values
    $1 = $2;
    if (ZF) goto $1; // Jump if equal (ZF=1)
    $1 = 0; // Bitwise XOR
    stc ; // Set carry flag
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    $1 -= $2; // Subtract values
    mov byte ptr [bp - 2], 0;
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1; // Jump to address
    shl si, 1; // Shift left
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x1b554; // Jump if above or equal (unsigned)
    $1 = $2;
    shr si, 1; // Shift right (unsigned)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jb 0x1b522; // Jump if below (unsigned)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x1b522; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    or di, di; // Bitwise OR; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr es:[di], ax; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    mov byte ptr [bp - 2], 1; // Check if values are equal
    mov word ptr es:[di + 2], di; // Check if values are equal
    goto $1; // Jump to address; Check if values are equal
    cmp byte ptr [bp - 2], 1; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1)
    goto $1; // Jump to address
    nop ; // No operation
    shl si, 1; // Shift left
    $1 = $2;
    $1 = $2;
    shr si, 1; // Shift right (unsigned)
    if (ZF) goto $1; // Jump if equal (ZF=1)
    jb 0x1b55d; // Jump if below (unsigned)
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x1b55d; // Jump if above or equal (unsigned)
    $1 = $2;
    $1 = $2; // Check if values are not equal
    or di, di; // Bitwise OR; Check if values are not equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp word ptr es:[0], ax; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are not equal
    cmp word ptr es:[2], 0; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    xchg word ptr es:[2], di; // Exchange values
    mov word ptr ss:[bx + 2], di;
    goto $1; // Jump to address
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are not equal
    $1 = $2; // Check if values are equal
    // Compare $1 with $2 // Compare values; Check if values are equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Check if values are equal
    cmp word ptr es:[0x10], 0; // Compare values; Check if values are equal
    if (ZF) goto $1; // Jump if equal (ZF=1); Check if values are not equal
    cmp byte ptr es:[0x20], 0xcd; // Compare values; Check if values are not equal
    if (!ZF) goto $1; // Jump if not equal (ZF=0); Prepare arguments and call function
    mov word ptr [bp + 8], 0; // Prepare arguments and call function
    push($1); // Push value onto stack; Prepare arguments and call function
    push($1); // Push value onto stack
    $1(); // Call function
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    push($1); // Push value onto stack
    $1 = $2;
    and al, 8; // Bitwise AND
    and byte ptr es:[0x1a], 0xf7; // Bitwise AND
    cwde ;
    $1 = $2;
    lcall [0x16];
    $1 = pop(); // Pop value from stack
    $1 = $2;
    *($1) = $2;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = $2;
    $1 = $2;
    $1(); // Call function
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2 // Compare values
    jae 0x1b61c; // Jump if above or equal (unsigned)
    $1 = $2;
    goto $1; // Jump to address
    shl bx, 1; // Shift left
    $1++; // Increment value
    push($1); // Push value onto stack
    $1 = $2;
    mul bx; // Multiply (unsigned)
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    lcall 0, 0x270c;
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = $2;
    or cx, dx; // Bitwise OR
    jcxz 0x1b64b;
    $1++; // Increment value
    $1 += $2; // Add values
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    $1 = 0; // Bitwise XOR
    push($1); // Push value onto stack
    push($1); // Push value onto stack
    nop ; // No operation
    push($1); // Push value onto stack
    $1(); // Call function
    or ax, ax; // Bitwise OR
    if (!ZF) goto $1; // Jump if not equal (ZF=0)
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    $1 = pop(); // Pop value from stack
    retf ; // Return from function
    ljmp 0:0x27a;
    ret ; // Return from function
    retf ; // Return from function
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    $1++; // Increment value
    adc byte ptr [bx + di], bl;
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    push($1); // Push value onto stack
    or word ptr [bx + di + 9], dx; // Bitwise OR
    push($1); // Push value onto stack
    or word ptr [si + 0xd], sp; // Bitwise OR
    add byte ptr [0], cl; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    $1 += $2; // Add values
    aas ;
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + si], al; // Add values
    push 0x14e; // Push value onto stack
    add byte ptr [bx + si], al; // Add values
    $1 += $2; // Add values
    $1 += $2; // Add values
    $1 += $2; // Add values
    add byte ptr [bx + si], cl; // Add values
    add byte ptr [si], ah; // Add values
    $1 += $2; // Add values
    add word ptr [bx + si], ax; // Add values
    str word ptr [bp + si + 5];
    jl 0x1b73e; // Jump if less (signed)
    add word ptr [bx + si], ax; // Add values
    add byte ptr [bx + si], al; // Add values
    jno 0x1b747;
    $1++; // Increment value
    $1 = pop(); // Pop value from stack
    add word ptr [bx + si], ax; // Add values
    or al, 0; // Bitwise OR
    in ax, 5; // Input from port
    $1 = $2;
    add word ptr [bx + si], ax; // Add values
    push($1); // Push value onto stack
    add byte ptr [bx + si], ah; // Add values
    push($1); // Push value onto stack
    $1++; // Increment value
    $1 += $2; // Add values
    $1 += $2; // Add values
    if (ZF) goto $1; // Jump if equal (ZF=1)
    cli ; // Clear interrupt flag
    $1 += $2; // Add values
    push($1); // Push value onto stack
    $1 += $2; // Add values
    push($1); // Push value onto stack
    jnp 0x1b768;
    add word ptr [bx + si], ax; // Add values
    or al, byte ptr [bx + si]; // Bitwise OR
    sbb al, byte ptr [bx];
    $1--; // Decrement value
    or byte ptr [bx + di], al; // Bitwise OR
    add byte ptr [si], cl; // Add values
    add byte ptr [bp + 0x4f07], bl; // Add values
    add word ptr [bx + di], ax; // Add values
    add byte ptr [si], cl; // Add values
    add byte ptr [bp + di + 0x1907], dh; // Add values
    $1 += $2; // Add values
    add byte ptr [bx + si], al; // Add values
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    $1 = $2;
    add byte ptr [bp + si], cl; // Add values
    $1 += $2; // Add values
    $1 = pop(); // Pop value from stack
    fld qword ptr [bx + si];
    add word ptr [bx + si], ax; // Add values
    or byte ptr [bx + si], al; // Bitwise OR
    or al, 8; // Bitwise OR
    nop ; // No operation
    $1 = pop(); // Pop value from stack
    add word ptr [bx + si], ax; // Add values
    push($1); // Push value onto stack
    add byte ptr [di - 0x5cf8], al; // Add values
    add word ptr [bx + di], ax; // Add values
    add byte ptr [bx + si], al; // Add values
    add byte ptr [bx + 0x2508], bl; // Add values
    or byte ptr [bx + di], al; // Bitwise OR
    add byte ptr [si], al; // Add values
    add byte ptr [bx + di], ah; // Add values
    or word ptr [bp + 0x103], dx; // Bitwise OR
    add byte ptr [0x5a00], al; // Add values
    or word ptr [bx], dx; // Bitwise OR
    add word ptr [bx + di], ax; // Add values
    add byte ptr [0x6b00], al; // Add values
    or word ptr [bp + di], di; // Bitwise OR
    $1 += $2; // Add values
    add byte ptr [bx + si], cl; // Add values
    add byte ptr [bp - 0x65f7], cl; // Add values
    $1 += $2; // Add values
    or al, 0; // Bitwise OR
    out 9, ax; // Output to port
    jb 0x1b7d0; // Jump if below (unsigned)
    add word ptr [bx + si], ax; // Add values
    or al, byte ptr [bx + si]; // Bitwise OR
    or cl, byte ptr cs:[di + 0x100]; // Bitwise OR
    add byte ptr [bp + si], al; // Add values
    add byte ptr [0xce0a], dh; // Add values
    add word ptr [bx + di], ax; // Add values
    add byte ptr [0x5200], cl; // Add values
    or dl, byte ptr [bx + si]; // Bitwise OR
    or word ptr [bx + di], ax; // Bitwise OR
    add byte ptr [0xe300], cl; // Add values
    or bl, byte ptr [bp + si + 2]; // Bitwise OR
    add word ptr [bx + si], ax; // Add values
    add byte ptr [bx + si], al; // Add values
    or byte ptr [bp + di], cl; // Bitwise OR
    retf ; // Return from function
    $1 += $2; // Add values
    add byte ptr [bp + si], cl; // Add values
    add byte ptr [si + 0xb], al; // Add values
    adc al, byte ptr [di];
    add word ptr [bx + si], ax; // Add values
    or al, 0; // Bitwise OR
    xchg bp, ax; // Exchange values
    or sp, word ptr [bx]; // Bitwise OR
    $1 += $2; // Add values
    add byte ptr [bp + si], al; // Add values
    $1 += $2; // Add values
    or bx, word ptr [bp + di + 9]; // Bitwise OR
    add word ptr [bx + si], ax; // Add values
    or byte ptr [bx + si], al; // Bitwise OR
    insb byte ptr es:[di], dx;
    or al, 8; // Bitwise OR
    $1 += $2; // Add values
    add byte ptr [si], cl; // Add values
    add byte ptr [si - 0x44f4], ch; // Add values
    or word ptr [bx + di], ax; // Bitwise OR
    add byte ptr [bx + si], cl; // Add values
    add byte ptr [bx + 0xd], al; // Add values
    jg 0x1b829; // Jump if greater (signed)
    add word ptr [bx + si], ax; // Add values
    or al, 0; // Bitwise OR
    lahf ;
    or ax, 0x14d6; // Bitwise OR
    add word ptr [bx + si], ax; // Add values
    add byte ptr [bx + si], al; // Add values
    in al, dx; // Input from port
    push($1); // Push value onto stack
    test al, 0xf; // Test bits (AND without storing)
    add word ptr [bx + si], ax; // Add values
    push($1); // Push value onto stack
    $1 += $2; // Add values
}

void sub_102B1(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 16

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 37 if statements

    // Block 0x102B1
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_102B1(); // Manipulates strings or memory blocks and performs calculations
    sub_102B1(); // Manipulates strings or memory blocks and performs calculations
    sub_102B1(); // Manipulates strings or memory blocks and performs calculations
    sub_102B1(); // Manipulates strings or memory blocks and performs calculations
    sub_102B1(); // Manipulates strings or memory blocks and performs calculations
    sub_102B1(); // Manipulates strings or memory blocks and performs calculations
}

void sub_106BF(int) {
    // Purpose: Handles mouse input and manipulates strings or memory blocks and performs calculations

    // Complexity: 32

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 60 if statements

    // Block 0x106BF
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_106BF(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_106BF(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_106BF(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_10E93(); // Unknown function purpose
    sub_10ECE(); // Performs arithmetic calculations
    sub_114B2(); // Handles mouse input and performs calculations
}

void sub_10BCD(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int game_state_6C_i;
    int game_state_6E_i;
    int game_state_80_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x10BCD
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bl;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0x10c91
        // Block 0x10C91
        cld ;
        $1 = $2;
        $1 = $2;
        xchg al, ah;
        stosw word ptr es:[di], ax;
        $1++;
        $1++;
        loop 0x10c95;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        cld ;
        $1 = $2;
        $1 = $2;
        xchg al, ah;
        stosw word ptr es:[di], ax;
        $1++;
        $1++;
        loop 0x10caa;
        jmp 0x10daa;
        // Block 0x10DAA
        $1 = $2;
        *($1) = $2;
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x10C81
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x10cb6
            // Block 0x10CB6
            cld ;
            mov dx, 0x10;
        } else {
            // Block 0x10C86
            // Compare $1 with $2
            if (a != b) {  // jne 0x10c8e
                // Block 0x10C8E
                jmp 0x10d61;
                // Block 0x10D61
                cld ;
                mov dx, 0x10;
            } else {
                // Block 0x10C8B
                jmp 0x10d24;
                // Block 0x10D24
                cld ;
                mov dx, 0x10;
            }
        }
    }
}

void sub_10DC0(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x10DC0
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    lcall 0x71a, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    *($1) = $2;
    *($1) = $2;
    return;  // ret 
}

void sub_10E6D(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x10E6D
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    return;  // ret 
}

void sub_10E93(void) {
    // Purpose: Unknown function purpose

    // Complexity: 2

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x10E93
    // Compare $1 with $2
    if (a >= b) {  // jge 0x10e9f
        // Block 0x10E9F
        // Compare $1 with $2
        if (a <= b) {  // jle 0x10ea9
            // Block 0x10EA9
            // Compare $1 with $2
            if (a >= b) {  // jge 0x10eb5
                // Block 0x10EB5
                // Compare $1 with $2
                if (a <= b) {  // jle 0x10ebf
                    // Block 0x10EBF
                    pushf ;
                    cli ;
                    *($1) = $2;
                    *($1) = $2;
                    popf ;
                    call 0x11a48;
                    // Block 0x10ECD
                    return;  // ret 
                } else {
                    // Block 0x10EBB
                    mov di, word ptr [0x5cd0];
                }
            } else {
                // Block 0x10EAF
                $1 = $2;
                jmp 0x10ebf;
                // Block 0x10EBF
                pushf ;
                cli ;
                *($1) = $2;
                *($1) = $2;
                popf ;
                call 0x11a48;
                // Block 0x10ECD
                return;  // ret 
            }
        } else {
            // Block 0x10EA5
            mov si, word ptr [0x5cce];
        }
    } else {
        // Block 0x10E99
        $1 = $2;
        jmp 0x10ea9;
        // Block 0x10EA9
        // Compare $1 with $2
        if (a >= b) {  // jge 0x10eb5
            // Block 0x10EB5
            // Compare $1 with $2
            if (a <= b) {  // jle 0x10ebf
                // Block 0x10EBF
                pushf ;
                cli ;
                *($1) = $2;
                *($1) = $2;
                popf ;
                call 0x11a48;
                // Block 0x10ECD
                return;  // ret 
            } else {
                // Block 0x10EBB
                mov di, word ptr [0x5cd0];
            }
        } else {
            // Block 0x10EAF
            $1 = $2;
            jmp 0x10ebf;
            // Block 0x10EBF
            pushf ;
            cli ;
            *($1) = $2;
            *($1) = $2;
            popf ;
            call 0x11a48;
            // Block 0x10ECD
            return;  // ret 
        }
    }

    // Function calls:
    sub_11A48(); // Unknown function purpose
}

void sub_10ECE(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 10

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int game_state_8E_i;
    int game_state_90_i;
    int game_state_92_i;
    int game_state_94_i;
    int game_state_96_i;
    int game_state_98_i;
    int game_state_9A_i;
    int game_state_9C_i;
    int game_state_9E_i;
    int game_state_A0_i;
    int result_ax;
    int source_si;
    char var_F3_c;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x10ECE
    $1 -= $2;
    $1 -= $2;
    cmp word ptr [0x5c74], 0;
    if (a == b) {  // je 0x10ee3
        // Block 0x10EE3
        push($1);
        $1 = 0;
        push($1);
        lcall 0x98e, 0x53a;
        *($1) = $2;
        test byte ptr [0x5c7a], 0xff;
        if (a == b) {  // je 0x10ef9
            // Block 0x10EF9
            $1 = pop();
            $1 = $2;
            xchg word ptr [0x5cd4], bx;
            or ax, bx;
            if (a == b) {  // je 0x10f07
                // Block 0x10F07
                cmp word ptr [0x5c86], si;
                if (a > b) {  // jg 0x10f33
                    // Block 0x10F33
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f44
                        // Block 0x10F44
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        mov word ptr var_5C9A, si;
                    } else {
                        // Block 0x10F41
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x10F0D
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f1f
                        // Block 0x10F1F
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        jmp 0x10f56;
                        // Block 0x10F56
                        cmp word ptr [0x5c88], di;
                        if (a > b) {  // jg 0x10f82
                            // Block 0x10F82
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f93
                                // Block 0x10F93
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr var_5C9C, di;
                            } else {
                                // Block 0x10F90
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0x10F5C
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f6e
                                // Block 0x10F6E
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x10fa5;
                                // Block 0x10FA5
                                $1 = 0;
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                lcall 0x71a, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                push($1);
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 += $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                lcall 0xa52, 0xe;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x110ad;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x10F6B
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x10F1C
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x10F04
                jmp 0x1109c;
                // Block 0x1109C
                or bx, bx;
                if (a != b) {  // jne 0x110a3
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                } else {
                    // Block 0x110A0
                    call 0x10e6d;
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                }
            }
        } else {
            // Block 0x10EF6
            call 0x1183c;
            // Block 0x10EF9
            $1 = pop();
            $1 = $2;
            xchg word ptr [0x5cd4], bx;
            or ax, bx;
            if (a == b) {  // je 0x10f07
                // Block 0x10F07
                cmp word ptr [0x5c86], si;
                if (a > b) {  // jg 0x10f33
                    // Block 0x10F33
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f44
                        // Block 0x10F44
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        mov word ptr var_5C9A, si;
                    } else {
                        // Block 0x10F41
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x10F0D
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f1f
                        // Block 0x10F1F
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        jmp 0x10f56;
                        // Block 0x10F56
                        cmp word ptr [0x5c88], di;
                        if (a > b) {  // jg 0x10f82
                            // Block 0x10F82
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f93
                                // Block 0x10F93
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr var_5C9C, di;
                            } else {
                                // Block 0x10F90
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0x10F5C
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f6e
                                // Block 0x10F6E
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x10fa5;
                                // Block 0x10FA5
                                $1 = 0;
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                lcall 0x71a, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                push($1);
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 += $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                lcall 0xa52, 0xe;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x110ad;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x10F6B
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x10F1C
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x10F04
                jmp 0x1109c;
                // Block 0x1109C
                or bx, bx;
                if (a != b) {  // jne 0x110a3
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                } else {
                    // Block 0x110A0
                    call 0x10e6d;
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x10EDD
        *($1) = $2;
        jmp 0x110c0;
        // Block 0x110C0
        return;  // ret 
    }

    // Function calls:
    sub_1183C(); // Sets video mode
    sub_10E6D(); // Performs arithmetic calculations
    sub_10DC0(); // Performs arithmetic calculations
    sub_1193C(); // Performs video operations
}

void sub_110C1(int) {
    // Purpose: Performs DOS operations and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int game_state_74_i;
    int game_state_80_i;
    int game_state_82_i;
    int game_state_84_i;
    int game_state_8A_i;
    int game_state_8C_i;
    int game_state_A2_i;
    int game_state_A8_i;
    int game_state_AE_i;
    int game_state_B4_i;
    int game_state_BA_i;
    int game_state_C0_i;
    int game_state_CA_i;
    int game_state_CC_i;
    int game_state_CE_i;
    int game_state_D0_i;
    int game_state_D2_i;
    int game_state_D4_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x110C1
    $1 = 0;
    mov word ptr [0x5c70], 0;
    mov word ptr [0x5c80], 0xffff;
    mov word ptr [0x5c74], 0xffff;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [0x5c8a], 0xf;
    mov word ptr [0x5c8c], 0xf;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    cmp word ptr [0x5ce6], 0;
    if (a != b) {  // jne 0x11127
        // Block 0x11127
        $1 = $2;
        shr ax, 1;
        push($1);
        $1 = $2;
        shr ax, 1;
        push ax;
    } else {
        // Block 0x1111D
        $1 = $2;
        push($1);
        $1 = $2;
        push($1);
        jmp 0x11133;
        // Block 0x11133
        push($1);
        call 0x114f8;
        // Block 0x11137
        return;  // ret 
    }

    // Function calls:
    sub_114F8(); // Handles mouse input and performs calculations
    sub_11A23(); // Unknown function purpose
    sub_11576(); // Manipulates strings or memory blocks and performs calculations
    sub_110C1(); // Performs DOS operations and performs calculations
    sub_11249(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_11249(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
}

void sub_11249(int) {
    // Purpose: Handles mouse input and manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int game_state_74_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x11249
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 0;
    if (a != b) {  // jne 0x11273
        // Block 0x11273
        cmp word ptr [bp + 6], 1;
        if (a == b) {  // je 0x1128e
            // Block 0x1128E
            cmp word ptr [0x5c74], 0;
            if (a == b) {  // je 0x112cd
                // Block 0x112CD
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            } else {
                // Block 0x11295
                $1 = $2;
                $1 = $2;
                call 0x11a48;
                // Block 0x112A0
                $1 = $2;
                $1++;
                push($1);
                or bx, ax;
                xchg word ptr [0x5cd4], ax;
                or bx, ax;
                if (a != b) {  // jne 0x112c8
                    // Block 0x112C8
                    $1 = pop();
                    mov word ptr var_5C74, bx;
                } else {
                    // Block 0x112B0
                    $1 = $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0x112bd
                        // Block 0x112BD
                        $1 -= $2;
                        $1 -= $2;
                        call 0x10dc0;
                        // Block 0x112C8
                        $1 = pop();
                        mov word ptr var_5C74, bx;
                    } else {
                        // Block 0x112B9
                        push($1);
                        call 0x10bcd;
                        // Block 0x112BD
                        $1 -= $2;
                        $1 -= $2;
                        call 0x10dc0;
                        // Block 0x112C8
                        $1 = pop();
                        mov word ptr var_5C74, bx;
                    }
                }
            }
        } else {
            // Block 0x11279
            $1 = $2;
            $1 = $2;
            $1--;
            *($1) = $2;
            or ax, word ptr [0x5cd4];
            if (a != b) {  // jne 0x112cd
                // Block 0x112CD
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            } else {
                // Block 0x11289
                call 0x10e6d;
                // Block 0x1128C
                jmp 0x112cd;
                // Block 0x112CD
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            }
        }
    } else {
        // Block 0x1125F
        cmp word ptr [bp + 6], 1;
        if (a != b) {  // jne 0x1126c
            // Block 0x1126C
            $1 = $2;
            int 0x33;
            jmp 0x112cd;
            // Block 0x112CD
            mov word ptr [bp - 2], 0;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        } else {
            // Block 0x11265
            $1 = $2;
            int 0x33;
            jmp 0x112cd;
            // Block 0x112CD
            mov word ptr [bp - 2], 0;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    }

    // Function calls:
    sub_10E6D(); // Performs arithmetic calculations
    sub_11A48(); // Unknown function purpose
    sub_10BCD(); // Manipulates strings or memory blocks and performs calculations
    sub_10DC0(); // Performs arithmetic calculations
    sub_11249(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_11249(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
}

void sub_114B2(int) {
    // Purpose: Handles mouse input and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x114B2
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 0;
    if (a != b) {  // jne 0x114cf
        // Block 0x114CF
        pushf ;
        cli ;
        $1 = $2;
        $1 = $2;
        popf ;
    } else {
        // Block 0x114C8
        $1 = $2;
        int 0x33;
        jmp 0x114da;
        // Block 0x114DA
        les di, ptr [bp + 0xa];
        mov word ptr es:[di], cx;
        les di, ptr [bp + 6];
        mov word ptr es:[di], dx;
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }
}

void sub_114F8(int) {
    // Purpose: Handles mouse input and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x114F8
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 1;
    if (a == b) {  // je 0x1151b
        // Block 0x1151B
        $1 = $2;
        $1 = $2;
        call 0x10e93;
        // Block 0x11524
        pushf ;
        cli ;
        cmp word ptr [0x5c74], 0;
        if (a != b) {  // jne 0x11530
            // Block 0x11530
            popf ;
        } else {
            // Block 0x1152D
            call 0x10ece;
            // Block 0x11530
            popf ;
        }
    } else {
        // Block 0x1150E
        $1 = $2;
        $1 = $2;
        $1 = $2;
        int 0x33;
        jmp 0x11531;
        // Block 0x11531
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_10E93(); // Unknown function purpose
    sub_10ECE(); // Performs arithmetic calculations
}

void sub_11576(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int game_state_7C_i;
    int game_state_7E_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x11576
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b) {  // jl 0x11592
        // Block 0x11592
        mov word ptr [bp - 2], 0xf05c;
        jmp 0x115c1;
        // Block 0x115C1
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    } else {
        // Block 0x1158D
        // Compare $1 with $2
        if (a <= b) {  // jle 0x11599
            // Block 0x11599
            $1 = $2;
            push($1);
            push($1);
            call 0x11249;
            // Block 0x115A1
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            push($1);
            call 0x10bcd;
            // Block 0x115B1
            call 0x117c2;
            // Block 0x115B4
            $1 = $2;
            push($1);
            push($1);
            call 0x11249;
            // Block 0x115BC
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x11592
            mov word ptr [bp - 2], 0xf05c;
            jmp 0x115c1;
            // Block 0x115C1
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        }
    }

    // Function calls:
    sub_11249(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_10BCD(); // Manipulates strings or memory blocks and performs calculations
    sub_117C2(); // Performs arithmetic calculations
    sub_11249(); // Handles mouse input and manipulates strings or memory blocks and performs calculations
    sub_110C1(); // Performs DOS operations and performs calculations
    sub_117C2(); // Performs arithmetic calculations
    sub_11A48(); // Unknown function purpose
    sub_10ECE(); // Performs arithmetic calculations
    sub_11A48(); // Unknown function purpose
    sub_10ECE(); // Performs arithmetic calculations
}

void sub_117C2(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x117C2
    push($1);
    lcall 0x98e, 0x12a;
    if (a < b (unsigned)) {  // jb 0x1183b
        // Block 0x1183B
        return;  // ret 
    } else {
        // Block 0x117CD
        $1 = $2;
        $1 = $2;
        push($1);
        $1 = $2;
        $1 = 0;
        $1 = $2;
        $1 -= $2;
        $1--;
        $1 += $2;
        $1++;
        if (a >= b) {  // jge 0x117eb
            // Block 0x117EB
            mul bx;
            and ax, 0xfff8;
            $1 = 0;
            div bx;
            *($1) = $2;
            $1 = $2;
            $1 -= $2;
            $1--;
            $1 += $2;
            $1++;
            if (a >= b) {  // jge 0x11808
                // Block 0x11808
                *($1) = $2;
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x11819
                    // Block 0x11819
                    mul bx;
                    $1 += $2;
                    and ax, 0xfff8;
                    $1 = 0;
                    div bx;
                    $1--;
                    *($1) = $2;
                    $1 = $2;
                    $1 += $2;
                    $1 = pop();
                    // Compare $1 with $2
                    if (a < b (unsigned)) {  // jb 0x11838
                        // Block 0x11838
                        mov word ptr [0x5cdc], ax;
                    } else {
                        // Block 0x11835
                        $1 = $2;
                        dec ax;
                    }
                } else {
                    // Block 0x11816
                    $1 = $2;
                    dec ax;
                }
            } else {
                // Block 0x11806
                xor ax, ax;
            }
        } else {
            // Block 0x117E9
            xor ax, ax;
        }
    }
}

void sub_1183C(int) {
    // Purpose: Sets video mode

    // Complexity: 10

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x1183C
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x11856
        // Block 0x11856
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        jmp 0x1193b;
        // Block 0x1193B
        return;  // ret 
    } else {
        // Block 0x11844
        // Compare $1 with $2
        if (a == b) {  // je 0x11856
            // Block 0x11856
            $1 = $2;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            jmp 0x1193b;
            // Block 0x1193B
            return;  // ret 
        } else {
            // Block 0x11849
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0x118a2
                // Block 0x118A2
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x118b4
                    // Block 0x118B4
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x118c6
                        // Block 0x118C6
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x118e8
                            // Block 0x118E8
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x118fa
                                // Block 0x118FA
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x11908
                                    // Block 0x11908
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x1191c
                                        // Block 0x1191C
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x1193b
                                            // Block 0x1193B
                                            return;  // ret 
                                        } else {
                                            // Block 0x11921
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            INT_10_AH4F();  // int 0x10
                                            *($1) = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            INT_10_AH4F();  // int 0x10
                                            mov byte ptr [0x65f0], dl;
                                        }
                                    } else {
                                        // Block 0x1190D
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, al;
                                        $1++;
                                        in al, dx;
                                        xor al, 2;
                                        *($1) = $2;
                                        jmp 0x1193b;
                                        // Block 0x1193B
                                        return;  // ret 
                                    }
                                } else {
                                    // Block 0x118FF
                                    $1 = $2;
                                    in al, dx;
                                    *($1) = $2;
                                    jmp 0x1193b;
                                    // Block 0x1193B
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x118ED
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                *($1) = $2;
                                jmp 0x1193b;
                                // Block 0x1193B
                                return;  // ret 
                            }
                        } else {
                            // Block 0x118CB
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            *($1) = $2;
                            $1--;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            *($1) = $2;
                            $1 = $2;
                            in al, dx;
                            *($1) = $2;
                            jmp 0x1193b;
                            // Block 0x1193B
                            return;  // ret 
                        }
                    } else {
                        // Block 0x118B9
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        *($1) = $2;
                        jmp 0x1193b;
                        // Block 0x1193B
                        return;  // ret 
                    }
                } else {
                    // Block 0x118AA
                    $1 = $2;
                    in al, dx;
                    *($1) = $2;
                    jmp 0x1193b;
                    // Block 0x1193B
                    return;  // ret 
                }
            } else {
                // Block 0x1184E
                // Compare $1 with $2
                if (a >= b (unsigned)) {  // jae 0x11856
                    // Block 0x11856
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    jmp 0x1193b;
                    // Block 0x1193B
                    return;  // ret 
                } else {
                    // Block 0x11853
                    jmp 0x1193b;
                    // Block 0x1193B
                    return;  // ret 
                }
            }
        }
    }
}

void sub_1193C(int) {
    // Purpose: Performs video operations

    // Complexity: 10

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x1193C
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x11956
        // Block 0x11956
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        jmp 0x11a22;
        // Block 0x11A22
        return;  // ret 
    } else {
        // Block 0x11944
        // Compare $1 with $2
        if (a == b) {  // je 0x11956
            // Block 0x11956
            $1 = $2;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            jmp 0x11a22;
            // Block 0x11A22
            return;  // ret 
        } else {
            // Block 0x11949
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0x11990
                // Block 0x11990
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x119a2
                    // Block 0x119A2
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x119b3
                        // Block 0x119B3
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x119d2
                            // Block 0x119D2
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x119e3
                                // Block 0x119E3
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x119f1
                                    // Block 0x119F1
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x11a02
                                        // Block 0x11A02
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x11a22
                                            // Block 0x11A22
                                            return;  // ret 
                                        } else {
                                            // Block 0x11A07
                                            $1 = 0;
                                            $1 = 0;
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            INT_10_AH4F();  // int 0x10
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            int 0x10;
                                        }
                                    } else {
                                        // Block 0x119F6
                                        $1 = $2;
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, ax;
                                        jmp 0x11a22;
                                        // Block 0x11A22
                                        return;  // ret 
                                    }
                                } else {
                                    // Block 0x119E8
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    jmp 0x11a22;
                                    // Block 0x11A22
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x119D7
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                out dx, ax;
                                jmp 0x11a22;
                                // Block 0x11A22
                                return;  // ret 
                            }
                        } else {
                            // Block 0x119B8
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            out dx, ax;
                            $1 = $2;
                            $1 = $2;
                            out dx, ax;
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            jmp 0x11a22;
                            // Block 0x11A22
                            return;  // ret 
                        }
                    } else {
                        // Block 0x119A7
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        out dx, ax;
                        jmp 0x11a22;
                        // Block 0x11A22
                        return;  // ret 
                    }
                } else {
                    // Block 0x11998
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    jmp 0x11a22;
                    // Block 0x11A22
                    return;  // ret 
                }
            } else {
                // Block 0x1194E
                // Compare $1 with $2
                if (a >= b (unsigned)) {  // jae 0x11956
                    // Block 0x11956
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    jmp 0x11a22;
                    // Block 0x11A22
                    return;  // ret 
                } else {
                    // Block 0x11953
                    jmp 0x11a22;
                    // Block 0x11A22
                    return;  // ret 
                }
            }
        }
    }
}

void sub_11A23(int) {
    // Purpose: Unknown function purpose

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x11A23
    $1 = $2;
    INT_10();  // int 0x10
    // Compare $1 with $2
    if (a != b) {  // jne 0x11a40
        // Block 0x11A40
        $1 = 0;
        jmp 0x11a47;
        // Block 0x11A47
        return;  // ret 
    } else {
        // Block 0x11A2C
        // Compare $1 with $2
        if (a == b) {  // je 0x11a44
            // Block 0x11A44
            mov ax, 1;
        } else {
            // Block 0x11A31
            // Compare $1 with $2
            if (a == b) {  // je 0x11a44
                // Block 0x11A44
                mov ax, 1;
            } else {
                // Block 0x11A36
                // Compare $1 with $2
                if (a == b) {  // je 0x11a44
                    // Block 0x11A44
                    mov ax, 1;
                } else {
                    // Block 0x11A3B
                    // Compare $1 with $2
                    if (a == b) {  // je 0x11a44
                        // Block 0x11A44
                        mov ax, 1;
                    } else {
                        // Block 0x11A40
                        $1 = 0;
                        jmp 0x11a47;
                        // Block 0x11A47
                        return;  // ret 
                    }
                }
            }
        }
    }
}

void sub_11A48(void) {
    // Purpose: Unknown function purpose

    // Complexity: 3

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x11A48
    $1 = 0;
    // Compare $1 with $2
    if (a < b) {  // jl 0x11a63
        // Block 0x11A63
        and ax, word ptr [0x5cd2];
        return;  // ret 
    } else {
        // Block 0x11A50
        // Compare $1 with $2
        if (a < b) {  // jl 0x11a63
            // Block 0x11A63
            and ax, word ptr [0x5cd2];
            return;  // ret 
        } else {
            // Block 0x11A56
            // Compare $1 with $2
            if (a > b) {  // jg 0x11a63
                // Block 0x11A63
                and ax, word ptr [0x5cd2];
                return;  // ret 
            } else {
                // Block 0x11A5C
                // Compare $1 with $2
                if (a > b) {  // jg 0x11a63
                    // Block 0x11A63
                    and ax, word ptr [0x5cd2];
                    return;  // ret 
                } else {
                    // Block 0x11A62
                    inc ax;
                }
            }
        }
    }
}

void sub_11A68(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 16 if statements

    // Block 0x11A68
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    or bx, ax;
    $1 = $2;
    *($1) = $2;
    or bx, ax;
    or bx, bx;
    if (a != b) {  // jne 0x11acf
        // Block 0x11ACF
        $1 = $2;
        shl bx, 1;
        shl bx, 1;
        $1 = $2;
        les di, ptr [0x54c1];
        lds si, ptr [bp + 0x10];
        lds si, ptr [si];
        $1 = $2;
        $1 = $2;
        lds si, ptr [bp + 0x10];
        $1 += $2;
        $1 -= $2;
        *($1) = $2;
        *($1) = $2;
        sub word ptr [bp - 0x22], bx;
        if (a >= b (unsigned)) {  // jae 0x11b00
            // Block 0x11B00
            $1 = $2;
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            lodsw ax, word ptr [si];
            $1 = $2;
            lodsw ax, word ptr [si];
            cmp word ptr [bp - 4], 1;
            if (a != b) {  // jne 0x11b31
                // Block 0x11B31
                $1 += $2;
                $1 += $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x11b3f
                    // Block 0x11B3F
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x11b47
                        // Block 0x11B47
                        xchg bx, ax;
                        stosw word ptr es:[di], ax;
                        $1 = $2;
                        stosw word ptr es:[di], ax;
                        loop 0x11b13;
                        $1 = $2;
                        $1 -= $2;
                        inc dx;
                    } else {
                        // Block 0x11B44
                        mov word ptr [bp - 0x26], ax;
                    }
                } else {
                    // Block 0x11B3C
                    mov word ptr [bp - 0x24], ax;
                }
            } else {
                // Block 0x11B1D
                push($1);
                push($1);
                push($1);
                lcall 0x1214, 0x21c;
                *($1) = $2;
                lcall 0x1214, 0x26c;
                $1 = $2;
                pop cx;
            }
        } else {
            // Block 0x11AF8
            mov word ptr [bp - 2], 0xfffe;
            jmp 0x11cf3;
            // Block 0x11CF3
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xe
        }
    } else {
        // Block 0x11A9E
        lds si, ptr [bp + 0x10];
        lds si, ptr [si];
        $1 = $2;
        $1++;
        $1++;
        lodsw ax, word ptr [si];
        $1 = $2;
        $1 = $2;
        $1--;
        $1++;
        $1++;
        lodsw ax, word ptr [si];
        // Compare $1 with $2
        if (a >= b) {  // jge 0x11abb
            // Block 0x11ABB
            // Compare $1 with $2
            if (a <= b) {  // jle 0x11ac1
                // Block 0x11AC1
                loop 0x11aae;
            } else {
                // Block 0x11ABF
                mov dx, ax;
            }
        } else {
            // Block 0x11AB5
            $1 = $2;
            loop 0x11aae;
            jmp 0x11ac3;
            // Block 0x11AC3
            *($1) = $2;
            *($1) = $2;
            $1 -= $2;
            $1++;
            jmp 0x11b55;
            // Block 0x11B55
            $1 = $2;
            shl dx, 1;
            *($1) = $2;
            $1 = $2;
            $1 = $2;
            les di, ptr [0x54c1];
            $1 = $2;
            $1 = 0;
            rep stosw word ptr es:[di], ax;
            $1 = $2;
            lds si, ptr [bp + 0x10];
            lds si, ptr [si];
            $1 = $2;
            $1 -= $2;
            shl bx, 1;
            shl bx, 1;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 += $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 += $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = 0;
            mov word ptr [bp - 6], ax;
        }
    }
}

void sub_11D00(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x11D00
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [0x54c1];
    mov word ptr [bp - 6], 0;
    $1 = $2;
    mov word ptr [bp - 4], ax;
}

void sub_11DD9(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x11DD9
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b) {  // jle 0x11df9
        // Block 0x11DF9
        cmp word ptr [si + 0x26], 1;
        if (a == b) {  // je 0x11e21
            // Block 0x11E21
            $1 = $2;
            $1 = $2;
            mul bx;
            $1 = $2;
            $1 += $2;
            $1 = $2;
            and cx, 7;
            $1 = $2;
            and bx, 7;
            $1 = $2;
            $1 = $2;
            rol ax, cl;
            *($1) = $2;
            push($1);
            push($1);
            push($1);
            push($1);
            lcall 0xd9f, 0x178;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 6
        } else {
            // Block 0x11DFF
            mov word ptr [si + 0x28], 0xffff;
            $1 = $2;
            *($1) = $2;
            push($1);
            push($1);
            push($1);
            push($1);
            lcall 0xd9f, 0x178;
            $1 = $2;
            mov word ptr [si + 0xc], ax;
        }
    } else {
        // Block 0x11DF3
        xchg word ptr [bp + 6], ax;
        mov word ptr [bp + 0xa], ax;
    }
}

void sub_11E61(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 7

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 23 if statements

    // Block 0x11E61
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    les di, ptr [0x54c1];
    lea ax, [bp + 8];
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x14];
    push($1);
    push($1);
    lea ax, [bp - 0x16];
    push($1);
    push($1);
    push($1);
    call 0x11a68;
    // Block 0x11EC1
    // Compare $1 with $2
    if (a == b) {  // je 0x11ecc
        // Block 0x11ECC
        mov word ptr [si + 0x3c], 0;
        $1 = 0;
        *($1) = $2;
        *($1) = $2;
        mov word ptr [bp - 0x1c], 0;
        $1 = $2;
        mov word ptr [bp - 0x1e], bx;
    } else {
        // Block 0x11EC6
        *($1) = $2;
        jmp 0x11ff2;
        // Block 0x11FF2
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 6
    }

    // Function calls:
    sub_11A68(); // Manipulates strings or memory blocks and performs calculations
    sub_11D00(); // Performs arithmetic calculations
    sub_11DD9(); // Performs arithmetic calculations
    sub_11E61(); // Performs arithmetic calculations
    sub_12166(); // Performs DOS operations and performs calculations
}

void sub_12166(int) {
    // Purpose: Performs DOS operations and performs calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x12166
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (a != b) {  // jne 0x121aa
        // Block 0x121AA
        $1 = $2;
        // Compare $1 with $2
        if (a >= b) {  // jge 0x121b8
            // Block 0x121B8
            $1 = $2;
            // Compare $1 with $2
            if (a >= b) {  // jge 0x121c6
                // Block 0x121C6
                $1 = $2;
                *($1) = $2;
                mov word ptr [si + 0x3c], 0;
                cmp word ptr [bp + 6], 2;
                if (a != b) {  // jne 0x121da
                    // Block 0x121DA
                    $1 = $2;
                    $1--;
                    $1 = $2;
                    $1 -= $2;
                    $1--;
                    $1 -= $2;
                    // Compare $1 with $2
                    if (a < b) {  // jl 0x121fa
                        // Block 0x121FA
                        $1 = $2;
                        shr bx, 1;
                        sub word ptr [bp + 0xe], bx;
                        sub word ptr [bp + 0xc], bx;
                        add word ptr [bp + 0xa], bx;
                        add word ptr [bp + 8], bx;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        cmp word ptr [si + 0x28], -1;
                        if (a == b) {  // je 0x1221d
                            // Block 0x1221D
                            cmp word ptr [si + 0x16], 0;
                            if (a != b) {  // jne 0x12226
                                // Block 0x12226
                                jmp 0x122de;
                                // Block 0x122DE
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [si + 0x2a], 1;
                                mov di, word ptr [bp + 0xc];
                            } else {
                                // Block 0x12223
                                jmp 0x122b0;
                                // Block 0x122B0
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xbd7, 8;
                                $1 = $2;
                                *($1) = $2;
                                jmp 0x123a3;
                                // Block 0x123A3
                                $1 = $2;
                                mov word ptr [si + 0x10], 1;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [bp - 2], 0;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x1221A
                            jmp 0x122de;
                            // Block 0x122DE
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            mov word ptr [si + 0x2a], 1;
                            mov di, word ptr [bp + 0xc];
                        }
                    } else {
                        // Block 0x121EC
                        $1 = $2;
                        $1 -= $2;
                        $1--;
                        $1 -= $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x12229
                            // Block 0x12229
                            $1 = $2;
                            shr di, 1;
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            push($1);
                            lcall 0xd9f, 0x178;
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            push($1);
                            lcall 0xd9f, 0x178;
                            $1++;
                            push($1);
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            lcall 0xd9f, 0x178;
                            push($1);
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            lcall 0xd9f, 0x178;
                            test word ptr [bp + 6], 2;
                            if (a != b) {  // jne 0x12295
                                // Block 0x12295
                                add word ptr [bp + 0xe], di;
                                add word ptr [bp + 0xc], di;
                                sub word ptr [bp + 0xa], di;
                                sub word ptr [bp + 8], di;
                            } else {
                                // Block 0x12292
                                jmp 0x123a3;
                                // Block 0x123A3
                                $1 = $2;
                                mov word ptr [si + 0x10], 1;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [bp - 2], 0;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x121FA
                            $1 = $2;
                            shr bx, 1;
                            sub word ptr [bp + 0xe], bx;
                            sub word ptr [bp + 0xc], bx;
                            add word ptr [bp + 0xa], bx;
                            add word ptr [bp + 8], bx;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            cmp word ptr [si + 0x28], -1;
                            if (a == b) {  // je 0x1221d
                                // Block 0x1221D
                                cmp word ptr [si + 0x16], 0;
                                if (a != b) {  // jne 0x12226
                                    // Block 0x12226
                                    jmp 0x122de;
                                    // Block 0x122DE
                                    $1 = $2;
                                    *($1) = $2;
                                    *($1) = $2;
                                    $1 = $2;
                                    *($1) = $2;
                                    mov word ptr [si + 0x2a], 1;
                                    mov di, word ptr [bp + 0xc];
                                } else {
                                    // Block 0x12223
                                    jmp 0x122b0;
                                    // Block 0x122B0
                                    $1 = $2;
                                    *($1) = $2;
                                    *($1) = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall 0xbd7, 8;
                                    $1 = $2;
                                    *($1) = $2;
                                    jmp 0x123a3;
                                    // Block 0x123A3
                                    $1 = $2;
                                    mov word ptr [si + 0x10], 1;
                                    $1 = $2;
                                    *($1) = $2;
                                    mov word ptr [bp - 2], 0;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0xa
                                }
                            } else {
                                // Block 0x1221A
                                jmp 0x122de;
                                // Block 0x122DE
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [si + 0x2a], 1;
                                mov di, word ptr [bp + 0xc];
                            }
                        }
                    }
                } else {
                    // Block 0x121D7
                    jmp 0x122a1;
                    // Block 0x122A1
                    $1 = $2;
                    cmp word ptr [si + 0x22], 0;
                    if (a != b) {  // jne 0x1230b
                        // Block 0x1230B
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        mov word ptr [si + 0x2a], 1;
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        $1 = $2;
                        $1 += $2;
                        $1 = $2;
                        and cx, 7;
                        $1 = $2;
                        and bx, 7;
                        mov dx, word ptr [bp + 0xc];
                    } else {
                        // Block 0x122AA
                        cmp word ptr [si + 0x16], 0;
                        if (a != b) {  // jne 0x122d3
                            // Block 0x122D3
                            $1 = $2;
                            *($1) = $2;
                            mov word ptr [si + 0x28], 0xffff;
                        } else {
                            // Block 0x122B0
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            lcall 0xbd7, 8;
                            $1 = $2;
                            *($1) = $2;
                            jmp 0x123a3;
                            // Block 0x123A3
                            $1 = $2;
                            mov word ptr [si + 0x10], 1;
                            $1 = $2;
                            *($1) = $2;
                            mov word ptr [bp - 2], 0;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        }
                    }
                }
            } else {
                // Block 0x121C0
                xchg word ptr [bp + 0xe], ax;
                mov word ptr [bp + 0xa], ax;
            }
        } else {
            // Block 0x121B2
            xchg word ptr [bp + 0xc], ax;
            mov word ptr [bp + 8], ax;
        }
    } else {
        // Block 0x1217E
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x26c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x26c;
        mov word ptr [bp + 8], ax;
    }
}

void sub_12524(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x12524
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test word ptr [0x6ab2], 0xffff;
    if (a != b) {  // jne 0x12542
        // Block 0x12542
        push($1);
        $1 = $2;
        $1 = $2;
        les di, ptr [bp + 6];
        $1 = $2;
        cld ;
        rep movsw word ptr es:[di], word ptr [si];
        $1 = pop();
        $1 = $2;
        $1 += $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x12566
            // Block 0x12566
            *($1) = $2;
            $1--;
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x12562
            mov si, word ptr [0x6aa6];
        }
    } else {
        // Block 0x1253B
        mov word ptr [bp - 2], 0xf04c;
        jmp 0x12573;
        // Block 0x12573
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }
}

void sub_12580(int) {
    // Purpose: Sets video mode and performs calculations

    // Complexity: 12

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 166 if statements

    // Block 0x12580
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x125a7
        // Block 0x125A7
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 += $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x125c8
            // Block 0x125C8
            *($1) = $2;
            $1++;
            popf ;
            push($1);
            $1 = $2;
            lds si, ptr [bp + 6];
            *($1) = $2;
            *($1) = $2;
            $1 = $2;
            cld ;
            rep movsw word ptr es:[di], word ptr [si];
            $1 = pop();
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x125C4
            mov si, word ptr [0x6aa6];
        }
    } else {
        // Block 0x1259B
        popf ;
        mov word ptr [bp - 2], 0xf04b;
        $1++;
        jmp 0x125eb;
        // Block 0x125EB
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_12524(); // Performs arithmetic calculations
    sub_12580(); // Sets video mode and performs calculations
    sub_14286(); // Manipulates strings or memory blocks and performs calculations
}

void sub_14286(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 23

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 62 if statements

    // Block 0x14286
    $1 = $2;
    mov word ptr [bx], 0x166;
    $1 += $2;
    mov word ptr [bx], 0x166;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x402;
    $1 += $2;
    mov word ptr [bx], 0x4b1;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov byte ptr [0x6f01], 1;
    return;  // retf 
}

void sub_1485A(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 54

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 74 if statements

    // Block 0x1485A
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp byte ptr [si], 0xa;
    if (a == b) {  // je 0x14878
        // Block 0x14878
        mov word ptr [bp - 2], 0;
    } else {
        // Block 0x14871
        mov word ptr [bp - 2], 0xf448;
        jmp 0x1487d;
        // Block 0x1487D
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_1485A(); // Manipulates strings or memory blocks and performs calculations
    sub_1485A(); // Manipulates strings or memory blocks and performs calculations
}

void sub_14D0E(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 7

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 9 if statements

    // Block 0x14D0E
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x14d30
        // Block 0x14D30
        $1 = $2;
        $1 = $2;
        $1 = $2;
        lds si, ptr [bp + 0xa];
        les di, ptr [bp + 6];
        // Compare $1 with $2
        if (a != b) {  // jne 0x14d4b
            // Block 0x14D4B
            // Compare $1 with $2
            if (a != b) {  // jne 0x14d6c
                // Block 0x14D6C
                // Compare $1 with $2
                if (a != b) {  // jne 0x14d82
                    // Block 0x14D82
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x14de4
                        // Block 0x14DE4
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x14e01
                            // Block 0x14E01
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x14e0d
                                // Block 0x14E0D
                                mov word ptr [bp - 2], 0xfff7;
                            } else {
                                // Block 0x14E06
                                $1 = $2;
                                goto $1;
                                jmp 0x14e12;
                                // Block 0x14E12
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x14DE9
                            mov cx, 0x30;
                        }
                    } else {
                        // Block 0x14D87
                        mov byte ptr [bp - 6], 0;
                        mov byte ptr [bp - 5], 0x20;
                        mov byte ptr [bp - 4], 4;
                        mov byte ptr [bp - 3], 0x24;
                        mov dx, 0x10;
                    }
                } else {
                    // Block 0x14D71
                    $1 = $2;
                    $1 = $2;
                    shr al, cl;
                    mov byte ptr es:[di], al;
                    mov word ptr [bp - 2], 0;
                    jmp 0x14e12;
                    // Block 0x14E12
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                }
            } else {
                // Block 0x14D50
                $1 = $2;
                $1 = $2;
                shr al, cl;
                mov byte ptr es:[di], al;
                $1++;
                $1 = $2;
                $1 = $2;
                shr al, cl;
                mov byte ptr es:[di], al;
                mov word ptr [bp - 2], 0;
                jmp 0x14e12;
                // Block 0x14E12
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xa
            }
        } else {
            // Block 0x14D43
            mov word ptr [bp - 2], 0;
            jmp 0x14e12;
            // Block 0x14E12
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xa
        }
    } else {
        // Block 0x14D28
        mov word ptr [bp - 2], 0xfc19;
        jmp 0x14e12;
        // Block 0x14E12
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_14E1F(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 14

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 21 if statements

    // Block 0x14E1F
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x14e41
        // Block 0x14E41
        $1 = $2;
        $1 = $2;
        $1 = $2;
        les di, ptr [bp + 0xa];
        lds si, ptr [bp + 6];
        // Compare $1 with $2
        if (a == b) {  // je 0x14e7b
            // Block 0x14E7B
            mov word ptr [bp - 2], 0;
            jmp 0x14f28;
            // Block 0x14F28
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xa
        } else {
            // Block 0x14E54
            // Compare $1 with $2
            if (a == b) {  // je 0x14e83
                // Block 0x14E83
                $1 = $2;
                $1 = $2;
                shl al, cl;
                mov byte ptr es:[di], al;
                mov byte ptr es:[di + 1], 0;
                mov byte ptr es:[di + 2], 0;
                $1 = $2;
                $1 = $2;
                shl al, cl;
                mov byte ptr es:[di + 3], al;
                mov byte ptr es:[di + 4], 0;
                mov byte ptr es:[di + 5], 0;
                mov word ptr [bp - 2], 0;
                jmp 0x14f28;
                // Block 0x14F28
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xa
            } else {
                // Block 0x14E59
                // Compare $1 with $2
                if (a == b) {  // je 0x14eb2
                    // Block 0x14EB2
                    $1 = $2;
                    $1 = $2;
                    shl al, cl;
                    mov byte ptr es:[di], al;
                    mov byte ptr es:[di + 1], 0;
                    mov byte ptr es:[di + 2], 0;
                    mov word ptr [bp - 2], 0;
                    jmp 0x14f28;
                    // Block 0x14F28
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                } else {
                    // Block 0x14E5E
                    // Compare $1 with $2
                    if (a == b) {  // je 0x14ecc
                        // Block 0x14ECC
                        $1 = $2;
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        shl ah, 1;
                        $1 = $2;
                        and al, 0x48;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x14ee5
                            // Block 0x14EE5
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x14eef
                                // Block 0x14EEF
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x14ef9
                                    // Block 0x14EF9
                                    mov byte ptr es:[di], 0xff;
                                } else {
                                    // Block 0x14EF3
                                    mov byte ptr es:[di], 0xaa;
                                    jmp 0x14efd;
                                    // Block 0x14EFD
                                    $1++;
                                    loop 0x14ed5;
                                    $1 = pop();
                                    $1++;
                                    loop 0x14ecf;
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x14f28;
                                    // Block 0x14F28
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0xa
                                }
                            } else {
                                // Block 0x14EE9
                                mov byte ptr es:[di], 0x55;
                                jmp 0x14efd;
                                // Block 0x14EFD
                                $1++;
                                loop 0x14ed5;
                                $1 = pop();
                                $1++;
                                loop 0x14ecf;
                                mov word ptr [bp - 2], 0;
                                jmp 0x14f28;
                                // Block 0x14F28
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x14EDF
                            mov byte ptr es:[di], 0;
                            jmp 0x14efd;
                            // Block 0x14EFD
                            $1++;
                            loop 0x14ed5;
                            $1 = pop();
                            $1++;
                            loop 0x14ecf;
                            mov word ptr [bp - 2], 0;
                            jmp 0x14f28;
                            // Block 0x14F28
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        }
                    } else {
                        // Block 0x14E63
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x14e6b
                            // Block 0x14E6B
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x14e73
                                // Block 0x14E73
                                mov word ptr [bp - 2], 0xfff7;
                                jmp 0x14f28;
                                // Block 0x14F28
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            } else {
                                // Block 0x14E70
                                jmp 0x14f23;
                                // Block 0x14F23
                                $1 = $2;
                                jmp 0x14f0e;
                                // Block 0x14F0E
                                $1 = $2;
                                shl al, 1;
                                shl al, 1;
                                mov byte ptr es:[di], al;
                                $1++;
                                $1++;
                                $1--;
                                if (a != b) {  // jne 0x14f0e
                                    // Jump to block at 0x14F0E
                                } else {
                                    // Block 0x14F1C
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x14f28;
                                    // Block 0x14F28
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0xa
                                }
                            }
                        } else {
                            // Block 0x14E68
                            jmp 0x14f0b;
                            // Block 0x14F0B
                            mov cx, 0x30;
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x14E39
        mov word ptr [bp - 2], 0xfc19;
        jmp 0x14f28;
        // Block 0x14F28
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }

    // Function calls:
    sub_14D0E(); // Manipulates strings or memory blocks and performs calculations
    sub_14E1F(); // Performs arithmetic calculations
}

void sub_15048(int) {
    // Purpose: Opens a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0x15048
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x1507b
        // Block 0x1507B
        *($1) = $2;
        push($1);
        lea ax, [bp - 0xe];
        push($1);
        push($1);
        lea ax, [bp - 0x10];
        push($1);
        lcall 0x96b, 0x66;
        // Compare $1 with $2
        if (a == b) {  // je 0x15098
            // Block 0x15098
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            lds si, ptr [bp - 0xe];
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            DOS_ReadFile();  // int 0x21
            if (a >= b (unsigned)) {  // jae 0x150bd
                // Block 0x150BD
                cmp byte ptr [si + 1], 5;
                if (a == b) {  // je 0x150cb
                    // Block 0x150CB
                    $1 = $2;
                    push($1);
                    lcall 0x98e, 0x12a;
                    if (a >= b (unsigned)) {  // jae 0x150de
                        // Block 0x150DE
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        lds si, ptr [bp - 0xe];
                        les di, ptr [bp + 6];
                        // Compare $1 with $2
                        if (a == b) {  // je 0x150f3
                            // Block 0x150F3
                            $1 = $2;
                            $1 = $2;
                            $1 -= $2;
                            sbb dx, 0;
                            $1 -= $2;
                            sbb dx, 0;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_MoveFilePointer();  // int 0x21
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_ReadFile();  // int 0x21
                            $1 = $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a == b) {  // je 0x15134
                                // Block 0x15134
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                DOS_ReadFile();  // int 0x21
                                $1 = pop();
                                // Compare $1 with $2
                                if (a == b) {  // je 0x15152
                                    // Block 0x15152
                                    push($1);
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x1516c
                                        // Block 0x1516C
                                        $1 = $2;
                                        push($1);
                                        push($1);
                                        push($1);
                                        push($1);
                                        push($1);
                                        push($1);
                                        call 0x14d0e;
                                        // Block 0x15178
                                        mov word ptr [bp - 2], ax;
                                    } else {
                                        // Block 0x15162
                                        mov word ptr [bp - 2], 0;
                                        jmp 0x1517b;
                                        // Block 0x1517B
                                        $1 = $2;
                                        push($1);
                                        $1 = $2;
                                        push($1);
                                        lcall 0x80c, 0x640;
                                    }
                                } else {
                                    // Block 0x1514B
                                    mov word ptr [bp - 2], 0xfffd;
                                    jmp 0x1517b;
                                    // Block 0x1517B
                                    $1 = $2;
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    lcall 0x80c, 0x640;
                                }
                            } else {
                                // Block 0x15128
                                // Compare $1 with $2
                                if (a == b) {  // je 0x15134
                                    // Block 0x15134
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    push($1);
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    DOS_ReadFile();  // int 0x21
                                    $1 = pop();
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x15152
                                        // Block 0x15152
                                        push($1);
                                        $1 = $2;
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a == b) {  // je 0x1516c
                                            // Block 0x1516C
                                            $1 = $2;
                                            push($1);
                                            push($1);
                                            push($1);
                                            push($1);
                                            push($1);
                                            push($1);
                                            call 0x14d0e;
                                            // Block 0x15178
                                            mov word ptr [bp - 2], ax;
                                        } else {
                                            // Block 0x15162
                                            mov word ptr [bp - 2], 0;
                                            jmp 0x1517b;
                                            // Block 0x1517B
                                            $1 = $2;
                                            push($1);
                                            $1 = $2;
                                            push($1);
                                            lcall 0x80c, 0x640;
                                        }
                                    } else {
                                        // Block 0x1514B
                                        mov word ptr [bp - 2], 0xfffd;
                                        jmp 0x1517b;
                                        // Block 0x1517B
                                        $1 = $2;
                                        push($1);
                                        $1 = $2;
                                        push($1);
                                        lcall 0x80c, 0x640;
                                    }
                                } else {
                                    // Block 0x1512D
                                    mov word ptr [bp - 2], 0xfff7;
                                    jmp 0x1517b;
                                    // Block 0x1517B
                                    $1 = $2;
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    lcall 0x80c, 0x640;
                                }
                            }
                        } else {
                            // Block 0x150F1
                            jmp 0x15169;
                            // Block 0x15169
                            add si, 0x10;
                        }
                    } else {
                        // Block 0x150D6
                        mov word ptr [bp - 2], 0xfc19;
                        jmp 0x1517b;
                        // Block 0x1517B
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        push($1);
                        lcall 0x80c, 0x640;
                    }
                } else {
                    // Block 0x150C3
                    mov word ptr [bp - 2], 0xfff6;
                    jmp 0x1517b;
                    // Block 0x1517B
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    push($1);
                    lcall 0x80c, 0x640;
                }
            } else {
                // Block 0x150B5
                mov word ptr [bp - 2], 0xfffd;
                jmp 0x1517b;
                // Block 0x1517B
                $1 = $2;
                push($1);
                $1 = $2;
                push($1);
                lcall 0x80c, 0x640;
            }
        } else {
            // Block 0x15092
            *($1) = $2;
            jmp 0x1517b;
            // Block 0x1517B
            $1 = $2;
            push($1);
            $1 = $2;
            push($1);
            lcall 0x80c, 0x640;
        }
    } else {
        // Block 0x15075
        *($1) = $2;
        jmp 0x15188;
        // Block 0x15188
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xe
    }

    // Function calls:
    sub_14D0E(); // Manipulates strings or memory blocks and performs calculations
    sub_15048(); // Opens a file and manipulates strings or memory blocks and performs calculations
    sub_14E1F(); // Performs arithmetic calculations
}

void sub_15454(int) {
    // Purpose: Reads data from a file and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x15454
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x15486
        // Block 0x15486
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        // Compare $1 with $2
        if (a == b) {  // je 0x154a4
            // Block 0x154A4
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0x154b1
                // Block 0x154B1
                mov word ptr [bp - 2], 0;
            } else {
                // Block 0x154AA
                mov word ptr [bp - 2], 0xf448;
                jmp 0x154b6;
                // Block 0x154B6
                $1 = $2;
                push($1);
                $1 = $2;
                push($1);
                lcall 0x80c, 0x640;
            }
        } else {
            // Block 0x1549D
            mov word ptr [bp - 2], 0xf448;
            jmp 0x154b6;
            // Block 0x154B6
            $1 = $2;
            push($1);
            $1 = $2;
            push($1);
            lcall 0x80c, 0x640;
        }
    } else {
        // Block 0x15481
        *($1) = $2;
        jmp 0x154c3;
        // Block 0x154C3
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }
}

void sub_154D0(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x154D0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    call 0x15454;
    // Block 0x154F3
    // Compare $1 with $2
    if (a == b) {  // je 0x154fd
        // Block 0x154FD
        $1 = $2;
        les di, ptr [bp + 6];
        cld ;
        $1 = $2;
        rep movsb byte ptr es:[di], byte ptr [si];
        mov word ptr [bp - 2], 0;
    } else {
        // Block 0x154F8
        *($1) = $2;
        jmp 0x1550e;
        // Block 0x1550E
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xc
    }

    // Function calls:
    sub_15454(); // Reads data from a file and performs calculations
    sub_154D0(); // Performs arithmetic calculations
    sub_156C6(); // Manipulates strings or memory blocks and performs calculations
}

void sub_156C6(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0x156C6
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x10];
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x156e3
        // Block 0x156E3
        $1 = $2;
        mul word ptr [bp + 0xa];
        $1 = $2;
        $1 = $2;
        shl ax, cl;
        $1--;
        and word ptr [bp + 8], ax;
        and word ptr [bp + 6], ax;
        $1 = $2;
        div byte ptr [bp + 0xa];
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        shl ax, cl;
        $1--;
        $1 = $2;
        not ah;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        cld ;
        cmp word ptr [bp + 0xc], 1;
        if (a != b) {  // jne 0x1573f
            // Block 0x1573F
            push($1);
            $1 = $2;
            push($1);
            push($1);
            $1 = 0;
            xor cx, cx;
        } else {
            // Block 0x1571F
            push($1);
            $1 = $2;
            $1 = 0;
            $1 = $2;
            push($1);
            $1 = $2;
            shl ax, cl;
            $1 = pop();
            // Compare $1 with $2
            if (a != b) {  // jne 0x15735
                // Block 0x15735
                or al, ah;
                loop 0x15728;
                stosb byte ptr es:[di], al;
                $1 = pop();
                loop 0x1571f;
                jmp 0x15786;
                // Block 0x15786
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xe
            } else {
                // Block 0x15733
                mov ah, bl;
            }
        }
    } else {
        // Block 0x156E0
        jmp 0x15786;
        // Block 0x15786
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xe
    }
}

void sub_15798(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 19

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 31 if statements

    // Block 0x15798
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    cmp word ptr [si], 0xca00;
    if (a != b) {  // jne 0x157ba
        // Block 0x157BA
        mov word ptr [bp - 2], 0xffe4;
        jmp 0x15832;
        // Block 0x15832
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xc
    } else {
        // Block 0x157B3
        cmp word ptr es:[di], 0xca00;
        if (a == b) {  // je 0x157c1
            // Block 0x157C1
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0x157d1
                // Block 0x157D1
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x157e3
                    // Block 0x157E3
                    mov word ptr [bp - 2], 0xf82d;
                    jmp 0x15832;
                    // Block 0x15832
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xc
                } else {
                    // Block 0x157DA
                    $1 = $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0x157ea
                        // Block 0x157EA
                        les di, ptr [bp + 0xe];
                        mov word ptr es:[di], 0xca20;
                        $1 = $2;
                        mov word ptr es:[di + 6], ax;
                        mov word ptr es:[di + 4], si;
                        lcall 0x1535, 0x2d;
                        mov word ptr es:[di + 2], ax;
                        mov word ptr es:[di + 0x8c], 0;
                        $1 = $2;
                        $1 -= $2;
                        if (a != b) {  // jne 0x15821
                            // Block 0x15821
                            lds si, ptr [bp + 6];
                            $1 += $2;
                            $1 = $2;
                            cld ;
                            rep movsb byte ptr es:[di], byte ptr [si];
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x15813
                            $1 = $2;
                            $1 -= $2;
                            if (a != b) {  // jne 0x15821
                                // Block 0x15821
                                lds si, ptr [bp + 6];
                                $1 += $2;
                                $1 = $2;
                                cld ;
                                rep movsb byte ptr es:[di], byte ptr [si];
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x1581A
                                mov word ptr es:[di + 0x8c], 1;
                            }
                        }
                    } else {
                        // Block 0x157E3
                        mov word ptr [bp - 2], 0xf82d;
                        jmp 0x15832;
                        // Block 0x15832
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 0xc
                    }
                }
            } else {
                // Block 0x157CA
                mov word ptr [bp - 2], 0xfffa;
                jmp 0x15832;
                // Block 0x15832
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xc
            }
        } else {
            // Block 0x157BA
            mov word ptr [bp - 2], 0xffe4;
            jmp 0x15832;
            // Block 0x15832
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xc
        }
    }

    // Function calls:
    sub_15798(); // Performs arithmetic calculations
    sub_15AB6(); // Manipulates strings or memory blocks and performs calculations
}

void sub_15AB6(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 15

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 36 if statements

    // Block 0x15AB6
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x12];
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp + 0xa], 1;
    if (a == b) {  // je 0x15ae1
        // Block 0x15AE1
        cmp word ptr [bp + 8], 1;
        if (a == b) {  // je 0x15af6
            // Block 0x15AF6
            ror dl, 1;
            not dl;
            cwde ;
            $1 = $2;
            shr cx, 1;
            lodsw ax, word ptr [si];
            xor ax, dx;
            stosw word ptr es:[di], ax;
            loop 0x15aff;
            jmp 0x15b6f;
            // Block 0x15B6F
            mov word ptr [bp - 2], 0;
            jmp 0x15b7b;
            // Block 0x15B7B
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0x10
        } else {
            // Block 0x15AE7
            cmp word ptr [bp + 8], 2;
            if (a == b) {  // je 0x15b07
                // Block 0x15B07
                $1 = $2;
                $1 = $2;
                lodsb al, byte ptr [si];
            } else {
                // Block 0x15AED
                cmp word ptr [bp + 8], 8;
                if (a == b) {  // je 0x15b25
                    // Block 0x15B25
                    lodsb al, byte ptr [si];
                    $1 = $2;
                    $1 = 0;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x15b30
                        // Block 0x15B30
                        stosb byte ptr es:[di], al;
                        loop 0x15b25;
                        jmp 0x15b6f;
                        // Block 0x15B6F
                        mov word ptr [bp - 2], 0;
                        jmp 0x15b7b;
                        // Block 0x15B7B
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 0x10
                    } else {
                        // Block 0x15B2E
                        not al;
                    }
                } else {
                    // Block 0x15AF3
                    jmp 0x15b76;
                    // Block 0x15B76
                    mov word ptr [bp - 2], 0xfffa;
                }
            }
        }
    } else {
        // Block 0x15AD8
        cmp word ptr [bp + 0xa], 4;
        if (a == b) {  // je 0x15b35
            // Block 0x15B35
            cmp word ptr [bp + 8], 1;
            if (a == b) {  // je 0x15b3d
                // Block 0x15B3D
                $1 = $2;
                not dh;
                $1 = $2;
                push($1);
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = $2;
                ror al, 1;
                cwde ;
                xor ah, byte ptr [si];
                and dl, ah;
                $1 += $2;
                loop 0x15b4c;
                $1 = pop();
                $1 = pop();
                mov byte ptr es:[di], dl;
                $1++;
                $1++;
                loop 0x15b43;
                lds si, ptr [bp + 0xe];
                mov dx, 3;
            } else {
                // Block 0x15B3B
                jmp 0x15b76;
                // Block 0x15B76
                mov word ptr [bp - 2], 0xfffa;
            }
        } else {
            // Block 0x15ADE
            jmp 0x15b76;
            // Block 0x15B76
            mov word ptr [bp - 2], 0xfffa;
        }
    }

    // Function calls:
    sub_15E6E(); // Manipulates strings or memory blocks and performs calculations
}

void sub_15E6E(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 49

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 76 if statements

    // Block 0x15E6E
    $1 = $2;
    mov word ptr [bx], 0x34c;
    $1 += $2;
    mov word ptr [bx], 0x34c;
    $1 += $2;
    mov word ptr [bx], 0x38b;
    $1 += $2;
    mov word ptr [bx], 0x55b;
    $1 += $2;
    mov byte ptr [0x6f51], 1;
    return;  // retf 

    // Function calls:
    sub_16504(); // Sets video mode and manipulates strings or memory blocks and performs calculations
}

void sub_16504(int) {
    // Purpose: Sets video mode and manipulates strings or memory blocks and performs calculations

    // Complexity: 80

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 164 if statements

    // Block 0x16504
    $1 = $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x78d;
    $1 += $2;
    mov word ptr [bx], 0x83b;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov byte ptr [0x6f50], 1;
    return;  // retf 
}

void sub_177DA(int) {
    // Purpose: Reads data from a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 16

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 54 if statements

    // Block 0x177DA
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x17808
        // Block 0x17808
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        // Compare $1 with $2
        if (a == b) {  // je 0x17826
            // Block 0x17826
            push($1);
            push($1);
            lcall 0x1542, 0;
            mov word ptr [bp - 2], ax;
        } else {
            // Block 0x1781F
            mov word ptr [bp - 2], 0xfc18;
            jmp 0x17830;
            // Block 0x17830
            push($1);
            push($1);
            lcall 0x80c, 0x640;
        }
    } else {
        // Block 0x17803
        *($1) = $2;
        jmp 0x1783b;
        // Block 0x1783B
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }

    // Function calls:
    sub_177DA(); // Reads data from a file and manipulates strings or memory blocks and performs calculations
    sub_17F32(); // Performs arithmetic calculations
}

void sub_17F32(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 25

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 61 if statements

    // Block 0x17F32
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x17f3b
        // Block 0x17F3B
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x17f44
            // Block 0x17F44
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x17f69
                // Block 0x17F69
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                mul bx;
                push($1);
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x17f81
                    // Block 0x17F81
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = pop();
                    $1 += $2;
                    $1 = $2;
                    cmp word ptr [bp - 0xa], 0xff00;
                    if (a != b) {  // jne 0x17fb6
                        // Block 0x17FB6
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        test bl, bl;
                        if (a != b) {  // jne 0x17fcf
                            // Block 0x17FCF
                            cmp word ptr [bp + 8], 0;
                            if (a < b) {  // jl 0x17fe0
                                // Block 0x17FE0
                                dec cx;
                            } else {
                                // Block 0x17FD5
                                and ah, byte ptr [bp - 0xa0];
                                out dx, ax;
                                and byte ptr es:[di], bh;
                                $1 = $2;
                                inc di;
                            }
                        } else {
                            // Block 0x17FCA
                            $1--;
                            if (a != b) {  // jne 0x17fe1
                                // Block 0x17FE1
                                $1--;
                                if (a > b) {  // jg 0x17fed
                                    // Block 0x17FED
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    out dx, ax;
                                    goto $1;
                                    and byte ptr es:[di], bh;
                                    // Block 0x17FFD
                                    $1++;
                                    loop 0x17ffa;
                                } else {
                                    // Block 0x17FE4
                                    $1 = $2;
                                    and byte ptr [bp - 0x1e], ah;
                                    jmp 0x18000;
                                    // Block 0x18000
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di + 1], bh;
                                }
                            } else {
                                // Block 0x17FCD
                                jmp 0x18000;
                                // Block 0x18000
                                $1 = $2;
                                out dx, ax;
                                and byte ptr es:[di], bh;
                                $1 = $2;
                                out dx, ax;
                                and byte ptr es:[di + 1], bh;
                            }
                        }
                    } else {
                        // Block 0x17F98
                        cmp word ptr [bp - 0x9c], 0xff;
                        if (a != b) {  // jne 0x17fb6
                            // Block 0x17FB6
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            test bl, bl;
                            if (a != b) {  // jne 0x17fcf
                                // Block 0x17FCF
                                cmp word ptr [bp + 8], 0;
                                if (a < b) {  // jl 0x17fe0
                                    // Block 0x17FE0
                                    dec cx;
                                } else {
                                    // Block 0x17FD5
                                    and ah, byte ptr [bp - 0xa0];
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    inc di;
                                }
                            } else {
                                // Block 0x17FCA
                                $1--;
                                if (a != b) {  // jne 0x17fe1
                                    // Block 0x17FE1
                                    $1--;
                                    if (a > b) {  // jg 0x17fed
                                        // Block 0x17FED
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        out dx, ax;
                                        goto $1;
                                        and byte ptr es:[di], bh;
                                        // Block 0x17FFD
                                        $1++;
                                        loop 0x17ffa;
                                    } else {
                                        // Block 0x17FE4
                                        $1 = $2;
                                        and byte ptr [bp - 0x1e], ah;
                                        jmp 0x18000;
                                        // Block 0x18000
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di + 1], bh;
                                    }
                                } else {
                                    // Block 0x17FCD
                                    jmp 0x18000;
                                    // Block 0x18000
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di + 1], bh;
                                }
                            }
                        } else {
                            // Block 0x17FA0
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            out dx, ax;
                            and byte ptr es:[di], bh;
                            $1++;
                            loop 0x17fae;
                            jmp 0x1800f;
                            // Block 0x1800F
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x17F7E
                    add bx, 8;
                }
            } else {
                // Block 0x17F53
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x17f66
                    // Block 0x17F66
                    jmp 0x1800f;
                    // Block 0x1800F
                    return;  // retf 
                } else {
                    // Block 0x17F60
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x17f69
                        // Block 0x17F69
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        push($1);
                        $1 = $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x17f81
                            // Block 0x17F81
                            $1 = $2;
                            $1 += $2;
                            lcall es:[di + 0x26];
                            $1 = pop();
                            $1 += $2;
                            $1 = $2;
                            cmp word ptr [bp - 0xa], 0xff00;
                            if (a != b) {  // jne 0x17fb6
                                // Block 0x17FB6
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                test bl, bl;
                                if (a != b) {  // jne 0x17fcf
                                    // Block 0x17FCF
                                    cmp word ptr [bp + 8], 0;
                                    if (a < b) {  // jl 0x17fe0
                                        // Block 0x17FE0
                                        dec cx;
                                    } else {
                                        // Block 0x17FD5
                                        and ah, byte ptr [bp - 0xa0];
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        inc di;
                                    }
                                } else {
                                    // Block 0x17FCA
                                    $1--;
                                    if (a != b) {  // jne 0x17fe1
                                        // Block 0x17FE1
                                        $1--;
                                        if (a > b) {  // jg 0x17fed
                                            // Block 0x17FED
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            out dx, ax;
                                            goto $1;
                                            and byte ptr es:[di], bh;
                                            // Block 0x17FFD
                                            $1++;
                                            loop 0x17ffa;
                                        } else {
                                            // Block 0x17FE4
                                            $1 = $2;
                                            and byte ptr [bp - 0x1e], ah;
                                            jmp 0x18000;
                                            // Block 0x18000
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di + 1], bh;
                                        }
                                    } else {
                                        // Block 0x17FCD
                                        jmp 0x18000;
                                        // Block 0x18000
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di + 1], bh;
                                    }
                                }
                            } else {
                                // Block 0x17F98
                                cmp word ptr [bp - 0x9c], 0xff;
                                if (a != b) {  // jne 0x17fb6
                                    // Block 0x17FB6
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    test bl, bl;
                                    if (a != b) {  // jne 0x17fcf
                                        // Block 0x17FCF
                                        cmp word ptr [bp + 8], 0;
                                        if (a < b) {  // jl 0x17fe0
                                            // Block 0x17FE0
                                            dec cx;
                                        } else {
                                            // Block 0x17FD5
                                            and ah, byte ptr [bp - 0xa0];
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            inc di;
                                        }
                                    } else {
                                        // Block 0x17FCA
                                        $1--;
                                        if (a != b) {  // jne 0x17fe1
                                            // Block 0x17FE1
                                            $1--;
                                            if (a > b) {  // jg 0x17fed
                                                // Block 0x17FED
                                                $1 = $2;
                                                out dx, ax;
                                                and byte ptr es:[di], bh;
                                                $1 = $2;
                                                out dx, ax;
                                                goto $1;
                                                and byte ptr es:[di], bh;
                                                // Block 0x17FFD
                                                $1++;
                                                loop 0x17ffa;
                                            } else {
                                                // Block 0x17FE4
                                                $1 = $2;
                                                and byte ptr [bp - 0x1e], ah;
                                                jmp 0x18000;
                                                // Block 0x18000
                                                $1 = $2;
                                                out dx, ax;
                                                and byte ptr es:[di], bh;
                                                $1 = $2;
                                                out dx, ax;
                                                and byte ptr es:[di + 1], bh;
                                            }
                                        } else {
                                            // Block 0x17FCD
                                            jmp 0x18000;
                                            // Block 0x18000
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di + 1], bh;
                                        }
                                    }
                                } else {
                                    // Block 0x17FA0
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1++;
                                    loop 0x17fae;
                                    jmp 0x1800f;
                                    // Block 0x1800F
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x17F7E
                            add bx, 8;
                        }
                    } else {
                        // Block 0x17F66
                        jmp 0x1800f;
                        // Block 0x1800F
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x17F41
            jmp 0x1800f;
            // Block 0x1800F
            return;  // retf 
        }
    } else {
        // Block 0x17F38
        jmp 0x1800f;
        // Block 0x1800F
        return;  // retf 
    }

    // Function calls:
    sub_1867D(); // Manipulates strings or memory blocks and performs calculations
}

void sub_1867D(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 29

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 60 if statements

    // Block 0x1867D
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x18686
        // Block 0x18686
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x1868f
            // Block 0x1868F
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x186b4
                // Block 0x186B4
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                $1 += $2;
                lcall es:[di + 0x26];
                $1 = $2;
                $1 = $2;
                cld ;
                // Compare $1 with $2
                if (a != b) {  // jne 0x186eb
                    // Block 0x186EB
                    $1 = $2;
                    $1--;
                    if (a == b) {  // je 0x18755
                        // Block 0x18755
                        $1 = $2;
                        and dx, word ptr [bp - 0x2a];
                        and dx, word ptr [bp - 0xa0];
                        $1 = $2;
                        $1 = $2;
                        ror ax, cl;
                        and word ptr es:[di], ax;
                        $1 = $2;
                        $1 = $2;
                        ror ax, cl;
                        and word ptr es:[di + 1], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di + 1], ax;
                    } else {
                        // Block 0x186F1
                        $1 = $2;
                        and dx, word ptr [bp - 0x2a];
                        and dx, word ptr [bp - 0x9c];
                        $1 = 0;
                        $1 = $2;
                        not ax;
                        ror ax, cl;
                        and word ptr es:[di], ax;
                        $1 = 0;
                        $1 = $2;
                        not ax;
                        ror ax, cl;
                        and word ptr es:[di + 1], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di + 1], ax;
                        jmp 0x18750;
                        // Block 0x18750
                        $1++;
                        $1++;
                        $1--;
                        if (a != b) {  // jne 0x1872b
                            // Block 0x1872B
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                        } else {
                            // Block 0x18755
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            and dx, word ptr [bp - 0xa0];
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                        }
                    }
                } else {
                    // Block 0x186D1
                    cmp word ptr [bp - 0x9c], -1;
                    if (a != b) {  // jne 0x186eb
                        // Block 0x186EB
                        $1 = $2;
                        $1--;
                        if (a == b) {  // je 0x18755
                            // Block 0x18755
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            and dx, word ptr [bp - 0xa0];
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                        } else {
                            // Block 0x186F1
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            and dx, word ptr [bp - 0x9c];
                            $1 = 0;
                            $1 = $2;
                            not ax;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            $1 = 0;
                            $1 = $2;
                            not ax;
                            ror ax, cl;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                            jmp 0x18750;
                            // Block 0x18750
                            $1++;
                            $1++;
                            $1--;
                            if (a != b) {  // jne 0x1872b
                                // Block 0x1872B
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                            } else {
                                // Block 0x18755
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                and dx, word ptr [bp - 0xa0];
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                            }
                        }
                    } else {
                        // Block 0x186D8
                        $1 = $2;
                        $1 = $2;
                        and ax, word ptr [bp - 0x2a];
                        mov word ptr es:[di], ax;
                        $1++;
                        $1++;
                        loop 0x186e1;
                        jmp 0x18789;
                        // Block 0x18789
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x1869E
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x186b1
                    // Block 0x186B1
                    jmp 0x18789;
                    // Block 0x18789
                    return;  // retf 
                } else {
                    // Block 0x186AB
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x186b4
                        // Block 0x186B4
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        lcall es:[di + 0x26];
                        $1 = $2;
                        $1 = $2;
                        cld ;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x186eb
                            // Block 0x186EB
                            $1 = $2;
                            $1--;
                            if (a == b) {  // je 0x18755
                                // Block 0x18755
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                and dx, word ptr [bp - 0xa0];
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                            } else {
                                // Block 0x186F1
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                and dx, word ptr [bp - 0x9c];
                                $1 = 0;
                                $1 = $2;
                                not ax;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                $1 = 0;
                                $1 = $2;
                                not ax;
                                ror ax, cl;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                                jmp 0x18750;
                                // Block 0x18750
                                $1++;
                                $1++;
                                $1--;
                                if (a != b) {  // jne 0x1872b
                                    // Block 0x1872B
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                } else {
                                    // Block 0x18755
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    and dx, word ptr [bp - 0xa0];
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                }
                            }
                        } else {
                            // Block 0x186D1
                            cmp word ptr [bp - 0x9c], -1;
                            if (a != b) {  // jne 0x186eb
                                // Block 0x186EB
                                $1 = $2;
                                $1--;
                                if (a == b) {  // je 0x18755
                                    // Block 0x18755
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    and dx, word ptr [bp - 0xa0];
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                } else {
                                    // Block 0x186F1
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    and dx, word ptr [bp - 0x9c];
                                    $1 = 0;
                                    $1 = $2;
                                    not ax;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    $1 = 0;
                                    $1 = $2;
                                    not ax;
                                    ror ax, cl;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                    jmp 0x18750;
                                    // Block 0x18750
                                    $1++;
                                    $1++;
                                    $1--;
                                    if (a != b) {  // jne 0x1872b
                                        // Block 0x1872B
                                        $1 = $2;
                                        and dx, word ptr [bp - 0x2a];
                                        $1 = $2;
                                        ror ax, cl;
                                        and word ptr es:[di], ax;
                                        and word ptr es:[di + 1], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di + 1], ax;
                                    } else {
                                        // Block 0x18755
                                        $1 = $2;
                                        and dx, word ptr [bp - 0x2a];
                                        and dx, word ptr [bp - 0xa0];
                                        $1 = $2;
                                        $1 = $2;
                                        ror ax, cl;
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        $1 = $2;
                                        ror ax, cl;
                                        and word ptr es:[di + 1], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di + 1], ax;
                                    }
                                }
                            } else {
                                // Block 0x186D8
                                $1 = $2;
                                $1 = $2;
                                and ax, word ptr [bp - 0x2a];
                                mov word ptr es:[di], ax;
                                $1++;
                                $1++;
                                loop 0x186e1;
                                jmp 0x18789;
                                // Block 0x18789
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0x186B1
                        jmp 0x18789;
                        // Block 0x18789
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x1868C
            jmp 0x18789;
            // Block 0x18789
            return;  // retf 
        }
    } else {
        // Block 0x18683
        jmp 0x18789;
        // Block 0x18789
        return;  // retf 
    }

    // Function calls:
    sub_18B44(); // Manipulates strings or memory blocks and performs calculations
}

void sub_18B44(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 32

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 71 if statements

    // Block 0x18B44
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x18b4d
        // Block 0x18B4D
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x18b56
            // Block 0x18B56
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x18b7b
                // Block 0x18B7B
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                mul bx;
                push($1);
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x18b93
                    // Block 0x18B93
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = pop();
                    $1 += $2;
                    $1 = $2;
                    $1 = $2;
                    cld ;
                    cmp word ptr [bp - 0xa], 0xff00;
                    if (a != b) {  // jne 0x18bce
                        // Block 0x18BCE
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        ror dx, cl;
                        $1--;
                        if (a != b) {  // jne 0x18bde
                            // Block 0x18BDE
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x18bec
                                // Block 0x18BEC
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                ror ax, cl;
                                and ax, word ptr [bp - 0xa0];
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18c07
                                    // Block 0x18C07
                                    or word ptr es:[di], ax;
                                    jmp 0x18c1b;
                                    // Block 0x18C1B
                                    inc di;
                                } else {
                                    // Block 0x18C02
                                    or byte ptr es:[di], ah;
                                    jmp 0x18c1c;
                                    // Block 0x18C1C
                                    $1--;
                                    if (a != b) {  // jne 0x18c0c
                                        // Block 0x18C0C
                                        and word ptr es:[di], dx;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C1F
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c33
                                            // Block 0x18C33
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C47
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C4D
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x18c55;
                                                    // Block 0x18C55
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x18C29
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c33
                                                // Block 0x18C33
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C47
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C4D
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x18c55;
                                                        // Block 0x18C55
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x18C2F
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x18BE8
                                xchg al, ah;
                                mov ah, 0xff;
                            }
                        } else {
                            // Block 0x18BDC
                            jmp 0x18c1f;
                            // Block 0x18C1F
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x18c33
                                // Block 0x18C33
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                and al, ch;
                                ror ax, cl;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18c52
                                    // Block 0x18C52
                                    or word ptr es:[di], ax;
                                } else {
                                    // Block 0x18C47
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x18c52
                                        // Block 0x18C52
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C4D
                                        or byte ptr es:[di], ah;
                                        jmp 0x18c55;
                                        // Block 0x18C55
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0x18C29
                                cmp word ptr [bp - 0xe], 1;
                                if (a != b) {  // jne 0x18c33
                                    // Block 0x18C33
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c52
                                        // Block 0x18C52
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C47
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C4D
                                            or byte ptr es:[di], ah;
                                            jmp 0x18c55;
                                            // Block 0x18C55
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x18C2F
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            }
                        }
                    } else {
                        // Block 0x18BAE
                        cmp word ptr [bp - 0x9c], 0xff00;
                        if (a != b) {  // jne 0x18bce
                            // Block 0x18BCE
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            ror dx, cl;
                            $1--;
                            if (a != b) {  // jne 0x18bde
                                // Block 0x18BDE
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18bec
                                    // Block 0x18BEC
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    ror ax, cl;
                                    and ax, word ptr [bp - 0xa0];
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c07
                                        // Block 0x18C07
                                        or word ptr es:[di], ax;
                                        jmp 0x18c1b;
                                        // Block 0x18C1B
                                        inc di;
                                    } else {
                                        // Block 0x18C02
                                        or byte ptr es:[di], ah;
                                        jmp 0x18c1c;
                                        // Block 0x18C1C
                                        $1--;
                                        if (a != b) {  // jne 0x18c0c
                                            // Block 0x18C0C
                                            and word ptr es:[di], dx;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C1F
                                            $1 = $2;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c33
                                                // Block 0x18C33
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C47
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C4D
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x18c55;
                                                        // Block 0x18C55
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x18C29
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c33
                                                    // Block 0x18C33
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C47
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C4D
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x18c55;
                                                            // Block 0x18C55
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x18C2F
                                                    xchg al, ah;
                                                    mov ah, 0xff;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x18BE8
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            } else {
                                // Block 0x18BDC
                                jmp 0x18c1f;
                                // Block 0x18C1F
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18c33
                                    // Block 0x18C33
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c52
                                        // Block 0x18C52
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C47
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C4D
                                            or byte ptr es:[di], ah;
                                            jmp 0x18c55;
                                            // Block 0x18C55
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x18C29
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x18c33
                                        // Block 0x18C33
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C47
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C4D
                                                or byte ptr es:[di], ah;
                                                jmp 0x18c55;
                                                // Block 0x18C55
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x18C2F
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                }
                            }
                        } else {
                            // Block 0x18BB6
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            not ah;
                            and byte ptr es:[di], ah;
                            xor al, byte ptr [bp - 8];
                            or byte ptr es:[di], al;
                            $1++;
                            loop 0x18bb9;
                            jmp 0x18c55;
                            // Block 0x18C55
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x18B90
                    add bx, 8;
                }
            } else {
                // Block 0x18B65
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x18b78
                    // Block 0x18B78
                    jmp 0x18c55;
                    // Block 0x18C55
                    return;  // retf 
                } else {
                    // Block 0x18B72
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x18b7b
                        // Block 0x18B7B
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        push($1);
                        $1 = $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x18b93
                            // Block 0x18B93
                            $1 = $2;
                            $1 += $2;
                            lcall es:[di + 0x26];
                            $1 = pop();
                            $1 += $2;
                            $1 = $2;
                            $1 = $2;
                            cld ;
                            cmp word ptr [bp - 0xa], 0xff00;
                            if (a != b) {  // jne 0x18bce
                                // Block 0x18BCE
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                ror dx, cl;
                                $1--;
                                if (a != b) {  // jne 0x18bde
                                    // Block 0x18BDE
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18bec
                                        // Block 0x18BEC
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        and ax, word ptr [bp - 0xa0];
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c07
                                            // Block 0x18C07
                                            or word ptr es:[di], ax;
                                            jmp 0x18c1b;
                                            // Block 0x18C1B
                                            inc di;
                                        } else {
                                            // Block 0x18C02
                                            or byte ptr es:[di], ah;
                                            jmp 0x18c1c;
                                            // Block 0x18C1C
                                            $1--;
                                            if (a != b) {  // jne 0x18c0c
                                                // Block 0x18C0C
                                                and word ptr es:[di], dx;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                ror ax, cl;
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C1F
                                                $1 = $2;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c33
                                                    // Block 0x18C33
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C47
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C4D
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x18c55;
                                                            // Block 0x18C55
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x18C29
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c33
                                                        // Block 0x18C33
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C47
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x18c52
                                                                // Block 0x18C52
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x18C4D
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x18c55;
                                                                // Block 0x18C55
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x18C2F
                                                        xchg al, ah;
                                                        mov ah, 0xff;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x18BE8
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                } else {
                                    // Block 0x18BDC
                                    jmp 0x18c1f;
                                    // Block 0x18C1F
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c33
                                        // Block 0x18C33
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C47
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C4D
                                                or byte ptr es:[di], ah;
                                                jmp 0x18c55;
                                                // Block 0x18C55
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x18C29
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x18c33
                                            // Block 0x18C33
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C47
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C4D
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x18c55;
                                                    // Block 0x18C55
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x18C2F
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x18BAE
                                cmp word ptr [bp - 0x9c], 0xff00;
                                if (a != b) {  // jne 0x18bce
                                    // Block 0x18BCE
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    ror dx, cl;
                                    $1--;
                                    if (a != b) {  // jne 0x18bde
                                        // Block 0x18BDE
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18bec
                                            // Block 0x18BEC
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            and ax, word ptr [bp - 0xa0];
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c07
                                                // Block 0x18C07
                                                or word ptr es:[di], ax;
                                                jmp 0x18c1b;
                                                // Block 0x18C1B
                                                inc di;
                                            } else {
                                                // Block 0x18C02
                                                or byte ptr es:[di], ah;
                                                jmp 0x18c1c;
                                                // Block 0x18C1C
                                                $1--;
                                                if (a != b) {  // jne 0x18c0c
                                                    // Block 0x18C0C
                                                    and word ptr es:[di], dx;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    ror ax, cl;
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C1F
                                                    $1 = $2;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x18c33
                                                        // Block 0x18C33
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C47
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x18c52
                                                                // Block 0x18C52
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x18C4D
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x18c55;
                                                                // Block 0x18C55
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x18C29
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x18c33
                                                            // Block 0x18C33
                                                            and word ptr es:[di], ax;
                                                            $1 = $2;
                                                            xor al, byte ptr [bp - 8];
                                                            $1 = 0;
                                                            and al, ch;
                                                            ror ax, cl;
                                                            cmp word ptr [bp + 8], 0;
                                                            if (a >= b) {  // jge 0x18c52
                                                                // Block 0x18C52
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x18C47
                                                                cmp word ptr [bp - 0xe], 1;
                                                                if (a != b) {  // jne 0x18c52
                                                                    // Block 0x18C52
                                                                    or word ptr es:[di], ax;
                                                                } else {
                                                                    // Block 0x18C4D
                                                                    or byte ptr es:[di], ah;
                                                                    jmp 0x18c55;
                                                                    // Block 0x18C55
                                                                    return;  // retf 
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x18C2F
                                                            xchg al, ah;
                                                            mov ah, 0xff;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x18BE8
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    } else {
                                        // Block 0x18BDC
                                        jmp 0x18c1f;
                                        // Block 0x18C1F
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c33
                                            // Block 0x18C33
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C47
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C4D
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x18c55;
                                                    // Block 0x18C55
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x18C29
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c33
                                                // Block 0x18C33
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C47
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C4D
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x18c55;
                                                        // Block 0x18C55
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x18C2F
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x18BB6
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    not ah;
                                    and byte ptr es:[di], ah;
                                    xor al, byte ptr [bp - 8];
                                    or byte ptr es:[di], al;
                                    $1++;
                                    loop 0x18bb9;
                                    jmp 0x18c55;
                                    // Block 0x18C55
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x18B90
                            add bx, 8;
                        }
                    } else {
                        // Block 0x18B78
                        jmp 0x18c55;
                        // Block 0x18C55
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x18B53
            jmp 0x18c55;
            // Block 0x18C55
            return;  // retf 
        }
    } else {
        // Block 0x18B4A
        jmp 0x18c55;
        // Block 0x18C55
        return;  // retf 
    }

    // Function calls:
    sub_19038(); // Manipulates strings or memory blocks and performs calculations
}

void sub_19038(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 36

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 74 if statements

    // Block 0x19038
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19041
        // Block 0x19041
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x1904a
            // Block 0x1904A
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x1906f
                // Block 0x1906F
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                mul bx;
                push($1);
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x19087
                    // Block 0x19087
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = pop();
                    $1 += $2;
                    $1 = $2;
                    $1 = $2;
                    cld ;
                    cmp word ptr [bp - 0xa], 0xff00;
                    if (a != b) {  // jne 0x190c2
                        // Block 0x190C2
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        ror dx, cl;
                        $1--;
                        if (a != b) {  // jne 0x190d2
                            // Block 0x190D2
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x190e0
                                // Block 0x190E0
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                ror ax, cl;
                                and ax, word ptr [bp - 0xa0];
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x190fb
                                    // Block 0x190FB
                                    or word ptr es:[di], ax;
                                    jmp 0x1910f;
                                    // Block 0x1910F
                                    inc di;
                                } else {
                                    // Block 0x190F6
                                    or byte ptr es:[di], ah;
                                    jmp 0x19110;
                                    // Block 0x19110
                                    $1--;
                                    if (a != b) {  // jne 0x19100
                                        // Block 0x19100
                                        and word ptr es:[di], dx;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x19113
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19127
                                            // Block 0x19127
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x1913B
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19141
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x19149;
                                                    // Block 0x19149
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x1911D
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19127
                                                // Block 0x19127
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x1913B
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x19141
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x19149;
                                                        // Block 0x19149
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x19123
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x190DC
                                xchg al, ah;
                                mov ah, 0xff;
                            }
                        } else {
                            // Block 0x190D0
                            jmp 0x19113;
                            // Block 0x19113
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x19127
                                // Block 0x19127
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                and al, ch;
                                ror ax, cl;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x19146
                                    // Block 0x19146
                                    or word ptr es:[di], ax;
                                } else {
                                    // Block 0x1913B
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x19146
                                        // Block 0x19146
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x19141
                                        or byte ptr es:[di], ah;
                                        jmp 0x19149;
                                        // Block 0x19149
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0x1911D
                                cmp word ptr [bp - 0xe], 1;
                                if (a != b) {  // jne 0x19127
                                    // Block 0x19127
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x19146
                                        // Block 0x19146
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x1913B
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x19141
                                            or byte ptr es:[di], ah;
                                            jmp 0x19149;
                                            // Block 0x19149
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x19123
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            }
                        }
                    } else {
                        // Block 0x190A2
                        cmp word ptr [bp - 0x9c], 0xff00;
                        if (a != b) {  // jne 0x190c2
                            // Block 0x190C2
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            ror dx, cl;
                            $1--;
                            if (a != b) {  // jne 0x190d2
                                // Block 0x190D2
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x190e0
                                    // Block 0x190E0
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    ror ax, cl;
                                    and ax, word ptr [bp - 0xa0];
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x190fb
                                        // Block 0x190FB
                                        or word ptr es:[di], ax;
                                        jmp 0x1910f;
                                        // Block 0x1910F
                                        inc di;
                                    } else {
                                        // Block 0x190F6
                                        or byte ptr es:[di], ah;
                                        jmp 0x19110;
                                        // Block 0x19110
                                        $1--;
                                        if (a != b) {  // jne 0x19100
                                            // Block 0x19100
                                            and word ptr es:[di], dx;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x19113
                                            $1 = $2;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19127
                                                // Block 0x19127
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x1913B
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x19141
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x19149;
                                                        // Block 0x19149
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x1911D
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19127
                                                    // Block 0x19127
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x1913B
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x19141
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x19149;
                                                            // Block 0x19149
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x19123
                                                    xchg al, ah;
                                                    mov ah, 0xff;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x190DC
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            } else {
                                // Block 0x190D0
                                jmp 0x19113;
                                // Block 0x19113
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x19127
                                    // Block 0x19127
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x19146
                                        // Block 0x19146
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x1913B
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x19141
                                            or byte ptr es:[di], ah;
                                            jmp 0x19149;
                                            // Block 0x19149
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x1911D
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x19127
                                        // Block 0x19127
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x1913B
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x19141
                                                or byte ptr es:[di], ah;
                                                jmp 0x19149;
                                                // Block 0x19149
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x19123
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                }
                            }
                        } else {
                            // Block 0x190AA
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            not ah;
                            and byte ptr es:[di], ah;
                            xor al, byte ptr [bp - 8];
                            or byte ptr es:[di], al;
                            $1++;
                            loop 0x190ad;
                            jmp 0x19149;
                            // Block 0x19149
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x19084
                    add bx, 8;
                }
            } else {
                // Block 0x19059
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x1906c
                    // Block 0x1906C
                    jmp 0x19149;
                    // Block 0x19149
                    return;  // retf 
                } else {
                    // Block 0x19066
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x1906f
                        // Block 0x1906F
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        push($1);
                        $1 = $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x19087
                            // Block 0x19087
                            $1 = $2;
                            $1 += $2;
                            lcall es:[di + 0x26];
                            $1 = pop();
                            $1 += $2;
                            $1 = $2;
                            $1 = $2;
                            cld ;
                            cmp word ptr [bp - 0xa], 0xff00;
                            if (a != b) {  // jne 0x190c2
                                // Block 0x190C2
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                ror dx, cl;
                                $1--;
                                if (a != b) {  // jne 0x190d2
                                    // Block 0x190D2
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x190e0
                                        // Block 0x190E0
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        and ax, word ptr [bp - 0xa0];
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x190fb
                                            // Block 0x190FB
                                            or word ptr es:[di], ax;
                                            jmp 0x1910f;
                                            // Block 0x1910F
                                            inc di;
                                        } else {
                                            // Block 0x190F6
                                            or byte ptr es:[di], ah;
                                            jmp 0x19110;
                                            // Block 0x19110
                                            $1--;
                                            if (a != b) {  // jne 0x19100
                                                // Block 0x19100
                                                and word ptr es:[di], dx;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                ror ax, cl;
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x19113
                                                $1 = $2;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19127
                                                    // Block 0x19127
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x1913B
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x19141
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x19149;
                                                            // Block 0x19149
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x1911D
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19127
                                                        // Block 0x19127
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x1913B
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x19146
                                                                // Block 0x19146
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x19141
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x19149;
                                                                // Block 0x19149
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x19123
                                                        xchg al, ah;
                                                        mov ah, 0xff;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x190DC
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                } else {
                                    // Block 0x190D0
                                    jmp 0x19113;
                                    // Block 0x19113
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x19127
                                        // Block 0x19127
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x1913B
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x19141
                                                or byte ptr es:[di], ah;
                                                jmp 0x19149;
                                                // Block 0x19149
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x1911D
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x19127
                                            // Block 0x19127
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x1913B
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19141
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x19149;
                                                    // Block 0x19149
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x19123
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x190A2
                                cmp word ptr [bp - 0x9c], 0xff00;
                                if (a != b) {  // jne 0x190c2
                                    // Block 0x190C2
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    ror dx, cl;
                                    $1--;
                                    if (a != b) {  // jne 0x190d2
                                        // Block 0x190D2
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x190e0
                                            // Block 0x190E0
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            and ax, word ptr [bp - 0xa0];
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x190fb
                                                // Block 0x190FB
                                                or word ptr es:[di], ax;
                                                jmp 0x1910f;
                                                // Block 0x1910F
                                                inc di;
                                            } else {
                                                // Block 0x190F6
                                                or byte ptr es:[di], ah;
                                                jmp 0x19110;
                                                // Block 0x19110
                                                $1--;
                                                if (a != b) {  // jne 0x19100
                                                    // Block 0x19100
                                                    and word ptr es:[di], dx;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    ror ax, cl;
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19113
                                                    $1 = $2;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x19127
                                                        // Block 0x19127
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x1913B
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x19146
                                                                // Block 0x19146
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x19141
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x19149;
                                                                // Block 0x19149
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x1911D
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x19127
                                                            // Block 0x19127
                                                            and word ptr es:[di], ax;
                                                            $1 = $2;
                                                            xor al, byte ptr [bp - 8];
                                                            $1 = 0;
                                                            and al, ch;
                                                            ror ax, cl;
                                                            cmp word ptr [bp + 8], 0;
                                                            if (a >= b) {  // jge 0x19146
                                                                // Block 0x19146
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x1913B
                                                                cmp word ptr [bp - 0xe], 1;
                                                                if (a != b) {  // jne 0x19146
                                                                    // Block 0x19146
                                                                    or word ptr es:[di], ax;
                                                                } else {
                                                                    // Block 0x19141
                                                                    or byte ptr es:[di], ah;
                                                                    jmp 0x19149;
                                                                    // Block 0x19149
                                                                    return;  // retf 
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x19123
                                                            xchg al, ah;
                                                            mov ah, 0xff;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x190DC
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    } else {
                                        // Block 0x190D0
                                        jmp 0x19113;
                                        // Block 0x19113
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19127
                                            // Block 0x19127
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x1913B
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19141
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x19149;
                                                    // Block 0x19149
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x1911D
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19127
                                                // Block 0x19127
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x1913B
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x19141
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x19149;
                                                        // Block 0x19149
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x19123
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x190AA
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    not ah;
                                    and byte ptr es:[di], ah;
                                    xor al, byte ptr [bp - 8];
                                    or byte ptr es:[di], al;
                                    $1++;
                                    loop 0x190ad;
                                    jmp 0x19149;
                                    // Block 0x19149
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x19084
                            add bx, 8;
                        }
                    } else {
                        // Block 0x1906C
                        jmp 0x19149;
                        // Block 0x19149
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x19047
            jmp 0x19149;
            // Block 0x19149
            return;  // retf 
        }
    } else {
        // Block 0x1903E
        jmp 0x19149;
        // Block 0x19149
        return;  // retf 
    }

    // Function calls:
    sub_19831(); // Performs arithmetic calculations
}

void sub_19831(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 11

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 25 if statements

    // Block 0x19831
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x712c], 1;
    if (a == b) {  // je 0x1984d
        // Block 0x1984D
        cmp word ptr [0x7132], 1;
        if (a != b) {  // jne 0x19866
            // Block 0x19866
            lcall 0x98e, 0x35e;
            // Compare $1 with $2
            if (a >= b) {  // jge 0x1989d
                // Block 0x1989D
                *($1) = $2;
                push($1);
                lcall 0x98e, 0x12a;
                if (a >= b (unsigned)) {  // jae 0x198b0
                    // Block 0x198B0
                    *($1) = $2;
                    *($1) = $2;
                    $1 = $2;
                    push($1);
                    lcall 0x98e, 0xa6;
                    or ax, ax;
                    if (a >= b) {  // jge 0x198cb
                        // Block 0x198CB
                        *($1) = $2;
                        les di, ptr [bp - 0x58];
                        push($1);
                        lea ax, [bp - 0x60];
                        push($1);
                        lcall 0x185d, 0x46;
                        or ax, ax;
                        if (a == b) {  // je 0x198e5
                            // Block 0x198E5
                            lds si, ptr [bp - 0x60];
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = 0;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 -= $2;
                            $1 += $2;
                            *($1) = $2;
                            test word ptr [si + 0x18], 0x10;
                            if (a != b) {  // jne 0x1996f
                                // Block 0x1996F
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                cmp word ptr es:[di + 0x1e], 0;
                                if (a == b) {  // je 0x19994
                                    // Block 0x19994
                                    cmp word ptr es:[di + 0x20], 0;
                                    if (a == b) {  // je 0x199a2
                                        // Block 0x199A2
                                        push($1);
                                        lea ax, [bp - 0x4c];
                                        push($1);
                                        push($1);
                                        lea ax, [bp - 0x4e];
                                        push($1);
                                        lcall 0x96b, 0x66;
                                        or ax, ax;
                                        if (a == b) {  // je 0x199bb
                                            // Block 0x199BB
                                            lds si, ptr [bp - 0x60];
                                            lds si, ptr [si + 0xa8];
                                            push($1);
                                            les di, ptr [bp - 0x4c];
                                            $1 = $2;
                                            rep movsb byte ptr es:[di], byte ptr [si];
                                            $1 = pop();
                                            les di, ptr [bp + 0xa];
                                            cld ;
                                            $1 = $2;
                                            $1 = $2;
                                            repne scasb al, byte ptr es:[di];
                                            $1 -= $2;
                                            $1--;
                                            // Compare $1 with $2
                                            if (a > b (unsigned)) {  // ja 0x199e8
                                                // Block 0x199E8
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [bp - 0x44], 0;
                                                les di, ptr [bp + 0xa];
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = 0;
                                                // Compare $1 with $2
                                                if (a < b (unsigned)) {  // jb 0x19a28
                                                    // Block 0x19A28
                                                    $1++;
                                                    loop 0x199fa;
                                                    $1 = $2;
                                                    // Compare $1 with $2
                                                    if (a <= b (unsigned)) {  // jbe 0x19a47
                                                        // Block 0x19A47
                                                        push($1);
                                                        call 0x19b03;
                                                        // Block 0x19A4B
                                                        les di, ptr [bp + 0xa];
                                                    } else {
                                                        // Block 0x19A33
                                                        push($1);
                                                        push($1);
                                                        lcall 0x1754, 0xa;
                                                        or ax, ax;
                                                        if (a == b) {  // je 0x19a47
                                                            // Block 0x19A47
                                                            push($1);
                                                            call 0x19b03;
                                                            // Block 0x19A4B
                                                            les di, ptr [bp + 0xa];
                                                        } else {
                                                            // Block 0x19A42
                                                            *($1) = $2;
                                                            jmp 0x19ab5;
                                                            // Block 0x19AB5
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 8
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x19A04
                                                    // Compare $1 with $2
                                                    if (a > b (unsigned)) {  // ja 0x19a28
                                                        // Block 0x19A28
                                                        $1++;
                                                        loop 0x199fa;
                                                        $1 = $2;
                                                        // Compare $1 with $2
                                                        if (a <= b (unsigned)) {  // jbe 0x19a47
                                                            // Block 0x19A47
                                                            push($1);
                                                            call 0x19b03;
                                                            // Block 0x19A4B
                                                            les di, ptr [bp + 0xa];
                                                        } else {
                                                            // Block 0x19A33
                                                            push($1);
                                                            push($1);
                                                            lcall 0x1754, 0xa;
                                                            or ax, ax;
                                                            if (a == b) {  // je 0x19a47
                                                                // Block 0x19A47
                                                                push($1);
                                                                call 0x19b03;
                                                                // Block 0x19A4B
                                                                les di, ptr [bp + 0xa];
                                                            } else {
                                                                // Block 0x19A42
                                                                *($1) = $2;
                                                                jmp 0x19ab5;
                                                                // Block 0x19AB5
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 8
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x19A09
                                                        $1 = $2;
                                                        // Compare $1 with $2
                                                        if (a != b) {  // jne 0x19a25
                                                            // Block 0x19A25
                                                            add word ptr [bp - 0x44], ax;
                                                        } else {
                                                            // Block 0x19A11
                                                            $1 = $2;
                                                            $1 = 0;
                                                            $1 -= $2;
                                                            shl bx, 1;
                                                            $1 = $2;
                                                            // Compare $1 with $2
                                                            if (a == b) {  // je 0x19a25
                                                                // Block 0x19A25
                                                                add word ptr [bp - 0x44], ax;
                                                            } else {
                                                                // Block 0x19A22
                                                                add ax, word ptr [bp - 0x34];
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x199E0
                                                mov word ptr [bp - 2], 0;
                                                jmp 0x19ab5;
                                                // Block 0x19AB5
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 8
                                            }
                                        } else {
                                            // Block 0x199B5
                                            *($1) = $2;
                                            jmp 0x19ab5;
                                            // Block 0x19AB5
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 8
                                        }
                                    } else {
                                        // Block 0x1999B
                                        $1 = $2;
                                        add word ptr [bp + 6], ax;
                                    }
                                } else {
                                    // Block 0x1998D
                                    $1 = $2;
                                    add word ptr [bp + 8], ax;
                                }
                            } else {
                                // Block 0x1996A
                                mov word ptr [bp - 0x32], 0;
                            }
                        } else {
                            // Block 0x198DF
                            *($1) = $2;
                            jmp 0x19ab5;
                            // Block 0x19AB5
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    } else {
                        // Block 0x198C3
                        mov word ptr [bp - 2], 0xfc19;
                        jmp 0x19ab5;
                        // Block 0x19AB5
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    }
                } else {
                    // Block 0x198A8
                    mov word ptr [bp - 2], 0xfc19;
                    jmp 0x19ab5;
                    // Block 0x19AB5
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 8
                }
            } else {
                // Block 0x19870
                // Compare $1 with $2
                if (a <= b) {  // jle 0x1987d
                    // Block 0x1987D
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    cmp word ptr es:[di + 4], 1;
                    if (a == b) {  // je 0x19894
                        // Block 0x19894
                        $1 = 0;
                        lcall 0x98e, 0x249;
                        xor ax, ax;
                    } else {
                        // Block 0x1988C
                        mov word ptr [bp - 2], 0xfffa;
                        jmp 0x19ab5;
                        // Block 0x19AB5
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    }
                } else {
                    // Block 0x19875
                    mov word ptr [bp - 2], 0xfffa;
                    jmp 0x19ab5;
                    // Block 0x19AB5
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 8
                }
            }
        } else {
            // Block 0x19854
            $1 = $2;
            mul word ptr [bp + 8];
            *($1) = $2;
            $1 = $2;
            mul word ptr [bp + 6];
            mov word ptr [bp + 6], ax;
        }
    } else {
        // Block 0x19848
        lcall 0x15d6, 0x216;
    }

    // Function calls:
    sub_19B03(); // Manipulates strings or memory blocks and performs calculations
    sub_19831(); // Performs arithmetic calculations
}

void sub_19B03(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 31

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 42 if statements

    // Block 0x19B03
    $1 = $2;
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19b0e
        // Block 0x19B0E
        // Compare $1 with $2
        if (a != b) {  // jne 0x19b16
            // Block 0x19B16
            // Compare $1 with $2
            if (a != b) {  // jne 0x19b25
                // Block 0x19B25
                // Compare $1 with $2
                if (a != b) {  // jne 0x19b32
                    // Block 0x19B32
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b3f
                        // Block 0x19B3F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b4c
                            // Block 0x19B4C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19b59
                                // Block 0x19B59
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            } else {
                                // Block 0x19B51
                                $1 = $2;
                                shr ax, 1;
                                sub word ptr [bp + 6], ax;
                            }
                        } else {
                            // Block 0x19B44
                            $1 = $2;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19b59;
                            // Block 0x19B59
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B37
                        $1 = $2;
                        sub word ptr [bp + 6], ax;
                        jmp 0x19b59;
                        // Block 0x19B59
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                } else {
                    // Block 0x19B2A
                    $1 = $2;
                    sub word ptr [bp + 8], ax;
                    jmp 0x19b32;
                    // Block 0x19B32
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b3f
                        // Block 0x19B3F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b4c
                            // Block 0x19B4C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19b59
                                // Block 0x19B59
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            } else {
                                // Block 0x19B51
                                $1 = $2;
                                shr ax, 1;
                                sub word ptr [bp + 6], ax;
                            }
                        } else {
                            // Block 0x19B44
                            $1 = $2;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19b59;
                            // Block 0x19B59
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B37
                        $1 = $2;
                        sub word ptr [bp + 6], ax;
                        jmp 0x19b59;
                        // Block 0x19B59
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x19B1B
                $1 = $2;
                shr ax, 1;
                sub word ptr [bp + 8], ax;
                jmp 0x19b32;
                // Block 0x19B32
                // Compare $1 with $2
                if (a != b) {  // jne 0x19b3f
                    // Block 0x19B3F
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b4c
                        // Block 0x19B4C
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b59
                            // Block 0x19B59
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        } else {
                            // Block 0x19B51
                            $1 = $2;
                            shr ax, 1;
                            sub word ptr [bp + 6], ax;
                        }
                    } else {
                        // Block 0x19B44
                        $1 = $2;
                        sub word ptr [bp + 6], ax;
                        jmp 0x19b59;
                        // Block 0x19B59
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                } else {
                    // Block 0x19B37
                    $1 = $2;
                    sub word ptr [bp + 6], ax;
                    jmp 0x19b59;
                    // Block 0x19B59
                    jmp 0x19c55;
                    // Block 0x19C55
                    return;  // retf 
                }
            }
        } else {
            // Block 0x19B14
            jmp 0x19b59;
            // Block 0x19B59
            jmp 0x19c55;
            // Block 0x19C55
            return;  // retf 
        }
    } else {
        // Block 0x19B0C
        jmp 0x19b5c;
        // Block 0x19B5C
        cmp word ptr [bp - 0x48], 1;
        if (a != b) {  // jne 0x19baf
            // Block 0x19BAF
            cmp word ptr [bp - 0x48], 2;
            if (a != b) {  // jne 0x19c02
                // Block 0x19C02
                cmp word ptr [bp - 0x48], 3;
                if (a != b) {  // jne 0x19c55
                    // Block 0x19C55
                    return;  // retf 
                } else {
                    // Block 0x19C08
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19c10
                        // Block 0x19C10
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19c1f
                            // Block 0x19C1F
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19c2c
                                // Block 0x19C2C
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c39
                                    // Block 0x19C39
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c46
                                        // Block 0x19C46
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x19c55
                                            // Block 0x19C55
                                            return;  // retf 
                                        } else {
                                            // Block 0x19C4B
                                            $1 = $2;
                                            shr ax, 1;
                                            sub word ptr [bp + 8], ax;
                                        }
                                    } else {
                                        // Block 0x19C3E
                                        $1 = $2;
                                        sub word ptr [bp + 8], ax;
                                        jmp 0x19c53;
                                        // Block 0x19C53
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    }
                                } else {
                                    // Block 0x19C31
                                    $1 = $2;
                                    sub word ptr [bp + 8], ax;
                                    jmp 0x19c53;
                                    // Block 0x19C53
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19C24
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c2c;
                                // Block 0x19C2C
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c39
                                    // Block 0x19C39
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c46
                                        // Block 0x19C46
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x19c55
                                            // Block 0x19C55
                                            return;  // retf 
                                        } else {
                                            // Block 0x19C4B
                                            $1 = $2;
                                            shr ax, 1;
                                            sub word ptr [bp + 8], ax;
                                        }
                                    } else {
                                        // Block 0x19C3E
                                        $1 = $2;
                                        sub word ptr [bp + 8], ax;
                                        jmp 0x19c53;
                                        // Block 0x19C53
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    }
                                } else {
                                    // Block 0x19C31
                                    $1 = $2;
                                    sub word ptr [bp + 8], ax;
                                    jmp 0x19c53;
                                    // Block 0x19C53
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x19C15
                            $1 = $2;
                            shr ax, 1;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19c2c;
                            // Block 0x19C2C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19c39
                                // Block 0x19C39
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c46
                                    // Block 0x19C46
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c55
                                        // Block 0x19C55
                                        return;  // retf 
                                    } else {
                                        // Block 0x19C4B
                                        $1 = $2;
                                        shr ax, 1;
                                        sub word ptr [bp + 8], ax;
                                    }
                                } else {
                                    // Block 0x19C3E
                                    $1 = $2;
                                    sub word ptr [bp + 8], ax;
                                    jmp 0x19c53;
                                    // Block 0x19C53
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19C31
                                $1 = $2;
                                sub word ptr [bp + 8], ax;
                                jmp 0x19c53;
                                // Block 0x19C53
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0x19C0E
                        jmp 0x19c53;
                        // Block 0x19C53
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x19BB5
                // Compare $1 with $2
                if (a != b) {  // jne 0x19bbd
                    // Block 0x19BBD
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19bcc
                        // Block 0x19BCC
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19bd9
                            // Block 0x19BD9
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19be6
                                // Block 0x19BE6
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19bf3
                                    // Block 0x19BF3
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c00
                                        // Block 0x19C00
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    } else {
                                        // Block 0x19BF8
                                        $1 = $2;
                                        shr ax, 1;
                                        sub word ptr [bp + 6], ax;
                                    }
                                } else {
                                    // Block 0x19BEB
                                    $1 = $2;
                                    sub word ptr [bp + 6], ax;
                                    jmp 0x19c00;
                                    // Block 0x19C00
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19BDE
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c00;
                                // Block 0x19C00
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        } else {
                            // Block 0x19BD1
                            $1 = $2;
                            add word ptr [bp + 8], ax;
                            jmp 0x19bd9;
                            // Block 0x19BD9
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19be6
                                // Block 0x19BE6
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19bf3
                                    // Block 0x19BF3
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c00
                                        // Block 0x19C00
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    } else {
                                        // Block 0x19BF8
                                        $1 = $2;
                                        shr ax, 1;
                                        sub word ptr [bp + 6], ax;
                                    }
                                } else {
                                    // Block 0x19BEB
                                    $1 = $2;
                                    sub word ptr [bp + 6], ax;
                                    jmp 0x19c00;
                                    // Block 0x19C00
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19BDE
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c00;
                                // Block 0x19C00
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0x19BC2
                        $1 = $2;
                        shr ax, 1;
                        add word ptr [bp + 8], ax;
                        jmp 0x19bd9;
                        // Block 0x19BD9
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19be6
                            // Block 0x19BE6
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19bf3
                                // Block 0x19BF3
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c00
                                    // Block 0x19C00
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                } else {
                                    // Block 0x19BF8
                                    $1 = $2;
                                    shr ax, 1;
                                    sub word ptr [bp + 6], ax;
                                }
                            } else {
                                // Block 0x19BEB
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c00;
                                // Block 0x19C00
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        } else {
                            // Block 0x19BDE
                            $1 = $2;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19c00;
                            // Block 0x19C00
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x19BBB
                    jmp 0x19c00;
                    // Block 0x19C00
                    jmp 0x19c55;
                    // Block 0x19C55
                    return;  // retf 
                }
            }
        } else {
            // Block 0x19B62
            // Compare $1 with $2
            if (a != b) {  // jne 0x19b6a
                // Block 0x19B6A
                // Compare $1 with $2
                if (a != b) {  // jne 0x19b79
                    // Block 0x19B79
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b84
                        // Block 0x19B84
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b92
                            // Block 0x19B92
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19b9f
                                // Block 0x19B9F
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19bac
                                    // Block 0x19BAC
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                } else {
                                    // Block 0x19BA4
                                    $1 = $2;
                                    shr ax, 1;
                                    sub word ptr [bp + 8], ax;
                                }
                            } else {
                                // Block 0x19B97
                                $1 = $2;
                                sub word ptr [bp + 8], ax;
                                jmp 0x19bac;
                                // Block 0x19BAC
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        } else {
                            // Block 0x19B89
                            $1 = $2;
                            $1--;
                            sub word ptr [bp + 8], ax;
                            jmp 0x19bac;
                            // Block 0x19BAC
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B7E
                        $1 = $2;
                        add word ptr [bp + 6], ax;
                    }
                } else {
                    // Block 0x19B6F
                    $1 = $2;
                    shr ax, 1;
                    add word ptr [bp + 6], ax;
                    jmp 0x19b84;
                    // Block 0x19B84
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b92
                        // Block 0x19B92
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b9f
                            // Block 0x19B9F
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19bac
                                // Block 0x19BAC
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            } else {
                                // Block 0x19BA4
                                $1 = $2;
                                shr ax, 1;
                                sub word ptr [bp + 8], ax;
                            }
                        } else {
                            // Block 0x19B97
                            $1 = $2;
                            sub word ptr [bp + 8], ax;
                            jmp 0x19bac;
                            // Block 0x19BAC
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B89
                        $1 = $2;
                        $1--;
                        sub word ptr [bp + 8], ax;
                        jmp 0x19bac;
                        // Block 0x19BAC
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x19B68
                jmp 0x19bac;
                // Block 0x19BAC
                jmp 0x19c55;
                // Block 0x19C55
                return;  // retf 
            }
        }
    }

    // Function calls:
    sub_19D41(); // Manipulates strings or memory blocks and performs calculations
}

void sub_19D41(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 14

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 24 if statements

    // Block 0x19D41
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19d4a
        // Block 0x19D4A
        $1 = $2;
        $1 = $2;
        $1 = $2;
        cmp word ptr es:[di + 0x10], 1;
        if (a != b) {  // jne 0x19d6e
            // Block 0x19D6E
            les di, ptr [bp - 0x58];
            $1 = $2;
            $1 = $2;
            $1 += $2;
            lcall es:[di + 0x26];
            $1 = $2;
            $1 = $2;
            $1 -= $2;
            *($1) = $2;
            $1 = $2;
            $1 -= $2;
            $1 = $2;
            cld ;
            $1 = $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x19da4
                // Block 0x19DA4
                // Compare $1 with $2
                if (a != b) {  // jne 0x19db0
                    // Block 0x19DB0
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19dbc
                        // Block 0x19DBC
                        mov word ptr [bp - 0x5c], 0x18e;
                    } else {
                        // Block 0x19DB5
                        mov word ptr [bp - 0x5c], 0x189;
                        jmp 0x19dc1;
                        // Block 0x19DC1
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        stc ;
                        rcl bh, 1;
                        if (a >= b (unsigned)) {  // jae 0x19de6
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        } else {
                            // Block 0x19DD1
                            goto $1;
                            xor byte ptr es:[di], al;
                            goto $1;
                            and byte ptr es:[di], al;
                            goto $1;
                            or byte ptr es:[di], al;
                            goto $1;
                            mov byte ptr es:[di], al;
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        }
                    }
                } else {
                    // Block 0x19DA9
                    mov word ptr [bp - 0x5c], 0x184;
                    jmp 0x19dc1;
                    // Block 0x19DC1
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    stc ;
                    rcl bh, 1;
                    if (a >= b (unsigned)) {  // jae 0x19de6
                        // Block 0x19DE6
                        $1++;
                        loop 0x19dcc;
                    } else {
                        // Block 0x19DD1
                        goto $1;
                        xor byte ptr es:[di], al;
                        goto $1;
                        and byte ptr es:[di], al;
                        goto $1;
                        or byte ptr es:[di], al;
                        goto $1;
                        mov byte ptr es:[di], al;
                        // Block 0x19DE6
                        $1++;
                        loop 0x19dcc;
                    }
                }
            } else {
                // Block 0x19D9D
                mov word ptr [bp - 0x5c], 0x193;
                jmp 0x19dc1;
                // Block 0x19DC1
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                stc ;
                rcl bh, 1;
                if (a >= b (unsigned)) {  // jae 0x19de6
                    // Block 0x19DE6
                    $1++;
                    loop 0x19dcc;
                } else {
                    // Block 0x19DD1
                    goto $1;
                    xor byte ptr es:[di], al;
                    goto $1;
                    and byte ptr es:[di], al;
                    goto $1;
                    or byte ptr es:[di], al;
                    goto $1;
                    mov byte ptr es:[di], al;
                    // Block 0x19DE6
                    $1++;
                    loop 0x19dcc;
                }
            }
        } else {
            // Block 0x19D59
            $1 = $2;
            $1 += $2;
            // Compare $1 with $2
            if (a < b (unsigned)) {  // jb 0x19d6c
                // Block 0x19D6C
                jmp 0x19de9;
                // Block 0x19DE9
                return;  // retf 
            } else {
                // Block 0x19D66
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0x19d6e
                    // Block 0x19D6E
                    les di, ptr [bp - 0x58];
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = $2;
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    $1 = $2;
                    $1 -= $2;
                    $1 = $2;
                    cld ;
                    $1 = $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19da4
                        // Block 0x19DA4
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19db0
                            // Block 0x19DB0
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19dbc
                                // Block 0x19DBC
                                mov word ptr [bp - 0x5c], 0x18e;
                            } else {
                                // Block 0x19DB5
                                mov word ptr [bp - 0x5c], 0x189;
                                jmp 0x19dc1;
                                // Block 0x19DC1
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                stc ;
                                rcl bh, 1;
                                if (a >= b (unsigned)) {  // jae 0x19de6
                                    // Block 0x19DE6
                                    $1++;
                                    loop 0x19dcc;
                                } else {
                                    // Block 0x19DD1
                                    goto $1;
                                    xor byte ptr es:[di], al;
                                    goto $1;
                                    and byte ptr es:[di], al;
                                    goto $1;
                                    or byte ptr es:[di], al;
                                    goto $1;
                                    mov byte ptr es:[di], al;
                                    // Block 0x19DE6
                                    $1++;
                                    loop 0x19dcc;
                                }
                            }
                        } else {
                            // Block 0x19DA9
                            mov word ptr [bp - 0x5c], 0x184;
                            jmp 0x19dc1;
                            // Block 0x19DC1
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            stc ;
                            rcl bh, 1;
                            if (a >= b (unsigned)) {  // jae 0x19de6
                                // Block 0x19DE6
                                $1++;
                                loop 0x19dcc;
                            } else {
                                // Block 0x19DD1
                                goto $1;
                                xor byte ptr es:[di], al;
                                goto $1;
                                and byte ptr es:[di], al;
                                goto $1;
                                or byte ptr es:[di], al;
                                goto $1;
                                mov byte ptr es:[di], al;
                                // Block 0x19DE6
                                $1++;
                                loop 0x19dcc;
                            }
                        }
                    } else {
                        // Block 0x19D9D
                        mov word ptr [bp - 0x5c], 0x193;
                        jmp 0x19dc1;
                        // Block 0x19DC1
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        stc ;
                        rcl bh, 1;
                        if (a >= b (unsigned)) {  // jae 0x19de6
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        } else {
                            // Block 0x19DD1
                            goto $1;
                            xor byte ptr es:[di], al;
                            goto $1;
                            and byte ptr es:[di], al;
                            goto $1;
                            or byte ptr es:[di], al;
                            goto $1;
                            mov byte ptr es:[di], al;
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        }
                    }
                } else {
                    // Block 0x19D6C
                    jmp 0x19de9;
                    // Block 0x19DE9
                    return;  // retf 
                }
            }
        }
    } else {
        // Block 0x19D47
        jmp 0x19de9;
        // Block 0x19DE9
        return;  // retf 
    }

    // Function calls:
    sub_19F12(); // Performs arithmetic calculations
}

void sub_19F12(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 19 if statements

    // Block 0x19F12
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19f49
        // Block 0x19F49
        les di, ptr [bp - 0x58];
        $1 = $2;
        $1 = $2;
        $1 += $2;
        lcall es:[di + 0x26];
        $1 = $2;
        *($1) = $2;
        push($1);
        push($1);
        lcall 0xa36, 0xe;
        $1 = $2;
        $1 -= $2;
        *($1) = $2;
        $1 = $2;
        $1 -= $2;
        $1 = $2;
        cld ;
        $1 = $2;
        // Compare $1 with $2
        if (a != b) {  // jne 0x19f8c
            // Block 0x19F8C
            // Compare $1 with $2
            if (a != b) {  // jne 0x19f98
                // Block 0x19F98
                // Compare $1 with $2
                if (a != b) {  // jne 0x19fa4
                    // Block 0x19FA4
                    mov word ptr [bp - 0x5c], 0x1e6;
                } else {
                    // Block 0x19F9D
                    mov word ptr [bp - 0x5c], 0x1e1;
                    jmp 0x19fa9;
                    // Block 0x19FA9
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    stc ;
                    rcl bh, 1;
                    if (a >= b (unsigned)) {  // jae 0x19fce
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    } else {
                        // Block 0x19FB9
                        goto $1;
                        xor byte ptr es:[di], al;
                        goto $1;
                        and byte ptr es:[di], al;
                        goto $1;
                        or byte ptr es:[di], al;
                        goto $1;
                        mov byte ptr es:[di], al;
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    }
                }
            } else {
                // Block 0x19F91
                mov word ptr [bp - 0x5c], 0x1dc;
                jmp 0x19fa9;
                // Block 0x19FA9
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                stc ;
                rcl bh, 1;
                if (a >= b (unsigned)) {  // jae 0x19fce
                    // Block 0x19FCE
                    $1++;
                    if (a != b) {  // jne 0x19fdf
                        // Block 0x19FDF
                        loop 0x19fb4;
                    } else {
                        // Block 0x19FD1
                        $1++;
                        push($1);
                        push($1);
                        lcall 0xa36, 0x63;
                    }
                } else {
                    // Block 0x19FB9
                    goto $1;
                    xor byte ptr es:[di], al;
                    goto $1;
                    and byte ptr es:[di], al;
                    goto $1;
                    or byte ptr es:[di], al;
                    goto $1;
                    mov byte ptr es:[di], al;
                    // Block 0x19FCE
                    $1++;
                    if (a != b) {  // jne 0x19fdf
                        // Block 0x19FDF
                        loop 0x19fb4;
                    } else {
                        // Block 0x19FD1
                        $1++;
                        push($1);
                        push($1);
                        lcall 0xa36, 0x63;
                    }
                }
            }
        } else {
            // Block 0x19F85
            mov word ptr [bp - 0x5c], 0x1eb;
            jmp 0x19fa9;
            // Block 0x19FA9
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            stc ;
            rcl bh, 1;
            if (a >= b (unsigned)) {  // jae 0x19fce
                // Block 0x19FCE
                $1++;
                if (a != b) {  // jne 0x19fdf
                    // Block 0x19FDF
                    loop 0x19fb4;
                } else {
                    // Block 0x19FD1
                    $1++;
                    push($1);
                    push($1);
                    lcall 0xa36, 0x63;
                }
            } else {
                // Block 0x19FB9
                goto $1;
                xor byte ptr es:[di], al;
                goto $1;
                and byte ptr es:[di], al;
                goto $1;
                or byte ptr es:[di], al;
                goto $1;
                mov byte ptr es:[di], al;
                // Block 0x19FCE
                $1++;
                if (a != b) {  // jne 0x19fdf
                    // Block 0x19FDF
                    loop 0x19fb4;
                } else {
                    // Block 0x19FD1
                    $1++;
                    push($1);
                    push($1);
                    lcall 0xa36, 0x63;
                }
            }
        }
    } else {
        // Block 0x19F18
        goto $1;
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x19f24
            // Block 0x19F24
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x19f49
                // Block 0x19F49
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                $1 += $2;
                lcall es:[di + 0x26];
                $1 = $2;
                *($1) = $2;
                push($1);
                push($1);
                lcall 0xa36, 0xe;
                $1 = $2;
                $1 -= $2;
                *($1) = $2;
                $1 = $2;
                $1 -= $2;
                $1 = $2;
                cld ;
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x19f8c
                    // Block 0x19F8C
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19f98
                        // Block 0x19F98
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19fa4
                            // Block 0x19FA4
                            mov word ptr [bp - 0x5c], 0x1e6;
                        } else {
                            // Block 0x19F9D
                            mov word ptr [bp - 0x5c], 0x1e1;
                            jmp 0x19fa9;
                            // Block 0x19FA9
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            stc ;
                            rcl bh, 1;
                            if (a >= b (unsigned)) {  // jae 0x19fce
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            } else {
                                // Block 0x19FB9
                                goto $1;
                                xor byte ptr es:[di], al;
                                goto $1;
                                and byte ptr es:[di], al;
                                goto $1;
                                or byte ptr es:[di], al;
                                goto $1;
                                mov byte ptr es:[di], al;
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            }
                        }
                    } else {
                        // Block 0x19F91
                        mov word ptr [bp - 0x5c], 0x1dc;
                        jmp 0x19fa9;
                        // Block 0x19FA9
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        stc ;
                        rcl bh, 1;
                        if (a >= b (unsigned)) {  // jae 0x19fce
                            // Block 0x19FCE
                            $1++;
                            if (a != b) {  // jne 0x19fdf
                                // Block 0x19FDF
                                loop 0x19fb4;
                            } else {
                                // Block 0x19FD1
                                $1++;
                                push($1);
                                push($1);
                                lcall 0xa36, 0x63;
                            }
                        } else {
                            // Block 0x19FB9
                            goto $1;
                            xor byte ptr es:[di], al;
                            goto $1;
                            and byte ptr es:[di], al;
                            goto $1;
                            or byte ptr es:[di], al;
                            goto $1;
                            mov byte ptr es:[di], al;
                            // Block 0x19FCE
                            $1++;
                            if (a != b) {  // jne 0x19fdf
                                // Block 0x19FDF
                                loop 0x19fb4;
                            } else {
                                // Block 0x19FD1
                                $1++;
                                push($1);
                                push($1);
                                lcall 0xa36, 0x63;
                            }
                        }
                    }
                } else {
                    // Block 0x19F85
                    mov word ptr [bp - 0x5c], 0x1eb;
                    jmp 0x19fa9;
                    // Block 0x19FA9
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    stc ;
                    rcl bh, 1;
                    if (a >= b (unsigned)) {  // jae 0x19fce
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    } else {
                        // Block 0x19FB9
                        goto $1;
                        xor byte ptr es:[di], al;
                        goto $1;
                        and byte ptr es:[di], al;
                        goto $1;
                        or byte ptr es:[di], al;
                        goto $1;
                        mov byte ptr es:[di], al;
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    }
                }
            } else {
                // Block 0x19F33
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x19f46
                    // Block 0x19F46
                    jmp 0x19fe1;
                    // Block 0x19FE1
                    return;  // retf 
                } else {
                    // Block 0x19F40
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x19f49
                        // Block 0x19F49
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        lcall es:[di + 0x26];
                        $1 = $2;
                        *($1) = $2;
                        push($1);
                        push($1);
                        lcall 0xa36, 0xe;
                        $1 = $2;
                        $1 -= $2;
                        *($1) = $2;
                        $1 = $2;
                        $1 -= $2;
                        $1 = $2;
                        cld ;
                        $1 = $2;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19f8c
                            // Block 0x19F8C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19f98
                                // Block 0x19F98
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19fa4
                                    // Block 0x19FA4
                                    mov word ptr [bp - 0x5c], 0x1e6;
                                } else {
                                    // Block 0x19F9D
                                    mov word ptr [bp - 0x5c], 0x1e1;
                                    jmp 0x19fa9;
                                    // Block 0x19FA9
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    stc ;
                                    rcl bh, 1;
                                    if (a >= b (unsigned)) {  // jae 0x19fce
                                        // Block 0x19FCE
                                        $1++;
                                        if (a != b) {  // jne 0x19fdf
                                            // Block 0x19FDF
                                            loop 0x19fb4;
                                        } else {
                                            // Block 0x19FD1
                                            $1++;
                                            push($1);
                                            push($1);
                                            lcall 0xa36, 0x63;
                                        }
                                    } else {
                                        // Block 0x19FB9
                                        goto $1;
                                        xor byte ptr es:[di], al;
                                        goto $1;
                                        and byte ptr es:[di], al;
                                        goto $1;
                                        or byte ptr es:[di], al;
                                        goto $1;
                                        mov byte ptr es:[di], al;
                                        // Block 0x19FCE
                                        $1++;
                                        if (a != b) {  // jne 0x19fdf
                                            // Block 0x19FDF
                                            loop 0x19fb4;
                                        } else {
                                            // Block 0x19FD1
                                            $1++;
                                            push($1);
                                            push($1);
                                            lcall 0xa36, 0x63;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x19F91
                                mov word ptr [bp - 0x5c], 0x1dc;
                                jmp 0x19fa9;
                                // Block 0x19FA9
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                stc ;
                                rcl bh, 1;
                                if (a >= b (unsigned)) {  // jae 0x19fce
                                    // Block 0x19FCE
                                    $1++;
                                    if (a != b) {  // jne 0x19fdf
                                        // Block 0x19FDF
                                        loop 0x19fb4;
                                    } else {
                                        // Block 0x19FD1
                                        $1++;
                                        push($1);
                                        push($1);
                                        lcall 0xa36, 0x63;
                                    }
                                } else {
                                    // Block 0x19FB9
                                    goto $1;
                                    xor byte ptr es:[di], al;
                                    goto $1;
                                    and byte ptr es:[di], al;
                                    goto $1;
                                    or byte ptr es:[di], al;
                                    goto $1;
                                    mov byte ptr es:[di], al;
                                    // Block 0x19FCE
                                    $1++;
                                    if (a != b) {  // jne 0x19fdf
                                        // Block 0x19FDF
                                        loop 0x19fb4;
                                    } else {
                                        // Block 0x19FD1
                                        $1++;
                                        push($1);
                                        push($1);
                                        lcall 0xa36, 0x63;
                                    }
                                }
                            }
                        } else {
                            // Block 0x19F85
                            mov word ptr [bp - 0x5c], 0x1eb;
                            jmp 0x19fa9;
                            // Block 0x19FA9
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            stc ;
                            rcl bh, 1;
                            if (a >= b (unsigned)) {  // jae 0x19fce
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            } else {
                                // Block 0x19FB9
                                goto $1;
                                xor byte ptr es:[di], al;
                                goto $1;
                                and byte ptr es:[di], al;
                                goto $1;
                                or byte ptr es:[di], al;
                                goto $1;
                                mov byte ptr es:[di], al;
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            }
                        }
                    } else {
                        // Block 0x19F46
                        jmp 0x19fe1;
                        // Block 0x19FE1
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x19F21
            jmp 0x19fe1;
            // Block 0x19FE1
            return;  // retf 
        }
    }
}

void sub_1A25E(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1A25E
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cld ;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 4

    // Function calls:
    sub_1A25E(); // Manipulates strings or memory blocks and performs calculations
}

void sub_1A2DE(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 12

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 42 if statements

    // Block 0x1A2DE
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 0x16];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (a == b) {  // je 0x1a301
        // Block 0x1A301
        lds si, ptr [bp - 0x16];
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        mov word ptr [bp - 8], 0;
        test word ptr [si + 0x18], 0x10;
        if (a == b) {  // je 0x1a328
            // Block 0x1A328
            push($1);
            lea ax, [bp - 0x10];
            push($1);
            push($1);
            lea ax, [bp - 0x12];
            push($1);
            lcall 0x96b, 0x66;
            or ax, ax;
            if (a == b) {  // je 0x1a340
                // Block 0x1A340
                lds si, ptr [bp + 6];
                les di, ptr [bp - 0x10];
                push($1);
                cld ;
                $1 = $2;
                rep movsb byte ptr es:[di], byte ptr [si];
                $1 = pop();
                $1 = $2;
                push($1);
                $1 = $2;
                push($1);
                push($1);
                call 0x1a25e;
                // Block 0x1A35A
                // Compare $1 with $2
                if (a > b (unsigned)) {  // ja 0x1a366
                    // Block 0x1A366
                    *($1) = $2;
                    mov word ptr [bp - 2], 0;
                    lds si, ptr [si + 0xa8];
                    les di, ptr [bp + 6];
                    $1 = $2;
                    lds si, ptr [bp - 0x16];
                    lds si, ptr [si + 0xa8];
                    $1 = $2;
                    $1 = 0;
                    // Compare $1 with $2
                    if (a < b (unsigned)) {  // jb 0x1a3b2
                        // Block 0x1A3B2
                        $1++;
                        loop 0x1a37f;
                    } else {
                        // Block 0x1A389
                        // Compare $1 with $2
                        if (a > b (unsigned)) {  // ja 0x1a3b2
                            // Block 0x1A3B2
                            $1++;
                            loop 0x1a37f;
                        } else {
                            // Block 0x1A38E
                            $1 = $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x1a3af
                                // Block 0x1A3AF
                                add word ptr [bp - 2], ax;
                            } else {
                                // Block 0x1A396
                                $1 = $2;
                                $1 = 0;
                                $1 -= $2;
                                shl bx, 1;
                                $1 = $2;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x1a3af
                                    // Block 0x1A3AF
                                    add word ptr [bp - 2], ax;
                                } else {
                                    // Block 0x1A3A7
                                    // Compare $1 with $2
                                    if (a <= b) {  // jle 0x1a3b2
                                        // Block 0x1A3B2
                                        $1++;
                                        loop 0x1a37f;
                                    } else {
                                        // Block 0x1A3AC
                                        add ax, word ptr [bp - 0xa];
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x1A35F
                    mov word ptr [bp - 2], 0;
                    jmp 0x1a3b5;
                    // Block 0x1A3B5
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                }
            } else {
                // Block 0x1A33B
                *($1) = $2;
                jmp 0x1a3b5;
                // Block 0x1A3B5
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            }
        } else {
            // Block 0x1A322
            $1 = $2;
            mov word ptr [bp - 8], ax;
        }
    } else {
        // Block 0x1A2FB
        *($1) = $2;
        jmp 0x1a3b5;
        // Block 0x1A3B5
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_1A25E(); // Manipulates strings or memory blocks and performs calculations
    sub_1A2DE(); // Manipulates strings or memory blocks and performs calculations
    sub_1A78A(); // Performs arithmetic calculations
}

void sub_1A78A(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1A78A
    cmp word ptr [bp - 0x48], 0;
    if (a != b) {  // jne 0x1a7b2
        // Block 0x1A7B2
        return;  // retf 
    } else {
        // Block 0x1A790
        $1 = $2;
        $1 = $2;
        $1 += $2;
        $1 = $2;
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        lcall 0x1787, 8;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1++;
        loop 0x1a79c;
    }
}

void sub_1A878(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x1A878
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x1a8a8
        // Block 0x1A8A8
        *($1) = $2;
        push($1);
        push($1);
        push($1);
        $1 = $2;
        push($1);
        push($1);
        lea ax, [bp - 0xe];
        push($1);
        push($1);
        lea ax, [bp - 0x10];
        push($1);
        lcall 0x96b, 0x166;
        or ax, ax;
        if (a == b) {  // je 0x1a8ce
            // Block 0x1A8CE
            lds si, ptr [bp - 0xe];
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            les di, ptr [bp + 6];
            mov word ptr es:[di], ax;
            $1 += $2;
            if (a >= b (unsigned)) {  // jae 0x1a8f2
                // Block 0x1A8F2
                $1 = $2;
                $1 -= $2;
                $1++;
                $1 = 0;
                $1 = $2;
                $1 -= $2;
                $1 = $2;
                shr ax, 1;
                shr ax, 1;
                shr ax, 1;
                and bx, 7;
                if (a == b) {  // je 0x1a90e
                    // Block 0x1A90E
                    shl ax, 1;
                    shl ax, 1;
                    shl ax, 1;
                    $1 += $2;
                    $1++;
                    $1++;
                    loop 0x1a8fb;
                    les di, ptr [bp + 0xa];
                    mov word ptr es:[di], dx;
                    mov word ptr [bp - 2], 0;
                    lcall 0x96b, 0x1c0;
                } else {
                    // Block 0x1A90D
                    inc ax;
                }
            } else {
                // Block 0x1A8EB
                mov word ptr [bp - 2], 0xfc18;
                jmp 0x1a92a;
                // Block 0x1A92A
                push($1);
                push($1);
                lcall 0x80c, 0x640;
            }
        } else {
            // Block 0x1A8C9
            *($1) = $2;
            jmp 0x1a935;
            // Block 0x1A935
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0x10
        }
    } else {
        // Block 0x1A8A2
        *($1) = $2;
        jmp 0x1a935;
        // Block 0x1A935
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0x10
    }

    // Function calls:
    sub_1A878(); // Performs arithmetic calculations
}

void sub_1A97C(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x1A97C
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    call 0x1a878;
    // Block 0x1A9A5
    or ax, ax;
    if (a == b) {  // je 0x1a9ab
        // Block 0x1A9AB
        $1 = $2;
        push($1);
        push($1);
        push($1);
        lcall 0xb08, 0x2e7;
        test dx, 0x8000;
        if (a != b) {  // jne 0x1a9cc
            // Block 0x1A9CC
            *($1) = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 8
        } else {
            // Block 0x1A9C0
            $1 = $2;
            $1 += $2;
            $1 += $2;
            adc dx, 0;
        }
    } else {
        // Block 0x1A9A9
        jmp 0x1a9cc;
        // Block 0x1A9CC
        *($1) = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }

    // Function calls:
    sub_1A878(); // Performs arithmetic calculations
    sub_1A97C(); // Manipulates strings or memory blocks and performs calculations
    sub_1ABE3(); // Manipulates strings or memory blocks and performs calculations
}

void sub_1ABE3(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 5

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x1ABE3
    lds si, ptr [bp + 0xe];
    les di, ptr [bp + 0xe];
    $1 = $2;
    cld ;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cx, cx;
    if (a == b) {  // je 0x1ac01
        // Block 0x1AC01
        push($1);
        push($1);
        lcall 0x1865, 0x8e;
        *($1) = $2;
        cmp byte ptr es:[di - 1], 0;
        if (a != b) {  // jne 0x1ac19
            // Block 0x1AC19
            $1 = $2;
            $1 += $2;
            // Compare $1 with $2
            if (a <= b) {  // jle 0x1ac3b
                // Block 0x1AC3B
                $1 = $2;
                $1 = $2;
                $1 = $2;
                les di, ptr [bp + 0xe];
                $1 += $2;
                $1 = 0;
                $1 = $2;
                *($1) = $2;
                inc bx;
            } else {
                // Block 0x1AC24
                cmp word ptr [bp - 0x1c], 0;
                if (a != b) {  // jne 0x1ac2d
                    // Block 0x1AC2D
                    mov word ptr [bp - 0x1c], 0;
                    $1 = $2;
                    $1 += $2;
                    mov word ptr [bp - 0x1e], ax;
                } else {
                    // Block 0x1AC2A
                    jmp 0x1ad0b;
                    // Block 0x1AD0B
                    $1 = $2;
                    return;  // retf 
                }
            }
        } else {
            // Block 0x1AC12
            $1 = $2;
            mov byte ptr es:[di - 1], al;
        }
    } else {
        // Block 0x1ABF5
        $1 = $2;
        *($1) = $2;
        mov byte ptr es:[di - 1], 0;
    }
}

void sub_1AD1A(void) {
    // Purpose: Closes a file and performs calculations

    // Complexity: 9

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 13 if statements

    // Block 0x1AD1A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    cmp word ptr [0xa0], 0;
    if (a != b) {  // jne 0x1ad33
        // Block 0x1AD33
        call 0x1aecb;
        // Block 0x1AD36
        if (a >= b (unsigned)) {  // jae 0x1ad64
            // Block 0x1AD64
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            call 0x1af95;
            // Block 0x1AD70
            $1 = $2;
            if (a < b (unsigned)) {  // jb 0x1ad5a
                // Block 0x1AD5A
                $1 = $2;
                INT_21();  // int 0x21
                $1 = $2;
                jmp 0x1ae41;
                // Block 0x1AE41
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 8
            } else {
                // Block 0x1AD75
                $1 = 0;
                $1 = 0;
                cmp word ptr [bp - 0x14], 0x5a4d;
                if (a == b) {  // je 0x1ad85
                    // Block 0x1AD85
                    $1 = $2;
                    $1 = $2;
                    if (condition_jcxz) {  // jcxz 0x1ad8e
                        // Block 0x1AD8E
                        $1 = $2;
                        mul dx;
                        $1 += $2;
                        $1 += $2;
                        adc dx, 0;
                        and ax, 0xfff0;
                    } else {
                        // Block 0x1AD8D
                        dec ax;
                    }
                } else {
                    // Block 0x1AD80
                    $1 = $2;
                    jmp 0x1ad5a;
                    // Block 0x1AD5A
                    $1 = $2;
                    INT_21();  // int 0x21
                    $1 = $2;
                    jmp 0x1ae41;
                    // Block 0x1AE41
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 8
                }
            }
        } else {
            // Block 0x1AD38
            $1 = $2;
            or ax, word ptr [bp + 8];
            if (a != b) {  // jne 0x1ad4a
                // Block 0x1AD4A
                call 0x1aebf;
                // Block 0x1AD4D
                if (a >= b (unsigned)) {  // jae 0x1ad64
                    // Block 0x1AD64
                    $1 = $2;
                    *($1) = $2;
                    $1 = $2;
                    call 0x1af95;
                    // Block 0x1AD70
                    $1 = $2;
                    if (a < b (unsigned)) {  // jb 0x1ad5a
                        // Block 0x1AD5A
                        $1 = $2;
                        INT_21();  // int 0x21
                        $1 = $2;
                        jmp 0x1ae41;
                        // Block 0x1AE41
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    } else {
                        // Block 0x1AD75
                        $1 = 0;
                        $1 = 0;
                        cmp word ptr [bp - 0x14], 0x5a4d;
                        if (a == b) {  // je 0x1ad85
                            // Block 0x1AD85
                            $1 = $2;
                            $1 = $2;
                            if (condition_jcxz) {  // jcxz 0x1ad8e
                                // Block 0x1AD8E
                                $1 = $2;
                                mul dx;
                                $1 += $2;
                                $1 += $2;
                                adc dx, 0;
                                and ax, 0xfff0;
                            } else {
                                // Block 0x1AD8D
                                dec ax;
                            }
                        } else {
                            // Block 0x1AD80
                            $1 = $2;
                            jmp 0x1ad5a;
                            // Block 0x1AD5A
                            $1 = $2;
                            INT_21();  // int 0x21
                            $1 = $2;
                            jmp 0x1ae41;
                            // Block 0x1AE41
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    }
                } else {
                    // Block 0x1AD4F
                    call 0x1af10;
                    // Block 0x1AD52
                    if (a >= b (unsigned)) {  // jae 0x1ad64
                        // Block 0x1AD64
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        call 0x1af95;
                        // Block 0x1AD70
                        $1 = $2;
                        if (a < b (unsigned)) {  // jb 0x1ad5a
                            // Block 0x1AD5A
                            $1 = $2;
                            INT_21();  // int 0x21
                            $1 = $2;
                            jmp 0x1ae41;
                            // Block 0x1AE41
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        } else {
                            // Block 0x1AD75
                            $1 = 0;
                            $1 = 0;
                            cmp word ptr [bp - 0x14], 0x5a4d;
                            if (a == b) {  // je 0x1ad85
                                // Block 0x1AD85
                                $1 = $2;
                                $1 = $2;
                                if (condition_jcxz) {  // jcxz 0x1ad8e
                                    // Block 0x1AD8E
                                    $1 = $2;
                                    mul dx;
                                    $1 += $2;
                                    $1 += $2;
                                    adc dx, 0;
                                    and ax, 0xfff0;
                                } else {
                                    // Block 0x1AD8D
                                    dec ax;
                                }
                            } else {
                                // Block 0x1AD80
                                $1 = $2;
                                jmp 0x1ad5a;
                                // Block 0x1AD5A
                                $1 = $2;
                                INT_21();  // int 0x21
                                $1 = $2;
                                jmp 0x1ae41;
                                // Block 0x1AE41
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 8
                            }
                        }
                    } else {
                        // Block 0x1AD54
                        $1 = $2;
                        jmp 0x1ae41;
                        // Block 0x1AE41
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    }
                }
            } else {
                // Block 0x1AD40
                mov word ptr [bp + 6], 0x4a8;
                mov word ptr [bp + 8], 0x19b2;
            }
        }
    } else {
        // Block 0x1AD30
        jmp 0x1ae3f;
        // Block 0x1AE3F
        xor ax, ax;
    }

    // Function calls:
    sub_1AECB(); // Performs DOS operations and manipulates strings or memory blocks
    sub_1AEBF(); // Unknown function purpose
    sub_1AF10(); // Manipulates strings or memory blocks
    sub_1AF95(); // Reads data from a file
    sub_1AF95(); // Reads data from a file
    sub_1AE4A(); // Opens a file
    sub_1AFA5(); // Performs arithmetic calculations
    sub_1B025(); // Performs arithmetic calculations
}

void sub_1AE4A(int) {
    // Purpose: Opens a file

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1AE4A
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21_AH35();  // int 0x21
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21_AH25();  // int 0x21
    $1 = pop();
    $1 = pop();
    $1 = pop();
    cmp word ptr [0xb8], 0;
    if (a == b) {  // je 0x1ae8c
        // Block 0x1AE8C
        lea dx, [0x1c];
        $1 = $2;
        $1 = $2;
        DOS_OpenFile();  // int 0x21
        mov word ptr [0xb8], ax;
    } else {
        // Block 0x1AE7C
        $1 = $2;
        $1 = $2;
        DOS_CloseFile();  // int 0x21
        mov word ptr [0xb8], 0;
        jmp 0x1ae9a;
        // Block 0x1AE9A
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_1AE4A(); // Opens a file
}

void sub_1AEBF(void) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1AEBF
    push($1);
    lea di, [0x1c];
    push($1);
    $1 = pop();
    call 0x1af6d;
    // Block 0x1AEC9
    $1 = pop();
    return;  // ret 

    // Function calls:
    sub_1AF6D(); // Opens a file and manipulates strings or memory blocks and performs calculations
}

void sub_1AECB(int) {
    // Purpose: Performs DOS operations and manipulates strings or memory blocks

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;
    int var_06_i;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1AECB
    $1 = $2;
    INT_21();  // int 0x21
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x1af0f
        // Block 0x1AF0F
        return;  // ret 
    } else {
        // Block 0x1AED3
        mov byte ptr [6], 0x20;
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = 0;
        cld ;
    }

    // Function calls:
    sub_1AF6D(); // Opens a file and manipulates strings or memory blocks and performs calculations
}

void sub_1AF10(int, int) {
    // Purpose: Manipulates strings or memory blocks

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x1AF10
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xor si, si;

    // Function calls:
    sub_1AF6D(); // Opens a file and manipulates strings or memory blocks and performs calculations
}

void sub_1AF6D(int, int) {
    // Purpose: Opens a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1AF6D
    lds si, ptr [bp + 6];
    $1 = $2;
    or ax, si;
    if (a == b) {  // je 0x1af84
        // Block 0x1AF84
        lea dx, [0x1c];
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_OpenFile();  // int 0x21
        return;  // ret 
    } else {
        // Block 0x1AF76
        $1 = $2;
        lodsb al, byte ptr [si];
        stosb byte ptr es:[di], al;
        or al, al;
        if (a == b) {  // je 0x1af84
            // Block 0x1AF84
            lea dx, [0x1c];
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            DOS_OpenFile();  // int 0x21
            return;  // ret 
        } else {
            // Block 0x1AF7F
            loop 0x1af79;
            $1 -= $2;
            stosb byte ptr es:[di], al;
        }
    }
}

void sub_1AF95(int, int) {
    // Purpose: Reads data from a file

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1AF95
    push($1);
    lea dx, [bp - 0x14];
    push($1);
    $1 = pop();
    $1 = $2;
    DOS_ReadFile();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x1afa4
        // Block 0x1AFA4
        return;  // ret 
    } else {
        // Block 0x1AFA2
        cmp ax, cx;
    }
}

void sub_1AFA5(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1AFA5
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    mov word ptr cs:[0x18], ax;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    lea si, [0xc0];

    // Function calls:
    sub_1B4B7(); // Performs arithmetic calculations
}

void sub_1B025(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x1B025
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push ds;

    // Function calls:
    sub_1B0F2(); // Reads data from a file and performs calculations
    sub_1B12B(); // Manipulates strings or memory blocks and performs calculations
    sub_1B39D(); // Manipulates strings or memory blocks
}

void sub_1B0F2(int, int) {
    // Purpose: Reads data from a file and performs calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x1B0F2
    push($1);
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    jmp 0x1b109;
    // Block 0x1B109
    $1 = $2;
    or di, di;
    if (a != b) {  // jne 0x1b112
        // Block 0x1B112
        $1 = 0;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        if (a < b (unsigned)) {  // jb 0x1b129
            // Block 0x1B129
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x1B11A
            // Compare $1 with $2
            if (a < b (unsigned)) {  // jb 0x1b129
                // Block 0x1B129
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x1B11E
                $1 -= $2;
                sbb di, 0;
                $1 = $2;
                or ax, di;
                if (a != b) {  // jne 0x1b102
                    // Block 0x1B102
                    $1 = $2;
                    $1 += $2;
                    mov ds, ax;
                } else {
                    // Block 0x1B129
                    $1 = pop();
                    return;  // ret 
                }
            }
        }
    } else {
        // Block 0x1B110
        mov cx, si;
    }
}

void sub_1B12B(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B12B
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    and si, 0xf;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shr cx, 1;
    cld ;
    lodsw ax, word ptr [si];
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and di, 0xfff8;
    $1 = $2;
    mov word ptr es:[bx], dx;
    test ax, 1;
    if (a == b) {  // je 0x1b16a
        // Block 0x1B16A
        $1 = pop();
        loop 0x1b14c;
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1B167
        call 0x1b170;
        // Block 0x1B16A
        $1 = pop();
        loop 0x1b14c;
        $1 = pop();
        $1 = pop();
        return;  // ret 
    }

    // Function calls:
    sub_1B170(); // Performs arithmetic calculations
}

void sub_1B170(int, int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // int data_dx; // from parameter 4
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x1B170
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and ax, 0xf807;
    // Compare $1 with $2
    if (a != b) {  // jne 0x1b1cc
        // Block 0x1B1CC
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1B181
        $1 = $2;
        $1 = $2;
        $1 = $2;
        and ax, 0xf807;
        // Compare $1 with $2
        if (a != b) {  // jne 0x1b1cc
            // Block 0x1B1CC
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x1B191
            // Compare $1 with $2
            if (a != b) {  // jne 0x1b1cc
                // Block 0x1B1CC
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x1B195
                $1 = $2;
                $1 = $2;
                $1 = $2;
                and ax, 0xf807;
                // Compare $1 with $2
                if (a != b) {  // jne 0x1b1cc
                    // Block 0x1B1CC
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x1B1A4
                    $1 = $2;
                    $1 = $2;
                    and ax, 0xf807;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x1b1cc
                        // Block 0x1B1CC
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x1B1B1
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        // Compare $1 with $2
                        if (a == b) {  // je 0x1b1c8
                            // Block 0x1B1C8
                            mov word ptr es:[bx + 4], di;
                        } else {
                            // Block 0x1B1C1
                            $1 += $2;
                            loop 0x1b1bc;
                            jmp 0x1b1ce;
                            // Block 0x1B1CE
                            $1 = pop();
                            return;  // ret 
                        }
                    }
                }
            }
        }
    }

    // Function calls:
    sub_1B0F2(); // Reads data from a file and performs calculations
    sub_1B12B(); // Manipulates strings or memory blocks and performs calculations
    sub_1B2AE(); // Performs arithmetic calculations
    sub_1B2AE(); // Performs arithmetic calculations
}

void sub_1B264(int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x1B264
    push($1);
    $1++;
    call 0x1b4b7;
    // Block 0x1B26C
    jmp 0x1b29c;
    // Block 0x1B29C
    call 0x1b48f;
    // Block 0x1B29F
    pushf ;
    // Compare $1 with $2
    if (a > b (unsigned)) {  // ja 0x1b26e
        // Block 0x1B26E
        popf ;
        push($1);
        if (a >= b (unsigned)) {  // jae 0x1b275
            // Block 0x1B275
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            cmp byte ptr es:[0x1b], 0;
            if (a != b) {  // jne 0x1b290
                // Block 0x1B290
                $1--;
                call 0x1b3ee;
                // Block 0x1B298
                call 0x1b43f;
                // Block 0x1B29B
                pop dx;
            } else {
                // Block 0x1B288
                call 0x1b329;
                // Block 0x1B28B
                call 0x1b4ab;
                // Block 0x1B28E
                jmp 0x1b29b;
                // Block 0x1B29B
                pop dx;
            }
        } else {
            // Block 0x1B272
            call 0x1b341;
            // Block 0x1B275
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            cmp byte ptr es:[0x1b], 0;
            if (a != b) {  // jne 0x1b290
                // Block 0x1B290
                $1--;
                call 0x1b3ee;
                // Block 0x1B298
                call 0x1b43f;
                // Block 0x1B29B
                pop dx;
            } else {
                // Block 0x1B288
                call 0x1b329;
                // Block 0x1B28B
                call 0x1b4ab;
                // Block 0x1B28E
                jmp 0x1b29b;
                // Block 0x1B29B
                pop dx;
            }
        }
    } else {
        // Block 0x1B2A4
        popf ;
        $1 = pop();
        $1 = $2;
        mov word ptr es:[0x10], ax;
        return;  // ret 
    }

    // Function calls:
    sub_1B4B7(); // Performs arithmetic calculations
    sub_1B341(); // Performs arithmetic calculations
    sub_1B329(); // Unknown function purpose
    sub_1B4AB(); // Performs arithmetic calculations
    sub_1B3EE(); // Manipulates strings or memory blocks and performs calculations
    sub_1B43F(); // Performs arithmetic calculations
    sub_1B48F(); // Performs arithmetic calculations
}

void sub_1B2AE(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 4

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1B2AE
    $1++;
    cmp word ptr es:[0x10], 0;
    if (a == b) {  // je 0x1b2c9
        // Block 0x1B2C9
        or byte ptr es:[0x1a], 8;
        call 0x1b264;
        // Block 0x1B2D2
        push($1);
        $1--;
        $1 = $2;
        *($1) = $2;
        $1 = pop();
        call word ptr es:[0x18];
        // Block 0x1B2E0
        if (a < b (unsigned)) {  // jb 0x1b324
            // Block 0x1B324
            ljmp 0:0xd87;
        } else {
            // Block 0x1B2E2
            call 0x1b43f;
            // Block 0x1B2E5
            call 0x1b37c;
            // Block 0x1B2E8
            $1 = $2;
            and al, 3;
            add byte ptr es:[0x1b], al;
            push($1);
            call 0x1b48f;
            // Block 0x1B2F7
            mov es, word ptr [0xbc];
        }
    } else {
        // Block 0x1B2BA
        mov byte ptr es:[0x1b], 1;
        or byte ptr es:[0x1a], 4;
        goto $1;
        nop ;
        // Block 0x1B2E5
        call 0x1b37c;
        // Block 0x1B2E8
        $1 = $2;
        and al, 3;
        add byte ptr es:[0x1b], al;
        push($1);
        call 0x1b48f;
        // Block 0x1B2F7
        mov es, word ptr [0xbc];
    }

    // Function calls:
    sub_1B264(); // Unknown function purpose
    sub_1B43F(); // Performs arithmetic calculations
    sub_1B37C(); // Unknown function purpose
    sub_1B48F(); // Performs arithmetic calculations
    sub_1B3BB(); // Manipulates strings or memory blocks
    sub_1B4AB(); // Performs arithmetic calculations
}

void sub_1B329(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B329
    call 0x1b3bb;
    // Block 0x1B32C
    cmp word ptr es:[0x18], 0x4d0;
    if (a != b) {  // jne 0x1b339
        // Block 0x1B339
        mov word ptr es:[0x10], 0;
        return;  // ret 
    } else {
        // Block 0x1B335
        call word ptr [0x10];
        // Block 0x1B339
        mov word ptr es:[0x10], 0;
        return;  // ret 
    }

    // Function calls:
    sub_1B3BB(); // Manipulates strings or memory blocks
}

void sub_1B341(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B341
    $1 = $2;
    xor cx, cx;

    // Function calls:
    sub_1B4AB(); // Performs arithmetic calculations
    sub_1B3EE(); // Manipulates strings or memory blocks and performs calculations
}

int sub_1B37C(int, int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x1B37C
    cmp word ptr es:[0xc], 0;
    if (a != b) {  // jne 0x1b385
        // Block 0x1B385
        cmp byte ptr es:[0x20], 0xea;
        if (a == b) {  // je 0x1b3ba
            // Block 0x1B3BA
        } else {
            // Block 0x1B38D
            $1 = $2;
            if (condition_jcxz) {  // jcxz 0x1b39d
                // Block 0x1B39D
            } else {
                // Block 0x1B394
                $1 = $2;
                $1 = $2;
                call 0x1b45d;
                // Block 0x1B39D
            }
        }
    } else {
        // Block 0x1B384
        return;  // ret 
    }

    // Function calls:
    sub_1B45D(); // Unknown function purpose
}

void sub_1B39D(int, int, int, int) {
    // Purpose: Manipulates strings or memory blocks

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // int data_dx; // from parameter 4
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1B39D
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    loop 0x1b3ab;
    return;  // ret 
}

void sub_1B3BB(int, int, int) {
    // Purpose: Manipulates strings or memory blocks

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B3BB
    cmp byte ptr es:[0x20], 0xcd;
    if (a == b) {  // je 0x1b3ed
        // Block 0x1B3ED
        return;  // ret 
    } else {
        // Block 0x1B3C3
        $1 = $2;
        $1 = $2;
        $1 = 0;
        call 0x1b45d;
        // Block 0x1B3CF
        mov word ptr es:[2], cx;
        $1 = $2;
        $1 = $2;
        cld ;
        $1 = $2;
        $1 = $2;
        stosw word ptr es:[di], ax;
        $1 = $2;
        stosw word ptr es:[di], ax;
        $1 = 0;
        stosb byte ptr es:[di], al;
        loop 0x1b3dd;
    }

    // Function calls:
    sub_1B45D(); // Unknown function purpose
}

void sub_1B3EE(int, int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1B3EE
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x10], ax;
    $1 = $2;
    $1++;
    shr cx, 1;
    $1 = 0;
    cld ;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x1b40f
        // Block 0x1B40F
        $1 = $2;
        push($1);
        push($1);
        $1 = $2;
        $1 = $2;
        rep movsw word ptr es:[di], word ptr [si];
        cld ;
        $1--;
        $1 = $2;
        $1 = pop();
        *($1) = $2;
        $1++;
        $1 = pop();
        cmp byte ptr es:[0x20], 0xcd;
        if (a == b) {  // je 0x1b43e
            // Block 0x1B43E
            return;  // ret 
        } else {
            // Block 0x1B42C
            call 0x1b469;
            // Block 0x1B42F
            $1 = $2;
            $1 = $2;
            cld ;
            stosw word ptr es:[di], ax;
            $1 += $2;
            loop 0x1b438;
        }
    } else {
        // Block 0x1B409
        $1 = $2;
        $1--;
        shl si, 1;
        std ;
    }

    // Function calls:
    sub_1B469(); // Unknown function purpose
}

void sub_1B43F(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B43F
    call 0x1b4ab;
    // Block 0x1B442
    add word ptr [0xb0], ax;
    push($1);
    mov ax, 0x19b0;

    // Function calls:
    sub_1B4AB(); // Performs arithmetic calculations
}

void sub_1B45D(void) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B45D
    call 0x1b469;
    // Block 0x1B460
    or bx, bx;
    if (a == b) {  // je 0x1b468
        // Block 0x1B468
        return;  // ret 
    } else {
        // Block 0x1B464
        xchg word ptr ss:[bx + 2], cx;
    }

    // Function calls:
    sub_1B469(); // Unknown function purpose
}

void sub_1B469(int) {
    // Purpose: Unknown function purpose

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x1B469
    $1 = 0;
    push($1);
    push($1);
    jmp 0x1b473;
    // Block 0x1B473
    $1 = $2;
    shr cx, 1;
    if (a == b) {  // je 0x1b48c
        // Block 0x1B48C
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1B47A
        if (a < b (unsigned)) {  // jb 0x1b46f
            // Block 0x1B46F
            shl cx, 1;
            mov bp, cx;
        } else {
            // Block 0x1B47C
            // Compare $1 with $2
            if (a != b) {  // jne 0x1b46f
                // Block 0x1B46F
                shl cx, 1;
                mov bp, cx;
            } else {
                // Block 0x1B481
                *($1) = $2;
                or bx, bx;
                if (a != b) {  // jne 0x1b46f
                    // Block 0x1B46F
                    shl cx, 1;
                    mov bp, cx;
                } else {
                    // Block 0x1B488
                    $1 = $2;
                    jmp 0x1b46f;
                    // Block 0x1B46F
                    shl cx, 1;
                    mov bp, cx;
                }
            }
        }
    }
}

void sub_1B48F(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1B48F
    $1 = $2;
    or ax, ax;
    if (a == b) {  // je 0x1b4a2
        // Block 0x1B4A2
        $1 = $2;
        $1 -= $2;
        stc ;
    } else {
        // Block 0x1B496
        $1 = $2;
        $1 = $2;
        $1 -= $2;
        if (a >= b (unsigned)) {  // jae 0x1b4aa
            // Block 0x1B4AA
            return;  // ret 
        } else {
            // Block 0x1B4A2
            $1 = $2;
            $1 -= $2;
            stc ;
        }
    }
}

void sub_1B4AB(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1B4AB
    $1 = $2;
    $1 += $2;
    $1 = $2;
    shr ax, cl;
    return;  // ret 
}

int sub_1B4B7(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 10

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 29 if statements

    // Block 0x1B4B7
    $1 = $2;
    $1 = $2;
    $1 += $2;
    shr ax, cl;
    $1 = $2;
    $1 += $2;
    shr dx, cl;
    $1 += $2;
    return;  // ret 

    // Function calls:
    sub_1B2AE(); // Performs arithmetic calculations
    sub_1AFA5(); // Performs arithmetic calculations
    sub_1AD1A(); // Closes a file and performs calculations
}

void sub_1D57(void) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1D57
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    call 0x1e31;
    // Block 0x1D67
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_1E31(); // Performs arithmetic calculations
}

void sub_1D6A(void) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1D6A
    return;  // retf 
}

void sub_1D6B(int, int) {
    // Purpose: Performs DOS operations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1D6B
    $1 = $2;
    $1 = $2;
    $1 = $2;
    DOS_TerminateWithReturnCode();  // int 0x21
    $1 = $2;
    $1 = $2;
    jmp 0x1e80;
    // Block 0x1E80
}

void sub_1D7D(int, int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1D7D
    push($1);
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    $1 = pop();
    return;  // ret 
}

void sub_1DC0(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x1DC0
    push($1);
    $1 = $2;
    lds dx, ptr [0x5b];
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x5f];
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x63];
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x67];
    INT_21();  // int 0x21
    $1 = pop();
    return;  // retf 
}

void sub_1DED(int, int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // int data_dx; // from parameter 4
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1DED
    $1 = $2;
    $1 = $2;
    mov bx, si;
}

void sub_1E31(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1E31
    $1 = $2;
    $1 = $2;
    mov bx, si;
}

void sub_1E72(int, int, int, int) {
    // Purpose: Writes data to a file and manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // int data_dx; // from parameter 4
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x1E72
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    return;  // ret 

    // Function calls:
    sub_1E72(); // Writes data to a file and manipulates strings or memory blocks and performs calculations
    sub_2ACF(); // Performs arithmetic calculations
    sub_1F91(); // Performs arithmetic calculations
    sub_1F91(); // Performs arithmetic calculations
}

void sub_1F91(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 16 if statements

    // Block 0x1F91
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lds si, ptr [si];
    or si, si;
    if (a == b) {  // je 0x1fe3
        // Block 0x1FE3
        $1 = 0;
        goto $1;
        add byte ptr [bx + si], al;
        add byte ptr [bx + si], al;
        add byte ptr [bx + si], al;
        add byte ptr [bp + si], al;
        add byte ptr [bx + si], al;
        $1 += $2;
        add byte ptr [bx + si], al;
        push($1);
        $1 = $2;
        push($1);
        push($1);
        push($1);
        push($1);
        cld ;
        push($1);
        $1 = $2;
        push($1);
        $1 = 0;
        push($1);
        push($1);
        les dx, ptr [bp + 6];
        push($1);
        push($1);
        nop ;
        push($1);
        call 0x2495;
        // Block 0x1FE0
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1FA0
        nop ;
        nop ;
        nop ;
        $1 -= $2;
        cmp word ptr [si], 0x494d;
        if (a != b) {  // jne 0x1fca
            // Block 0x1FCA
            cmp word ptr [si], 0x454b;
            if (a != b) {  // jne 0x1fe3
                // Block 0x1FE3
                $1 = 0;
                goto $1;
                add byte ptr [bx + si], al;
                add byte ptr [bx + si], al;
                add byte ptr [bx + si], al;
                add byte ptr [bp + si], al;
                add byte ptr [bx + si], al;
                $1 += $2;
                add byte ptr [bx + si], al;
                push($1);
                $1 = $2;
                push($1);
                push($1);
                push($1);
                push($1);
                cld ;
                push($1);
                $1 = $2;
                push($1);
                $1 = 0;
                push($1);
                push($1);
                les dx, ptr [bp + 6];
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x2495;
                // Block 0x1FE0
                $1 = pop();
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x1FD0
                nop ;
                nop ;
                nop ;
                cmp word ptr [si + 2], 0x4e52;
                if (a != b) {  // jne 0x1fe3
                    // Block 0x1FE3
                    $1 = 0;
                    goto $1;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bp + si], al;
                    add byte ptr [bx + si], al;
                    $1 += $2;
                    add byte ptr [bx + si], al;
                    push($1);
                    $1 = $2;
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    cld ;
                    push($1);
                    $1 = $2;
                    push($1);
                    $1 = 0;
                    push($1);
                    push($1);
                    les dx, ptr [bp + 6];
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x2495;
                    // Block 0x1FE0
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x1FDA
                    nop ;
                    nop ;
                    nop ;
                }
            }
        } else {
            // Block 0x1FAC
            nop ;
            nop ;
            nop ;
            cmp word ptr [si + 2], 0x4944;
            if (a != b) {  // jne 0x1fca
                // Block 0x1FCA
                cmp word ptr [si], 0x454b;
                if (a != b) {  // jne 0x1fe3
                    // Block 0x1FE3
                    $1 = 0;
                    goto $1;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bp + si], al;
                    add byte ptr [bx + si], al;
                    $1 += $2;
                    add byte ptr [bx + si], al;
                    push($1);
                    $1 = $2;
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    cld ;
                    push($1);
                    $1 = $2;
                    push($1);
                    $1 = 0;
                    push($1);
                    push($1);
                    les dx, ptr [bp + 6];
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x2495;
                    // Block 0x1FE0
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x1FD0
                    nop ;
                    nop ;
                    nop ;
                    cmp word ptr [si + 2], 0x4e52;
                    if (a != b) {  // jne 0x1fe3
                        // Block 0x1FE3
                        $1 = 0;
                        goto $1;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bp + si], al;
                        add byte ptr [bx + si], al;
                        $1 += $2;
                        add byte ptr [bx + si], al;
                        push($1);
                        $1 = $2;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        cld ;
                        push($1);
                        $1 = $2;
                        push($1);
                        $1 = 0;
                        push($1);
                        push($1);
                        les dx, ptr [bp + 6];
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x2495;
                        // Block 0x1FE0
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x1FDA
                        nop ;
                        nop ;
                        nop ;
                    }
                }
            } else {
                // Block 0x1FB6
                nop ;
                nop ;
                nop ;
                $1 = $2;
                int 0x66;
                or ax, ax;
                if (a != b) {  // jne 0x1fdd
                    // Block 0x1FDD
                    mov ax, 1;
                } else {
                    // Block 0x1FC2
                    nop ;
                    nop ;
                    nop ;
                    if (a == b) {  // je 0x1fe3
                        // Block 0x1FE3
                        $1 = 0;
                        goto $1;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bp + si], al;
                        add byte ptr [bx + si], al;
                        $1 += $2;
                        add byte ptr [bx + si], al;
                        push($1);
                        $1 = $2;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        cld ;
                        push($1);
                        $1 = $2;
                        push($1);
                        $1 = 0;
                        push($1);
                        push($1);
                        les dx, ptr [bp + 6];
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x2495;
                        // Block 0x1FE0
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x1FC7
                        nop ;
                        nop ;
                        nop ;
                    }
                }
            }
        }
    }

    // Function calls:
    sub_2495(); // Opens a file and manipulates strings or memory blocks and performs calculations
    sub_2128(); // Opens a file and performs calculations
}

void sub_2128(int) {
    // Purpose: Opens a file and performs calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 40 if statements

    // Block 0x2128
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lds si, ptr [si];
    or si, si;
    if (a == b) {  // je 0x2156
        // Block 0x2156
        $1 = 0;
        goto $1;
        $1 = $2;
        int 0x66;
        return;  // retf 
    } else {
        // Block 0x2137
        nop ;
        nop ;
        nop ;
        $1 -= $2;
        cmp word ptr [si], 0x494d;
        if (a != b) {  // jne 0x2156
            // Block 0x2156
            $1 = 0;
            goto $1;
            $1 = $2;
            int 0x66;
            return;  // retf 
        } else {
            // Block 0x2143
            nop ;
            nop ;
            nop ;
            cmp word ptr [si + 2], 0x4944;
            if (a != b) {  // jne 0x2156
                // Block 0x2156
                $1 = 0;
                goto $1;
                $1 = $2;
                int 0x66;
                return;  // retf 
            } else {
                // Block 0x214D
                nop ;
                nop ;
                nop ;
                mov ax, 1;
            }
        }
    }

    // Function calls:
    sub_2495(); // Opens a file and manipulates strings or memory blocks and performs calculations
}

void sub_2495(void) {
    // Purpose: Opens a file and manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 32 if statements

    // Block 0x2495
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    DOS_OpenFile();  // int 0x21
    if (a >= b (unsigned)) {  // jae 0x24ab
        // Block 0x24AB
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = 0;
        $1 = 0;
        DOS_MoveFilePointer();  // int 0x21
        if (a < b (unsigned)) {  // jb 0x2532
            // Block 0x2532
            $1 = $2;
            int 0x21;
        } else {
            // Block 0x24B9
            lds di, ptr [bp + 0xa];
            or di, di;
            if (a == b) {  // je 0x24c5
                // Block 0x24C5
                $1 = $2;
                $1 = $2;
                $1 += $2;
                adc dx, 0;
                push($1);
                push($1);
                lcall 0x1a10, 0x2f;
                $1 += $2;
                $1 = $2;
                or ax, ax;
                if (a != b) {  // jne 0x24e3
                    // Block 0x24E3
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    // Swap cx and cx
                    int 0x21;
                    $1 = $2;
                    DOS_MoveFilePointer();  // int 0x21
                    $1 = $2;
                    $1 += $2;
                    mov dx, di;
                    add dx, 0xf;
                    and dx, 0xfff0;
                } else {
                    // Block 0x24DF
                    or dx, dx;
                    if (a == b) {  // je 0x2532
                        // Block 0x2532
                        $1 = $2;
                        int 0x21;
                    } else {
                        // Block 0x24E3
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        // Swap cx and cx
                        int 0x21;
                        $1 = $2;
                        DOS_MoveFilePointer();  // int 0x21
                        $1 = $2;
                        $1 += $2;
                        mov dx, di;
                        add dx, 0xf;
                        and dx, 0xfff0;
                    }
                }
            } else {
                // Block 0x24C0
                *($1) = $2;
                mov word ptr [di + 2], dx;
            }
        }
    } else {
        // Block 0x24A8
        jmp 0x2536;
        // Block 0x2536
        $1 = 0;
        $1 = 0;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }
}

void sub_2827(void) {
    // Purpose: Writes data to a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 4

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 24 if statements

    // Block 0x2827
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 6];
    push($1);
    push($1);
    $1 = pop();
    $1 = $2;
    INT_21_AH19();  // int 0x21
    $1 += $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    DOS_GetCurrentDirectory();  // int 0x21
    $1 = pop();
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2827(); // Writes data to a file and manipulates strings or memory blocks and performs calculations
    sub_2ACF(); // Performs arithmetic calculations
    sub_2D44(); // Unknown function purpose
}

void sub_2A03(void) {
    // Purpose: Performs DOS operations

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x2A03
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    lds dx, ptr [bp + 6];
    INT_21_AH43();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x2a1d
        // Block 0x2A1D
        push($1);
        call 0x2d7d;
        // Block 0x2A21
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x2A13
        les bx, ptr [bp + 0xa];
        mov word ptr es:[bx], cx;
        $1 = 0;
        jmp 0x2a21;
        // Block 0x2A21
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D7D(); // Performs arithmetic calculations
    sub_2D7D(); // Performs arithmetic calculations
}

void sub_2A40(int, int) {
    // Purpose: Performs DOS operations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x2A40
    push($1);
    $1 = $2;
    $1 = $2;
    INT_21_AH19();  // int 0x21
    $1 = $2;
    $1++;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], ax;
    $1 = pop();
    return;  // retf 
}

void sub_2A52(int, int) {
    // Purpose: Performs DOS operations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x2A52
    push($1);
    $1 = $2;
    $1 = $2;
    $1--;
    $1 = $2;
    INT_21_AH0E();  // int 0x21
    $1 = $2;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], ax;
    $1 = pop();
    return;  // retf 
}

void sub_2A69(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x2A69
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or si, si;
    if (a != b) {  // jne 0x2a96
        // Block 0x2A96
        nop ;
        push($1);
        call 0x1dc0;
        // Block 0x2A9B
        nop ;
        push($1);
        call 0x1d6a;
        // Block 0x2AA0
        cmp word ptr [bp + 6], 0;
        if (a != b) {  // jne 0x2abb
            // Block 0x2ABB
            $1 = pop();
            $1 = pop();
            return;  // ret 6
        } else {
            // Block 0x2AA6
            or si, si;
            if (a != b) {  // jne 0x2ab2
                // Block 0x2AB2
                push($1);
                nop ;
                push($1);
                call 0x1d6b;
                // Block 0x2ABA
                pop cx;
            } else {
                // Block 0x2AAA
                lcall [0x7338];
                lcall [0x733c];
            }
        }
    } else {
        // Block 0x2A74
        jmp 0x2a86;
        // Block 0x2A86
        cmp word ptr [0x7230], 0;
        if (a != b) {  // jne 0x2a76
            // Block 0x2A76
            $1--;
            $1 = $2;
            $1 = $2;
            shl bx, cl;
            lcall [bx - 0x78fe];
        } else {
            // Block 0x2A8D
            nop ;
            push($1);
            call 0x1d57;
            // Block 0x2A92
            lcall [0x7334];
        }
    }

    // Function calls:
    sub_1D57(); // Unknown function purpose
    sub_1DC0(); // Unknown function purpose
    sub_1D6A(); // Unknown function purpose
    sub_1D6B(); // Performs DOS operations
}

void sub_2AC0(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x2AC0
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    call 0x2a69;
    // Block 0x2ACD
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2A69(); // Unknown function purpose
}

void sub_2ACF(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x2ACF
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    call 0x2a69;
    // Block 0x2ADF
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2A69(); // Unknown function purpose
    sub_2A69(); // Unknown function purpose
    sub_2A69(); // Unknown function purpose
}

void sub_2B2E(void) {
    // Purpose: Performs DOS operations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x2B2E
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 8];
    DOS_GetCurrentDirectory();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x2b44
        // Block 0x2B44
        push($1);
        call 0x2d44;
        // Block 0x2B48
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x2B40
        $1 = 0;
        jmp 0x2b48;
        // Block 0x2B48
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_2B71(int, int) {
    // Purpose: Performs DOS operations and performs calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 13 if statements

    // Block 0x2B71
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lea ax, [bp - 2];
    push($1);
    nop ;
    push($1);
    call 0x2a40;
    // Block 0x2B81
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1--;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2A40(); // Performs DOS operations
    sub_2A52(); // Performs DOS operations
    sub_2D44(); // Unknown function purpose
}

void sub_2C9B(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x2C9B
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    if (a >= b (unsigned)) {  // jae 0x2cb3
        // Block 0x2CB3
        $1 -= $2;
        xchg dx, ax;
        $1 = 0;
        shl dx, cl;
        return;  // retf 
    } else {
        // Block 0x2CA3
        $1 = $2;
        shl ax, cl;
        shl dx, cl;
        neg cl;
        $1 += $2;
        shr bx, cl;
        or dx, bx;
        return;  // retf 
    }
}

void sub_2CBC(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x2CBC
    $1 = pop();
    push($1);
    push($1);
    or cx, cx;
    if (a >= b) {  // jge 0x2ccf
        // Block 0x2CCF
        $1 += $2;
        if (a >= b (unsigned)) {  // jae 0x2cd7
            // Block 0x2CD7
            $1 = $2;
            $1 = $2;
            shl ch, cl;
            $1 += $2;
            $1 = $2;
            shr ax, cl;
            $1 += $2;
            $1 = $2;
            and ax, 0xf;
            return;  // retf 
        } else {
            // Block 0x2CD3
            add dx, 0x1000;
        }
    } else {
        // Block 0x2CC3
        not bx;
        not cx;
        $1 += $2;
        adc cx, 0;
        jmp 0x2cfe;
        // Block 0x2CFE
        $1 -= $2;
        if (a >= b (unsigned)) {  // jae 0x2d06
            // Block 0x2D06
            $1 = $2;
            $1 = $2;
            shl bh, cl;
            $1 = 0;
            $1 -= $2;
            $1 = $2;
            shr ax, cl;
            $1 += $2;
            $1 = $2;
            and ax, 0xf;
            return;  // retf 
        } else {
            // Block 0x2D02
            sub dx, 0x1000;
        }
    }
}

void sub_2D1C(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x2D1C
    $1 = pop();
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl dx, cl;
    shr ch, cl;
    $1 += $2;
    adc ch, 0;
    $1 = $2;
    shl di, cl;
    shr ah, cl;
    $1 += $2;
    adc ah, 0;
    $1 -= $2;
    sbb ch, ah;
    $1 = $2;
    cwde ;
    xchg dx, ax;
    $1 = pop();
    return;  // retf 
}

void sub_2D44(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x2D44
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or si, si;
    if (a < b) {  // jl 0x2d64
        // Block 0x2D64
        neg si;
        // Compare $1 with $2
        if (a > b) {  // jg 0x2d54
            // Block 0x2D54
            mov si, 0x57;
        } else {
            // Block 0x2D6B
            mov word ptr [0x74fe], 0xffff;
        }
    } else {
        // Block 0x2D4F
        // Compare $1 with $2
        if (a <= b) {  // jle 0x2d57
            // Block 0x2D57
            *($1) = $2;
            $1 = $2;
            cwde ;
            $1 = $2;
            jmp 0x2d71;
            // Block 0x2D71
            *($1) = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            return;  // ret 2
        } else {
            // Block 0x2D54
            mov si, 0x57;
        }
    }
}

void sub_2D7D(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x2D7D
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    call 0x2d44;
    // Block 0x2D88
    $1 = $2;
    $1 = pop();
    $1 = pop();
    return;  // ret 2

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_57EF(); // Unknown function purpose
    sub_57EF(); // Unknown function purpose
    sub_5C29(); // Performs arithmetic calculations
    sub_5C29(); // Performs arithmetic calculations
}

void sub_2F4E(int, int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x2F4E
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    xchg dx, ax;
    and ax, 0x80;
    $1 = pop();
    return;  // retf 
}

void sub_2F5F(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 8 if statements

    // Block 0x2F5F
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    les di, ptr [bp + 0xa];
    $1 = $2;
    // Compare $1 with $2
    if (a > b (unsigned)) {  // ja 0x2fcf
        // Block 0x2FCF
        $1 = $2;
        stosb byte ptr es:[di], al;
        $1 = pop();
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // ret 0xe
    } else {
        // Block 0x2F73
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x2fcf
            // Block 0x2FCF
            $1 = $2;
            stosb byte ptr es:[di], al;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // ret 0xe
        } else {
            // Block 0x2F78
            $1 = $2;
            $1 = $2;
            or cx, cx;
            if (a >= b) {  // jge 0x2f94
                // Block 0x2F94
                lea si, [bp - 0x22];
                if (condition_jcxz) {  // jcxz 0x2fa9
                    // Block 0x2FA9
                    $1 -= $2;
                    div bx;
                    mov byte ptr ss:[si], dl;
                    inc si;
                } else {
                    // Block 0x2F99
                    xchg cx, ax;
                    $1 -= $2;
                    div bx;
                    xchg cx, ax;
                    div bx;
                    mov byte ptr ss:[si], dl;
                    $1++;
                    if (condition_jcxz) {  // jcxz 0x2fb1
                        // Block 0x2FB1
                        or ax, ax;
                        if (a != b) {  // jne 0x2fa9
                            // Block 0x2FA9
                            $1 -= $2;
                            div bx;
                            mov byte ptr ss:[si], dl;
                            inc si;
                        } else {
                            // Block 0x2FB5
                            lea cx, [bp - 0x22];
                            neg cx;
                            $1 += $2;
                            cld ;
                            $1--;
                            $1 = $2;
                            $1 -= $2;
                            if (a >= b (unsigned)) {  // jae 0x2fc9
                                // Block 0x2FC9
                                add al, byte ptr [bp + 4];
                            } else {
                                // Block 0x2FC5
                                $1 += $2;
                                jmp 0x2fcc;
                                // Block 0x2FCC
                                stosb byte ptr es:[di], al;
                                loop 0x2fbd;
                            }
                        }
                    } else {
                        // Block 0x2FA7
                        jmp 0x2f99;
                    }
                }
            } else {
                // Block 0x2F82
                cmp byte ptr [bp + 6], 0;
                if (a == b) {  // je 0x2f94
                    // Block 0x2F94
                    lea si, [bp - 0x22];
                    if (condition_jcxz) {  // jcxz 0x2fa9
                        // Block 0x2FA9
                        $1 -= $2;
                        div bx;
                        mov byte ptr ss:[si], dl;
                        inc si;
                    } else {
                        // Block 0x2F99
                        xchg cx, ax;
                        $1 -= $2;
                        div bx;
                        xchg cx, ax;
                        div bx;
                        mov byte ptr ss:[si], dl;
                        $1++;
                        if (condition_jcxz) {  // jcxz 0x2fb1
                            // Block 0x2FB1
                            or ax, ax;
                            if (a != b) {  // jne 0x2fa9
                                // Block 0x2FA9
                                $1 -= $2;
                                div bx;
                                mov byte ptr ss:[si], dl;
                                inc si;
                            } else {
                                // Block 0x2FB5
                                lea cx, [bp - 0x22];
                                neg cx;
                                $1 += $2;
                                cld ;
                                $1--;
                                $1 = $2;
                                $1 -= $2;
                                if (a >= b (unsigned)) {  // jae 0x2fc9
                                    // Block 0x2FC9
                                    add al, byte ptr [bp + 4];
                                } else {
                                    // Block 0x2FC5
                                    $1 += $2;
                                    jmp 0x2fcc;
                                    // Block 0x2FCC
                                    stosb byte ptr es:[di], al;
                                    loop 0x2fbd;
                                }
                            }
                        } else {
                            // Block 0x2FA7
                            jmp 0x2f99;
                        }
                    }
                } else {
                    // Block 0x2F88
                    mov byte ptr es:[di], 0x2d;
                    $1++;
                    neg cx;
                    neg ax;
                    sbb cx, 0;
                }
            }
        }
    }
}

void sub_2FE1(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x2FE1
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    call 0x2f5f;
    // Block 0x2FFD
    $1 = pop();
    return;  // ret 6

    // Function calls:
    sub_2F5F(); // Manipulates strings or memory blocks and performs calculations
}

void sub_3001(int, int, int) {
    // Purpose: Moves file pointer

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x3001
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    and word ptr [bx + 0x74d2], 0xfdff;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    if (a < b (unsigned)) {  // jb 0x3023
        // Block 0x3023
        push($1);
        call 0x2d44;
        // Block 0x3027
        cdq ;
    } else {
        // Block 0x3021
        jmp 0x3028;
        // Block 0x3028
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_302A(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x302A
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (a != b) {  // jne 0x303d
        // Block 0x303D
        push($1);
        $1 = $2;
        or ax, word ptr [bp + 8];
        if (a != b) {  // jne 0x304f
            // Block 0x304F
            $1 = $2;
            mov ax, word ptr [bp + 6];
        } else {
            // Block 0x3048
            $1 = $2;
            $1 = $2;
            jmp 0x3055;
            // Block 0x3055
            push($1);
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x3e97;
            // Block 0x3062
            $1 += $2;
            push($1);
            push($1);
            call 0x2fe1;
            // Block 0x306A
            push($1);
            $1 = $2;
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x65b8;
            // Block 0x307A
            $1 += $2;
            $1 = $2;
            $1 = $2;
            $1 = pop();
            return;  // ret 0xa
        }
    } else {
        // Block 0x3035
        *($1) = $2;
        mov word ptr [bp + 0xa], 0x8782;
    }

    // Function calls:
    sub_3E97(); // Performs arithmetic calculations
    sub_2FE1(); // Unknown function purpose
    sub_65B8(); // Manipulates strings or memory blocks and performs calculations
    sub_302A(); // Performs arithmetic calculations
    sub_2A03(); // Performs DOS operations
}

void sub_30E0(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x30E0
    push($1);
    xchg si, ax;
    xchg dx, ax;
    test ax, ax;
    if (a == b) {  // je 0x30e9
        // Block 0x30E9
        if (condition_jcxz) {  // jcxz 0x30f0
            // Block 0x30F0
            xchg si, ax;
            mul bx;
            $1 += $2;
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x30EB
            xchg cx, ax;
            mul si;
            add ax, cx;
        }
    } else {
        // Block 0x30E7
        mul bx;
    }
}

void sub_30F7(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x30F7
    push($1);
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    and ax, 0xf;
    and bx, 0xf;
    // Compare $1 with $2
    if (a != b) {  // jne 0x3117
        // Block 0x3117
        return;  // ret 
    } else {
        // Block 0x3115
        cmp ax, bx;
    }
}

void sub_3118(int, int) {
    // Purpose: Reads data from a file

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x3118
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 2;
    if (a == b) {  // je 0x312e
        // Block 0x312E
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        lds dx, ptr [bp + 8];
        DOS_ReadFile();  // int 0x21
        $1 = pop();
        if (a < b (unsigned)) {  // jb 0x3141
            // Block 0x3141
            push ax;
        } else {
            // Block 0x313F
            jmp 0x3145;
            // Block 0x3145
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x3128
        $1 = $2;
        push($1);
        jmp 0x3142;
        // Block 0x3142
        call 0x2d44;
        // Block 0x3145
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_3147(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x3147
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 0;
    jmp 0x3176;
    // Block 0x3176
}

void sub_315B(void) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 15

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x315B
    les di, ptr [bp + 0x10];
    test byte ptr [bp - 1], 0x20;
    if (a == b) {  // je 0x316c
        // Block 0x316C
        $1 = $2;
        push($1);
        $1 = pop();
        add word ptr [bp + 0x10], 2;
        return;  // ret 
    } else {
        // Block 0x3164
        les di, ptr es:[di];
        add word ptr [bp + 0x10], 4;
        return;  // ret 
    }

    // Function calls:
    sub_3666(); // Performs arithmetic calculations
    sub_315B(); // Manipulates strings or memory blocks and performs calculations
    sub_32DA(); // Performs arithmetic calculations
}

void sub_32DA(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x32DA
    goto $1;
    push($1);
    push($1);
    push($1);
    call word ptr [bp + 6];
    // Block 0x357B

    // Function calls:
    sub_32F5(); // Performs arithmetic calculations
}

void sub_32F5(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x32F5
    goto $1;
    push($1);
    // Compare $1 with $2
    if (a == b) {  // je 0x3316
        // Block 0x3316
        call 0x3319;
        // Block 0x3319
    } else {
        // Block 0x32FD
        or ax, ax;
        if (a <= b) {  // jle 0x3311
            // Block 0x3311
            $1 = pop();
            $1 = $2;
            jmp 0x3335;
            // Block 0x3335
        } else {
            // Block 0x3301
            push($1);
            push($1);
            push($1);
            call word ptr [bp + 6];
            // Block 0x330B
            $1 += $2;
            dec word ptr [bp - 6];
        }
    }

    // Function calls:
    sub_3319(); // Manipulates strings or memory blocks and performs calculations
}

void sub_3319(int, int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 5

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x3319
    goto $1;
    $1 = pop();
    or ax, ax;
    if (a <= b) {  // jle 0x3335
        // Block 0x3335
        test byte ptr [bp - 1], 1;
        if (a != b) {  // jne 0x334b
            // Block 0x334B
            jmp 0x3178;
            // Block 0x3178
        } else {
            // Block 0x333B
            call 0x315b;
            // Block 0x333E
            $1++;
            xchg dx, ax;
            stosw word ptr es:[di], ax;
            test byte ptr [bp - 1], 0x20;
            if (a == b) {  // je 0x334b
                // Block 0x334B
                jmp 0x3178;
                // Block 0x3178
            } else {
                // Block 0x3349
                xchg bx, ax;
                stosw word ptr es:[di], ax;
            }
        }
    } else {
        // Block 0x3321
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        call word ptr [bp + 6];
        // Block 0x332D
        $1 += $2;
        $1--;
        $1 = pop();
        pop dx;
    }

    // Function calls:
    sub_315B(); // Manipulates strings or memory blocks and performs calculations
    sub_4890(); // Unknown function purpose
    sub_315B(); // Manipulates strings or memory blocks and performs calculations
    sub_4894(); // Unknown function purpose
    sub_4898(); // Unknown function purpose
    sub_4898(); // Unknown function purpose
    sub_33BE(); // Manipulates strings or memory blocks and performs calculations
}

void sub_33BE(void) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 33

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 loops
    // - 55 if statements

    // Block 0x33BE
    goto $1;
    test byte ptr [bp - 1], 1;
    if (a != b) {  // jne 0x33cd
        // Block 0x33CD
        and word ptr [bp - 0xa], 0x7fff;
        if (a == b) {  // je 0x3401
            // Block 0x3401
            push($1);
            push($1);
            push($1);
            push($1);
            call word ptr [bp + 6];
            // Block 0x340C
            $1 += $2;
            $1 = pop();
            $1--;
            test byte ptr [bp - 1], 1;
            if (a != b) {  // jne 0x341c
                // Block 0x341C
                goto $1;
                test byte ptr [bp - 1], 1;
                if (a != b) {  // jne 0x3428
                    // Block 0x3428
                    $1 = $2;
                    or si, si;
                    if (a >= b) {  // jge 0x3432
                        // Block 0x3432
                        if (a == b) {  // je 0x3452
                            // Block 0x3452
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x345b
                                // Block 0x345B
                                jmp 0x3178;
                                // Block 0x3178
                            } else {
                                // Block 0x3458
                                inc word ptr [bp - 4];
                            }
                        } else {
                            // Block 0x3434
                            $1++;
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 4];
                            // Block 0x3441
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            or ax, ax;
                            if (a < b) {  // jl 0x345e
                                // Block 0x345E
                                goto $1;
                                push($1);
                                $1 -= $2;
                                cld ;
                                push($1);
                                $1 = pop();
                                lea di, [bp - 0x2a];
                                $1 = $2;
                                rep stosw word ptr es:[di], ax;
                                $1 = pop();
                                lodsb al, byte ptr es:[si];
                                and byte ptr [bp - 1], 0xef;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x3480
                                    // Block 0x3480
                                    mov ah, 0;
                                } else {
                                    // Block 0x347A
                                    or byte ptr [bp - 1], 0x10;
                                    lodsb al, byte ptr es:[si];
                                }
                            } else {
                                // Block 0x3448
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x344f
                                    // Block 0x344F
                                    $1--;
                                    if (a > b) {  // jg 0x3434
                                        // Jump to block at 0x3434
                                    } else {
                                        // Block 0x3452
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x345b
                                            // Block 0x345B
                                            jmp 0x3178;
                                            // Block 0x3178
                                        } else {
                                            // Block 0x3458
                                            inc word ptr [bp - 4];
                                        }
                                    }
                                } else {
                                    // Block 0x344E
                                    stosb byte ptr es:[di], al;
                                }
                            }
                        }
                    } else {
                        // Block 0x342F
                        mov si, 1;
                    }
                } else {
                    // Block 0x3425
                    call 0x315b;
                    // Block 0x3428
                    $1 = $2;
                    or si, si;
                    if (a >= b) {  // jge 0x3432
                        // Block 0x3432
                        if (a == b) {  // je 0x3452
                            // Block 0x3452
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x345b
                                // Block 0x345B
                                jmp 0x3178;
                                // Block 0x3178
                            } else {
                                // Block 0x3458
                                inc word ptr [bp - 4];
                            }
                        } else {
                            // Block 0x3434
                            $1++;
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 4];
                            // Block 0x3441
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            or ax, ax;
                            if (a < b) {  // jl 0x345e
                                // Block 0x345E
                                goto $1;
                                push($1);
                                $1 -= $2;
                                cld ;
                                push($1);
                                $1 = pop();
                                lea di, [bp - 0x2a];
                                $1 = $2;
                                rep stosw word ptr es:[di], ax;
                                $1 = pop();
                                lodsb al, byte ptr es:[si];
                                and byte ptr [bp - 1], 0xef;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x3480
                                    // Block 0x3480
                                    mov ah, 0;
                                } else {
                                    // Block 0x347A
                                    or byte ptr [bp - 1], 0x10;
                                    lodsb al, byte ptr es:[si];
                                }
                            } else {
                                // Block 0x3448
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x344f
                                    // Block 0x344F
                                    $1--;
                                    if (a > b) {  // jg 0x3434
                                        // Jump to block at 0x3434
                                    } else {
                                        // Block 0x3452
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x345b
                                            // Block 0x345B
                                            jmp 0x3178;
                                            // Block 0x3178
                                        } else {
                                            // Block 0x3458
                                            inc word ptr [bp - 4];
                                        }
                                    }
                                } else {
                                    // Block 0x344E
                                    stosb byte ptr es:[di], al;
                                }
                            }
                        }
                    } else {
                        // Block 0x342F
                        mov si, 1;
                    }
                }
            } else {
                // Block 0x3419
                $1 = $2;
                stosb byte ptr es:[di], al;
            }
        } else {
            // Block 0x33D4
            test byte ptr [bp - 1], 1;
            if (a != b) {  // jne 0x33db
                // Block 0x33DB
                $1++;
                push($1);
                push($1);
                push($1);
                call word ptr [bp + 4];
                // Block 0x33E8
                $1 = pop();
                $1 = pop();
                $1 = pop();
                or ax, ax;
                if (a <= b) {  // jle 0x3401
                    // Block 0x3401
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    call word ptr [bp + 6];
                    // Block 0x340C
                    $1 += $2;
                    $1 = pop();
                    $1--;
                    test byte ptr [bp - 1], 1;
                    if (a != b) {  // jne 0x341c
                        // Block 0x341C
                        goto $1;
                        test byte ptr [bp - 1], 1;
                        if (a != b) {  // jne 0x3428
                            // Block 0x3428
                            $1 = $2;
                            or si, si;
                            if (a >= b) {  // jge 0x3432
                                // Block 0x3432
                                if (a == b) {  // je 0x3452
                                    // Block 0x3452
                                    test byte ptr [bp - 1], 1;
                                    if (a != b) {  // jne 0x345b
                                        // Block 0x345B
                                        jmp 0x3178;
                                        // Block 0x3178
                                    } else {
                                        // Block 0x3458
                                        inc word ptr [bp - 4];
                                    }
                                } else {
                                    // Block 0x3434
                                    $1++;
                                    push($1);
                                    push($1);
                                    push($1);
                                    call word ptr [bp + 4];
                                    // Block 0x3441
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a < b) {  // jl 0x345e
                                        // Block 0x345E
                                        goto $1;
                                        push($1);
                                        $1 -= $2;
                                        cld ;
                                        push($1);
                                        $1 = pop();
                                        lea di, [bp - 0x2a];
                                        $1 = $2;
                                        rep stosw word ptr es:[di], ax;
                                        $1 = pop();
                                        lodsb al, byte ptr es:[si];
                                        and byte ptr [bp - 1], 0xef;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x3480
                                            // Block 0x3480
                                            mov ah, 0;
                                        } else {
                                            // Block 0x347A
                                            or byte ptr [bp - 1], 0x10;
                                            lodsb al, byte ptr es:[si];
                                        }
                                    } else {
                                        // Block 0x3448
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x344f
                                            // Block 0x344F
                                            $1--;
                                            if (a > b) {  // jg 0x3434
                                                // Jump to block at 0x3434
                                            } else {
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            }
                                        } else {
                                            // Block 0x344E
                                            stosb byte ptr es:[di], al;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x342F
                                mov si, 1;
                            }
                        } else {
                            // Block 0x3425
                            call 0x315b;
                            // Block 0x3428
                            $1 = $2;
                            or si, si;
                            if (a >= b) {  // jge 0x3432
                                // Block 0x3432
                                if (a == b) {  // je 0x3452
                                    // Block 0x3452
                                    test byte ptr [bp - 1], 1;
                                    if (a != b) {  // jne 0x345b
                                        // Block 0x345B
                                        jmp 0x3178;
                                        // Block 0x3178
                                    } else {
                                        // Block 0x3458
                                        inc word ptr [bp - 4];
                                    }
                                } else {
                                    // Block 0x3434
                                    $1++;
                                    push($1);
                                    push($1);
                                    push($1);
                                    call word ptr [bp + 4];
                                    // Block 0x3441
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a < b) {  // jl 0x345e
                                        // Block 0x345E
                                        goto $1;
                                        push($1);
                                        $1 -= $2;
                                        cld ;
                                        push($1);
                                        $1 = pop();
                                        lea di, [bp - 0x2a];
                                        $1 = $2;
                                        rep stosw word ptr es:[di], ax;
                                        $1 = pop();
                                        lodsb al, byte ptr es:[si];
                                        and byte ptr [bp - 1], 0xef;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x3480
                                            // Block 0x3480
                                            mov ah, 0;
                                        } else {
                                            // Block 0x347A
                                            or byte ptr [bp - 1], 0x10;
                                            lodsb al, byte ptr es:[si];
                                        }
                                    } else {
                                        // Block 0x3448
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x344f
                                            // Block 0x344F
                                            $1--;
                                            if (a > b) {  // jg 0x3434
                                                // Jump to block at 0x3434
                                            } else {
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            }
                                        } else {
                                            // Block 0x344E
                                            stosb byte ptr es:[di], al;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x342F
                                mov si, 1;
                            }
                        }
                    } else {
                        // Block 0x3419
                        $1 = $2;
                        stosb byte ptr es:[di], al;
                    }
                } else {
                    // Block 0x33EF
                    or al, al;
                    if (condition_js) {  // js 0x33fc
                        // Block 0x33FC
                        $1--;
                        if (a > b) {  // jg 0x33d4
                            // Jump to block at 0x33D4
                        } else {
                            // Block 0x3401
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 6];
                            // Block 0x340C
                            $1 += $2;
                            $1 = pop();
                            $1--;
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x341c
                                // Block 0x341C
                                goto $1;
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x3428
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                } else {
                                    // Block 0x3425
                                    call 0x315b;
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                }
                            } else {
                                // Block 0x3419
                                $1 = $2;
                                stosb byte ptr es:[di], al;
                            }
                        }
                    } else {
                        // Block 0x33F3
                        xchg bx, ax;
                        cmp byte ptr [bx + 0x7564], 1;
                        xchg bx, ax;
                        if (a <= b) {  // jle 0x3401
                            // Block 0x3401
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 6];
                            // Block 0x340C
                            $1 += $2;
                            $1 = pop();
                            $1--;
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x341c
                                // Block 0x341C
                                goto $1;
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x3428
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                } else {
                                    // Block 0x3425
                                    call 0x315b;
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                }
                            } else {
                                // Block 0x3419
                                $1 = $2;
                                stosb byte ptr es:[di], al;
                            }
                        } else {
                            // Block 0x33FC
                            $1--;
                            if (a > b) {  // jg 0x33d4
                                // Jump to block at 0x33D4
                            } else {
                                // Block 0x3401
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                call word ptr [bp + 6];
                                // Block 0x340C
                                $1 += $2;
                                $1 = pop();
                                $1--;
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x341c
                                    // Block 0x341C
                                    goto $1;
                                    test byte ptr [bp - 1], 1;
                                    if (a != b) {  // jne 0x3428
                                        // Block 0x3428
                                        $1 = $2;
                                        or si, si;
                                        if (a >= b) {  // jge 0x3432
                                            // Block 0x3432
                                            if (a == b) {  // je 0x3452
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            } else {
                                                // Block 0x3434
                                                $1++;
                                                push($1);
                                                push($1);
                                                push($1);
                                                call word ptr [bp + 4];
                                                // Block 0x3441
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                or ax, ax;
                                                if (a < b) {  // jl 0x345e
                                                    // Block 0x345E
                                                    goto $1;
                                                    push($1);
                                                    $1 -= $2;
                                                    cld ;
                                                    push($1);
                                                    $1 = pop();
                                                    lea di, [bp - 0x2a];
                                                    $1 = $2;
                                                    rep stosw word ptr es:[di], ax;
                                                    $1 = pop();
                                                    lodsb al, byte ptr es:[si];
                                                    and byte ptr [bp - 1], 0xef;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0x3480
                                                        // Block 0x3480
                                                        mov ah, 0;
                                                    } else {
                                                        // Block 0x347A
                                                        or byte ptr [bp - 1], 0x10;
                                                        lodsb al, byte ptr es:[si];
                                                    }
                                                } else {
                                                    // Block 0x3448
                                                    test byte ptr [bp - 1], 1;
                                                    if (a != b) {  // jne 0x344f
                                                        // Block 0x344F
                                                        $1--;
                                                        if (a > b) {  // jg 0x3434
                                                            // Jump to block at 0x3434
                                                        } else {
                                                            // Block 0x3452
                                                            test byte ptr [bp - 1], 1;
                                                            if (a != b) {  // jne 0x345b
                                                                // Block 0x345B
                                                                jmp 0x3178;
                                                                // Block 0x3178
                                                            } else {
                                                                // Block 0x3458
                                                                inc word ptr [bp - 4];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x344E
                                                        stosb byte ptr es:[di], al;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x342F
                                            mov si, 1;
                                        }
                                    } else {
                                        // Block 0x3425
                                        call 0x315b;
                                        // Block 0x3428
                                        $1 = $2;
                                        or si, si;
                                        if (a >= b) {  // jge 0x3432
                                            // Block 0x3432
                                            if (a == b) {  // je 0x3452
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            } else {
                                                // Block 0x3434
                                                $1++;
                                                push($1);
                                                push($1);
                                                push($1);
                                                call word ptr [bp + 4];
                                                // Block 0x3441
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                or ax, ax;
                                                if (a < b) {  // jl 0x345e
                                                    // Block 0x345E
                                                    goto $1;
                                                    push($1);
                                                    $1 -= $2;
                                                    cld ;
                                                    push($1);
                                                    $1 = pop();
                                                    lea di, [bp - 0x2a];
                                                    $1 = $2;
                                                    rep stosw word ptr es:[di], ax;
                                                    $1 = pop();
                                                    lodsb al, byte ptr es:[si];
                                                    and byte ptr [bp - 1], 0xef;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0x3480
                                                        // Block 0x3480
                                                        mov ah, 0;
                                                    } else {
                                                        // Block 0x347A
                                                        or byte ptr [bp - 1], 0x10;
                                                        lodsb al, byte ptr es:[si];
                                                    }
                                                } else {
                                                    // Block 0x3448
                                                    test byte ptr [bp - 1], 1;
                                                    if (a != b) {  // jne 0x344f
                                                        // Block 0x344F
                                                        $1--;
                                                        if (a > b) {  // jg 0x3434
                                                            // Jump to block at 0x3434
                                                        } else {
                                                            // Block 0x3452
                                                            test byte ptr [bp - 1], 1;
                                                            if (a != b) {  // jne 0x345b
                                                                // Block 0x345B
                                                                jmp 0x3178;
                                                                // Block 0x3178
                                                            } else {
                                                                // Block 0x3458
                                                                inc word ptr [bp - 4];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x344E
                                                        stosb byte ptr es:[di], al;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x342F
                                            mov si, 1;
                                        }
                                    }
                                } else {
                                    // Block 0x3419
                                    $1 = $2;
                                    stosb byte ptr es:[di], al;
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x33DA
                stosb byte ptr es:[di], al;
            }
        }
    } else {
        // Block 0x33C7
        call 0x315b;
        // Block 0x33CA
        inc word ptr [bp - 4];
    }

    // Function calls:
    sub_315B(); // Manipulates strings or memory blocks and performs calculations
    sub_315B(); // Manipulates strings or memory blocks and performs calculations
    sub_315B(); // Manipulates strings or memory blocks and performs calculations
}

void sub_363B(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x363B
    push($1);
    $1 -= $2;
    if (a < b (unsigned)) {  // jb 0x3663
        // Block 0x3663
        $1 = pop();
        stc ;
    } else {
        // Block 0x3641
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x3658
            // Block 0x3658
            // Compare $1 with $2
            if (a >= b (unsigned)) {  // jae 0x3663
                // Block 0x3663
                $1 = pop();
                stc ;
            } else {
                // Block 0x365C
                $1++;
                $1++;
                clc ;
                $1 = $2;
                jmp 0x3665;
                // Block 0x3665
                return;  // ret 
            }
        } else {
            // Block 0x3646
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0x3650
                // Block 0x3650
                sub bl, 0x27;
            } else {
                // Block 0x364B
                $1 -= $2;
                jmp 0x3653;
                // Block 0x3653
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0x3663
                    // Block 0x3663
                    $1 = pop();
                    stc ;
                } else {
                    // Block 0x3658
                    // Compare $1 with $2
                    if (a >= b (unsigned)) {  // jae 0x3663
                        // Block 0x3663
                        $1 = pop();
                        stc ;
                    } else {
                        // Block 0x365C
                        $1++;
                        $1++;
                        clc ;
                        $1 = $2;
                        jmp 0x3665;
                        // Block 0x3665
                        return;  // ret 
                    }
                }
            }
        }
    }
}

void sub_3666(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 21

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 28 if statements

    // Block 0x3666
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov byte ptr [bp - 1], 0;
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 1;

    // Function calls:
    sub_363B(); // Performs arithmetic calculations
    sub_363B(); // Performs arithmetic calculations
    sub_363B(); // Performs arithmetic calculations
}

void sub_3808(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x3808
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    les si, ptr [bp + 6];
    mov word ptr es:[si], bx;
    $1 = $2;
    mov word ptr es:[si + 2], ax;
    mov word ptr es:[si + 4], ss;
    mov word ptr es:[si + 6], ds;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_2F4E(); // Unknown function purpose
    sub_60C5(); // Performs arithmetic calculations
    sub_2F4E(); // Unknown function purpose
    sub_60C5(); // Performs arithmetic calculations
}

void sub_3905(void) {
    // Purpose: Deletes a file

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x3905
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    DOS_DeleteFile();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x3917
        // Block 0x3917
        push($1);
        call 0x2d44;
        // Block 0x391B
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x3913
        $1 = 0;
        jmp 0x391b;
        // Block 0x391B
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_391D(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x391D
    $1 = $2;
    call 0x3924;
    // Block 0x3922
    mov al, dl;

    // Function calls:
    sub_3924(); // Unknown function purpose
}

void sub_3924(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x3924
    aam 0x10;
    xchg al, ah;
    call 0x392d;
    // Block 0x392B
    xchg al, ah;

    // Function calls:
    sub_392D(); // Manipulates strings or memory blocks and performs calculations
}

void sub_392D(void) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x392D
    $1 += $2;
    daa ;
    adc al, 0x40;
    daa ;
    stosb byte ptr es:[di], al;
    return;  // ret 
}

void sub_3935(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x3935
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 0x12], 0;
    mov word ptr [bp - 0x14], 0x50;
    mov word ptr [bp - 0x16], 0;
    jmp 0x3999;
    // Block 0x3999
}

void sub_394F(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x394F
    push($1);
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1 = pop();
    return;  // ret 
}

void sub_395C(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x395C
    mov byte ptr ss:[di], al;
    $1++;
    $1--;
    if (a != b) {  // jne 0x3998
        // Block 0x3998
    } else {
        // Block 0x3965
    }
}

void sub_3965(int, int, int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 41

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // int data_dx; // from parameter 4
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 63 if statements

    // Block 0x3965
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x96];
    $1 -= $2;
    push($1);
    lea ax, [bp - 0x96];
    push($1);
    push($1);
    push($1);
    push($1);
    call word ptr [bp + 0xe];
    // Block 0x397F
    or ax, ax;
    if (a != b) {  // jne 0x3988
        // Block 0x3988
        mov word ptr [bp - 0x14], 0x50;
        add word ptr [bp - 0x12], di;
        lea di, [bp - 0x96];
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x3983
        mov word ptr [bp - 0x16], 1;
    }

    // Function calls:
    sub_3965(); // Manipulates strings or memory blocks and performs calculations
    sub_2F5F(); // Manipulates strings or memory blocks and performs calculations
    sub_391D(); // Unknown function purpose
    sub_391D(); // Unknown function purpose
    sub_394F(); // Unknown function purpose
    sub_488C(); // Unknown function purpose
    sub_394F(); // Unknown function purpose
    sub_394F(); // Unknown function purpose
    sub_395C(); // Unknown function purpose
    sub_395C(); // Unknown function purpose
    sub_395C(); // Unknown function purpose
    sub_395C(); // Unknown function purpose
    sub_395C(); // Unknown function purpose
    sub_3965(); // Manipulates strings or memory blocks and performs calculations
    sub_395C(); // Unknown function purpose
    sub_395C(); // Unknown function purpose
    sub_3965(); // Manipulates strings or memory blocks and performs calculations
}

void sub_3DF8(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x3DF8
    in al, dx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--;
    imul dx;
    push($1);
    $1 = $2;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1--;
    $1 += $2;
    shl ax, 1;
    $1 = $2;
    $1 = pop();
    return;  // ret 4
}

void sub_3E1D(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 5

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x3E1D
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    if (condition_jcxz) {  // jcxz 0x3e8d
        // Block 0x3E8D
        cld ;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x3E33
        les di, ptr [bp + 0xa];
        lds si, ptr [bp + 6];
        cld ;
        // Compare $1 with $2
        if (a >= b (unsigned)) {  // jae 0x3e48
            // Block 0x3E48
            cmp word ptr [bp - 2], 0;
            if (a != b) {  // jne 0x3e52
                // Block 0x3E52
                $1 = $2;
                $1 = $2;
                $1 = $2;
                // Compare $1 with $2
                if (a == b) {  // je 0x3e6e
                    // Block 0x3E6E
                    cli ;
                } else {
                    // Block 0x3E5D
                    cli ;
                }
            } else {
                // Block 0x3E4E
                rep movsw word ptr es:[di], word ptr [si];
                jmp 0x3e8d;
                // Block 0x3E8D
                cld ;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // ret 0xa
            }
        } else {
            // Block 0x3E3E
            $1 = $2;
            $1--;
            shl ax, 1;
            $1 += $2;
            $1 += $2;
            std ;
        }
    }
}

void sub_3E97(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x3E97
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    call 0x6661;
    // Block 0x3EA6
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1++;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    call 0x59ff;
    // Block 0x3EBD
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_6661(); // Unknown function purpose
    sub_59FF(); // Manipulates strings or memory blocks
    sub_4A85(); // Manipulates strings or memory blocks and performs calculations
    sub_3F2F(); // Sets video mode
}

void sub_3EF4(int) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 2 if statements

    // Block 0x3EF4
    push($1);
    $1 = $2;
    jmp 0x3f11;
    // Block 0x3F11
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx], 0;
    if (a != b) {  // jne 0x3ef9
        // Block 0x3EF9
        les bx, ptr [bp + 4];
        $1++;
        $1 = $2;
        les bx, ptr [bp + 8];
        $1++;
        // Compare $1 with $2
        if (a == b) {  // je 0x3f11
            // Jump to block at 0x3F11
        } else {
            // Block 0x3F0D
            $1 = 0;
            jmp 0x3f1d;
            // Block 0x3F1D
            $1 = pop();
            return;  // ret 8
        }
    } else {
        // Block 0x3F1A
        mov ax, 1;
    }
}

void sub_3F21(void) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x3F21
    $1 = $2;
    $1 = $2;
    call 0x3f2f;
    // Block 0x3F28
    $1 = $2;
    $1 += $2;
    $1 = $2;
    return;  // ret 

    // Function calls:
    sub_3F2F(); // Sets video mode
}

void sub_3F2F(int) {
    // Purpose: Sets video mode

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x3F2F
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0x3f46
        // Block 0x3F46
        // Compare $1 with $2
        if (a == b) {  // je 0x3f4e
            // Block 0x3F4E
            push($1);
            $1 = $2;
            INT_10();  // int 0x10
            // Compare $1 with $2
            if (a == b) {  // je 0x3f5d
                // Block 0x3F5D
                $1 = $2;
                $1 = $2;
                INT_10();  // int 0x10
                $1 = pop();
                jmp 0x3f42;
                // Block 0x3F42
                INT_10();  // int 0x10
                jmp 0x3fb7;
                // Block 0x3FB7
                $1 = pop();
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x3F58
                and byte ptr [0x87], 0xfe;
            }
        } else {
            // Block 0x3F4A
            // Compare $1 with $2
            if (a != b) {  // jne 0x3f67
                // Block 0x3F67
                // Compare $1 with $2
                if (a != b) {  // jne 0x3f42
                    // Block 0x3F42
                    INT_10();  // int 0x10
                    jmp 0x3fb7;
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3F6B
                    $1 = $2;
                    $1 = $2;
                    INT_10_AH12();  // int 0x10
                    // Compare $1 with $2
                    if (a == b) {  // je 0x3fb7
                        // Block 0x3FB7
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x3F76
                        $1 = $2;
                        $1 = 0;
                        INT_10();  // int 0x10
                        $1 = $2;
                        $1 = $2;
                        INT_10();  // int 0x10
                        $1 = $2;
                        INT_10();  // int 0x10
                        // Compare $1 with $2
                        if (a == b) {  // je 0x3fb7
                            // Block 0x3FB7
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 
                        } else {
                            // Block 0x3F8D
                            or byte ptr [0x87], 1;
                            $1 = $2;
                            $1 = $2;
                            INT_10_AH01();  // int 0x10
                            jmp 0x3fb7;
                            // Block 0x3FB7
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 
                        }
                    }
                }
            } else {
                // Block 0x3F4E
                push($1);
                $1 = $2;
                INT_10();  // int 0x10
                // Compare $1 with $2
                if (a == b) {  // je 0x3f5d
                    // Block 0x3F5D
                    $1 = $2;
                    $1 = $2;
                    INT_10();  // int 0x10
                    $1 = pop();
                    jmp 0x3f42;
                    // Block 0x3F42
                    INT_10();  // int 0x10
                    jmp 0x3fb7;
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3F58
                    and byte ptr [0x87], 0xfe;
                }
            }
        }
    } else {
        // Block 0x3F3D
        // Compare $1 with $2
        if (a == b) {  // je 0x3f9b
            // Block 0x3F9B
            INT_10();  // int 0x10
            // Compare $1 with $2
            if (a == b) {  // je 0x3fa5
                // Block 0x3FA5
                push($1);
                call 0x3f21;
                // Block 0x3FA9
                or al, al;
                $1 = pop();
                if (a == b) {  // je 0x3fb7
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3FAE
                    cmp byte ptr [0x84], 0x18;
                    if (a == b) {  // je 0x3fb7
                        // Block 0x3FB7
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x3FB5
                        mov al, 0x40;
                    }
                }
            } else {
                // Block 0x3FA1
                // Compare $1 with $2
                if (a != b) {  // jne 0x3fb7
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3FA5
                    push($1);
                    call 0x3f21;
                    // Block 0x3FA9
                    or al, al;
                    $1 = pop();
                    if (a == b) {  // je 0x3fb7
                        // Block 0x3FB7
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x3FAE
                        cmp byte ptr [0x84], 0x18;
                        if (a == b) {  // je 0x3fb7
                            // Block 0x3FB7
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 
                        } else {
                            // Block 0x3FB5
                            mov al, 0x40;
                        }
                    }
                }
            }
        } else {
            // Block 0x3F42
            INT_10();  // int 0x10
            jmp 0x3fb7;
            // Block 0x3FB7
            $1 = pop();
            $1 = pop();
            return;  // ret 
        }
    }

    // Function calls:
    sub_3F21(); // Performs arithmetic calculations
    sub_3F2F(); // Sets video mode
    sub_3FD7(); // Writes data to a file and performs calculations
    sub_3F2F(); // Sets video mode
}

void sub_3FD7(void) {
    // Purpose: Writes data to a file and performs calculations

    // Complexity: 4

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int ptr_59_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x3FD7
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    call 0x3f2f;
    // Block 0x3FE5
    *($1) = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x4003
        // Block 0x4003
        cmp byte ptr [0x7652], 3;
        if (a <= b (unsigned)) {  // jbe 0x401d
            // Block 0x401D
            xor ax, ax;
        } else {
            // Block 0x400A
            cmp byte ptr [0x7652], 0x40;
            if (a >= b (unsigned)) {  // jae 0x401d
                // Block 0x401D
                xor ax, ax;
            } else {
                // Block 0x4011
                cmp byte ptr [0x7652], 7;
                if (a == b) {  // je 0x401d
                    // Block 0x401D
                    xor ax, ax;
                } else {
                    // Block 0x4018
                    $1 = $2;
                    jmp 0x401f;
                    // Block 0x401F
                    *($1) = $2;
                    cmp byte ptr [0x7652], 0x40;
                    if (a == b) {  // je 0x402d
                        // Block 0x402D
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        inc al;
                    } else {
                        // Block 0x4029
                        $1 = $2;
                        jmp 0x4038;
                        // Block 0x4038
                        *($1) = $2;
                        cmp byte ptr [0x7652], 7;
                        if (a == b) {  // je 0x4062
                            // Block 0x4062
                            xor ax, ax;
                        } else {
                            // Block 0x4042
                            $1 = $2;
                            $1 = $2;
                            push($1);
                            push($1);
                            push($1);
                            $1 = $2;
                            push($1);
                            call 0x3ef4;
                            // Block 0x4052
                            or ax, ax;
                            if (a != b) {  // jne 0x4062
                                // Block 0x4062
                                xor ax, ax;
                            } else {
                                // Block 0x4056
                                call 0x3f21;
                                // Block 0x4059
                                or ax, ax;
                                if (a != b) {  // jne 0x4062
                                    // Block 0x4062
                                    xor ax, ax;
                                } else {
                                    // Block 0x405D
                                    $1 = $2;
                                    jmp 0x4064;
                                    // Block 0x4064
                                    *($1) = $2;
                                    cmp byte ptr [0x7652], 7;
                                    if (a != b) {  // jne 0x4073
                                        // Block 0x4073
                                        mov ax, 0xb800;
                                    } else {
                                        // Block 0x406E
                                        $1 = $2;
                                        jmp 0x4076;
                                        // Block 0x4076
                                        *($1) = $2;
                                        mov word ptr [0x7657], 0;
                                        $1 = $2;
                                        *($1) = $2;
                                        *($1) = $2;
                                        $1 = $2;
                                        $1 += $2;
                                        *($1) = $2;
                                        $1 = $2;
                                        $1 += $2;
                                        *($1) = $2;
                                        $1 = pop();
                                        return;  // ret 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x3FEF
        $1 = $2;
        $1 = $2;
        call 0x3f2f;
        // Block 0x3FF7
        $1 = $2;
        call 0x3f2f;
        // Block 0x3FFC
        *($1) = $2;
        mov byte ptr [0x7654], ah;
    }

    // Function calls:
    sub_3F2F(); // Sets video mode
    sub_3F2F(); // Sets video mode
    sub_3F2F(); // Sets video mode
    sub_3EF4(); // Unknown function purpose
    sub_3F21(); // Performs arithmetic calculations
}

void sub_40C4(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x40C4
    // Compare $1 with $2
    if (a == b) {  // je 0x4102
        // Block 0x4102
        mov word ptr cs:[0x24b8], 0;
        mov word ptr cs:[0x24ba], 0;
        mov word ptr cs:[0x24bc], 0;
    } else {
        // Block 0x40CB
        $1 = $2;
        $1 = $2;
        cmp word ptr [2], 0;
        if (a == b) {  // je 0x40df
            // Block 0x40DF
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0x40fd
                // Block 0x40FD
                mov dx, word ptr cs:[0x24b8];
            } else {
                // Block 0x40E8
                $1 = $2;
                mov word ptr cs:[0x24ba], ax;
                push($1);
                $1 = 0;
                push($1);
                call 0x4198;
                // Block 0x40F6
                $1 = $2;
                jmp 0x4120;
                // Block 0x4120
                call 0x4560;
                // Block 0x4123
                $1 += $2;
                return;  // ret 
            }
        } else {
            // Block 0x40D8
            mov word ptr cs:[0x24ba], ds;
            jmp 0x4117;
            // Block 0x4117
            $1 = $2;
            push($1);
            $1 = 0;
            push ax;
        }
    }

    // Function calls:
    sub_4198(); // Unknown function purpose
    sub_4560(); // Unknown function purpose
}

int sub_4127(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x4127
    $1 = $2;
    push($1);
    $1 = $2;
    mov word ptr [2], 0;
    *($1) = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x416d
        // Block 0x416D
        call 0x41c1;
        // Block 0x4170
        $1 = pop();
        $1 = $2;
        $1 += $2;
        $1 = $2;
        cmp word ptr [2], 0;
        if (a == b) {  // je 0x4182
            // Block 0x4182
            $1 = $2;
            add word ptr es:[0], ax;
            $1 = $2;
            $1 = $2;
            $1 += $2;
            $1 = $2;
            mov word ptr es:[2], ax;
        } else {
            // Block 0x4181
            return;  // ret 
        }
    } else {
        // Block 0x413F
        cmp word ptr es:[2], 0;
        if (a != b) {  // jne 0x416d
            // Block 0x416D
            call 0x41c1;
            // Block 0x4170
            $1 = pop();
            $1 = $2;
            $1 += $2;
            $1 = $2;
            cmp word ptr [2], 0;
            if (a == b) {  // je 0x4182
                // Block 0x4182
                $1 = $2;
                add word ptr es:[0], ax;
                $1 = $2;
                $1 = $2;
                $1 += $2;
                $1 = $2;
                mov word ptr es:[2], ax;
            } else {
                // Block 0x4181
                return;  // ret 
            }
        } else {
            // Block 0x4147
            $1 = $2;
            $1 = pop();
            push($1);
            add word ptr es:[0], ax;
            $1 = $2;
            $1 += $2;
            $1 = $2;
            cmp word ptr es:[2], 0;
            if (a != b) {  // jne 0x4166
                // Block 0x4166
                mov word ptr es:[2], cx;
                jmp 0x4170;
                // Block 0x4170
                $1 = pop();
                $1 = $2;
                $1 += $2;
                $1 = $2;
                cmp word ptr [2], 0;
                if (a == b) {  // je 0x4182
                    // Block 0x4182
                    $1 = $2;
                    add word ptr es:[0], ax;
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    mov word ptr es:[2], ax;
                } else {
                    // Block 0x4181
                    return;  // ret 
                }
            } else {
                // Block 0x415F
                mov word ptr es:[8], cx;
                jmp 0x4170;
                // Block 0x4170
                $1 = pop();
                $1 = $2;
                $1 += $2;
                $1 = $2;
                cmp word ptr [2], 0;
                if (a == b) {  // je 0x4182
                    // Block 0x4182
                    $1 = $2;
                    add word ptr es:[0], ax;
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    mov word ptr es:[2], ax;
                } else {
                    // Block 0x4181
                    return;  // ret 
                }
            }
        }
    }

    // Function calls:
    sub_41C1(); // Unknown function purpose
}

void sub_4198(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4198
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x41b9
        // Block 0x41B9
        mov word ptr cs:[0x24bc], 0;
        return;  // ret 
    } else {
        // Block 0x41A0
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        mov word ptr es:[4], ds;
        mov word ptr cs:[0x24bc], ds;
        $1 = $2;
        return;  // ret 
    }
}

void sub_41C1(int, int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x41C1
    $1 = $2;
    or ax, ax;
    if (a == b) {  // je 0x41ea
        // Block 0x41EA
        mov word ptr cs:[0x24bc], ds;
        *($1) = $2;
        *($1) = $2;
        return;  // ret 
    } else {
        // Block 0x41C9
        $1 = $2;
        pushf ;
        cli ;
        $1 = $2;
        $1 = $2;
        mov word ptr ss:[6], ds;
        *($1) = $2;
        $1 = $2;
        popf ;
        mov word ptr es:[4], ds;
        *($1) = $2;
        return;  // ret 
    }
}

void sub_41F8(int) {
    // Purpose: Unknown function purpose

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x41F8
    push($1);
    $1 = $2;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    $1 = $2;
    or dx, dx;
    if (a == b) {  // je 0x4218
        // Block 0x4218
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4209
        // Compare $1 with $2
        if (a != b) {  // jne 0x4215
            // Block 0x4215
            call 0x4127;
            // Block 0x4218
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x4210
            call 0x40c4;
            // Block 0x4213
            jmp 0x4218;
            // Block 0x4218
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        }
    }

    // Function calls:
    sub_40C4(); // Performs arithmetic calculations
    sub_4127(); // Performs arithmetic calculations
}

void sub_4221(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;
    int var;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x4221
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    call 0x459f;
    // Block 0x422E
    $1 += $2;
    and ax, 0xf;
    if (a == b) {  // je 0x424a
        // Block 0x424A
        $1 = pop();
        push($1);
        $1 = 0;
        $1 = $2;
        $1 = $2;
        shr bx, cl;
        shl ax, cl;
        $1 = $2;
        push($1);
        push($1);
        call 0x459f;
        // Block 0x4260
        $1 += $2;
        $1 = pop();
        // Compare $1 with $2
        if (a == b) {  // je 0x4281
            // Block 0x4281
            $1 = 0;
            cdq ;
            return;  // ret 
        } else {
            // Block 0x4269
            mov word ptr cs:[0x24b8], dx;
            mov word ptr cs:[0x24ba], dx;
            $1 = $2;
            *($1) = $2;
            *($1) = $2;
            $1 = $2;
            return;  // ret 
        }
    } else {
        // Block 0x4236
        $1 = $2;
        $1 -= $2;
        $1 = 0;
        $1 = $2;
        push($1);
        push($1);
        call 0x459f;
        // Block 0x4247
        add sp, 4;
    }

    // Function calls:
    sub_459F(); // Performs arithmetic calculations
    sub_459F(); // Performs arithmetic calculations
    sub_459F(); // Performs arithmetic calculations
}

void sub_4285(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;
    int var;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x4285
    push($1);
    $1 = 0;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    shl ax, cl;
    $1 = $2;
    push($1);
    push($1);
    call 0x459f;
    // Block 0x429A
    $1 += $2;
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0x42db
        // Block 0x42DB
        $1 = 0;
        cdq ;
        return;  // ret 
    } else {
        // Block 0x42A3
        and ax, 0xf;
        if (a != b) {  // jne 0x42c0
            // Block 0x42C0
            push($1);
            push($1);
            neg ax;
            $1 += $2;
            $1 = 0;
            push($1);
            push($1);
            call 0x459f;
            // Block 0x42CE
            $1 += $2;
            $1 = pop();
            $1 = pop();
            // Compare $1 with $2
            if (a == b) {  // je 0x42db
                // Block 0x42DB
                $1 = 0;
                cdq ;
                return;  // ret 
            } else {
                // Block 0x42D8
                $1++;
                jmp 0x42a8;
                // Block 0x42A8
                $1 = $2;
                mov word ptr cs:[0x24ba], dx;
                $1 = $2;
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                return;  // ret 
            }
        } else {
            // Block 0x42A8
            $1 = $2;
            mov word ptr cs:[0x24ba], dx;
            $1 = $2;
            *($1) = $2;
            *($1) = $2;
            $1 = $2;
            return;  // ret 
        }
    }

    // Function calls:
    sub_459F(); // Performs arithmetic calculations
    sub_459F(); // Performs arithmetic calculations
}

void sub_42DF(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x42DF
    $1 = $2;
    sub word ptr [0], ax;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    return;  // ret 
}

int sub_4302(int) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x4302
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    jmp 0x4315;
    // Block 0x4315
}

void sub_430C(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x430C
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, dx;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    if (a == b) {  // je 0x4380
        // Block 0x4380
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4322
        $1 += $2;
        adc dx, 0;
        if (a < b (unsigned)) {  // jb 0x436b
            // Block 0x436B
            $1 = 0;
            cdq ;
            jmp 0x4380;
            // Block 0x4380
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x432A
            test dx, 0xfff0;
            if (a != b) {  // jne 0x436b
                // Block 0x436B
                $1 = 0;
                cdq ;
                jmp 0x4380;
                // Block 0x4380
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0x4330
                $1 = $2;
                shr ax, cl;
                shl dx, cl;
                or ah, dl;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0x4361
                    // Block 0x4361
                    call 0x4221;
                    // Block 0x4364
                    jmp 0x4380;
                    // Block 0x4380
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x4341
                    $1 = $2;
                    or dx, dx;
                    if (a == b) {  // je 0x435c
                        // Block 0x435C
                        call 0x4285;
                        // Block 0x435F
                        jmp 0x4380;
                        // Block 0x4380
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x434A
                        mov bx, dx;
                    }
                }
            }
        }
    }

    // Function calls:
    sub_4285(); // Performs arithmetic calculations
    sub_4221(); // Performs arithmetic calculations
    sub_42DF(); // Performs arithmetic calculations
    sub_4198(); // Unknown function purpose
}

void sub_4389(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x4389
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    call 0x430c;
    // Block 0x439A
    $1 += $2;
    or dx, dx;
    if (a != b) {  // jne 0x43a3
        // Block 0x43A3
        $1 = pop();
        $1 = $2;
        push($1);
        push($1);
        push($1);
        $1 = $2;
        cld ;
        $1--;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        rep movsw word ptr es:[di], word ptr [si];
        or dx, dx;
        if (a == b) {  // je 0x43f4
            // Block 0x43F4
            $1 = $2;
            push($1);
            call 0x41f8;
            // Block 0x43FD
            $1 += $2;
            $1 = pop();
            $1 = $2;
            return;  // ret 
        } else {
            // Block 0x43BD
            $1 = $2;
            $1++;
            $1 = $2;
            $1 = $2;
            $1++;
            mov ds, ax;
        }
    } else {
        // Block 0x43A1
        $1 = pop();
        return;  // ret 
    }

    // Function calls:
    sub_430C(); // Performs arithmetic calculations
    sub_41F8(); // Unknown function purpose
}

void sub_4405(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x4405
    // Compare $1 with $2
    if (a == b) {  // je 0x4451
        // Block 0x4451
        push($1);
        $1 = $2;
        mov word ptr es:[0], ax;
        $1 += $2;
        push($1);
        $1 = 0;
        push($1);
        call 0x4560;
        // Block 0x4461
        $1 += $2;
        $1 = pop();
        $1 = $2;
        return;  // ret 
    } else {
        // Block 0x440C
        $1 = $2;
        $1 += $2;
        $1 = $2;
        $1 = $2;
        $1 -= $2;
        mov word ptr es:[0], si;
        mov word ptr es:[2], bx;
        push($1);
        push($1);
        $1 = $2;
        mov word ptr es:[0], ax;
        $1 = $2;
        $1 += $2;
        $1 = $2;
        cmp word ptr es:[2], 0;
        if (a == b) {  // je 0x443d
            // Block 0x443D
            mov word ptr es:[8], di;
        } else {
            // Block 0x4436
            mov word ptr es:[2], di;
            jmp 0x4442;
            // Block 0x4442
            $1 = $2;
            push($1);
            call 0x41f8;
            // Block 0x4448
            $1 += $2;
            $1 = $2;
            $1 = $2;
            return;  // ret 
        }
    }

    // Function calls:
    sub_41F8(); // Unknown function purpose
    sub_4560(); // Unknown function purpose
    sub_4405(); // Performs arithmetic calculations
    sub_4389(); // Performs arithmetic calculations
    sub_430C(); // Performs arithmetic calculations
    sub_41F8(); // Unknown function purpose
}

void sub_44EA(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x44EA
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1++;
    $1 -= $2;
    $1 += $2;
    $1 = $2;
    shr si, cl;
    // Compare $1 with $2
    if (a != b) {  // jne 0x4515
        // Block 0x4515
        $1 = $2;
        shl si, cl;
        $1 = $2;
        $1 = $2;
        $1 += $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x452d
            // Block 0x452D
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x4d1c;
            // Block 0x4537
            $1 = pop();
            $1 = pop();
            $1 = $2;
            cmp dx, -1;
            if (a != b) {  // jne 0x454b
                // Block 0x454B
                $1 = $2;
                $1 += $2;
                *($1) = $2;
                mov word ptr [0x8f], 0;
                xor ax, ax;
            } else {
                // Block 0x4540
                $1 = $2;
                $1 = $2;
                shr ax, cl;
                *($1) = $2;
                jmp 0x4503;
                // Block 0x4503
                $1 = $2;
                $1 = $2;
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                jmp 0x455b;
                // Block 0x455B
                $1 = pop();
                $1 = pop();
                return;  // ret 4
            }
        } else {
            // Block 0x4527
            $1 = $2;
            sub si, word ptr [0x7b];
        }
    } else {
        // Block 0x4503
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        *($1) = $2;
        $1 = $2;
        jmp 0x455b;
        // Block 0x455B
        $1 = pop();
        $1 = pop();
        return;  // ret 4
    }

    // Function calls:
    sub_4D1C(); // Resizes memory block
}

void sub_4560(int, int, int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // int data_dx; // from parameter 4
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x4560
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    call 0x30f7;
    // Block 0x4574
    if (a < b (unsigned)) {  // jb 0x4596
        // Block 0x4596
        $1 = $2;
        jmp 0x459d;
        // Block 0x459D
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x4576
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        call 0x30f7;
        // Block 0x4587
        if (a > b (unsigned)) {  // ja 0x4596
            // Block 0x4596
            $1 = $2;
            jmp 0x459d;
            // Block 0x459D
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x4589
            push($1);
            push($1);
            call 0x44ea;
            // Block 0x4592
            or ax, ax;
            if (a != b) {  // jne 0x459b
                // Block 0x459B
                xor ax, ax;
            } else {
                // Block 0x4596
                $1 = $2;
                jmp 0x459d;
                // Block 0x459D
                $1 = pop();
                return;  // ret 
            }
        }
    }

    // Function calls:
    sub_30F7(); // Performs arithmetic calculations
    sub_30F7(); // Performs arithmetic calculations
    sub_44EA(); // Performs arithmetic calculations
}

void sub_459F(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x459F
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    call 0x2c9b;
    // Block 0x45AF
    $1 += $2;
    adc dx, 0;
    $1 += $2;
    adc dx, word ptr [bp + 6];
    // Compare $1 with $2
    if (a < b) {  // jl 0x45d0
        // Block 0x45D0
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        call 0x2cbc;
        // Block 0x45E0
        *($1) = $2;
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        call 0x30f7;
        // Block 0x45F1
        if (a < b (unsigned)) {  // jb 0x45c8
            // Block 0x45C8
            $1 = $2;
            $1 = $2;
            jmp 0x4626;
            // Block 0x4626
            $1 = $2;
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x45F3
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            call 0x30f7;
            // Block 0x4604
            if (a > b (unsigned)) {  // ja 0x45c8
                // Block 0x45C8
                $1 = $2;
                $1 = $2;
                jmp 0x4626;
                // Block 0x4626
                $1 = $2;
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x4606
                $1 = $2;
                $1 = $2;
                *($1) = $2;
                *($1) = $2;
                push($1);
                push($1);
                call 0x44ea;
                // Block 0x461C
                or ax, ax;
                if (a == b) {  // je 0x45c8
                    // Block 0x45C8
                    $1 = $2;
                    $1 = $2;
                    jmp 0x4626;
                    // Block 0x4626
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x4620
                    $1 = $2;
                    mov ax, word ptr [bp - 8];
                }
            }
        }
    } else {
        // Block 0x45C1
        if (a > b) {  // jg 0x45c8
            // Block 0x45C8
            $1 = $2;
            $1 = $2;
            jmp 0x4626;
            // Block 0x4626
            $1 = $2;
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x45C3
            // Compare $1 with $2
            if (a <= b (unsigned)) {  // jbe 0x45d0
                // Block 0x45D0
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                call 0x2cbc;
                // Block 0x45E0
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                $1 = $2;
                call 0x30f7;
                // Block 0x45F1
                if (a < b (unsigned)) {  // jb 0x45c8
                    // Block 0x45C8
                    $1 = $2;
                    $1 = $2;
                    jmp 0x4626;
                    // Block 0x4626
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x45F3
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    call 0x30f7;
                    // Block 0x4604
                    if (a > b (unsigned)) {  // ja 0x45c8
                        // Block 0x45C8
                        $1 = $2;
                        $1 = $2;
                        jmp 0x4626;
                        // Block 0x4626
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x4606
                        $1 = $2;
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        push($1);
                        push($1);
                        call 0x44ea;
                        // Block 0x461C
                        or ax, ax;
                        if (a == b) {  // je 0x45c8
                            // Block 0x45C8
                            $1 = $2;
                            $1 = $2;
                            jmp 0x4626;
                            // Block 0x4626
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 
                        } else {
                            // Block 0x4620
                            $1 = $2;
                            mov ax, word ptr [bp - 8];
                        }
                    }
                }
            } else {
                // Block 0x45C8
                $1 = $2;
                $1 = $2;
                jmp 0x4626;
                // Block 0x4626
                $1 = $2;
                $1 = pop();
                return;  // ret 
            }
        }
    }

    // Function calls:
    sub_2C9B(); // Performs arithmetic calculations
    sub_2CBC(); // Performs arithmetic calculations
    sub_30F7(); // Performs arithmetic calculations
    sub_30F7(); // Performs arithmetic calculations
    sub_44EA(); // Performs arithmetic calculations
    sub_2D1C(); // Performs arithmetic calculations
}

void sub_467A(void) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x467A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    call 0x4a0e;
    // Block 0x4693
    or ax, ax;
    if (a != b) {  // jne 0x469b
        // Block 0x469B
        $1 = $2;
        $1 -= $2;
        $1++;
        *($1) = $2;
        jmp 0x46c2;
        // Block 0x46C2
        // Compare $1 with $2
        if (a <= b) {  // jle 0x46a6
            // Block 0x46A6
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x3df8;
            // Block 0x46B1
            push($1);
            push($1);
            push($1);
            call 0x49d2;
            // Block 0x46B9
            $1 = $2;
            shl ax, 1;
            add word ptr [bp + 0xe], ax;
            inc si;
        } else {
            // Block 0x46C7
            mov ax, 1;
        }
    } else {
        // Block 0x4697
        $1 = 0;
        jmp 0x46ca;
        // Block 0x46CA
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4A0E(); // Unknown function purpose
    sub_3DF8(); // Performs arithmetic calculations
    sub_49D2(); // Unknown function purpose
}

void sub_46D0(void) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x46D0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    call 0x4a0e;
    // Block 0x46E9
    or ax, ax;
    if (a != b) {  // jne 0x46f1
        // Block 0x46F1
        $1 = $2;
        $1 -= $2;
        $1++;
        *($1) = $2;
        jmp 0x4718;
        // Block 0x4718
        // Compare $1 with $2
        if (a <= b) {  // jle 0x46fc
            // Block 0x46FC
            push($1);
            push($1);
            call 0x3df8;
            // Block 0x4701
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x49d2;
            // Block 0x470F
            $1 = $2;
            shl ax, 1;
            add word ptr [bp + 0xe], ax;
            inc si;
        } else {
            // Block 0x471D
            mov ax, 1;
        }
    } else {
        // Block 0x46ED
        $1 = 0;
        jmp 0x4720;
        // Block 0x4720
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4A0E(); // Unknown function purpose
    sub_3DF8(); // Performs arithmetic calculations
    sub_49D2(); // Unknown function purpose
    sub_3808(); // Performs arithmetic calculations
    sub_4754(); // Unknown function purpose
}

void sub_4754(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4754
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 0xe];
    push($1);
    push($1);
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    push($1);
    INT_21();  // int 0x21
    $1 = pop();
    pushf ;
    pushf ;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 0xe];
    $1 = pop();
    $1 = pop();
    lds si, ptr [bp + 0xa];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    and word ptr [si + 0xc], 1;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop();
    if (a == b) {  // je 0x47b0
        // Block 0x47B0
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x47AA
        push($1);
        push($1);
        call 0x2d44;
        // Block 0x47AF
        pop ax;
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_47B4(int, int) {
    // Purpose: Performs DOS operations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x47B4
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21_AH44();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x47d7
        // Block 0x47D7
        push($1);
        call 0x2d44;
        // Block 0x47DB
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x47CB
        cmp word ptr [bp + 8], 0;
        if (a != b) {  // jne 0x47d5
            // Block 0x47D5
            jmp 0x47db;
            // Block 0x47DB
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x47D1
            $1 = $2;
            jmp 0x47db;
            // Block 0x47DB
            $1 = pop();
            return;  // retf 
        }
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_47EF(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x47EF
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    call 0x4a0e;
    // Block 0x4808
    or ax, ax;
    if (a == b) {  // je 0x482f
        // Block 0x482F
        $1 = 0;
        jmp 0x4886;
        // Block 0x4886
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x480C
        push($1);
        push($1);
        $1 = $2;
        $1 -= $2;
        $1 = $2;
        $1 += $2;
        push($1);
        $1 = $2;
        $1 -= $2;
        $1 = $2;
        $1 += $2;
        push($1);
        call 0x4a0e;
        // Block 0x482B
        or ax, ax;
        if (a != b) {  // jne 0x4833
            // Block 0x4833
            $1 = $2;
            *($1) = $2;
            mov word ptr [bp - 4], 1;
            // Compare $1 with $2
            if (a >= b) {  // jge 0x484c
                // Block 0x484C
                $1 = $2;
                jmp 0x4879;
                // Block 0x4879
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x4850
                    // Block 0x4850
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    call 0x3df8;
                    // Block 0x4860
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    call 0x3df8;
                    // Block 0x4869
                    push($1);
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    $1++;
                    push($1);
                    call 0x49d2;
                    // Block 0x4876
                    add di, word ptr [bp - 4];
                } else {
                    // Block 0x4883
                    mov ax, 1;
                }
            } else {
                // Block 0x4842
                $1 = $2;
                *($1) = $2;
                mov word ptr [bp - 4], 0xffff;
            }
        } else {
            // Block 0x482F
            $1 = 0;
            jmp 0x4886;
            // Block 0x4886
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    }

    // Function calls:
    sub_4A0E(); // Unknown function purpose
    sub_4A0E(); // Unknown function purpose
    sub_3DF8(); // Performs arithmetic calculations
    sub_3DF8(); // Performs arithmetic calculations
    sub_49D2(); // Unknown function purpose
}

void sub_488C(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x488C
    jmp word ptr [0x76b0];
}

void sub_4890(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x4890
    jmp word ptr [0x76b2];
}

void sub_4894(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x4894
    jmp word ptr [0x76b4];
}

void sub_4898(void) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x4898
    jmp word ptr [0x76b6];
}

void sub_489C(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x489C
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    shr ax, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = pop();
    div bx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    return;  // ret 4
}

void sub_48D4(int, int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x48D4
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1 = $2;
    les bx, ptr [bp + 4];
    // Compare $1 with $2
    if (a == b) {  // je 0x48f2
        // Block 0x48F2
        $1++;
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x48fe
            // Block 0x48FE
            les bx, ptr [bp + 8];
            mov word ptr es:[bx], dx;
            $1 = pop();
            return;  // ret 8
        } else {
            // Block 0x48FA
            $1++;
            mov dl, 0;
        }
    } else {
        // Block 0x48E5
        $1 = $2;
        $1 = $2;
        call 0x3f2f;
        // Block 0x48EC
        les bx, ptr [bp + 4];
        mov word ptr es:[bx], dx;
    }

    // Function calls:
    sub_3F2F(); // Sets video mode
}

void sub_4908(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 7 if statements

    // Block 0x4908
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    call 0x4d38;
    // Block 0x4916
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x492a
        // Block 0x492A
        xor ax, ax;
    } else {
        // Block 0x4925
        $1 = $2;
        jmp 0x492c;
        // Block 0x492C
        *($1) = $2;
        or ax, ax;
        if (a == b) {  // je 0x493f
            // Block 0x493F
            $1 = $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x494d
                // Block 0x494D
                xor ax, ax;
            } else {
                // Block 0x4948
                $1 = $2;
                jmp 0x494f;
                // Block 0x494F
                *($1) = $2;
                or ax, ax;
                if (a == b) {  // je 0x49b9
                    // Block 0x49B9
                    $1 = $2;
                    $1--;
                    or ax, ax;
                    if (a != b) {  // jne 0x4964
                        // Block 0x4964
                        cmp word ptr [bp - 0xc], 0;
                        if (a == b) {  // je 0x4982
                            // Block 0x4982
                            les bx, ptr [bp + 6];
                            $1 = $2;
                            add word ptr [bp + 6], 2;
                        } else {
                            // Block 0x496A
                            push($1);
                            lea ax, [bp - 4];
                            push($1);
                            push($1);
                            lea ax, [bp - 6];
                            push($1);
                            call 0x48d4;
                            // Block 0x4977
                            $1 = $2;
                            $1 = $2;
                            call 0x3f2f;
                            // Block 0x497E
                            $1 = $2;
                            jmp 0x498c;
                            // Block 0x498C
                            cmp word ptr [bp - 0xa], 0;
                            if (a == b) {  // je 0x49af
                                // Block 0x49AF
                                les bx, ptr [bp + 0xa];
                                mov word ptr es:[bx], si;
                                add word ptr [bp + 0xa], 2;
                            } else {
                                // Block 0x4992
                                push($1);
                                lea ax, [bp - 2];
                                push($1);
                                push($1);
                                lea ax, [bp - 6];
                                push($1);
                                call 0x48d4;
                                // Block 0x499F
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                call 0x3f2f;
                                // Block 0x49AD
                                jmp 0x49b9;
                            }
                        }
                    } else {
                        // Block 0x49C0
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        call 0x3f2f;
                        // Block 0x49CA
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 0xa
                    }
                } else {
                    // Block 0x4956
                    push($1);
                    push($1);
                    call 0x489c;
                    // Block 0x495F
                    *($1) = $2;
                    jmp 0x49b9;
                    // Block 0x49B9
                    $1 = $2;
                    $1--;
                    or ax, ax;
                    if (a != b) {  // jne 0x4964
                        // Block 0x4964
                        cmp word ptr [bp - 0xc], 0;
                        if (a == b) {  // je 0x4982
                            // Block 0x4982
                            les bx, ptr [bp + 6];
                            $1 = $2;
                            add word ptr [bp + 6], 2;
                        } else {
                            // Block 0x496A
                            push($1);
                            lea ax, [bp - 4];
                            push($1);
                            push($1);
                            lea ax, [bp - 6];
                            push($1);
                            call 0x48d4;
                            // Block 0x4977
                            $1 = $2;
                            $1 = $2;
                            call 0x3f2f;
                            // Block 0x497E
                            $1 = $2;
                            jmp 0x498c;
                            // Block 0x498C
                            cmp word ptr [bp - 0xa], 0;
                            if (a == b) {  // je 0x49af
                                // Block 0x49AF
                                les bx, ptr [bp + 0xa];
                                mov word ptr es:[bx], si;
                                add word ptr [bp + 0xa], 2;
                            } else {
                                // Block 0x4992
                                push($1);
                                lea ax, [bp - 2];
                                push($1);
                                push($1);
                                lea ax, [bp - 6];
                                push($1);
                                call 0x48d4;
                                // Block 0x499F
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                call 0x3f2f;
                                // Block 0x49AD
                                jmp 0x49b9;
                            }
                        }
                    } else {
                        // Block 0x49C0
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        call 0x3f2f;
                        // Block 0x49CA
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 0xa
                    }
                }
            }
        } else {
            // Block 0x4933
            push($1);
            push($1);
            call 0x489c;
            // Block 0x493C
            mov word ptr [bp - 2], ax;
        }
    }

    // Function calls:
    sub_4D38(); // Performs arithmetic calculations
    sub_489C(); // Performs arithmetic calculations
    sub_489C(); // Performs arithmetic calculations
    sub_48D4(); // Unknown function purpose
    sub_3F2F(); // Sets video mode
    sub_48D4(); // Unknown function purpose
    sub_3F2F(); // Sets video mode
    sub_3F2F(); // Sets video mode
}

void sub_49D2(int) {
    // Purpose: Unknown function purpose

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x49D2
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (a != b) {  // jne 0x49fa
        // Block 0x49FA
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        call 0x4908;
        // Block 0x4A0A
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x49E1
        cmp word ptr [0x765b], 0;
        if (a == b) {  // je 0x49fa
            // Block 0x49FA
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x4908;
            // Block 0x4A0A
            $1 = pop();
            return;  // ret 0xa
        } else {
            // Block 0x49E8
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x3e1d;
            // Block 0x49F8
            jmp 0x4a0a;
            // Block 0x4A0A
            $1 = pop();
            return;  // ret 0xa
        }
    }

    // Function calls:
    sub_3E1D(); // Manipulates strings or memory blocks and performs calculations
    sub_4908(); // Performs arithmetic calculations
}

void sub_4A0E(int, int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int count_cx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x4A0E
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a > b (unsigned)) {  // ja 0x4a5b
        // Block 0x4A5B
        xor ax, ax;
    } else {
        // Block 0x4A2E
        // Compare $1 with $2
        if (a > b (unsigned)) {  // ja 0x4a5b
            // Block 0x4A5B
            xor ax, ax;
        } else {
            // Block 0x4A32
            // Compare $1 with $2
            if (a > b) {  // jg 0x4a5b
                // Block 0x4A5B
                xor ax, ax;
            } else {
                // Block 0x4A36
                // Compare $1 with $2
                if (a > b (unsigned)) {  // ja 0x4a5b
                    // Block 0x4A5B
                    xor ax, ax;
                } else {
                    // Block 0x4A3A
                    cmp word ptr [bp + 4], dx;
                    if (a > b (unsigned)) {  // ja 0x4a5b
                        // Block 0x4A5B
                        xor ax, ax;
                    } else {
                        // Block 0x4A3F
                        // Compare $1 with $2
                        if (a > b) {  // jg 0x4a5b
                            // Block 0x4A5B
                            xor ax, ax;
                        } else {
                            // Block 0x4A44
                            or bx, bx;
                            if (a <= b) {  // jle 0x4a5b
                                // Block 0x4A5B
                                xor ax, ax;
                            } else {
                                // Block 0x4A48
                                or di, di;
                                if (a <= b) {  // jle 0x4a5b
                                    // Block 0x4A5B
                                    xor ax, ax;
                                } else {
                                    // Block 0x4A4C
                                    or si, si;
                                    if (a <= b) {  // jle 0x4a5b
                                        // Block 0x4A5B
                                        xor ax, ax;
                                    } else {
                                        // Block 0x4A50
                                        cmp word ptr [bp + 4], 0;
                                        if (a <= b) {  // jle 0x4a5b
                                            // Block 0x4A5B
                                            xor ax, ax;
                                        } else {
                                            // Block 0x4A56
                                            $1 = $2;
                                            jmp 0x4a5d;
                                            // Block 0x4A5D
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // ret 8
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void sub_4A63(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4A63
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    jmp 0x4a7c;
    // Block 0x4A7C
    // Compare $1 with $2
    if (a <= b) {  // jle 0x4a71
        // Block 0x4A71
        les bx, ptr [bp + 8];
        mov word ptr es:[bx], cx;
        add word ptr [bp + 8], 2;
        inc dx;
    } else {
        // Block 0x4A81
        $1 = pop();
        return;  // ret 8
    }
}

void sub_4A85(void) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 10

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x4A85
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (a == b) {  // je 0x4a98
        // Block 0x4A98
        cmp word ptr [0x765b], 0;
        if (a != b) {  // jne 0x4aa2
            // Block 0x4AA2
            cmp byte ptr [bp + 4], 1;
            if (a == b) {  // je 0x4aab
                // Block 0x4AAB
                $1++;
                $1++;
                $1++;
                $1++;
                cmp byte ptr [bp + 0xe], 6;
                if (a == b) {  // je 0x4ac0
                    // Block 0x4AC0
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    $1++;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x47ef;
                    // Block 0x4AEA
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x467a;
                    // Block 0x4B10
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    call 0x4a63;
                    // Block 0x4B28
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    mov al, byte ptr [bp + 6];
                } else {
                    // Block 0x4ABD
                    jmp 0x4b51;
                    // Block 0x4B51
                    $1 = $2;
                    $1 = $2;
                    $1++;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    $1--;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x47ef;
                    // Block 0x4B7C
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x467a;
                    // Block 0x4BA2
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    call 0x4a63;
                    // Block 0x4BBA
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    jmp 0x4b3d;
                    // Block 0x4B3D
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x46d0;
                    // Block 0x4B4B
                    $1 += $2;
                    jmp 0x4beb;
                    // Block 0x4BEB
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 0xc
                }
            } else {
                // Block 0x4AA8
                jmp 0x4bd2;
                // Block 0x4BD2
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                call 0x3f2f;
                // Block 0x4BEB
                $1 = $2;
                $1 = pop();
                return;  // ret 0xc
            }
        } else {
            // Block 0x4A9F
            jmp 0x4bd2;
            // Block 0x4BD2
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            call 0x3f2f;
            // Block 0x4BEB
            $1 = $2;
            $1 = pop();
            return;  // ret 0xc
        }
    } else {
        // Block 0x4A95
        jmp 0x4bd2;
        // Block 0x4BD2
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        call 0x3f2f;
        // Block 0x4BEB
        $1 = $2;
        $1 = pop();
        return;  // ret 0xc
    }

    // Function calls:
    sub_47EF(); // Performs arithmetic calculations
    sub_467A(); // Performs arithmetic calculations
    sub_4A63(); // Performs arithmetic calculations
    sub_46D0(); // Performs arithmetic calculations
    sub_47EF(); // Performs arithmetic calculations
    sub_467A(); // Performs arithmetic calculations
    sub_4A63(); // Performs arithmetic calculations
    sub_3F2F(); // Sets video mode
    sub_4C86(); // Manipulates strings or memory blocks and performs calculations
    sub_4C86(); // Manipulates strings or memory blocks and performs calculations
}

int sub_4C86(void) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 5

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x4C86
    or ax, ax;
    if (a == b) {  // je 0x4c91
        // Block 0x4C91
        xchg al, ah;
        $1 = 0;
        stc ;
        if (condition_jcxz) {  // jcxz 0x4cad
            // Block 0x4CAD
            return;  // ret 
        } else {
            // Block 0x4C98
            lodsb al, byte ptr [si];
            $1--;
            $1 -= $2;
            if (a == b) {  // je 0x4cad
                // Block 0x4CAD
                return;  // ret 
            } else {
                // Block 0x4C9E
                $1 += $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x4cab
                    // Block 0x4CAB
                    or si, si;
                } else {
                    // Block 0x4CA4
                    cmp byte ptr [si], 0x22;
                    if (a != b) {  // jne 0x4cab
                        // Block 0x4CAB
                        or si, si;
                    } else {
                        // Block 0x4CA9
                        lodsb al, byte ptr [si];
                        dec cx;
                    }
                }
            }
        }
    } else {
        // Block 0x4C8A
        $1++;
        stosb byte ptr es:[di], al;
        or al, al;
        if (a != b) {  // jne 0x4c91
            // Block 0x4C91
            xchg al, ah;
            $1 = 0;
            stc ;
            if (condition_jcxz) {  // jcxz 0x4cad
                // Block 0x4CAD
                return;  // ret 
            } else {
                // Block 0x4C98
                lodsb al, byte ptr [si];
                $1--;
                $1 -= $2;
                if (a == b) {  // je 0x4cad
                    // Block 0x4CAD
                    return;  // ret 
                } else {
                    // Block 0x4C9E
                    $1 += $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x4cab
                        // Block 0x4CAB
                        or si, si;
                    } else {
                        // Block 0x4CA4
                        cmp byte ptr [si], 0x22;
                        if (a != b) {  // jne 0x4cab
                            // Block 0x4CAB
                            or si, si;
                        } else {
                            // Block 0x4CA9
                            lodsb al, byte ptr [si];
                            dec cx;
                        }
                    }
                }
            }
        } else {
            // Block 0x4C90
            inc bx;
        }
    }
}

void sub_4D1C(int, int) {
    // Purpose: Resizes memory block

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4D1C
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    DOS_ModifyMemoryAllocation();  // int 0x21
    if (a < b (unsigned)) {  // jb 0x4d30
        // Block 0x4D30
        push($1);
        push($1);
        call 0x2d44;
        // Block 0x4D35
        pop ax;
    } else {
        // Block 0x4D2B
        $1 = $2;
        jmp 0x4d36;
        // Block 0x4D36
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_4D38(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x4D38
    $1 = $2;
    $1 = $2;
    call 0x3f2f;
    // Block 0x4D3F
    $1 = $2;
    return;  // ret 

    // Function calls:
    sub_3F2F(); // Sets video mode
    sub_4D38(); // Performs arithmetic calculations
    sub_4D38(); // Performs arithmetic calculations
    sub_4E21(); // Performs DOS operations
}

void sub_4D9B(void) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x4D9B
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    les si, ptr [bp + 6];
    cld ;
    $1 -= $2;
    cdq ;
    $1 = $2;
    $1 = $2;
    mov di, 0x7233;

    // Function calls:
    sub_4D9B(); // Performs arithmetic calculations
}

void sub_4E21(int) {
    // Purpose: Performs DOS operations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4E21
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    INT_21_AH43();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x4e38
        // Block 0x4E38
        push($1);
        call 0x2d44;
        // Block 0x4E3C
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4E35
        xchg cx, ax;
        jmp 0x4e3c;
        // Block 0x4E3C
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_4E3E(int, int, int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4E3E
    push($1);
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x4e53
        // Block 0x4E53
        $1 = $2;
        shl bx, 1;
        mov word ptr [bx + 0x74d2], 0;
        push($1);
        nop ;
        push($1);
        call 0x4e66;
        // Block 0x4E63
        pop cx;
    } else {
        // Block 0x4E4A
        $1 = $2;
        push($1);
        call 0x2d44;
        // Block 0x4E51
        jmp 0x4e64;
        // Block 0x4E64
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_4E66(); // Closes a file
}

void sub_4E66(int) {
    // Purpose: Closes a file

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4E66
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    DOS_CloseFile();  // int 0x21
    if (a < b (unsigned)) {  // jb 0x4e7e
        // Block 0x4E7E
        push($1);
        call 0x2d44;
        // Block 0x4E82
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4E72
        shl bx, 1;
        mov word ptr [bx + 0x74d2], 0;
        $1 = 0;
        jmp 0x4e82;
        // Block 0x4E82
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_4E84(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x4E84
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x4e99
        // Block 0x4E99
        $1 = $2;
        shl bx, 1;
        test word ptr [bx + 0x74d2], 0x200;
        if (a == b) {  // je 0x4eab
            // Block 0x4EAB
            $1 = $2;
            $1 = $2;
            INT_21();  // int 0x21
            if (a < b (unsigned)) {  // jb 0x4ef3
                // Block 0x4EF3
                push ax;
            } else {
                // Block 0x4EB5
                test dl, 0x80;
                if (a != b) {  // jne 0x4eef
                    // Block 0x4EEF
                    $1 = 0;
                    jmp 0x4ef7;
                    // Block 0x4EF7
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x4EBA
                    $1 = $2;
                    $1 = 0;
                    $1 = $2;
                    INT_21();  // int 0x21
                    if (a < b (unsigned)) {  // jb 0x4ef3
                        // Block 0x4EF3
                        push ax;
                    } else {
                        // Block 0x4EC5
                        push($1);
                        push($1);
                        $1 = $2;
                        $1 = 0;
                        $1 = $2;
                        INT_21();  // int 0x21
                        *($1) = $2;
                        *($1) = $2;
                        $1 = pop();
                        $1 = pop();
                        if (a < b (unsigned)) {  // jb 0x4ef3
                            // Block 0x4EF3
                            push ax;
                        } else {
                            // Block 0x4EDA
                            $1 = $2;
                            INT_21();  // int 0x21
                            if (a < b (unsigned)) {  // jb 0x4ef3
                                // Block 0x4EF3
                                push ax;
                            } else {
                                // Block 0x4EE1
                                // Compare $1 with $2
                                if (a < b (unsigned)) {  // jb 0x4eef
                                    // Block 0x4EEF
                                    $1 = 0;
                                    jmp 0x4ef7;
                                    // Block 0x4EF7
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0x4EE6
                                    if (a > b (unsigned)) {  // ja 0x4eed
                                        // Block 0x4EED
                                        jmp 0x4ea6;
                                        // Block 0x4EA6
                                        $1 = $2;
                                        jmp 0x4ef7;
                                        // Block 0x4EF7
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0x4EE8
                                        // Compare $1 with $2
                                        if (a < b (unsigned)) {  // jb 0x4eef
                                            // Block 0x4EEF
                                            $1 = 0;
                                            jmp 0x4ef7;
                                            // Block 0x4EF7
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0x4EED
                                            jmp 0x4ea6;
                                            // Block 0x4EA6
                                            $1 = $2;
                                            jmp 0x4ef7;
                                            // Block 0x4EF7
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            // Block 0x4EA6
            $1 = $2;
            jmp 0x4ef7;
            // Block 0x4EF7
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x4E93
        $1 = $2;
        push($1);
        jmp 0x4ef4;
        // Block 0x4EF4
        call 0x2d44;
        // Block 0x4EF7
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_4EFB(int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 5

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x4EFB
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (a != b) {  // jne 0x4f0d
        // Block 0x4F0D
        les bx, ptr [bp + 6];
        $1 = $2;
        // Compare $1 with $2
        if (a == b) {  // je 0x4f1c
            // Block 0x4F1C
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx + 6], 0;
            if (a == b) {  // je 0x4f55
                // Block 0x4F55
                les bx, ptr [bp + 6];
                cmp byte ptr es:[bx + 4], 0;
                if (a < b) {  // jl 0x4f6d
                    // Block 0x4F6D
                    les bx, ptr [bp + 6];
                    mov word ptr es:[bx + 2], 0;
                    mov word ptr es:[bx + 6], 0;
                    mov word ptr es:[bx], 0;
                    mov byte ptr es:[bx + 4], 0xff;
                    cmp word ptr es:[bx + 0x10], 0;
                    if (a == b) {  // je 0x4fae
                        // Block 0x4FAE
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x4F8D
                        $1 = 0;
                        $1 = 0;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        call 0x302a;
                        // Block 0x4F9C
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x3905;
                        // Block 0x4FA3
                        $1 = pop();
                        $1 = pop();
                        les bx, ptr [bp + 6];
                        mov word ptr es:[bx + 0x10], 0;
                    }
                } else {
                    // Block 0x4F5F
                    $1 = $2;
                    cwde ;
                    push($1);
                    nop ;
                    push($1);
                    call 0x4e3e;
                    // Block 0x4F6A
                    $1 = pop();
                    mov si, ax;
                }
            } else {
                // Block 0x4F26
                cmp word ptr es:[bx], 0;
                if (a >= b) {  // jge 0x4f3b
                    // Block 0x4F3B
                    les bx, ptr [bp + 6];
                    test word ptr es:[bx + 2], 4;
                    if (a == b) {  // je 0x4f55
                        // Block 0x4F55
                        les bx, ptr [bp + 6];
                        cmp byte ptr es:[bx + 4], 0;
                        if (a < b) {  // jl 0x4f6d
                            // Block 0x4F6D
                            les bx, ptr [bp + 6];
                            mov word ptr es:[bx + 2], 0;
                            mov word ptr es:[bx + 6], 0;
                            mov word ptr es:[bx], 0;
                            mov byte ptr es:[bx + 4], 0xff;
                            cmp word ptr es:[bx + 0x10], 0;
                            if (a == b) {  // je 0x4fae
                                // Block 0x4FAE
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0x4F8D
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                call 0x302a;
                                // Block 0x4F9C
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x3905;
                                // Block 0x4FA3
                                $1 = pop();
                                $1 = pop();
                                les bx, ptr [bp + 6];
                                mov word ptr es:[bx + 0x10], 0;
                            }
                        } else {
                            // Block 0x4F5F
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x4e3e;
                            // Block 0x4F6A
                            $1 = pop();
                            mov si, ax;
                        }
                    } else {
                        // Block 0x4F46
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x41f8;
                        // Block 0x4F53
                        $1 = pop();
                        pop cx;
                    }
                } else {
                    // Block 0x4F2C
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x4fb3;
                    // Block 0x4F35
                    $1 = pop();
                    $1 = pop();
                    or ax, ax;
                    if (a != b) {  // jne 0x4fae
                        // Block 0x4FAE
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x4F3B
                        les bx, ptr [bp + 6];
                        test word ptr es:[bx + 2], 4;
                        if (a == b) {  // je 0x4f55
                            // Block 0x4F55
                            les bx, ptr [bp + 6];
                            cmp byte ptr es:[bx + 4], 0;
                            if (a < b) {  // jl 0x4f6d
                                // Block 0x4F6D
                                les bx, ptr [bp + 6];
                                mov word ptr es:[bx + 2], 0;
                                mov word ptr es:[bx + 6], 0;
                                mov word ptr es:[bx], 0;
                                mov byte ptr es:[bx + 4], 0xff;
                                cmp word ptr es:[bx + 0x10], 0;
                                if (a == b) {  // je 0x4fae
                                    // Block 0x4FAE
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0x4F8D
                                    $1 = 0;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    call 0x302a;
                                    // Block 0x4F9C
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x3905;
                                    // Block 0x4FA3
                                    $1 = pop();
                                    $1 = pop();
                                    les bx, ptr [bp + 6];
                                    mov word ptr es:[bx + 0x10], 0;
                                }
                            } else {
                                // Block 0x4F5F
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x4e3e;
                                // Block 0x4F6A
                                $1 = pop();
                                mov si, ax;
                            }
                        } else {
                            // Block 0x4F46
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x41f8;
                            // Block 0x4F53
                            $1 = pop();
                            pop cx;
                        }
                    }
                }
            }
        } else {
            // Block 0x4F19
            jmp 0x4fae;
            // Block 0x4FAE
            $1 = $2;
            $1 = pop();
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x4F0A
        jmp 0x4fae;
        // Block 0x4FAE
        $1 = $2;
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_41F8(); // Unknown function purpose
    sub_4E3E(); // Unknown function purpose
    sub_302A(); // Performs arithmetic calculations
    sub_3905(); // Deletes a file
}

void sub_4FB3(int) {
    // Purpose: Performs DOS operations and performs calculations

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x4FB3
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (a != b) {  // jne 0x4fc7
        // Block 0x4FC7
        les bx, ptr [bp + 6];
        $1 = $2;
        // Compare $1 with $2
        if (a == b) {  // je 0x4fd9
            // Block 0x4FD9
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx], 0;
            if (a < b) {  // jl 0x5033
                // Block 0x5033
                les bx, ptr [bp + 6];
                $1 = $2;
                $1 += $2;
                $1++;
                $1 = $2;
                sub word ptr es:[bx], si;
                push($1);
                $1 = $2;
                $1 = $2;
                mov word ptr es:[bx + 0xe], ax;
                mov word ptr es:[bx + 0xc], dx;
                push($1);
                push($1);
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x679c;
                // Block 0x5061
                $1 += $2;
                // Compare $1 with $2
                if (a == b) {  // je 0x507b
                    // Block 0x507B
                    xor ax, ax;
                } else {
                    // Block 0x5068
                    les bx, ptr [bp + 6];
                    test word ptr es:[bx + 2], 0x200;
                    if (a != b) {  // jne 0x507b
                        // Block 0x507B
                        xor ax, ax;
                    } else {
                        // Block 0x5073
                        or word ptr es:[bx + 2], 0x10;
                        jmp 0x4fd3;
                        // Block 0x4FD3
                        $1 = $2;
                        jmp 0x507d;
                        // Block 0x507D
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x4FE2
                test word ptr es:[bx + 2], 8;
                if (a != b) {  // jne 0x5002
                    // Block 0x5002
                    les bx, ptr [bp + 6];
                    mov word ptr es:[bx], 0;
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x507b
                        // Block 0x507B
                        xor ax, ax;
                    } else {
                        // Block 0x5019
                        cmp word ptr es:[bx + 0xc], dx;
                        if (a != b) {  // jne 0x507b
                            // Block 0x507B
                            xor ax, ax;
                        } else {
                            // Block 0x501F
                            $1 = $2;
                            $1 = $2;
                            mov word ptr es:[bx + 0xe], ax;
                            mov word ptr es:[bx + 0xc], dx;
                            goto $1;
                            jmp 0x507b;
                            // Block 0x507B
                            xor ax, ax;
                        }
                    }
                } else {
                    // Block 0x4FEA
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0x4ffc
                        // Block 0x4FFC
                        cmp word ptr es:[bx + 0xc], dx;
                        if (a != b) {  // jne 0x507b
                            // Block 0x507B
                            xor ax, ax;
                        } else {
                            // Block 0x5002
                            les bx, ptr [bp + 6];
                            mov word ptr es:[bx], 0;
                            $1 = $2;
                            $1 = $2;
                            $1 += $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x507b
                                // Block 0x507B
                                xor ax, ax;
                            } else {
                                // Block 0x5019
                                cmp word ptr es:[bx + 0xc], dx;
                                if (a != b) {  // jne 0x507b
                                    // Block 0x507B
                                    xor ax, ax;
                                } else {
                                    // Block 0x501F
                                    $1 = $2;
                                    $1 = $2;
                                    mov word ptr es:[bx + 0xe], ax;
                                    mov word ptr es:[bx + 0xc], dx;
                                    goto $1;
                                    jmp 0x507b;
                                    // Block 0x507B
                                    xor ax, ax;
                                }
                            }
                        }
                    } else {
                        // Block 0x4FF9
                        jmp 0x507b;
                        // Block 0x507B
                        xor ax, ax;
                    }
                }
            }
        } else {
            // Block 0x4FD3
            $1 = $2;
            jmp 0x507d;
            // Block 0x507D
            $1 = pop();
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x4FBF
        nop ;
        push($1);
        call 0x50e0;
        // Block 0x4FC4
        jmp 0x507b;
        // Block 0x507B
        xor ax, ax;
    }

    // Function calls:
    sub_50E0(); // Performs arithmetic calculations
    sub_679C(); // Performs arithmetic calculations
    sub_2D44(); // Unknown function purpose
    sub_2D44(); // Unknown function purpose
}

void sub_50E0(void) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x50E0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    jmp 0x5113;
    // Block 0x5113
    $1 = $2;
    $1--;
    or ax, ax;
    if (a != b) {  // jne 0x50f8
        // Block 0x50F8
        les bx, ptr [bp - 4];
        test word ptr es:[bx + 2], 3;
        if (a == b) {  // je 0x510f
            // Block 0x510F
            add word ptr [bp - 4], 0x14;
        } else {
            // Block 0x5103
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x4fb3;
            // Block 0x510C
            $1 = pop();
            $1 = pop();
            inc di;
        }
    } else {
        // Block 0x511A
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4FB3(); // Performs DOS operations and performs calculations
}

void sub_5122(int) {
    // Purpose: Unknown function purpose

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int ptr_38_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x5122
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = 0;
    les bx, ptr [bp + 0xc];
    $1++;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x5140
        // Block 0x5140
        // Compare $1 with $2
        if (a != b) {  // jne 0x514a
            // Block 0x514A
            // Compare $1 with $2
            if (a != b) {  // jne 0x515a
                // Block 0x515A
                $1 = 0;
                jmp 0x51d8;
                // Block 0x51D8
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // ret 0xc
            } else {
                // Block 0x514F
                mov dx, 0x902;
            }
        } else {
            // Block 0x5145
            $1 = $2;
            jmp 0x5152;
            // Block 0x5152
            $1 = $2;
            $1 = $2;
            jmp 0x515e;
            // Block 0x515E
            les bx, ptr [bp + 0xc];
            $1 = $2;
            $1++;
            // Compare $1 with $2
            if (a == b) {  // je 0x517f
                // Block 0x517F
                // Compare $1 with $2
                if (a != b) {  // jne 0x518a
                    // Block 0x518A
                    and dx, 0xfffc;
                    or dx, 4;
                    $1 = $2;
                    mov si, 3;
                } else {
                    // Block 0x5184
                    les bx, ptr [bp + 0xc];
                    mov cl, byte ptr es:[bx];
                }
            } else {
                // Block 0x516C
                les bx, ptr [bp + 0xc];
                cmp byte ptr es:[bx], 0x2b;
                if (a != b) {  // jne 0x5196
                    // Block 0x5196
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x51a1
                        // Block 0x51A1
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x51ac
                            // Block 0x51AC
                            $1 = $2;
                            and ax, 0xc000;
                            or dx, ax;
                            $1 = $2;
                            test ax, 0x8000;
                            if (a == b) {  // je 0x51be
                                // Block 0x51BE
                                mov word ptr [0x733a], 0;
                                mov word ptr [0x7338], 0x4d2c;
                                les bx, ptr [bp + 8];
                                mov word ptr es:[bx], dx;
                                les bx, ptr [bp + 4];
                                mov word ptr es:[bx], di;
                                mov ax, si;
                            } else {
                                // Block 0x51BB
                                or si, 0x40;
                            }
                        } else {
                            // Block 0x51A6
                            or dx, 0x8000;
                            jmp 0x51bb;
                            // Block 0x51BB
                            or si, 0x40;
                        }
                    } else {
                        // Block 0x519B
                        or dx, 0x4000;
                        jmp 0x51be;
                        // Block 0x51BE
                        mov word ptr [0x733a], 0;
                        mov word ptr [0x7338], 0x4d2c;
                        les bx, ptr [bp + 8];
                        mov word ptr es:[bx], dx;
                        les bx, ptr [bp + 4];
                        mov word ptr es:[bx], di;
                        mov ax, si;
                    }
                } else {
                    // Block 0x5175
                    // Compare $1 with $2
                    if (a == b) {  // je 0x517f
                        // Block 0x517F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x518a
                            // Block 0x518A
                            and dx, 0xfffc;
                            or dx, 4;
                            $1 = $2;
                            mov si, 3;
                        } else {
                            // Block 0x5184
                            les bx, ptr [bp + 0xc];
                            mov cl, byte ptr es:[bx];
                        }
                    } else {
                        // Block 0x517A
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x5196
                            // Block 0x5196
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x51a1
                                // Block 0x51A1
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x51ac
                                    // Block 0x51AC
                                    $1 = $2;
                                    and ax, 0xc000;
                                    or dx, ax;
                                    $1 = $2;
                                    test ax, 0x8000;
                                    if (a == b) {  // je 0x51be
                                        // Block 0x51BE
                                        mov word ptr [0x733a], 0;
                                        mov word ptr [0x7338], 0x4d2c;
                                        les bx, ptr [bp + 8];
                                        mov word ptr es:[bx], dx;
                                        les bx, ptr [bp + 4];
                                        mov word ptr es:[bx], di;
                                        mov ax, si;
                                    } else {
                                        // Block 0x51BB
                                        or si, 0x40;
                                    }
                                } else {
                                    // Block 0x51A6
                                    or dx, 0x8000;
                                    jmp 0x51bb;
                                    // Block 0x51BB
                                    or si, 0x40;
                                }
                            } else {
                                // Block 0x519B
                                or dx, 0x4000;
                                jmp 0x51be;
                                // Block 0x51BE
                                mov word ptr [0x733a], 0;
                                mov word ptr [0x7338], 0x4d2c;
                                les bx, ptr [bp + 8];
                                mov word ptr es:[bx], dx;
                                les bx, ptr [bp + 4];
                                mov word ptr es:[bx], di;
                                mov ax, si;
                            }
                        } else {
                            // Block 0x517F
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x518a
                                // Block 0x518A
                                and dx, 0xfffc;
                                or dx, 4;
                                $1 = $2;
                                mov si, 3;
                            } else {
                                // Block 0x5184
                                les bx, ptr [bp + 0xc];
                                mov cl, byte ptr es:[bx];
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x5138
        $1 = $2;
        $1 = $2;
        jmp 0x515e;
        // Block 0x515E
        les bx, ptr [bp + 0xc];
        $1 = $2;
        $1++;
        // Compare $1 with $2
        if (a == b) {  // je 0x517f
            // Block 0x517F
            // Compare $1 with $2
            if (a != b) {  // jne 0x518a
                // Block 0x518A
                and dx, 0xfffc;
                or dx, 4;
                $1 = $2;
                mov si, 3;
            } else {
                // Block 0x5184
                les bx, ptr [bp + 0xc];
                mov cl, byte ptr es:[bx];
            }
        } else {
            // Block 0x516C
            les bx, ptr [bp + 0xc];
            cmp byte ptr es:[bx], 0x2b;
            if (a != b) {  // jne 0x5196
                // Block 0x5196
                // Compare $1 with $2
                if (a != b) {  // jne 0x51a1
                    // Block 0x51A1
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x51ac
                        // Block 0x51AC
                        $1 = $2;
                        and ax, 0xc000;
                        or dx, ax;
                        $1 = $2;
                        test ax, 0x8000;
                        if (a == b) {  // je 0x51be
                            // Block 0x51BE
                            mov word ptr [0x733a], 0;
                            mov word ptr [0x7338], 0x4d2c;
                            les bx, ptr [bp + 8];
                            mov word ptr es:[bx], dx;
                            les bx, ptr [bp + 4];
                            mov word ptr es:[bx], di;
                            mov ax, si;
                        } else {
                            // Block 0x51BB
                            or si, 0x40;
                        }
                    } else {
                        // Block 0x51A6
                        or dx, 0x8000;
                        jmp 0x51bb;
                        // Block 0x51BB
                        or si, 0x40;
                    }
                } else {
                    // Block 0x519B
                    or dx, 0x4000;
                    jmp 0x51be;
                    // Block 0x51BE
                    mov word ptr [0x733a], 0;
                    mov word ptr [0x7338], 0x4d2c;
                    les bx, ptr [bp + 8];
                    mov word ptr es:[bx], dx;
                    les bx, ptr [bp + 4];
                    mov word ptr es:[bx], di;
                    mov ax, si;
                }
            } else {
                // Block 0x5175
                // Compare $1 with $2
                if (a == b) {  // je 0x517f
                    // Block 0x517F
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x518a
                        // Block 0x518A
                        and dx, 0xfffc;
                        or dx, 4;
                        $1 = $2;
                        mov si, 3;
                    } else {
                        // Block 0x5184
                        les bx, ptr [bp + 0xc];
                        mov cl, byte ptr es:[bx];
                    }
                } else {
                    // Block 0x517A
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x5196
                        // Block 0x5196
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x51a1
                            // Block 0x51A1
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x51ac
                                // Block 0x51AC
                                $1 = $2;
                                and ax, 0xc000;
                                or dx, ax;
                                $1 = $2;
                                test ax, 0x8000;
                                if (a == b) {  // je 0x51be
                                    // Block 0x51BE
                                    mov word ptr [0x733a], 0;
                                    mov word ptr [0x7338], 0x4d2c;
                                    les bx, ptr [bp + 8];
                                    mov word ptr es:[bx], dx;
                                    les bx, ptr [bp + 4];
                                    mov word ptr es:[bx], di;
                                    mov ax, si;
                                } else {
                                    // Block 0x51BB
                                    or si, 0x40;
                                }
                            } else {
                                // Block 0x51A6
                                or dx, 0x8000;
                                jmp 0x51bb;
                                // Block 0x51BB
                                or si, 0x40;
                            }
                        } else {
                            // Block 0x519B
                            or dx, 0x4000;
                            jmp 0x51be;
                            // Block 0x51BE
                            mov word ptr [0x733a], 0;
                            mov word ptr [0x7338], 0x4d2c;
                            les bx, ptr [bp + 8];
                            mov word ptr es:[bx], dx;
                            les bx, ptr [bp + 4];
                            mov word ptr es:[bx], di;
                            mov ax, si;
                        }
                    } else {
                        // Block 0x517F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x518a
                            // Block 0x518A
                            and dx, 0xfffc;
                            or dx, 4;
                            $1 = $2;
                            mov si, 3;
                        } else {
                            // Block 0x5184
                            les bx, ptr [bp + 0xc];
                            mov cl, byte ptr es:[bx];
                        }
                    }
                }
            }
        }
    }
}

void sub_51DE(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0x51DE
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 2];
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    call 0x5122;
    // Block 0x51F7
    les bx, ptr [bp + 0xe];
    mov word ptr es:[bx + 2], ax;
    or ax, ax;
    if (a == b) {  // je 0x522c
        // Block 0x522C
        les bx, ptr [bp + 0xe];
        mov byte ptr es:[bx + 4], 0xff;
        mov word ptr es:[bx + 2], 0;
    } else {
        // Block 0x5202
        cmp byte ptr es:[bx + 4], 0;
        if (a >= b) {  // jge 0x5240
            // Block 0x5240
            les bx, ptr [bp + 0xe];
            $1 = $2;
            cwde ;
            push($1);
            nop ;
            push($1);
            call 0x2f4e;
            // Block 0x524E
            $1 = pop();
            or ax, ax;
            if (a == b) {  // je 0x525c
                // Block 0x525C
                $1 = $2;
                push($1);
                les bx, ptr [bp + 0xe];
                test word ptr es:[bx + 2], 0x200;
                if (a == b) {  // je 0x5270
                    // Block 0x5270
                    xor ax, ax;
                } else {
                    // Block 0x526B
                    $1 = $2;
                    jmp 0x5272;
                    // Block 0x5272
                    push($1);
                    $1 = 0;
                    $1 = 0;
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x60c5;
                    // Block 0x5284
                    $1 += $2;
                    or ax, ax;
                    if (a == b) {  // je 0x529a
                        // Block 0x529A
                        les bx, ptr [bp + 0xe];
                        mov word ptr es:[bx + 0x10], 0;
                        $1 = $2;
                        mov ax, word ptr [bp + 0xe];
                    } else {
                        // Block 0x528B
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x4efb;
                        // Block 0x5296
                        $1 = pop();
                        $1 = pop();
                        jmp 0x523a;
                        // Block 0x523A
                        $1 = 0;
                        $1 = 0;
                        jmp 0x52a9;
                        // Block 0x52A9
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 0xe
                    }
                }
            } else {
                // Block 0x5253
                les bx, ptr [bp + 0xe];
                or word ptr es:[bx + 2], 0x200;
            }
        } else {
            // Block 0x5209
            push($1);
            $1 = $2;
            or ax, word ptr [bp + 4];
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x5a50;
            // Block 0x521E
            $1 += $2;
            les bx, ptr [bp + 0xe];
            mov byte ptr es:[bx + 4], al;
            or al, al;
            if (a >= b) {  // jge 0x5240
                // Block 0x5240
                les bx, ptr [bp + 0xe];
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x2f4e;
                // Block 0x524E
                $1 = pop();
                or ax, ax;
                if (a == b) {  // je 0x525c
                    // Block 0x525C
                    $1 = $2;
                    push($1);
                    les bx, ptr [bp + 0xe];
                    test word ptr es:[bx + 2], 0x200;
                    if (a == b) {  // je 0x5270
                        // Block 0x5270
                        xor ax, ax;
                    } else {
                        // Block 0x526B
                        $1 = $2;
                        jmp 0x5272;
                        // Block 0x5272
                        push($1);
                        $1 = 0;
                        $1 = 0;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x60c5;
                        // Block 0x5284
                        $1 += $2;
                        or ax, ax;
                        if (a == b) {  // je 0x529a
                            // Block 0x529A
                            les bx, ptr [bp + 0xe];
                            mov word ptr es:[bx + 0x10], 0;
                            $1 = $2;
                            mov ax, word ptr [bp + 0xe];
                        } else {
                            // Block 0x528B
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x4efb;
                            // Block 0x5296
                            $1 = pop();
                            $1 = pop();
                            jmp 0x523a;
                            // Block 0x523A
                            $1 = 0;
                            $1 = 0;
                            jmp 0x52a9;
                            // Block 0x52A9
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 0xe
                        }
                    }
                } else {
                    // Block 0x5253
                    les bx, ptr [bp + 0xe];
                    or word ptr es:[bx + 2], 0x200;
                }
            } else {
                // Block 0x522C
                les bx, ptr [bp + 0xe];
                mov byte ptr es:[bx + 4], 0xff;
                mov word ptr es:[bx + 2], 0;
            }
        }
    }

    // Function calls:
    sub_5122(); // Unknown function purpose
    sub_5A50(); // Performs arithmetic calculations
    sub_2F4E(); // Unknown function purpose
    sub_60C5(); // Performs arithmetic calculations
    sub_4EFB(); // Unknown function purpose
}

void sub_52AF(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x52AF
    push($1);
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;

    // Function calls:
    sub_52AF(); // Performs arithmetic calculations
    sub_51DE(); // Performs arithmetic calculations
    sub_3935(); // Performs arithmetic calculations
}

void sub_534A(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 11

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 19 if statements

    // Block 0x534A
    push($1);
    $1 = $2;
    push($1);
    push($1);
    jmp 0x542c;
    // Block 0x542C
    cmp word ptr [bp + 8], 0;
    if (a == b) {  // je 0x5435
        // Block 0x5435
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x5432
        jmp 0x5352;
        // Block 0x5352
        $1++;
        les bx, ptr [bp + 4];
        $1 = $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x5366
            // Block 0x5366
            les bx, ptr [bp + 4];
            mov ax, word ptr es:[bx + 6];
        } else {
            // Block 0x5361
            $1 = $2;
            jmp 0x536d;
            // Block 0x536D
            $1 = $2;
            les bx, ptr [bp + 4];
            test word ptr es:[bx + 2], 0x40;
            if (a == b) {  // je 0x53e9
                // Block 0x53E9
                $1--;
                $1 = $2;
                or ax, ax;
                if (a == b) {  // je 0x5427
                    // Block 0x5427
                    cmp dx, -1;
                    if (a == b) {  // je 0x53d6
                        // Block 0x53D6
                        les bx, ptr [bp + 4];
                        or word ptr es:[bx + 2], 0x20;
                        jmp 0x5435;
                        // Block 0x5435
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 0xa
                    } else {
                        // Jump to block at 0x542C
                    }
                } else {
                    // Block 0x53F3
                    $1--;
                    if (a == b) {  // je 0x5427
                        // Block 0x5427
                        cmp dx, -1;
                        if (a == b) {  // je 0x53d6
                            // Block 0x53D6
                            les bx, ptr [bp + 4];
                            or word ptr es:[bx + 2], 0x20;
                            jmp 0x5435;
                            // Block 0x5435
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 0xa
                        } else {
                            // Jump to block at 0x542C
                        }
                    } else {
                        // Block 0x53F6
                        les bx, ptr [bp + 4];
                        $1--;
                        if (a < b) {  // jl 0x5413
                            // Block 0x5413
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x57ef;
                            // Block 0x541E
                            $1 = pop();
                            pop cx;
                        } else {
                            // Block 0x53FE
                            $1 = $2;
                            $1 = $2;
                            $1++;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            jmp 0x5420;
                            // Block 0x5420
                            $1 = $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x53e0
                                // Block 0x53E0
                                les bx, ptr [bp + 0xa];
                                mov byte ptr es:[bx], dl;
                                inc word ptr [bp + 0xa];
                            } else {
                                // Block 0x5427
                                cmp dx, -1;
                                if (a == b) {  // je 0x53d6
                                    // Block 0x53D6
                                    les bx, ptr [bp + 4];
                                    or word ptr es:[bx + 2], 0x20;
                                    jmp 0x5435;
                                    // Block 0x5435
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // ret 0xa
                                } else {
                                    // Jump to block at 0x542C
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x537A
                cmp word ptr es:[bx + 6], 0;
                if (a == b) {  // je 0x53e9
                    // Block 0x53E9
                    $1--;
                    $1 = $2;
                    or ax, ax;
                    if (a == b) {  // je 0x5427
                        // Block 0x5427
                        cmp dx, -1;
                        if (a == b) {  // je 0x53d6
                            // Block 0x53D6
                            les bx, ptr [bp + 4];
                            or word ptr es:[bx + 2], 0x20;
                            jmp 0x5435;
                            // Block 0x5435
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 0xa
                        } else {
                            // Jump to block at 0x542C
                        }
                    } else {
                        // Block 0x53F3
                        $1--;
                        if (a == b) {  // je 0x5427
                            // Block 0x5427
                            cmp dx, -1;
                            if (a == b) {  // je 0x53d6
                                // Block 0x53D6
                                les bx, ptr [bp + 4];
                                or word ptr es:[bx + 2], 0x20;
                                jmp 0x5435;
                                // Block 0x5435
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                return;  // ret 0xa
                            } else {
                                // Jump to block at 0x542C
                            }
                        } else {
                            // Block 0x53F6
                            les bx, ptr [bp + 4];
                            $1--;
                            if (a < b) {  // jl 0x5413
                                // Block 0x5413
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x57ef;
                                // Block 0x541E
                                $1 = pop();
                                pop cx;
                            } else {
                                // Block 0x53FE
                                $1 = $2;
                                $1 = $2;
                                $1++;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                jmp 0x5420;
                                // Block 0x5420
                                $1 = $2;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x53e0
                                    // Block 0x53E0
                                    les bx, ptr [bp + 0xa];
                                    mov byte ptr es:[bx], dl;
                                    inc word ptr [bp + 0xa];
                                } else {
                                    // Block 0x5427
                                    cmp dx, -1;
                                    if (a == b) {  // je 0x53d6
                                        // Block 0x53D6
                                        les bx, ptr [bp + 4];
                                        or word ptr es:[bx + 2], 0x20;
                                        jmp 0x5435;
                                        // Block 0x5435
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // ret 0xa
                                    } else {
                                        // Jump to block at 0x542C
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x5381
                    $1 = $2;
                    // Compare $1 with $2
                    if (a >= b (unsigned)) {  // jae 0x53e9
                        // Block 0x53E9
                        $1--;
                        $1 = $2;
                        or ax, ax;
                        if (a == b) {  // je 0x5427
                            // Block 0x5427
                            cmp dx, -1;
                            if (a == b) {  // je 0x53d6
                                // Block 0x53D6
                                les bx, ptr [bp + 4];
                                or word ptr es:[bx + 2], 0x20;
                                jmp 0x5435;
                                // Block 0x5435
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                return;  // ret 0xa
                            } else {
                                // Jump to block at 0x542C
                            }
                        } else {
                            // Block 0x53F3
                            $1--;
                            if (a == b) {  // je 0x5427
                                // Block 0x5427
                                cmp dx, -1;
                                if (a == b) {  // je 0x53d6
                                    // Block 0x53D6
                                    les bx, ptr [bp + 4];
                                    or word ptr es:[bx + 2], 0x20;
                                    jmp 0x5435;
                                    // Block 0x5435
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // ret 0xa
                                } else {
                                    // Jump to block at 0x542C
                                }
                            } else {
                                // Block 0x53F6
                                les bx, ptr [bp + 4];
                                $1--;
                                if (a < b) {  // jl 0x5413
                                    // Block 0x5413
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x57ef;
                                    // Block 0x541E
                                    $1 = pop();
                                    pop cx;
                                } else {
                                    // Block 0x53FE
                                    $1 = $2;
                                    $1 = $2;
                                    $1++;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    jmp 0x5420;
                                    // Block 0x5420
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x53e0
                                        // Block 0x53E0
                                        les bx, ptr [bp + 0xa];
                                        mov byte ptr es:[bx], dl;
                                        inc word ptr [bp + 0xa];
                                    } else {
                                        // Block 0x5427
                                        cmp dx, -1;
                                        if (a == b) {  // je 0x53d6
                                            // Block 0x53D6
                                            les bx, ptr [bp + 4];
                                            or word ptr es:[bx + 2], 0x20;
                                            jmp 0x5435;
                                            // Block 0x5435
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // ret 0xa
                                        } else {
                                            // Jump to block at 0x542C
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x538A
                        cmp word ptr es:[bx], 0;
                        if (a != b) {  // jne 0x53e9
                            // Block 0x53E9
                            $1--;
                            $1 = $2;
                            or ax, ax;
                            if (a == b) {  // je 0x5427
                                // Block 0x5427
                                cmp dx, -1;
                                if (a == b) {  // je 0x53d6
                                    // Block 0x53D6
                                    les bx, ptr [bp + 4];
                                    or word ptr es:[bx + 2], 0x20;
                                    jmp 0x5435;
                                    // Block 0x5435
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // ret 0xa
                                } else {
                                    // Jump to block at 0x542C
                                }
                            } else {
                                // Block 0x53F3
                                $1--;
                                if (a == b) {  // je 0x5427
                                    // Block 0x5427
                                    cmp dx, -1;
                                    if (a == b) {  // je 0x53d6
                                        // Block 0x53D6
                                        les bx, ptr [bp + 4];
                                        or word ptr es:[bx + 2], 0x20;
                                        jmp 0x5435;
                                        // Block 0x5435
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // ret 0xa
                                    } else {
                                        // Jump to block at 0x542C
                                    }
                                } else {
                                    // Block 0x53F6
                                    les bx, ptr [bp + 4];
                                    $1--;
                                    if (a < b) {  // jl 0x5413
                                        // Block 0x5413
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x57ef;
                                        // Block 0x541E
                                        $1 = pop();
                                        pop cx;
                                    } else {
                                        // Block 0x53FE
                                        $1 = $2;
                                        $1 = $2;
                                        $1++;
                                        $1 = $2;
                                        $1 = $2;
                                        $1 = $2;
                                        jmp 0x5420;
                                        // Block 0x5420
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x53e0
                                            // Block 0x53E0
                                            les bx, ptr [bp + 0xa];
                                            mov byte ptr es:[bx], dl;
                                            inc word ptr [bp + 0xa];
                                        } else {
                                            // Block 0x5427
                                            cmp dx, -1;
                                            if (a == b) {  // je 0x53d6
                                                // Block 0x53D6
                                                les bx, ptr [bp + 4];
                                                or word ptr es:[bx + 2], 0x20;
                                                jmp 0x5435;
                                                // Block 0x5435
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // ret 0xa
                                            } else {
                                                // Jump to block at 0x542C
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0x5390
                            $1--;
                            $1 = 0;
                            jmp 0x53a5;
                            // Block 0x53A5
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            // Compare $1 with $2
                            if (a <= b (unsigned)) {  // jbe 0x5397
                                // Block 0x5397
                                les bx, ptr [bp + 4];
                                $1 += $2;
                                $1 = $2;
                                sub word ptr [bp + 8], ax;
                            } else {
                                // Block 0x53B1
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x3118;
                                // Block 0x53C3
                                $1 += $2;
                                $1 = $2;
                                add word ptr [bp + 0xa], dx;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x542c
                                    // Jump to block at 0x542C
                                } else {
                                    // Block 0x53CF
                                    $1 = $2;
                                    $1 -= $2;
                                    add word ptr [bp + 8], ax;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Function calls:
    sub_3118(); // Reads data from a file
    sub_57EF(); // Unknown function purpose
    sub_30E0(); // Performs arithmetic calculations
    sub_534A(); // Performs arithmetic calculations
    sub_2CBC(); // Performs arithmetic calculations
    sub_534A(); // Performs arithmetic calculations
}

void sub_54CC(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 loops
    // - 7 if statements

    // Block 0x54CC
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx], 0;
    if (a >= b) {  // jge 0x54e8
        // Block 0x54E8
        les bx, ptr [bp + 4];
        $1 = $2;
        cdq ;
        xor ax, dx;
        $1 -= $2;
        $1 = $2;
        mov si, ax;
    } else {
        // Block 0x54DC
        $1 = $2;
        $1 += $2;
        $1++;
        $1 = $2;
        jmp 0x54f7;
        // Block 0x54F7
        les bx, ptr [bp + 4];
        test word ptr es:[bx + 2], 0x40;
        if (a != b) {  // jne 0x5545
            // Block 0x5545
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // ret 4
        } else {
            // Block 0x5502
            les bx, ptr [bp + 4];
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            *($1) = $2;
            cmp word ptr es:[bx], 0;
            if (a >= b) {  // jge 0x553e
                // Block 0x553E
                $1 = $2;
                $1--;
                or ax, ax;
                if (a != b) {  // jne 0x5531
                    // Block 0x5531
                    les bx, ptr [bp - 4];
                    $1++;
                    cmp byte ptr es:[bx], 0xa;
                    if (a != b) {  // jne 0x553e
                        // Jump to block at 0x553E
                    } else {
                        // Block 0x553D
                        inc si;
                    }
                } else {
                    // Block 0x5545
                    $1 = $2;
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 4
                }
            } else {
                // Block 0x5519
                jmp 0x5528;
                // Block 0x5528
                $1 = $2;
                $1--;
                or ax, ax;
                if (a != b) {  // jne 0x551b
                    // Block 0x551B
                    $1--;
                    les bx, ptr [bp - 4];
                    cmp byte ptr es:[bx], 0xa;
                    if (a != b) {  // jne 0x5528
                        // Jump to block at 0x5528
                    } else {
                        // Block 0x5527
                        inc si;
                    }
                } else {
                    // Block 0x552F
                    jmp 0x5545;
                    // Block 0x5545
                    $1 = $2;
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 4
                }
            }
        }
    }
}

void sub_554E(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 13

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0x554E
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    nop ;
    push($1);
    call 0x4fb3;
    // Block 0x5560
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (a == b) {  // je 0x556b
        // Block 0x556B
        // Compare $1 with $2
        if (a != b) {  // jne 0x5587
            // Block 0x5587
            les bx, ptr [bp + 6];
            and word ptr es:[bx + 2], 0xfe5f;
            mov word ptr es:[bx], 0;
            $1 = $2;
            $1 = $2;
            mov word ptr es:[bx + 0xe], ax;
            mov word ptr es:[bx + 0xc], dx;
            push($1);
            push($1);
            push($1);
            $1 = $2;
            cwde ;
            push($1);
            nop ;
            push($1);
            call 0x3001;
            // Block 0x55B7
            $1 += $2;
            cmp dx, -1;
            if (a != b) {  // jne 0x55c9
                // Block 0x55C9
                xor ax, ax;
            } else {
                // Block 0x55BF
                // Compare $1 with $2
                if (a != b) {  // jne 0x55c9
                    // Block 0x55C9
                    xor ax, ax;
                } else {
                    // Block 0x55C4
                    $1 = $2;
                    jmp 0x55cb;
                    // Block 0x55CB
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            }
        } else {
            // Block 0x5570
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx], 0;
            if (a <= b) {  // jle 0x5587
                // Block 0x5587
                les bx, ptr [bp + 6];
                and word ptr es:[bx + 2], 0xfe5f;
                mov word ptr es:[bx], 0;
                $1 = $2;
                $1 = $2;
                mov word ptr es:[bx + 0xe], ax;
                mov word ptr es:[bx + 0xc], dx;
                push($1);
                push($1);
                push($1);
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x3001;
                // Block 0x55B7
                $1 += $2;
                cmp dx, -1;
                if (a != b) {  // jne 0x55c9
                    // Block 0x55C9
                    xor ax, ax;
                } else {
                    // Block 0x55BF
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x55c9
                        // Block 0x55C9
                        xor ax, ax;
                    } else {
                        // Block 0x55C4
                        $1 = $2;
                        jmp 0x55cb;
                        // Block 0x55CB
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x5579
                push($1);
                push($1);
                call 0x54cc;
                // Block 0x5580
                cdq ;
                sub word ptr [bp + 0xa], ax;
                sbb word ptr [bp + 0xc], dx;
            }
        }
    } else {
        // Block 0x5566
        $1 = $2;
        jmp 0x55cb;
        // Block 0x55CB
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_54CC(); // Performs arithmetic calculations
    sub_3001(); // Moves file pointer
    sub_3001(); // Moves file pointer
    sub_3001(); // Moves file pointer
    sub_3001(); // Moves file pointer
    sub_54CC(); // Performs arithmetic calculations
    sub_54CC(); // Performs arithmetic calculations
    sub_30E0(); // Performs arithmetic calculations
    sub_5DEE(); // Performs arithmetic calculations
    sub_5DEE(); // Performs arithmetic calculations
    sub_2CBC(); // Performs arithmetic calculations
}

void sub_5739(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x5739
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    jmp 0x576b;
    // Block 0x576B
    $1 = $2;
    $1--;
    or ax, ax;
    if (a != b) {  // jne 0x574d
        // Block 0x574D
        les bx, ptr [bp - 4];
        $1 = $2;
        and ax, 0x300;
        // Compare $1 with $2
        if (a != b) {  // jne 0x5767
            // Block 0x5767
            add word ptr [bp - 4], 0x14;
        } else {
            // Block 0x575C
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x4fb3;
            // Block 0x5765
            $1 = pop();
            pop cx;
        }
    } else {
        // Block 0x5772
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // ret 
    }

    // Function calls:
    sub_4FB3(); // Performs DOS operations and performs calculations
}

void sub_5777(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x5777
    push($1);
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x200;
    if (a == b) {  // je 0x5788
        // Block 0x5788
        les bx, ptr [bp + 4];
        push($1);
        $1 = $2;
        $1 = $2;
        mov word ptr es:[bx + 0xe], ax;
        mov word ptr es:[bx + 0xc], dx;
        push($1);
        push($1);
        $1 = $2;
        cwde ;
        push($1);
        nop ;
        push($1);
        call 0x5ff1;
        // Block 0x57AC
        $1 += $2;
        les bx, ptr [bp + 4];
        mov word ptr es:[bx], ax;
        or ax, ax;
        if (a <= b) {  // jle 0x57c2
            // Block 0x57C2
            les bx, ptr [bp + 4];
            cmp word ptr es:[bx], 0;
            if (a != b) {  // jne 0x57db
                // Block 0x57DB
                les bx, ptr [bp + 4];
                mov word ptr es:[bx], 0;
                or word ptr es:[bx + 2], 0x10;
            } else {
                // Block 0x57CB
                $1 = $2;
                and ax, 0xfe7f;
                or ax, 0x20;
                mov word ptr es:[bx + 2], ax;
                jmp 0x57e8;
                // Block 0x57E8
                mov ax, 0xffff;
            }
        } else {
            // Block 0x57B9
            and word ptr es:[bx + 2], 0xffdf;
            $1 = 0;
            jmp 0x57eb;
            // Block 0x57EB
            $1 = pop();
            return;  // ret 4
        }
    } else {
        // Block 0x5785
        call 0x5739;
        // Block 0x5788
        les bx, ptr [bp + 4];
        push($1);
        $1 = $2;
        $1 = $2;
        mov word ptr es:[bx + 0xe], ax;
        mov word ptr es:[bx + 0xc], dx;
        push($1);
        push($1);
        $1 = $2;
        cwde ;
        push($1);
        nop ;
        push($1);
        call 0x5ff1;
        // Block 0x57AC
        $1 += $2;
        les bx, ptr [bp + 4];
        mov word ptr es:[bx], ax;
        or ax, ax;
        if (a <= b) {  // jle 0x57c2
            // Block 0x57C2
            les bx, ptr [bp + 4];
            cmp word ptr es:[bx], 0;
            if (a != b) {  // jne 0x57db
                // Block 0x57DB
                les bx, ptr [bp + 4];
                mov word ptr es:[bx], 0;
                or word ptr es:[bx + 2], 0x10;
            } else {
                // Block 0x57CB
                $1 = $2;
                and ax, 0xfe7f;
                or ax, 0x20;
                mov word ptr es:[bx + 2], ax;
                jmp 0x57e8;
                // Block 0x57E8
                mov ax, 0xffff;
            }
        } else {
            // Block 0x57B9
            and word ptr es:[bx + 2], 0xffdf;
            $1 = 0;
            jmp 0x57eb;
            // Block 0x57EB
            $1 = pop();
            return;  // ret 4
        }
    }

    // Function calls:
    sub_5739(); // Performs arithmetic calculations
    sub_5FF1(); // Manipulates strings or memory blocks and performs calculations
}

void sub_57EF(int, int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x57EF
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    $1++;
    push($1);
    push($1);
    push($1);
    call 0x5807;
    // Block 0x5800
    $1 = pop();
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_5807(); // Performs arithmetic calculations
}

void sub_5807(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 18 if statements

    // Block 0x5807
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (a != b) {  // jne 0x5819
        // Block 0x5819
        les bx, ptr [bp + 6];
        cmp word ptr es:[bx], 0;
        if (a <= b) {  // jle 0x583c
            // Block 0x583C
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx], 0;
            if (a < b) {  // jl 0x58b4
                // Block 0x58B4
                les bx, ptr [bp + 6];
                or word ptr es:[bx + 2], 0x10;
                jmp 0x5813;
                // Block 0x5813
                $1 = $2;
                jmp 0x58f2;
                // Block 0x58F2
                $1 = pop();
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0x5845
                test word ptr es:[bx + 2], 0x110;
                if (a != b) {  // jne 0x58b4
                    // Block 0x58B4
                    les bx, ptr [bp + 6];
                    or word ptr es:[bx + 2], 0x10;
                    jmp 0x5813;
                    // Block 0x5813
                    $1 = $2;
                    jmp 0x58f2;
                    // Block 0x58F2
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x584D
                    test word ptr es:[bx + 2], 1;
                    if (a == b) {  // je 0x58b4
                        // Block 0x58B4
                        les bx, ptr [bp + 6];
                        or word ptr es:[bx + 2], 0x10;
                        jmp 0x5813;
                        // Block 0x5813
                        $1 = $2;
                        jmp 0x58f2;
                        // Block 0x58F2
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x5855
                        les bx, ptr [bp + 6];
                        or word ptr es:[bx + 2], 0x80;
                        cmp word ptr es:[bx + 6], 0;
                        if (a == b) {  // je 0x5874
                            // Block 0x5874
                            les bx, ptr [bp + 6];
                            test word ptr es:[bx + 2], 0x200;
                            if (a == b) {  // je 0x5882
                                // Block 0x5882
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                les bx, ptr [bp + 6];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x5ff1;
                                // Block 0x5899
                                $1 += $2;
                                or ax, ax;
                                if (a != b) {  // jne 0x58d3
                                    // Block 0x58D3
                                    cmp byte ptr [0x8790], 0xd;
                                    if (a != b) {  // jne 0x58e5
                                        // Block 0x58E5
                                        les bx, ptr [bp + 6];
                                        and word ptr es:[bx + 2], 0xffdf;
                                        mov al, byte ptr [0x8790];
                                    } else {
                                        // Block 0x58DA
                                        les bx, ptr [bp + 6];
                                        test word ptr es:[bx + 2], 0x40;
                                        if (a == b) {  // je 0x5874
                                            // Jump to block at 0x5874
                                        } else {
                                            // Block 0x58E5
                                            les bx, ptr [bp + 6];
                                            and word ptr es:[bx + 2], 0xffdf;
                                            mov al, byte ptr [0x8790];
                                        }
                                    }
                                } else {
                                    // Block 0x58A0
                                    les bx, ptr [bp + 6];
                                    $1 = $2;
                                    cwde ;
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e84;
                                    // Block 0x58AE
                                    $1 = pop();
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x58bf
                                        // Block 0x58BF
                                        les bx, ptr [bp + 6];
                                        $1 = $2;
                                        and ax, 0xfe7f;
                                        or ax, 0x20;
                                        mov word ptr es:[bx + 2], ax;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0x58B4
                                        les bx, ptr [bp + 6];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0x587F
                                call 0x5739;
                                // Block 0x5882
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                les bx, ptr [bp + 6];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x5ff1;
                                // Block 0x5899
                                $1 += $2;
                                or ax, ax;
                                if (a != b) {  // jne 0x58d3
                                    // Block 0x58D3
                                    cmp byte ptr [0x8790], 0xd;
                                    if (a != b) {  // jne 0x58e5
                                        // Block 0x58E5
                                        les bx, ptr [bp + 6];
                                        and word ptr es:[bx + 2], 0xffdf;
                                        mov al, byte ptr [0x8790];
                                    } else {
                                        // Block 0x58DA
                                        les bx, ptr [bp + 6];
                                        test word ptr es:[bx + 2], 0x40;
                                        if (a == b) {  // je 0x5874
                                            // Jump to block at 0x5874
                                        } else {
                                            // Block 0x58E5
                                            les bx, ptr [bp + 6];
                                            and word ptr es:[bx + 2], 0xffdf;
                                            mov al, byte ptr [0x8790];
                                        }
                                    }
                                } else {
                                    // Block 0x58A0
                                    les bx, ptr [bp + 6];
                                    $1 = $2;
                                    cwde ;
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e84;
                                    // Block 0x58AE
                                    $1 = pop();
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x58bf
                                        // Block 0x58BF
                                        les bx, ptr [bp + 6];
                                        $1 = $2;
                                        and ax, 0xfe7f;
                                        or ax, 0x20;
                                        mov word ptr es:[bx + 2], ax;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0x58B4
                                        les bx, ptr [bp + 6];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            }
                        } else {
                            // Block 0x5865
                            push($1);
                            push($1);
                            call 0x5777;
                            // Block 0x586C
                            or ax, ax;
                            if (a == b) {  // je 0x5822
                                // Block 0x5822
                                les bx, ptr [bp + 6];
                                $1--;
                                $1 = $2;
                                $1 = $2;
                                $1++;
                                $1 = $2;
                                $1 = $2;
                                jmp 0x58f0;
                                // Block 0x58F0
                                mov ah, 0;
                            } else {
                                // Block 0x5870
                                goto $1;
                                jmp 0x5822;
                                // Block 0x5822
                                les bx, ptr [bp + 6];
                                $1--;
                                $1 = $2;
                                $1 = $2;
                                $1++;
                                $1 = $2;
                                $1 = $2;
                                jmp 0x58f0;
                                // Block 0x58F0
                                mov ah, 0;
                            }
                        }
                    }
                }
            }
        } else {
            // Block 0x5822
            les bx, ptr [bp + 6];
            $1--;
            $1 = $2;
            $1 = $2;
            $1++;
            $1 = $2;
            $1 = $2;
            jmp 0x58f0;
            // Block 0x58F0
            mov ah, 0;
        }
    } else {
        // Block 0x5813
        $1 = $2;
        jmp 0x58f2;
        // Block 0x58F2
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_5777(); // Performs arithmetic calculations
    sub_5739(); // Performs arithmetic calculations
    sub_5FF1(); // Manipulates strings or memory blocks and performs calculations
    sub_4E84(); // Performs arithmetic calculations
    sub_5807(); // Performs arithmetic calculations
    sub_2B71(); // Performs DOS operations and performs calculations
    sub_2B2E(); // Performs DOS operations
    sub_6661(); // Unknown function purpose
    sub_4302(); // Unknown function purpose
    sub_65F7(); // Manipulates strings or memory blocks and performs calculations
    sub_2F5F(); // Manipulates strings or memory blocks and performs calculations
    sub_2F5F(); // Manipulates strings or memory blocks and performs calculations
    sub_2F5F(); // Manipulates strings or memory blocks and performs calculations
}

void sub_59FF(int, int) {
    // Purpose: Manipulates strings or memory blocks

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x59FF
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    shr cx, 1;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    if (a >= b (unsigned)) {  // jae 0x5a17
        // Block 0x5A17
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x5A16
        movsb byte ptr es:[di], byte ptr [si];
    }
}

void sub_5A23(int) {
    // Purpose: Performs DOS operations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x5A23
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    INT_21_AH3C();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x5a36
        // Block 0x5A36
        push($1);
        call 0x2d44;
        // Block 0x5A3A
        $1 = pop();
        return;  // ret 6
    } else {
        // Block 0x5A34
        jmp 0x5a3a;
        // Block 0x5A3A
        $1 = pop();
        return;  // ret 6
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
}

void sub_5A3E(int) {
    // Purpose: Writes data to a file and performs calculations

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x5A3E
    push($1);
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    DOS_WriteFile();  // int 0x21
    $1 = pop();
    return;  // ret 2
}

void sub_5A50(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 12

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x5A50
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test si, 0xc000;
    if (a != b) {  // jne 0x5a6c
        // Block 0x5A6C
        $1 = 0;
        push($1);
        push($1);
        push($1);
        nop ;
        push($1);
        call 0x4e21;
        // Block 0x5A7A
        $1 += $2;
        *($1) = $2;
        test si, 0x100;
        if (a != b) {  // jne 0x5a89
            // Block 0x5A89
            and di, word ptr [0x74fc];
            $1 = $2;
            test ax, 0x180;
            if (a != b) {  // jne 0x5a9b
                // Block 0x5A9B
                cmp word ptr [bp - 2], -1;
                if (a != b) {  // jne 0x5ac4
                    // Block 0x5AC4
                    test si, 0x400;
                    if (a == b) {  // je 0x5b09
                        // Block 0x5B09
                        push($1);
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x5bbf;
                        // Block 0x5B15
                        $1 += $2;
                        $1 = $2;
                        or ax, ax;
                        if (a < b) {  // jl 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B1E
                            $1 = 0;
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x47b4;
                            // Block 0x5B27
                            $1 = pop();
                            $1 = pop();
                            *($1) = $2;
                            test ax, 0x80;
                            if (a == b) {  // je 0x5b54
                                // Block 0x5B54
                                test si, 0x200;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B5A
                                    push($1);
                                    call 0x5a3e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B31
                                or si, 0x2000;
                                test si, 0x8000;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B3B
                                    and ax, 0xff;
                                    or ax, 0x20;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x47b4;
                                    // Block 0x5B4F
                                    $1 += $2;
                                    jmp 0x5b5e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x5ACA
                        $1 = $2;
                        push($1);
                        jmp 0x5aac;
                        // Block 0x5AAC
                        call 0x2d44;
                        // Block 0x5AAF
                        jmp 0x5bb9;
                        // Block 0x5BB9
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0x5AA1
                    cmp word ptr [0x74fe], 2;
                    if (a == b) {  // je 0x5ab2
                        // Block 0x5AB2
                        test di, 0x80;
                        if (a == b) {  // je 0x5abc
                            // Block 0x5ABC
                            mov ax, 1;
                        } else {
                            // Block 0x5AB8
                            $1 = 0;
                            jmp 0x5abf;
                            // Block 0x5ABF
                            *($1) = $2;
                            jmp 0x5ad0;
                            // Block 0x5AD0
                            test si, 0xf0;
                            if (a == b) {  // je 0x5af4
                                // Block 0x5AF4
                                push($1);
                                push($1);
                                push($1);
                                call 0x5a23;
                                // Block 0x5B00
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B06
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            } else {
                                // Block 0x5AD6
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                call 0x5a23;
                                // Block 0x5AE2
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5aeb
                                    // Block 0x5AEB
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e66;
                                    // Block 0x5AF1
                                    $1 = pop();
                                    jmp 0x5b09;
                                    // Block 0x5B09
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x5bbf;
                                    // Block 0x5B15
                                    $1 += $2;
                                    $1 = $2;
                                    or ax, ax;
                                    if (a < b) {  // jl 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B1E
                                        $1 = 0;
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x47b4;
                                        // Block 0x5B27
                                        $1 = pop();
                                        $1 = pop();
                                        *($1) = $2;
                                        test ax, 0x80;
                                        if (a == b) {  // je 0x5b54
                                            // Block 0x5B54
                                            test si, 0x200;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B5A
                                                push($1);
                                                call 0x5a3e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B31
                                            or si, 0x2000;
                                            test si, 0x8000;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B3B
                                                and ax, 0xff;
                                                or ax, 0x20;
                                                $1 = 0;
                                                push($1);
                                                push($1);
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x47b4;
                                                // Block 0x5B4F
                                                $1 += $2;
                                                jmp 0x5b5e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5AE8
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            }
                        }
                    } else {
                        // Block 0x5AA8
                        push word ptr [0x74fe];
                    }
                }
            } else {
                // Block 0x5A94
                $1 = $2;
                push($1);
                call 0x2d44;
                // Block 0x5A9B
                cmp word ptr [bp - 2], -1;
                if (a != b) {  // jne 0x5ac4
                    // Block 0x5AC4
                    test si, 0x400;
                    if (a == b) {  // je 0x5b09
                        // Block 0x5B09
                        push($1);
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x5bbf;
                        // Block 0x5B15
                        $1 += $2;
                        $1 = $2;
                        or ax, ax;
                        if (a < b) {  // jl 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B1E
                            $1 = 0;
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x47b4;
                            // Block 0x5B27
                            $1 = pop();
                            $1 = pop();
                            *($1) = $2;
                            test ax, 0x80;
                            if (a == b) {  // je 0x5b54
                                // Block 0x5B54
                                test si, 0x200;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B5A
                                    push($1);
                                    call 0x5a3e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B31
                                or si, 0x2000;
                                test si, 0x8000;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B3B
                                    and ax, 0xff;
                                    or ax, 0x20;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x47b4;
                                    // Block 0x5B4F
                                    $1 += $2;
                                    jmp 0x5b5e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x5ACA
                        $1 = $2;
                        push($1);
                        jmp 0x5aac;
                        // Block 0x5AAC
                        call 0x2d44;
                        // Block 0x5AAF
                        jmp 0x5bb9;
                        // Block 0x5BB9
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0x5AA1
                    cmp word ptr [0x74fe], 2;
                    if (a == b) {  // je 0x5ab2
                        // Block 0x5AB2
                        test di, 0x80;
                        if (a == b) {  // je 0x5abc
                            // Block 0x5ABC
                            mov ax, 1;
                        } else {
                            // Block 0x5AB8
                            $1 = 0;
                            jmp 0x5abf;
                            // Block 0x5ABF
                            *($1) = $2;
                            jmp 0x5ad0;
                            // Block 0x5AD0
                            test si, 0xf0;
                            if (a == b) {  // je 0x5af4
                                // Block 0x5AF4
                                push($1);
                                push($1);
                                push($1);
                                call 0x5a23;
                                // Block 0x5B00
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B06
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            } else {
                                // Block 0x5AD6
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                call 0x5a23;
                                // Block 0x5AE2
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5aeb
                                    // Block 0x5AEB
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e66;
                                    // Block 0x5AF1
                                    $1 = pop();
                                    jmp 0x5b09;
                                    // Block 0x5B09
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x5bbf;
                                    // Block 0x5B15
                                    $1 += $2;
                                    $1 = $2;
                                    or ax, ax;
                                    if (a < b) {  // jl 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B1E
                                        $1 = 0;
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x47b4;
                                        // Block 0x5B27
                                        $1 = pop();
                                        $1 = pop();
                                        *($1) = $2;
                                        test ax, 0x80;
                                        if (a == b) {  // je 0x5b54
                                            // Block 0x5B54
                                            test si, 0x200;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B5A
                                                push($1);
                                                call 0x5a3e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B31
                                            or si, 0x2000;
                                            test si, 0x8000;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B3B
                                                and ax, 0xff;
                                                or ax, 0x20;
                                                $1 = 0;
                                                push($1);
                                                push($1);
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x47b4;
                                                // Block 0x5B4F
                                                $1 += $2;
                                                jmp 0x5b5e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5AE8
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            }
                        }
                    } else {
                        // Block 0x5AA8
                        push word ptr [0x74fe];
                    }
                }
            }
        } else {
            // Block 0x5A86
            jmp 0x5b09;
            // Block 0x5B09
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x5bbf;
            // Block 0x5B15
            $1 += $2;
            $1 = $2;
            or ax, ax;
            if (a < b) {  // jl 0x5b84
                // Block 0x5B84
                or di, di;
                if (a < b) {  // jl 0x5bb7
                    // Block 0x5BB7
                    mov ax, di;
                } else {
                    // Block 0x5B88
                    test si, 0x300;
                    if (a == b) {  // je 0x5b93
                        // Block 0x5B93
                        xor ax, ax;
                    } else {
                        // Block 0x5B8E
                        $1 = $2;
                        jmp 0x5b95;
                        // Block 0x5B95
                        $1 = $2;
                        and dx, 0xf8ff;
                        or dx, ax;
                        push($1);
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5ba9
                            // Block 0x5BA9
                            mov ax, 0x100;
                        } else {
                            // Block 0x5BA5
                            $1 = 0;
                            jmp 0x5bac;
                            // Block 0x5BAC
                            $1 = pop();
                            or dx, ax;
                            $1 = $2;
                            shl bx, 1;
                            mov word ptr [bx + 0x74d2], dx;
                        }
                    }
                }
            } else {
                // Block 0x5B1E
                $1 = 0;
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x47b4;
                // Block 0x5B27
                $1 = pop();
                $1 = pop();
                *($1) = $2;
                test ax, 0x80;
                if (a == b) {  // je 0x5b54
                    // Block 0x5B54
                    test si, 0x200;
                    if (a == b) {  // je 0x5b5e
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    } else {
                        // Block 0x5B5A
                        push($1);
                        call 0x5a3e;
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x5B31
                    or si, 0x2000;
                    test si, 0x8000;
                    if (a == b) {  // je 0x5b5e
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    } else {
                        // Block 0x5B3B
                        and ax, 0xff;
                        or ax, 0x20;
                        $1 = 0;
                        push($1);
                        push($1);
                        $1 = $2;
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x47b4;
                        // Block 0x5B4F
                        $1 += $2;
                        jmp 0x5b5e;
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x5A64
        $1 = $2;
        and ax, 0xc000;
        or si, ax;
    }

    // Function calls:
    sub_4E21(); // Performs DOS operations
    sub_2D44(); // Unknown function purpose
    sub_2D44(); // Unknown function purpose
    sub_5A23(); // Performs DOS operations
    sub_4E66(); // Closes a file
    sub_5A23(); // Performs DOS operations
    sub_5BBF(); // Opens a file and performs calculations
    sub_47B4(); // Performs DOS operations
    sub_47B4(); // Performs DOS operations
    sub_5A3E(); // Writes data to a file and performs calculations
    sub_4E21(); // Performs DOS operations
}

void sub_5BBF(int) {
    // Purpose: Opens a file and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x5BBF
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    test cx, 2;
    if (a != b) {  // jne 0x5bda
        // Block 0x5BDA
        push($1);
        lds dx, ptr [bp + 6];
        $1 = $2;
        and cl, byte ptr [bp + 0xa];
        or al, cl;
        $1 = $2;
        DOS_OpenFile();  // int 0x21
        $1 = pop();
        if (a < b (unsigned)) {  // jb 0x5c06
            // Block 0x5C06
            push($1);
            call 0x2d44;
            // Block 0x5C0A
            $1 = $2;
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x5BEC
            *($1) = $2;
            $1 = $2;
            and ax, 0xb8ff;
            or ax, 0x8000;
            $1 = $2;
            shl bx, 1;
            *($1) = $2;
            $1 = $2;
            jmp 0x5c0a;
            // Block 0x5C0A
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x5BD0
        $1 = $2;
        test cx, 4;
        if (a != b) {  // jne 0x5bda
            // Block 0x5BDA
            push($1);
            lds dx, ptr [bp + 6];
            $1 = $2;
            and cl, byte ptr [bp + 0xa];
            or al, cl;
            $1 = $2;
            DOS_OpenFile();  // int 0x21
            $1 = pop();
            if (a < b (unsigned)) {  // jb 0x5c06
                // Block 0x5C06
                push($1);
                call 0x2d44;
                // Block 0x5C0A
                $1 = $2;
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0x5BEC
                *($1) = $2;
                $1 = $2;
                and ax, 0xb8ff;
                or ax, 0x8000;
                $1 = $2;
                shl bx, 1;
                *($1) = $2;
                $1 = $2;
                jmp 0x5c0a;
                // Block 0x5C0A
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        } else {
            // Block 0x5BD8
            mov al, 0;
        }
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_3935(); // Performs arithmetic calculations
}

void sub_5C29(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0x5C29
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1--;
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    call 0x5c45;
    // Block 0x5C40
    $1 += $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_5C45(); // Performs arithmetic calculations
}

void sub_5C45(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 19

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x5C45
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 8];
    cmp word ptr es:[bx], -1;
    if (a >= b) {  // jge 0x5cac
        // Block 0x5CAC
        les bx, ptr [bp + 8];
        test word ptr es:[bx + 2], 0x90;
        if (a != b) {  // jne 0x5cbf
            // Block 0x5CBF
            les bx, ptr [bp + 8];
            or word ptr es:[bx + 2], 0x10;
            jmp 0x5ca3;
            // Block 0x5CA3
            $1 = $2;
            goto $1;
            jmp 0x5dd2;
            // Block 0x5DD2
            $1 = $2;
            mov ah, 0;
        } else {
            // Block 0x5CB7
            test word ptr es:[bx + 2], 2;
            if (a != b) {  // jne 0x5cc9
                // Block 0x5CC9
                les bx, ptr [bp + 8];
                or word ptr es:[bx + 2], 0x100;
                cmp word ptr es:[bx + 6], 0;
                if (a == b) {  // je 0x5d48
                    // Block 0x5D48
                    les bx, ptr [bp + 8];
                    $1 = $2;
                    cwde ;
                    shl ax, 1;
                    $1 = $2;
                    test word ptr [bx + 0x74d2], 0x800;
                    if (a == b) {  // je 0x5d77
                        // Block 0x5D77
                        cmp byte ptr [0x8792], 0xa;
                        if (a != b) {  // jne 0x5da5
                            // Block 0x5DA5
                            $1 = $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            push($1);
                            les bx, ptr [bp + 8];
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x68ed;
                            // Block 0x5DBC
                            $1 += $2;
                            // Compare $1 with $2
                            if (a == b) {  // je 0x5dd2
                                // Block 0x5DD2
                                $1 = $2;
                                mov ah, 0;
                            } else {
                                // Block 0x5DC4
                                les bx, ptr [bp + 8];
                                test word ptr es:[bx + 2], 0x200;
                                if (a != b) {  // jne 0x5dd2
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                } else {
                                    // Block 0x5DCF
                                    jmp 0x5cbf;
                                    // Block 0x5CBF
                                    les bx, ptr [bp + 8];
                                    or word ptr es:[bx + 2], 0x10;
                                    jmp 0x5ca3;
                                    // Block 0x5CA3
                                    $1 = $2;
                                    goto $1;
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                }
                            }
                        } else {
                            // Block 0x5D7E
                            les bx, ptr [bp + 8];
                            test word ptr es:[bx + 2], 0x40;
                            if (a != b) {  // jne 0x5da5
                                // Block 0x5DA5
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                les bx, ptr [bp + 8];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x68ed;
                                // Block 0x5DBC
                                $1 += $2;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x5dd2
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                } else {
                                    // Block 0x5DC4
                                    les bx, ptr [bp + 8];
                                    test word ptr es:[bx + 2], 0x200;
                                    if (a != b) {  // jne 0x5dd2
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5DCF
                                        jmp 0x5cbf;
                                        // Block 0x5CBF
                                        les bx, ptr [bp + 8];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5ca3;
                                        // Block 0x5CA3
                                        $1 = $2;
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                }
                            } else {
                                // Block 0x5D89
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x68ed;
                                // Block 0x5D9D
                                $1 += $2;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x5dc4
                                    // Block 0x5DC4
                                    les bx, ptr [bp + 8];
                                    test word ptr es:[bx + 2], 0x200;
                                    if (a != b) {  // jne 0x5dd2
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5DCF
                                        jmp 0x5cbf;
                                        // Block 0x5CBF
                                        les bx, ptr [bp + 8];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5ca3;
                                        // Block 0x5CA3
                                        $1 = $2;
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                } else {
                                    // Block 0x5DA5
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    les bx, ptr [bp + 8];
                                    $1 = $2;
                                    cwde ;
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x68ed;
                                    // Block 0x5DBC
                                    $1 += $2;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x5dd2
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5DC4
                                        les bx, ptr [bp + 8];
                                        test word ptr es:[bx + 2], 0x200;
                                        if (a != b) {  // jne 0x5dd2
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        } else {
                                            // Block 0x5DCF
                                            jmp 0x5cbf;
                                            // Block 0x5CBF
                                            les bx, ptr [bp + 8];
                                            or word ptr es:[bx + 2], 0x10;
                                            jmp 0x5ca3;
                                            // Block 0x5CA3
                                            $1 = $2;
                                            goto $1;
                                            jmp 0x5dd2;
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x5D5C
                        $1 = $2;
                        push($1);
                        $1 = 0;
                        $1 = 0;
                        push($1);
                        push($1);
                        $1 = $2;
                        $1 = $2;
                        cwde ;
                        push($1);
                        nop ;
                        push($1);
                        call 0x3001;
                        // Block 0x5D74
                        add sp, 8;
                    }
                } else {
                    // Block 0x5CD9
                    cmp word ptr es:[bx], 0;
                    if (a == b) {  // je 0x5cee
                        // Block 0x5CEE
                        les bx, ptr [bp + 8];
                        $1 = $2;
                        neg ax;
                        mov word ptr es:[bx], ax;
                        $1 = $2;
                        $1 = $2;
                        $1++;
                        $1 = $2;
                        $1 = $2;
                        mov byte ptr es:[si], dl;
                        $1 = $2;
                        test word ptr es:[bx + 2], 8;
                        if (a != b) {  // jne 0x5d1d
                            // Block 0x5D1D
                            cmp byte ptr [0x8792], 0xa;
                            if (a == b) {  // je 0x5d2e
                                // Block 0x5D2E
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x4fb3;
                                // Block 0x5D39
                                $1 = pop();
                                $1 = pop();
                                or ax, ax;
                                if (a != b) {  // jne 0x5d42
                                    // Block 0x5D42
                                    goto $1;
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                } else {
                                    // Block 0x5D3F
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                }
                            } else {
                                // Block 0x5D24
                                cmp byte ptr [0x8792], 0xd;
                                if (a == b) {  // je 0x5d2e
                                    // Block 0x5D2E
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4fb3;
                                    // Block 0x5D39
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a != b) {  // jne 0x5d42
                                        // Block 0x5D42
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5D3F
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                } else {
                                    // Block 0x5D2B
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                }
                            }
                        } else {
                            // Block 0x5D1A
                            jmp 0x5dd2;
                            // Block 0x5DD2
                            $1 = $2;
                            mov ah, 0;
                        }
                    } else {
                        // Block 0x5CDF
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x4fb3;
                        // Block 0x5CE8
                        $1 = pop();
                        $1 = pop();
                        or ax, ax;
                        if (a != b) {  // jne 0x5ca3
                            // Block 0x5CA3
                            $1 = $2;
                            goto $1;
                            jmp 0x5dd2;
                            // Block 0x5DD2
                            $1 = $2;
                            mov ah, 0;
                        } else {
                            // Block 0x5CEE
                            les bx, ptr [bp + 8];
                            $1 = $2;
                            neg ax;
                            mov word ptr es:[bx], ax;
                            $1 = $2;
                            $1 = $2;
                            $1++;
                            $1 = $2;
                            $1 = $2;
                            mov byte ptr es:[si], dl;
                            $1 = $2;
                            test word ptr es:[bx + 2], 8;
                            if (a != b) {  // jne 0x5d1d
                                // Block 0x5D1D
                                cmp byte ptr [0x8792], 0xa;
                                if (a == b) {  // je 0x5d2e
                                    // Block 0x5D2E
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4fb3;
                                    // Block 0x5D39
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a != b) {  // jne 0x5d42
                                        // Block 0x5D42
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5D3F
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                } else {
                                    // Block 0x5D24
                                    cmp byte ptr [0x8792], 0xd;
                                    if (a == b) {  // je 0x5d2e
                                        // Block 0x5D2E
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x4fb3;
                                        // Block 0x5D39
                                        $1 = pop();
                                        $1 = pop();
                                        or ax, ax;
                                        if (a != b) {  // jne 0x5d42
                                            // Block 0x5D42
                                            goto $1;
                                            jmp 0x5dd2;
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        } else {
                                            // Block 0x5D3F
                                            jmp 0x5dd2;
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        }
                                    } else {
                                        // Block 0x5D2B
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                }
                            } else {
                                // Block 0x5D1A
                                jmp 0x5dd2;
                                // Block 0x5DD2
                                $1 = $2;
                                mov ah, 0;
                            }
                        }
                    }
                }
            } else {
                // Block 0x5CBF
                les bx, ptr [bp + 8];
                or word ptr es:[bx + 2], 0x10;
                jmp 0x5ca3;
                // Block 0x5CA3
                $1 = $2;
                goto $1;
                jmp 0x5dd2;
                // Block 0x5DD2
                $1 = $2;
                mov ah, 0;
            }
        }
    } else {
        // Block 0x5C58
        $1++;
        $1 = $2;
        $1 = $2;
        $1++;
        $1 = $2;
        $1 = $2;
        mov byte ptr es:[si], dl;
        $1 = $2;
        test word ptr es:[bx + 2], 8;
        if (a != b) {  // jne 0x5c7e
            // Block 0x5C7E
            cmp byte ptr [0x8792], 0xa;
            if (a == b) {  // je 0x5c8f
                // Block 0x5C8F
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x4fb3;
                // Block 0x5C9A
                $1 = pop();
                $1 = pop();
                or ax, ax;
                if (a != b) {  // jne 0x5ca3
                    // Block 0x5CA3
                    $1 = $2;
                    goto $1;
                    jmp 0x5dd2;
                    // Block 0x5DD2
                    $1 = $2;
                    mov ah, 0;
                } else {
                    // Block 0x5CA0
                    jmp 0x5dd2;
                    // Block 0x5DD2
                    $1 = $2;
                    mov ah, 0;
                }
            } else {
                // Block 0x5C85
                cmp byte ptr [0x8792], 0xd;
                if (a == b) {  // je 0x5c8f
                    // Block 0x5C8F
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x4fb3;
                    // Block 0x5C9A
                    $1 = pop();
                    $1 = pop();
                    or ax, ax;
                    if (a != b) {  // jne 0x5ca3
                        // Block 0x5CA3
                        $1 = $2;
                        goto $1;
                        jmp 0x5dd2;
                        // Block 0x5DD2
                        $1 = $2;
                        mov ah, 0;
                    } else {
                        // Block 0x5CA0
                        jmp 0x5dd2;
                        // Block 0x5DD2
                        $1 = $2;
                        mov ah, 0;
                    }
                } else {
                    // Block 0x5C8C
                    jmp 0x5dd2;
                    // Block 0x5DD2
                    $1 = $2;
                    mov ah, 0;
                }
            }
        } else {
            // Block 0x5C7B
            jmp 0x5dd2;
            // Block 0x5DD2
            $1 = $2;
            mov ah, 0;
        }
    }

    // Function calls:
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_3001(); // Moves file pointer
    sub_68ED(); // Writes data to a file and performs calculations
    sub_68ED(); // Writes data to a file and performs calculations
    sub_5C45(); // Performs arithmetic calculations
}

void sub_5DEE(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 18

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 loops
    // - 20 if statements

    // Block 0x5DEE
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 8;
    if (a == b) {  // je 0x5e35
        // Block 0x5E35
        les bx, ptr [bp + 4];
        test word ptr es:[bx + 2], 0x40;
        if (a != b) {  // jne 0x5e43
            // Block 0x5E43
            cmp word ptr es:[bx + 6], 0;
            if (a != b) {  // jne 0x5e4d
                // Block 0x5E4D
                cmp word ptr es:[bx + 6], di;
                if (a >= b (unsigned)) {  // jae 0x5ebc
                    // Block 0x5EBC
                    les bx, ptr [bp + 4];
                    $1 = $2;
                    $1 += $2;
                    if (a < b) {  // jl 0x5eec
                        // Block 0x5EEC
                        push($1);
                        push($1);
                        push($1);
                        les bx, ptr [bp + 4];
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x59ff;
                        // Block 0x5F03
                        $1 += $2;
                        les bx, ptr [bp + 4];
                        $1 = $2;
                        $1 += $2;
                        mov word ptr es:[bx], ax;
                        add word ptr es:[bx + 0xc], di;
                        jmp 0x5fe6;
                        // Block 0x5FE6
                        mov ax, word ptr [bp - 2];
                    } else {
                        // Block 0x5EC6
                        cmp word ptr es:[bx], 0;
                        if (a != b) {  // jne 0x5ed8
                            // Block 0x5ED8
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x4fb3;
                            // Block 0x5EE3
                            $1 = pop();
                            $1 = pop();
                            or ax, ax;
                            if (a == b) {  // je 0x5eec
                                // Block 0x5EEC
                                push($1);
                                push($1);
                                push($1);
                                les bx, ptr [bp + 4];
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x59ff;
                                // Block 0x5F03
                                $1 += $2;
                                les bx, ptr [bp + 4];
                                $1 = $2;
                                $1 += $2;
                                mov word ptr es:[bx], ax;
                                add word ptr es:[bx + 0xc], di;
                                jmp 0x5fe6;
                                // Block 0x5FE6
                                mov ax, word ptr [bp - 2];
                            } else {
                                // Block 0x5EE9
                                jmp 0x5e26;
                                // Block 0x5E26
                                $1 = 0;
                                jmp 0x5fe9;
                                // Block 0x5FE9
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // ret 0xa
                            }
                        } else {
                            // Block 0x5ECC
                            $1 = $2;
                            $1 -= $2;
                            mov word ptr es:[bx], ax;
                            jmp 0x5eec;
                            // Block 0x5EEC
                            push($1);
                            push($1);
                            push($1);
                            les bx, ptr [bp + 4];
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x59ff;
                            // Block 0x5F03
                            $1 += $2;
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            $1 += $2;
                            mov word ptr es:[bx], ax;
                            add word ptr es:[bx + 0xc], di;
                            jmp 0x5fe6;
                            // Block 0x5FE6
                            mov ax, word ptr [bp - 2];
                        }
                    }
                } else {
                    // Block 0x5E53
                    cmp word ptr es:[bx], 0;
                    if (a == b) {  // je 0x5e68
                        // Block 0x5E68
                        les bx, ptr [bp + 4];
                        $1 = $2;
                        cwde ;
                        shl ax, 1;
                        $1 = $2;
                        test word ptr [bx + 0x74d2], 0x800;
                        if (a == b) {  // je 0x5e97
                            // Block 0x5E97
                            push($1);
                            push($1);
                            push($1);
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x68ed;
                            // Block 0x5EAC
                            $1 += $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x5eb6
                                // Block 0x5EB6
                                goto $1;
                                jmp 0x5fe6;
                                // Block 0x5FE6
                                mov ax, word ptr [bp - 2];
                            } else {
                                // Block 0x5EB3
                                jmp 0x5fe6;
                                // Block 0x5FE6
                                mov ax, word ptr [bp - 2];
                            }
                        } else {
                            // Block 0x5E7C
                            $1 = $2;
                            push($1);
                            $1 = 0;
                            $1 = 0;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x3001;
                            // Block 0x5E94
                            add sp, 8;
                        }
                    } else {
                        // Block 0x5E59
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x4fb3;
                        // Block 0x5E62
                        $1 = pop();
                        $1 = pop();
                        or ax, ax;
                        if (a != b) {  // jne 0x5e26
                            // Block 0x5E26
                            $1 = 0;
                            jmp 0x5fe9;
                            // Block 0x5FE9
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 0xa
                        } else {
                            // Block 0x5E68
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            cwde ;
                            shl ax, 1;
                            $1 = $2;
                            test word ptr [bx + 0x74d2], 0x800;
                            if (a == b) {  // je 0x5e97
                                // Block 0x5E97
                                push($1);
                                push($1);
                                push($1);
                                les bx, ptr [bp + 4];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x68ed;
                                // Block 0x5EAC
                                $1 += $2;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x5eb6
                                    // Block 0x5EB6
                                    goto $1;
                                    jmp 0x5fe6;
                                    // Block 0x5FE6
                                    mov ax, word ptr [bp - 2];
                                } else {
                                    // Block 0x5EB3
                                    jmp 0x5fe6;
                                    // Block 0x5FE6
                                    mov ax, word ptr [bp - 2];
                                }
                            } else {
                                // Block 0x5E7C
                                $1 = $2;
                                push($1);
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x3001;
                                // Block 0x5E94
                                add sp, 8;
                            }
                        }
                    }
                }
            } else {
                // Block 0x5E4A
                jmp 0x5f18;
                // Block 0x5F18
                les bx, ptr [bp + 4];
                $1 = $2;
                cwde ;
                shl ax, 1;
                $1 = $2;
                test word ptr [bx + 0x74d2], 0x800;
                if (a == b) {  // je 0x5f47
                    // Block 0x5F47
                    push($1);
                    push($1);
                    push($1);
                    les bx, ptr [bp + 4];
                    $1 = $2;
                    cwde ;
                    push($1);
                    nop ;
                    push($1);
                    call 0x68ed;
                    // Block 0x5F5C
                    $1 += $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x5f66
                        // Block 0x5F66
                        goto $1;
                        jmp 0x5fe6;
                        // Block 0x5FE6
                        mov ax, word ptr [bp - 2];
                    } else {
                        // Block 0x5F63
                        jmp 0x5fe6;
                        // Block 0x5FE6
                        mov ax, word ptr [bp - 2];
                    }
                } else {
                    // Block 0x5F2C
                    $1 = $2;
                    push($1);
                    $1 = 0;
                    $1 = 0;
                    push($1);
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    cwde ;
                    push($1);
                    nop ;
                    push($1);
                    call 0x3001;
                    // Block 0x5F44
                    add sp, 8;
                }
            }
        } else {
            // Block 0x5E40
            jmp 0x5f6b;
            // Block 0x5F6B
            les bx, ptr [bp + 4];
            cmp word ptr es:[bx + 6], 0;
            if (a == b) {  // je 0x5fc7
                // Block 0x5FC7
                push($1);
                push($1);
                push($1);
                les bx, ptr [bp + 4];
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x679c;
                // Block 0x5FDC
                $1 += $2;
                // Compare $1 with $2
                if (a == b) {  // je 0x5fe6
                    // Block 0x5FE6
                    mov ax, word ptr [bp - 2];
                } else {
                    // Block 0x5FE3
                    jmp 0x5e26;
                    // Block 0x5E26
                    $1 = 0;
                    jmp 0x5fe9;
                    // Block 0x5FE9
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 0xa
                }
            } else {
                // Block 0x5F75
                jmp 0x5fbe;
                // Block 0x5FBE
                $1 = $2;
                $1--;
                or ax, ax;
                if (a != b) {  // jne 0x5f77
                    // Block 0x5F77
                    les bx, ptr [bp + 4];
                    $1++;
                    if (a >= b) {  // jge 0x5f9f
                        // Block 0x5F9F
                        push($1);
                        push($1);
                        les bx, ptr [bp + 0xa];
                        $1++;
                        $1 = $2;
                        push($1);
                        push($1);
                        call 0x5c29;
                        // Block 0x5FB3
                        add sp, 6;
                    } else {
                        // Block 0x5F7F
                        $1 = $2;
                        $1 = $2;
                        $1++;
                        les bx, ptr [bp + 0xa];
                        $1++;
                        $1 = $2;
                        $1 = $2;
                        mov byte ptr es:[si], dl;
                        $1 = $2;
                        $1 = $2;
                        jmp 0x5fb6;
                        // Block 0x5FB6
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x5fbe
                            // Jump to block at 0x5FBE
                        } else {
                            // Block 0x5FBB
                            jmp 0x5e26;
                            // Block 0x5E26
                            $1 = 0;
                            jmp 0x5fe9;
                            // Block 0x5FE9
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 0xa
                        }
                    }
                } else {
                    // Block 0x5FC5
                    jmp 0x5fe6;
                    // Block 0x5FE6
                    mov ax, word ptr [bp - 2];
                }
            }
        }
    } else {
        // Block 0x5E07
        jmp 0x5e2b;
        // Block 0x5E2B
        $1 = $2;
        $1--;
        or ax, ax;
        if (a != b) {  // jne 0x5e09
            // Block 0x5E09
            push($1);
            push($1);
            les bx, ptr [bp + 0xa];
            $1++;
            $1 = $2;
            cwde ;
            push($1);
            push($1);
            call 0x5c45;
            // Block 0x5E1E
            $1 += $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x5e2b
                // Jump to block at 0x5E2B
            } else {
                // Block 0x5E26
                $1 = 0;
                jmp 0x5fe9;
                // Block 0x5FE9
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // ret 0xa
            }
        } else {
            // Block 0x5E32
            jmp 0x5fe6;
            // Block 0x5FE6
            mov ax, word ptr [bp - 2];
        }
    }

    // Function calls:
    sub_5C45(); // Performs arithmetic calculations
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_3001(); // Moves file pointer
    sub_68ED(); // Writes data to a file and performs calculations
    sub_4FB3(); // Performs DOS operations and performs calculations
    sub_59FF(); // Manipulates strings or memory blocks
    sub_3001(); // Moves file pointer
    sub_68ED(); // Writes data to a file and performs calculations
    sub_5C29(); // Performs arithmetic calculations
    sub_679C(); // Performs arithmetic calculations
}

void sub_5FF1(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 loops
    // - 8 if statements

    // Block 0x5FF1
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x600c
        // Block 0x600C
        $1 = $2;
        $1++;
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x6022
            // Block 0x6022
            $1 = 0;
            jmp 0x60bc;
            // Block 0x60BC
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x6015
            $1 = $2;
            shl bx, 1;
            test word ptr [bx + 0x74d2], 0x200;
            if (a == b) {  // je 0x6027
                // Block 0x6027
                push($1);
                push($1);
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x3118;
                // Block 0x6038
                $1 += $2;
                *($1) = $2;
                $1++;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x6051
                    // Block 0x6051
                    $1 = $2;
                    jmp 0x60bc;
                    // Block 0x60BC
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x6044
                    $1 = $2;
                    shl bx, 1;
                    test word ptr [bx + 0x74d2], 0x4000;
                    if (a != b) {  // jne 0x6056
                        // Block 0x6056
                        $1 = $2;
                        les si, ptr [bp + 8];
                        $1 = $2;
                        $1 = $2;
                        cld ;
                        lodsb al, byte ptr es:[si];
                        // Compare $1 with $2
                        if (a == b) {  // je 0x6097
                            // Block 0x6097
                            push($1);
                            $1 = $2;
                            push($1);
                            neg cx;
                            sbb ax, ax;
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x3001;
                            // Block 0x60AA
                            $1 += $2;
                            $1 = $2;
                            shl bx, 1;
                            or word ptr [bx + 0x74d2], 0x200;
                            pop bx;
                        } else {
                            // Block 0x6067
                            // Compare $1 with $2
                            if (a == b) {  // je 0x6070
                                // Block 0x6070
                                loop 0x6061;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lea ax, [bp - 3];
                                push($1);
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x3118;
                                // Block 0x6085
                                $1 += $2;
                                $1 = pop();
                                $1 = pop();
                                cld ;
                                $1 = $2;
                                stosb byte ptr es:[di], al;
                            } else {
                                // Block 0x606B
                                stosb byte ptr es:[di], al;
                                loop 0x6061;
                                jmp 0x608f;
                                // Block 0x608F
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x6095
                                    // Block 0x6095
                                    jmp 0x60b9;
                                    // Block 0x60B9
                                    $1 -= $2;
                                    xchg di, ax;
                                } else {
                                    // Block 0x6093
                                    jmp 0x6027;
                                }
                            }
                        }
                    } else {
                        // Block 0x6051
                        $1 = $2;
                        jmp 0x60bc;
                        // Block 0x60BC
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x6022
                $1 = 0;
                jmp 0x60bc;
                // Block 0x60BC
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        }
    } else {
        // Block 0x6002
        $1 = $2;
        push($1);
        call 0x2d44;
        // Block 0x6009
        jmp 0x60bc;
        // Block 0x60BC
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_3118(); // Reads data from a file
    sub_3118(); // Reads data from a file
    sub_3001(); // Moves file pointer
}

void sub_60C5(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 10

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int ptr_34_i;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x60C5
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x60e7
        // Block 0x60E7
        $1 = $2;
        jmp 0x61de;
        // Block 0x61DE
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x60DC
        // Compare $1 with $2
        if (a > b) {  // jg 0x60e7
            // Block 0x60E7
            $1 = $2;
            jmp 0x61de;
            // Block 0x61DE
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x60E1
            // Compare $1 with $2
            if (a <= b (unsigned)) {  // jbe 0x60ed
                // Block 0x60ED
                cmp word ptr [0x76ae], 0;
                if (a != b) {  // jne 0x6103
                    // Block 0x6103
                    cmp word ptr [0x76ac], 0;
                    if (a != b) {  // jne 0x6117
                        // Block 0x6117
                        les bx, ptr [bp + 6];
                        cmp word ptr es:[bx], 0;
                        if (a == b) {  // je 0x6136
                            // Block 0x6136
                            les bx, ptr [bp + 6];
                            test word ptr es:[bx + 2], 4;
                            if (a == b) {  // je 0x6150
                                // Block 0x6150
                                les bx, ptr [bp + 6];
                                and word ptr es:[bx + 2], 0xfff3;
                                mov word ptr es:[bx + 6], 0;
                                $1 = $2;
                                $1 = $2;
                                $1 += $2;
                                mov word ptr es:[bx + 0xa], ax;
                                mov word ptr es:[bx + 8], dx;
                                mov word ptr es:[bx + 0xe], ax;
                                mov word ptr es:[bx + 0xc], dx;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x61dc
                                    // Block 0x61DC
                                    xor ax, ax;
                                } else {
                                    // Block 0x617C
                                    or si, si;
                                    if (a <= b (unsigned)) {  // jbe 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x6180
                                        mov word ptr [0x7336], 0;
                                        mov word ptr [0x7334], 0x4d69;
                                        $1 = $2;
                                        or ax, word ptr [bp + 0xc];
                                        if (a != b) {  // jne 0x61b5
                                            // Block 0x61B5
                                            les bx, ptr [bp + 6];
                                            $1 = $2;
                                            $1 = $2;
                                            mov word ptr es:[bx + 0xe], ax;
                                            mov word ptr es:[bx + 0xc], dx;
                                            mov word ptr es:[bx + 0xa], ax;
                                            mov word ptr es:[bx + 8], dx;
                                            mov word ptr es:[bx + 6], si;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0x61dc
                                                // Block 0x61DC
                                                xor ax, ax;
                                            } else {
                                                // Block 0x61D7
                                                or word ptr es:[bx + 2], 8;
                                            }
                                        } else {
                                            // Block 0x6194
                                            push($1);
                                            nop ;
                                            push($1);
                                            call 0x4302;
                                            // Block 0x619A
                                            $1 = pop();
                                            *($1) = $2;
                                            *($1) = $2;
                                            or ax, dx;
                                            if (a != b) {  // jne 0x61a8
                                                // Block 0x61A8
                                                les bx, ptr [bp + 6];
                                                or word ptr es:[bx + 2], 4;
                                                goto $1;
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0x61A5
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x6141
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x41f8;
                                // Block 0x614E
                                $1 = pop();
                                pop cx;
                            }
                        } else {
                            // Block 0x6120
                            $1 = $2;
                            push($1);
                            $1 = 0;
                            $1 = 0;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x554e;
                            // Block 0x6133
                            add sp, 0xa;
                        }
                    } else {
                        // Block 0x610A
                        cmp word ptr [bp + 6], 0x7340;
                        if (a != b) {  // jne 0x6117
                            // Block 0x6117
                            les bx, ptr [bp + 6];
                            cmp word ptr es:[bx], 0;
                            if (a == b) {  // je 0x6136
                                // Block 0x6136
                                les bx, ptr [bp + 6];
                                test word ptr es:[bx + 2], 4;
                                if (a == b) {  // je 0x6150
                                    // Block 0x6150
                                    les bx, ptr [bp + 6];
                                    and word ptr es:[bx + 2], 0xfff3;
                                    mov word ptr es:[bx + 6], 0;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 += $2;
                                    mov word ptr es:[bx + 0xa], ax;
                                    mov word ptr es:[bx + 8], dx;
                                    mov word ptr es:[bx + 0xe], ax;
                                    mov word ptr es:[bx + 0xc], dx;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x617C
                                        or si, si;
                                        if (a <= b (unsigned)) {  // jbe 0x61dc
                                            // Block 0x61DC
                                            xor ax, ax;
                                        } else {
                                            // Block 0x6180
                                            mov word ptr [0x7336], 0;
                                            mov word ptr [0x7334], 0x4d69;
                                            $1 = $2;
                                            or ax, word ptr [bp + 0xc];
                                            if (a != b) {  // jne 0x61b5
                                                // Block 0x61B5
                                                les bx, ptr [bp + 6];
                                                $1 = $2;
                                                $1 = $2;
                                                mov word ptr es:[bx + 0xe], ax;
                                                mov word ptr es:[bx + 0xc], dx;
                                                mov word ptr es:[bx + 0xa], ax;
                                                mov word ptr es:[bx + 8], dx;
                                                mov word ptr es:[bx + 6], si;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x61dc
                                                    // Block 0x61DC
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x61D7
                                                    or word ptr es:[bx + 2], 8;
                                                }
                                            } else {
                                                // Block 0x6194
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4302;
                                                // Block 0x619A
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                or ax, dx;
                                                if (a != b) {  // jne 0x61a8
                                                    // Block 0x61A8
                                                    les bx, ptr [bp + 6];
                                                    or word ptr es:[bx + 2], 4;
                                                    goto $1;
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0x61A5
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x6141
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x41f8;
                                    // Block 0x614E
                                    $1 = pop();
                                    pop cx;
                                }
                            } else {
                                // Block 0x6120
                                $1 = $2;
                                push($1);
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x554e;
                                // Block 0x6133
                                add sp, 0xa;
                            }
                        } else {
                            // Block 0x6111
                            mov word ptr [0x76ac], 1;
                        }
                    }
                } else {
                    // Block 0x60F4
                    cmp word ptr [bp + 6], 0x7354;
                    if (a != b) {  // jne 0x6103
                        // Block 0x6103
                        cmp word ptr [0x76ac], 0;
                        if (a != b) {  // jne 0x6117
                            // Block 0x6117
                            les bx, ptr [bp + 6];
                            cmp word ptr es:[bx], 0;
                            if (a == b) {  // je 0x6136
                                // Block 0x6136
                                les bx, ptr [bp + 6];
                                test word ptr es:[bx + 2], 4;
                                if (a == b) {  // je 0x6150
                                    // Block 0x6150
                                    les bx, ptr [bp + 6];
                                    and word ptr es:[bx + 2], 0xfff3;
                                    mov word ptr es:[bx + 6], 0;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 += $2;
                                    mov word ptr es:[bx + 0xa], ax;
                                    mov word ptr es:[bx + 8], dx;
                                    mov word ptr es:[bx + 0xe], ax;
                                    mov word ptr es:[bx + 0xc], dx;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x617C
                                        or si, si;
                                        if (a <= b (unsigned)) {  // jbe 0x61dc
                                            // Block 0x61DC
                                            xor ax, ax;
                                        } else {
                                            // Block 0x6180
                                            mov word ptr [0x7336], 0;
                                            mov word ptr [0x7334], 0x4d69;
                                            $1 = $2;
                                            or ax, word ptr [bp + 0xc];
                                            if (a != b) {  // jne 0x61b5
                                                // Block 0x61B5
                                                les bx, ptr [bp + 6];
                                                $1 = $2;
                                                $1 = $2;
                                                mov word ptr es:[bx + 0xe], ax;
                                                mov word ptr es:[bx + 0xc], dx;
                                                mov word ptr es:[bx + 0xa], ax;
                                                mov word ptr es:[bx + 8], dx;
                                                mov word ptr es:[bx + 6], si;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x61dc
                                                    // Block 0x61DC
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x61D7
                                                    or word ptr es:[bx + 2], 8;
                                                }
                                            } else {
                                                // Block 0x6194
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4302;
                                                // Block 0x619A
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                or ax, dx;
                                                if (a != b) {  // jne 0x61a8
                                                    // Block 0x61A8
                                                    les bx, ptr [bp + 6];
                                                    or word ptr es:[bx + 2], 4;
                                                    goto $1;
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0x61A5
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x6141
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x41f8;
                                    // Block 0x614E
                                    $1 = pop();
                                    pop cx;
                                }
                            } else {
                                // Block 0x6120
                                $1 = $2;
                                push($1);
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x554e;
                                // Block 0x6133
                                add sp, 0xa;
                            }
                        } else {
                            // Block 0x610A
                            cmp word ptr [bp + 6], 0x7340;
                            if (a != b) {  // jne 0x6117
                                // Block 0x6117
                                les bx, ptr [bp + 6];
                                cmp word ptr es:[bx], 0;
                                if (a == b) {  // je 0x6136
                                    // Block 0x6136
                                    les bx, ptr [bp + 6];
                                    test word ptr es:[bx + 2], 4;
                                    if (a == b) {  // je 0x6150
                                        // Block 0x6150
                                        les bx, ptr [bp + 6];
                                        and word ptr es:[bx + 2], 0xfff3;
                                        mov word ptr es:[bx + 6], 0;
                                        $1 = $2;
                                        $1 = $2;
                                        $1 += $2;
                                        mov word ptr es:[bx + 0xa], ax;
                                        mov word ptr es:[bx + 8], dx;
                                        mov word ptr es:[bx + 0xe], ax;
                                        mov word ptr es:[bx + 0xc], dx;
                                        // Compare $1 with $2
                                        if (a == b) {  // je 0x61dc
                                            // Block 0x61DC
                                            xor ax, ax;
                                        } else {
                                            // Block 0x617C
                                            or si, si;
                                            if (a <= b (unsigned)) {  // jbe 0x61dc
                                                // Block 0x61DC
                                                xor ax, ax;
                                            } else {
                                                // Block 0x6180
                                                mov word ptr [0x7336], 0;
                                                mov word ptr [0x7334], 0x4d69;
                                                $1 = $2;
                                                or ax, word ptr [bp + 0xc];
                                                if (a != b) {  // jne 0x61b5
                                                    // Block 0x61B5
                                                    les bx, ptr [bp + 6];
                                                    $1 = $2;
                                                    $1 = $2;
                                                    mov word ptr es:[bx + 0xe], ax;
                                                    mov word ptr es:[bx + 0xc], dx;
                                                    mov word ptr es:[bx + 0xa], ax;
                                                    mov word ptr es:[bx + 8], dx;
                                                    mov word ptr es:[bx + 6], si;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0x61dc
                                                        // Block 0x61DC
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x61D7
                                                        or word ptr es:[bx + 2], 8;
                                                    }
                                                } else {
                                                    // Block 0x6194
                                                    push($1);
                                                    nop ;
                                                    push($1);
                                                    call 0x4302;
                                                    // Block 0x619A
                                                    $1 = pop();
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    or ax, dx;
                                                    if (a != b) {  // jne 0x61a8
                                                        // Block 0x61A8
                                                        les bx, ptr [bp + 6];
                                                        or word ptr es:[bx + 2], 4;
                                                        goto $1;
                                                        jmp 0x60e7;
                                                        // Block 0x60E7
                                                        $1 = $2;
                                                        jmp 0x61de;
                                                        // Block 0x61DE
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0x61A5
                                                        jmp 0x60e7;
                                                        // Block 0x60E7
                                                        $1 = $2;
                                                        jmp 0x61de;
                                                        // Block 0x61DE
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x6141
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x41f8;
                                        // Block 0x614E
                                        $1 = pop();
                                        pop cx;
                                    }
                                } else {
                                    // Block 0x6120
                                    $1 = $2;
                                    push($1);
                                    $1 = 0;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x554e;
                                    // Block 0x6133
                                    add sp, 0xa;
                                }
                            } else {
                                // Block 0x6111
                                mov word ptr [0x76ac], 1;
                            }
                        }
                    } else {
                        // Block 0x60FB
                        mov word ptr [0x76ae], 1;
                        jmp 0x6117;
                        // Block 0x6117
                        les bx, ptr [bp + 6];
                        cmp word ptr es:[bx], 0;
                        if (a == b) {  // je 0x6136
                            // Block 0x6136
                            les bx, ptr [bp + 6];
                            test word ptr es:[bx + 2], 4;
                            if (a == b) {  // je 0x6150
                                // Block 0x6150
                                les bx, ptr [bp + 6];
                                and word ptr es:[bx + 2], 0xfff3;
                                mov word ptr es:[bx + 6], 0;
                                $1 = $2;
                                $1 = $2;
                                $1 += $2;
                                mov word ptr es:[bx + 0xa], ax;
                                mov word ptr es:[bx + 8], dx;
                                mov word ptr es:[bx + 0xe], ax;
                                mov word ptr es:[bx + 0xc], dx;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x61dc
                                    // Block 0x61DC
                                    xor ax, ax;
                                } else {
                                    // Block 0x617C
                                    or si, si;
                                    if (a <= b (unsigned)) {  // jbe 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x6180
                                        mov word ptr [0x7336], 0;
                                        mov word ptr [0x7334], 0x4d69;
                                        $1 = $2;
                                        or ax, word ptr [bp + 0xc];
                                        if (a != b) {  // jne 0x61b5
                                            // Block 0x61B5
                                            les bx, ptr [bp + 6];
                                            $1 = $2;
                                            $1 = $2;
                                            mov word ptr es:[bx + 0xe], ax;
                                            mov word ptr es:[bx + 0xc], dx;
                                            mov word ptr es:[bx + 0xa], ax;
                                            mov word ptr es:[bx + 8], dx;
                                            mov word ptr es:[bx + 6], si;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0x61dc
                                                // Block 0x61DC
                                                xor ax, ax;
                                            } else {
                                                // Block 0x61D7
                                                or word ptr es:[bx + 2], 8;
                                            }
                                        } else {
                                            // Block 0x6194
                                            push($1);
                                            nop ;
                                            push($1);
                                            call 0x4302;
                                            // Block 0x619A
                                            $1 = pop();
                                            *($1) = $2;
                                            *($1) = $2;
                                            or ax, dx;
                                            if (a != b) {  // jne 0x61a8
                                                // Block 0x61A8
                                                les bx, ptr [bp + 6];
                                                or word ptr es:[bx + 2], 4;
                                                goto $1;
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0x61A5
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x6141
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x41f8;
                                // Block 0x614E
                                $1 = pop();
                                pop cx;
                            }
                        } else {
                            // Block 0x6120
                            $1 = $2;
                            push($1);
                            $1 = 0;
                            $1 = 0;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x554e;
                            // Block 0x6133
                            add sp, 0xa;
                        }
                    }
                }
            } else {
                // Block 0x60E7
                $1 = $2;
                jmp 0x61de;
                // Block 0x61DE
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            }
        }
    }

    // Function calls:
    sub_554E(); // Performs arithmetic calculations
    sub_41F8(); // Unknown function purpose
    sub_4302(); // Unknown function purpose
}

void sub_61E2(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x61E2
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (a == b) {  // je 0x6236
        // Block 0x6236
        $1 = pop();
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x61F1
        push($1);
        push($1);
        nop ;
        push($1);
        call 0x6661;
        // Block 0x61FC
        $1 = pop();
        $1 = pop();
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x6222
            // Block 0x6222
            push($1);
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x65f7;
            // Block 0x6233
            add sp, 8;
        } else {
            // Block 0x6202
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x6680;
            // Block 0x6214
            $1 += $2;
            les bx, ptr [bp + 0xa];
            $1 += $2;
            mov byte ptr es:[bx], 0;
            jmp 0x6236;
            // Block 0x6236
            $1 = pop();
            $1 = pop();
            return;  // ret 0xa
        }
    }

    // Function calls:
    sub_6661(); // Unknown function purpose
    sub_6680(); // Manipulates strings or memory blocks and performs calculations
    sub_65F7(); // Manipulates strings or memory blocks and performs calculations
}

void sub_623B(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x623B
    push($1);
    $1 = $2;
    $1 -= $2;
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx - 1], 0x2e;
    if (a != b) {  // jne 0x624e
        // Block 0x624E
        $1--;
        les bx, ptr [bp + 4];
        $1 = $2;
        cwde ;
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        // Compare $1 with $2
        if (a == b) {  // je 0x6270
            // Block 0x6270
            goto $1;
            les bx, ptr [bp + 4];
            cmp byte ptr es:[bx - 2], 0;
            if (a != b) {  // jne 0x6283
                // Block 0x6283
                xor ax, ax;
            } else {
                // Block 0x627E
                $1 = $2;
                jmp 0x6285;
                // Block 0x6285
                $1 = $2;
                $1 = pop();
                return;  // ret 4
            }
        } else {
            // Block 0x6269
            $1 += $2;
            loop 0x6261;
            jmp 0x6283;
            // Block 0x6283
            xor ax, ax;
        }
    } else {
        // Block 0x624B
        dec word ptr [bp + 4];
    }
}

void sub_629B(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 25 if statements

    // Block 0x629B
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (a == b) {  // je 0x62b4
        // Block 0x62B4
        $1 = $2;
        or ax, word ptr [bp + 0x10];
        if (a == b) {  // je 0x62c3
            // Block 0x62C3
            $1 = $2;
            or ax, word ptr [bp + 0x14];
            if (a == b) {  // je 0x62d2
                // Block 0x62D2
                $1 = $2;
                or ax, word ptr [bp + 0x18];
                if (a == b) {  // je 0x62e1
                    // Block 0x62E1
                    lea ax, [bp - 0x58];
                    *($1) = $2;
                    *($1) = $2;
                    jmp 0x62ef;
                    // Block 0x62EF
                    les bx, ptr [bp + 6];
                    cmp byte ptr es:[bx], 0x20;
                    if (a == b) {  // je 0x62ec
                        // Block 0x62EC
                        inc word ptr [bp + 6];
                    } else {
                        // Block 0x62F8
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x6661;
                        // Block 0x6301
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        // Compare $1 with $2
                        if (a <= b) {  // jle 0x630d
                            // Block 0x630D
                            les bx, ptr [bp - 4];
                            mov byte ptr es:[bx], 0;
                            $1++;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x6680;
                            // Block 0x6329
                            $1 += $2;
                            add word ptr [bp - 4], si;
                            les bx, ptr [bp - 4];
                            mov byte ptr es:[bx], 0;
                            xor si, si;
                        } else {
                            // Block 0x630A
                            mov si, 0x50;
                        }
                    }
                } else {
                    // Block 0x62DA
                    les bx, ptr [bp + 0x16];
                    mov byte ptr es:[bx], 0;
                }
            } else {
                // Block 0x62CB
                les bx, ptr [bp + 0x12];
                mov byte ptr es:[bx], 0;
            }
        } else {
            // Block 0x62BC
            les bx, ptr [bp + 0xe];
            mov byte ptr es:[bx], 0;
        }
    } else {
        // Block 0x62AD
        les bx, ptr [bp + 0xa];
        mov byte ptr es:[bx], 0;
    }

    // Function calls:
    sub_6661(); // Unknown function purpose
    sub_6680(); // Manipulates strings or memory blocks and performs calculations
    sub_623B(); // Performs arithmetic calculations
    sub_61E2(); // Performs arithmetic calculations
    sub_61E2(); // Performs arithmetic calculations
    sub_61E2(); // Performs arithmetic calculations
    sub_61E2(); // Performs arithmetic calculations
    sub_629B(); // Manipulates strings or memory blocks and performs calculations
    sub_59FF(); // Manipulates strings or memory blocks
    sub_3935(); // Performs arithmetic calculations
    sub_3935(); // Performs arithmetic calculations
    sub_3147(); // Performs arithmetic calculations
    sub_3147(); // Performs arithmetic calculations
}

void sub_65B8(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x65B8
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    push($1);
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    push($1);
    lea si, [di - 1];
    les di, ptr [bp + 0xa];
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1 -= $2;
    push($1);
    $1 = pop();
    $1 = pop();
    xchg di, si;
    test si, 1;
    if (a == b) {  // je 0x65e8
        // Block 0x65E8
        shr cx, 1;
        rep movsw word ptr es:[di], word ptr [si];
        if (a >= b (unsigned)) {  // jae 0x65ef
            // Block 0x65EF
            xchg dx, ax;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x65EE
            movsb byte ptr es:[di], byte ptr [si];
        }
    } else {
        // Block 0x65E6
        movsb byte ptr es:[di], byte ptr [si];
        dec cx;
    }
}

void sub_65F7(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x65F7
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    return;  // retf 
}

void sub_6661(int) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x6661
    push($1);
    $1 = $2;
    push($1);
    les di, ptr [bp + 6];
    $1 = 0;
    // Compare $1 with $2
    if (a != b) {  // jne 0x6673
        // Block 0x6673
        cld ;
        $1 = $2;
        repne scasb al, byte ptr es:[di];
        xchg cx, ax;
        not ax;
        dec ax;
    } else {
        // Block 0x666F
        // Compare $1 with $2
        if (a == b) {  // je 0x667d
            // Block 0x667D
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x6673
            cld ;
            $1 = $2;
            repne scasb al, byte ptr es:[di];
            xchg cx, ax;
            not ax;
            dec ax;
        }
    }
}

void sub_6680(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x6680
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    xchg bx, cx;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    return;  // retf 
}

void sub_679C(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 8

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x679C
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x67b8
        // Block 0x67B8
        $1 = $2;
        $1++;
        // Compare $1 with $2
        if (a >= b (unsigned)) {  // jae 0x67c6
            // Block 0x67C6
            $1 = $2;
            shl bx, 1;
            test word ptr [bx + 0x74d2], 0x800;
            if (a == b) {  // je 0x67e5
                // Block 0x67E5
                $1 = $2;
                shl bx, 1;
                test word ptr [bx + 0x74d2], 0x4000;
                if (a != b) {  // jne 0x6806
                    // Block 0x6806
                    $1 = $2;
                    shl bx, 1;
                    and word ptr [bx + 0x74d2], 0xfdff;
                    $1 = $2;
                    $1 = $2;
                    *($1) = $2;
                    *($1) = $2;
                    $1 = $2;
                    *($1) = $2;
                    jmp 0x6899;
                    // Block 0x6899
                    lea ax, [bp - 0x8e];
                    *($1) = $2;
                    mov word ptr [bp - 4], ax;
                } else {
                    // Block 0x67F1
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x68ed;
                    // Block 0x6800
                    $1 += $2;
                    jmp 0x68e7;
                    // Block 0x68E7
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0x67D2
                $1 = $2;
                push($1);
                $1 = 0;
                $1 = 0;
                push($1);
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x3001;
                // Block 0x67E2
                add sp, 8;
            }
        } else {
            // Block 0x67C1
            $1 = 0;
            jmp 0x68e7;
            // Block 0x68E7
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x67AE
        $1 = $2;
        push($1);
        call 0x2d44;
        // Block 0x67B5
        jmp 0x68e7;
        // Block 0x68E7
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_3001(); // Moves file pointer
    sub_68ED(); // Writes data to a file and performs calculations
    sub_68ED(); // Writes data to a file and performs calculations
    sub_68ED(); // Writes data to a file and performs calculations
}

void sub_68ED(int, int) {
    // Purpose: Writes data to a file and performs calculations

    // Complexity: 24

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 54 if statements

    // Block 0x68ED
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 1;
    if (a == b) {  // je 0x6903
        // Block 0x6903
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        lds dx, ptr [bp + 8];
        DOS_WriteFile();  // int 0x21
        $1 = pop();
        if (a < b (unsigned)) {  // jb 0x6923
            // Block 0x6923
            push ax;
        } else {
            // Block 0x6914
            push($1);
            $1 = $2;
            shl bx, 1;
            or word ptr [bx + 0x74d2], 0x1000;
            $1 = pop();
            jmp 0x6927;
            // Block 0x6927
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x68FD
        $1 = $2;
        push($1);
        jmp 0x6924;
        // Block 0x6924
        call 0x2d44;
        // Block 0x6927
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44(); // Unknown function purpose
    sub_4EFB(); // Unknown function purpose
    sub_4FB3(); // Performs DOS operations and performs calculations
}

void sub_70A0(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x70A0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov ax, word ptr [bp + 6];

    // Function calls:
    sub_70A0(); // Performs arithmetic calculations
}

void sub_715E(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x715E
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cmp word ptr [0x54d2], -1;
    if (a != b) {  // jne 0x7187
        // Block 0x7187
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = $2;
        cli ;
        $1 = $2;
        $1 = $2;
        sti ;
        cmp word ptr [0x54d2], 0;
        if (a != b) {  // jne 0x71a8
            // Block 0x71A8
            push($1);
            $1 = 0;
            out 0x43, al;
            in al, 0x40;
            xchg al, ah;
            in al, 0x40;
            xchg al, ah;
            not ax;
            *($1) = $2;
            $1 = pop();
            // Compare $1 with $2
            if (a == b) {  // je 0x71d0
                // Block 0x71D0
                cmp word ptr [0x54ce], dx;
                if (a > b (unsigned)) {  // ja 0x71de
                    // Block 0x71DE
                    $1 += $2;
                    adc dx, 0x18;
                } else {
                    // Block 0x71D6
                    if (a < b (unsigned)) {  // jb 0x71e4
                        // Block 0x71E4
                        $1 -= $2;
                        sbb dx, word ptr [0x54ce];
                        $1 = $2;
                        lcall 0x7ff, 8;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        push($1);
                        push($1);
                        $1 = $2;
                        mul word ptr [bp - 4];
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = pop();
                        $1 += $2;
                        $1 = pop();
                        adc dx, bx;
                        *($1) = $2;
                        popf ;
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x71D8
                        cmp word ptr [0x54cc], ax;
                        if (a <= b (unsigned)) {  // jbe 0x71e4
                            // Block 0x71E4
                            $1 -= $2;
                            sbb dx, word ptr [0x54ce];
                            $1 = $2;
                            lcall 0x7ff, 8;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            push($1);
                            push($1);
                            $1 = $2;
                            mul word ptr [bp - 4];
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = pop();
                            $1 += $2;
                            $1 = pop();
                            adc dx, bx;
                            *($1) = $2;
                            popf ;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0x71DE
                            $1 += $2;
                            adc dx, 0x18;
                        }
                    }
                }
            } else {
                // Block 0x71C0
                cmp word ptr [bp - 4], 0x8000;
                if (a > b (unsigned)) {  // ja 0x71d0
                    // Block 0x71D0
                    cmp word ptr [0x54ce], dx;
                    if (a > b (unsigned)) {  // ja 0x71de
                        // Block 0x71DE
                        $1 += $2;
                        adc dx, 0x18;
                    } else {
                        // Block 0x71D6
                        if (a < b (unsigned)) {  // jb 0x71e4
                            // Block 0x71E4
                            $1 -= $2;
                            sbb dx, word ptr [0x54ce];
                            $1 = $2;
                            lcall 0x7ff, 8;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            push($1);
                            push($1);
                            $1 = $2;
                            mul word ptr [bp - 4];
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = pop();
                            $1 += $2;
                            $1 = pop();
                            adc dx, bx;
                            *($1) = $2;
                            popf ;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0x71D8
                            cmp word ptr [0x54cc], ax;
                            if (a <= b (unsigned)) {  // jbe 0x71e4
                                // Block 0x71E4
                                $1 -= $2;
                                sbb dx, word ptr [0x54ce];
                                $1 = $2;
                                lcall 0x7ff, 8;
                                $1 = $2;
                                lcall 0x7ff, 0x32;
                                push($1);
                                push($1);
                                $1 = $2;
                                mul word ptr [bp - 4];
                                $1 = $2;
                                lcall 0x7ff, 0x32;
                                $1 = $2;
                                lcall 0x7ff, 0x32;
                                $1 = pop();
                                $1 += $2;
                                $1 = pop();
                                adc dx, bx;
                                *($1) = $2;
                                popf ;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0x71DE
                                $1 += $2;
                                adc dx, 0x18;
                            }
                        }
                    }
                } else {
                    // Block 0x71C7
                    cli ;
                    $1 = $2;
                    $1 = $2;
                    sti ;
                }
            }
        } else {
            // Block 0x71A1
            mov word ptr [bp - 4], 0;
            jmp 0x71d0;
            // Block 0x71D0
            cmp word ptr [0x54ce], dx;
            if (a > b (unsigned)) {  // ja 0x71de
                // Block 0x71DE
                $1 += $2;
                adc dx, 0x18;
            } else {
                // Block 0x71D6
                if (a < b (unsigned)) {  // jb 0x71e4
                    // Block 0x71E4
                    $1 -= $2;
                    sbb dx, word ptr [0x54ce];
                    $1 = $2;
                    lcall 0x7ff, 8;
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    push($1);
                    push($1);
                    $1 = $2;
                    mul word ptr [bp - 4];
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    $1 = pop();
                    $1 += $2;
                    $1 = pop();
                    adc dx, bx;
                    *($1) = $2;
                    popf ;
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x71D8
                    cmp word ptr [0x54cc], ax;
                    if (a <= b (unsigned)) {  // jbe 0x71e4
                        // Block 0x71E4
                        $1 -= $2;
                        sbb dx, word ptr [0x54ce];
                        $1 = $2;
                        lcall 0x7ff, 8;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        push($1);
                        push($1);
                        $1 = $2;
                        mul word ptr [bp - 4];
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = pop();
                        $1 += $2;
                        $1 = pop();
                        adc dx, bx;
                        *($1) = $2;
                        popf ;
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x71DE
                        $1 += $2;
                        adc dx, 0x18;
                    }
                }
            }
        }
    } else {
        // Block 0x7175
        cli ;
        $1 = $2;
        out 0x43, al;
        $1 = 0;
        out 0x40, al;
        out 0x40, al;
        sti ;
        mov word ptr [0x54d2], 1;
    }
}

void sub_7229(int) {
    // Purpose: Handles keyboard input and performs calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x7229
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    call 0x715e;
    // Block 0x723C
    cmp word ptr [bp + 8], dx;
    if (a > b (unsigned)) {  // ja 0x7248
        // Block 0x7248
        $1 += $2;
        adc dx, 0x526;
    } else {
        // Block 0x7241
        if (a < b (unsigned)) {  // jb 0x724f
            // Block 0x724F
            $1 -= $2;
            sbb dx, word ptr [bp + 8];
            *($1) = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        } else {
            // Block 0x7243
            cmp word ptr [bp + 6], ax;
            if (a <= b (unsigned)) {  // jbe 0x724f
                // Block 0x724F
                $1 -= $2;
                sbb dx, word ptr [bp + 8];
                *($1) = $2;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            } else {
                // Block 0x7248
                $1 += $2;
                adc dx, 0x526;
            }
        }
    }

    // Function calls:
    sub_715E(); // Performs arithmetic calculations
    sub_715E(); // Performs arithmetic calculations
    sub_70A0(); // Performs arithmetic calculations
    sub_7229(); // Handles keyboard input and performs calculations
}

void sub_731C(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x731C
    push($1);
    push($1);
    $1 = $2;
    xor bx, bx;
}

void sub_7353(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x7353
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 0x3f;
    and dx, 0x3f3f;
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x7386
        // Block 0x7386
        $1 = $2;
        $1 = $2;
        call 0x731c;
        // Block 0x738E
        jmp 0x7398;
        // Block 0x7398
        $1 = 0;
        mov word ptr [bp - 2], ax;
    } else {
        // Block 0x737A
        // Compare $1 with $2
        if (a == b) {  // je 0x7390
            // Block 0x7390
            $1 = 0;
            $1 = $2;
            call 0x731c;
            // Block 0x7398
            $1 = 0;
            mov word ptr [bp - 2], ax;
        } else {
            // Block 0x737F
            mov word ptr [bp - 2], 0xfff7;
            jmp 0x739d;
            // Block 0x739D
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 8
        }
    }

    // Function calls:
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
}

void sub_7426(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x7426
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    lodsb al, byte ptr [si];
    $1 = 0;
    $1 = $2;
    shl bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    and bl, 3;
    $1 = $2;
    $1 = $2;
    for (bl = 0; bl < $2_2; bl++) {
    cmp bl, 0;
    if (a == b) {  // je 0x747c
        // Block 0x747C
        $1 = $2;
        rep movsb byte ptr es:[di], byte ptr [si];
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    } else {
        // Block 0x7469
        for (bl = 1; bl < $2_2; bl++) {
        cmp bl, 1;
        if (a == b) {  // je 0x747c
            // Block 0x747C
            $1 = $2;
            rep movsb byte ptr es:[di], byte ptr [si];
            mov word ptr [bp - 2], 0;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 8
        } else {
            // Block 0x7471
            for (bl = 2; bl < $2_2; bl++) {
            cmp bl, 2;
            if (a == b) {  // je 0x747c
                // Block 0x747C
                $1 = $2;
                rep movsb byte ptr es:[di], byte ptr [si];
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 8
            } else {
                // Block 0x7479
                mov si, 0x3ad3;
            }
        }
    }
}

void sub_74D9(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x74D9
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    or cx, cx;
    if (a != b) {  // jne 0x74fc
        // Block 0x74FC
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x7504
            // Block 0x7504
            lodsb al, byte ptr [si];
            $1 = $2;
            and dh, al;
            $1 = $2;
            and dl, al;
            $1 = $2;
            and ah, al;
            $1 = 0;
            or dh, dh;
            if (a == b) {  // je 0x7527
                // Block 0x7527
                stosb byte ptr es:[di], al;
                $1 = 0;
                or dl, dl;
                if (a == b) {  // je 0x753e
                    // Block 0x753E
                    stosb byte ptr es:[di], al;
                    $1 = 0;
                    or ah, ah;
                    if (a == b) {  // je 0x7555
                        // Block 0x7555
                        stosb byte ptr es:[di], al;
                        loop 0x7504;
                        mov word ptr [bp - 2], 0;
                    } else {
                        // Block 0x7545
                        for (ah = 8; ah < $2_2; ah++) {
                        cmp ah, 8;
                        if (a == b) {  // je 0x7555
                            // Block 0x7555
                            stosb byte ptr es:[di], al;
                            loop 0x7504;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x754C
                            for (ah = 1; ah < $2_2; ah++) {
                            cmp ah, 1;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7553
                                mov al, 0x3f;
                            }
                        }
                    }
                } else {
                    // Block 0x752E
                    for (dl = 0x10; dl < $2_2; dl++) {
                    cmp dl, 0x10;
                    if (a == b) {  // je 0x753e
                        // Block 0x753E
                        stosb byte ptr es:[di], al;
                        $1 = 0;
                        or ah, ah;
                        if (a == b) {  // je 0x7555
                            // Block 0x7555
                            stosb byte ptr es:[di], al;
                            loop 0x7504;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x7545
                            for (ah = 8; ah < $2_2; ah++) {
                            cmp ah, 8;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x754C
                                for (ah = 1; ah < $2_2; ah++) {
                                cmp ah, 1;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7553
                                    mov al, 0x3f;
                                }
                            }
                        }
                    } else {
                        // Block 0x7535
                        for (dl = 2; dl < $2_2; dl++) {
                        cmp dl, 2;
                        if (a == b) {  // je 0x753e
                            // Block 0x753E
                            stosb byte ptr es:[di], al;
                            $1 = 0;
                            or ah, ah;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7545
                                for (ah = 8; ah < $2_2; ah++) {
                                cmp ah, 8;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x754C
                                    for (ah = 1; ah < $2_2; ah++) {
                                    cmp ah, 1;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7553
                                        mov al, 0x3f;
                                    }
                                }
                            }
                        } else {
                            // Block 0x753C
                            mov al, 0x3f;
                        }
                    }
                }
            } else {
                // Block 0x7517
                for (dh = 0x20; dh < $2_2; dh++) {
                cmp dh, 0x20;
                if (a == b) {  // je 0x7527
                    // Block 0x7527
                    stosb byte ptr es:[di], al;
                    $1 = 0;
                    or dl, dl;
                    if (a == b) {  // je 0x753e
                        // Block 0x753E
                        stosb byte ptr es:[di], al;
                        $1 = 0;
                        or ah, ah;
                        if (a == b) {  // je 0x7555
                            // Block 0x7555
                            stosb byte ptr es:[di], al;
                            loop 0x7504;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x7545
                            for (ah = 8; ah < $2_2; ah++) {
                            cmp ah, 8;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x754C
                                for (ah = 1; ah < $2_2; ah++) {
                                cmp ah, 1;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7553
                                    mov al, 0x3f;
                                }
                            }
                        }
                    } else {
                        // Block 0x752E
                        for (dl = 0x10; dl < $2_2; dl++) {
                        cmp dl, 0x10;
                        if (a == b) {  // je 0x753e
                            // Block 0x753E
                            stosb byte ptr es:[di], al;
                            $1 = 0;
                            or ah, ah;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7545
                                for (ah = 8; ah < $2_2; ah++) {
                                cmp ah, 8;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x754C
                                    for (ah = 1; ah < $2_2; ah++) {
                                    cmp ah, 1;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7553
                                        mov al, 0x3f;
                                    }
                                }
                            }
                        } else {
                            // Block 0x7535
                            for (dl = 2; dl < $2_2; dl++) {
                            cmp dl, 2;
                            if (a == b) {  // je 0x753e
                                // Block 0x753E
                                stosb byte ptr es:[di], al;
                                $1 = 0;
                                or ah, ah;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7545
                                    for (ah = 8; ah < $2_2; ah++) {
                                    cmp ah, 8;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x754C
                                        for (ah = 1; ah < $2_2; ah++) {
                                        cmp ah, 1;
                                        if (a == b) {  // je 0x7555
                                            // Block 0x7555
                                            stosb byte ptr es:[di], al;
                                            loop 0x7504;
                                            mov word ptr [bp - 2], 0;
                                        } else {
                                            // Block 0x7553
                                            mov al, 0x3f;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x753C
                                mov al, 0x3f;
                            }
                        }
                    }
                } else {
                    // Block 0x751E
                    for (dh = 4; dh < $2_2; dh++) {
                    cmp dh, 4;
                    if (a == b) {  // je 0x7527
                        // Block 0x7527
                        stosb byte ptr es:[di], al;
                        $1 = 0;
                        or dl, dl;
                        if (a == b) {  // je 0x753e
                            // Block 0x753E
                            stosb byte ptr es:[di], al;
                            $1 = 0;
                            or ah, ah;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7545
                                for (ah = 8; ah < $2_2; ah++) {
                                cmp ah, 8;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x754C
                                    for (ah = 1; ah < $2_2; ah++) {
                                    cmp ah, 1;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7553
                                        mov al, 0x3f;
                                    }
                                }
                            }
                        } else {
                            // Block 0x752E
                            for (dl = 0x10; dl < $2_2; dl++) {
                            cmp dl, 0x10;
                            if (a == b) {  // je 0x753e
                                // Block 0x753E
                                stosb byte ptr es:[di], al;
                                $1 = 0;
                                or ah, ah;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7545
                                    for (ah = 8; ah < $2_2; ah++) {
                                    cmp ah, 8;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x754C
                                        for (ah = 1; ah < $2_2; ah++) {
                                        cmp ah, 1;
                                        if (a == b) {  // je 0x7555
                                            // Block 0x7555
                                            stosb byte ptr es:[di], al;
                                            loop 0x7504;
                                            mov word ptr [bp - 2], 0;
                                        } else {
                                            // Block 0x7553
                                            mov al, 0x3f;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x7535
                                for (dl = 2; dl < $2_2; dl++) {
                                cmp dl, 2;
                                if (a == b) {  // je 0x753e
                                    // Block 0x753E
                                    stosb byte ptr es:[di], al;
                                    $1 = 0;
                                    or ah, ah;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7545
                                        for (ah = 8; ah < $2_2; ah++) {
                                        cmp ah, 8;
                                        if (a == b) {  // je 0x7555
                                            // Block 0x7555
                                            stosb byte ptr es:[di], al;
                                            loop 0x7504;
                                            mov word ptr [bp - 2], 0;
                                        } else {
                                            // Block 0x754C
                                            for (ah = 1; ah < $2_2; ah++) {
                                            cmp ah, 1;
                                            if (a == b) {  // je 0x7555
                                                // Block 0x7555
                                                stosb byte ptr es:[di], al;
                                                loop 0x7504;
                                                mov word ptr [bp - 2], 0;
                                            } else {
                                                // Block 0x7553
                                                mov al, 0x3f;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x753C
                                    mov al, 0x3f;
                                }
                            }
                        }
                    } else {
                        // Block 0x7525
                        mov al, 0x3f;
                    }
                }
            }
        } else {
            // Block 0x7501
            mov cx, 0x10;
        }
    } else {
        // Block 0x74F5
        mov word ptr [bp - 2], 0xfff6;
        jmp 0x755d;
        // Block 0x755D
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_756A(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x756A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    cmp word ptr [bp + 0xe], 0;
    if (a != b) {  // jne 0x758a
        // Block 0x758A
        $1 = $2;
        push($1);
        lodsb al, byte ptr [si];
        push($1);
        lodsb al, byte ptr [si];
        push($1);
        lodsb al, byte ptr [si];
        push($1);
        push($1);
        call 0x7353;
        // Block 0x7598
        *($1) = $2;
        $1--;
        if (a != b) {  // jne 0x75a3
            // Block 0x75A3
            $1 = 0;
            cmp word ptr [bp + 0xe], 3;
            if (a <= b (unsigned)) {  // jbe 0x75b0
                // Block 0x75B0
                $1 = $2;
                $1 = $2;
                for (cx = 0; cx < $2_2; cx++) {
                cmp cx, 0;
                if (a == b) {  // je 0x75d0
                    // Block 0x75D0
                    push($1);
                    push($1);
                    push($1);
                    $1 = 0;
                    mov word ptr [bp - 6], 0xffff;
                } else {
                    // Block 0x75BD
                    for (cx = 1; cx < $2_2; cx++) {
                    cmp cx, 1;
                    if (a == b) {  // je 0x75d0
                        // Block 0x75D0
                        push($1);
                        push($1);
                        push($1);
                        $1 = 0;
                        mov word ptr [bp - 6], 0xffff;
                    } else {
                        // Block 0x75C5
                        for (cx = 2; cx < $2_2; cx++) {
                        cmp cx, 2;
                        if (a == b) {  // je 0x75d0
                            // Block 0x75D0
                            push($1);
                            push($1);
                            push($1);
                            $1 = 0;
                            mov word ptr [bp - 6], 0xffff;
                        } else {
                            // Block 0x75CD
                            mov di, 0x3ad3;
                        }
                    }
                }
            } else {
                // Block 0x75AB
                mov word ptr [bp + 0xe], 3;
            }
        } else {
            // Block 0x75A0
            jmp 0x762d;
            // Block 0x762D
            mov word ptr [bp - 2], 0;
        }
    } else {
        // Block 0x7582
        mov word ptr [bp - 2], 0xfff6;
        jmp 0x7632;
        // Block 0x7632
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }

    // Function calls:
    sub_7353(); // Performs arithmetic calculations
    sub_7353(); // Performs arithmetic calculations
}

void sub_7678(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x7678
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 5], 8;
    mov byte ptr [bp - 4], 1;
    mov byte ptr [bp - 3], 9;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    or cx, cx;
    if (a != b) {  // jne 0x76ad
        // Block 0x76AD
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x76b5
            // Block 0x76B5
            lodsb al, byte ptr [si];
            $1 = $2;
            lodsb al, byte ptr [si];
            $1 = $2;
            lodsb al, byte ptr [si];
            $1 = $2;
            push($1);
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = 0;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            shl al, 1;
            shl al, 1;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            shl dh, 1;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            or al, dh;
            or al, dl;
            $1 = pop();
            $1 = pop();
            stosb byte ptr es:[di], al;
            loop 0x76b5;
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x76B2
            mov cx, 0x10;
        }
    } else {
        // Block 0x76A6
        mov word ptr [bp - 2], 0xfff6;
        jmp 0x76fd;
        // Block 0x76FD
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_770A(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 14

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 31 if statements

    // Block 0x770A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    mov ch, 0xb;

    // Function calls:
    sub_770A(); // Manipulates strings or memory blocks and performs calculations
    sub_74D9(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_7678(); // Manipulates strings or memory blocks and performs calculations
    sub_770A(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_7426(); // Manipulates strings or memory blocks and performs calculations
    sub_74D9(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_731C(); // Manipulates strings or memory blocks and performs calculations
    sub_756A(); // Manipulates strings or memory blocks and performs calculations
    sub_7678(); // Manipulates strings or memory blocks and performs calculations
}

void sub_7A56(int) {
    // Purpose: Closes a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 63

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 96 if statements

    // Block 0x7A56
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 0x10];
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x7a80
        // Block 0x7A80
        $1 = $2;
        $1 = $2;
        mov word ptr es:[di], 0xca00;
        mov byte ptr es:[di + 2], 2;
        mov byte ptr es:[di + 3], 2;
        $1 = $2;
        mov word ptr es:[di + 4], ax;
        $1 = 0;
        mov word ptr es:[di + 6], ax;
        mov word ptr es:[di + 8], ax;
        $1 = $2;
        mov word ptr es:[di + 0x2c], ax;
        $1--;
        mov word ptr es:[di + 0xa], ax;
        $1 = $2;
        mov word ptr es:[di + 0x2e], ax;
        $1--;
        mov word ptr es:[di + 0xc], ax;
        $1 = 0;
        $1 = $2;
        mov byte ptr es:[di + 0x12], al;
        mul word ptr [bp + 6];
        mov word ptr es:[di + 0x34], ax;
        $1 = $2;
        mov word ptr es:[di + 0xe], ax;
        $1 = $2;
        mov word ptr es:[di + 0x10], ax;
        $1 = 0;
        $1 = $2;
        mov byte ptr es:[di + 0x13], al;
        mul word ptr [bp + 8];
        $1 = $2;
        div bx;
        or dx, dx;
        if (a == b) {  // je 0x7af0
            // Block 0x7AF0
            mov word ptr es:[di + 0x30], ax;
            test ax, 1;
            if (a == b) {  // je 0x7afa
                // Block 0x7AFA
                mov word ptr es:[di + 0x14], ax;
                $1 = $2;
                xor cl, 7;
                $1++;
                and cl, 7;
                $1 = $2;
                shl ch, cl;
                $1 = $2;
                not ch;
                mov word ptr es:[di + 0x32], cx;
                mov word ptr es:[di + 0x28], 0;
                mov word ptr es:[di + 0x2a], 4;
                $1 = $2;
                mov word ptr es:[di + 0x16], ax;
                // Compare $1 with $2
                if (a != b) {  // jne 0x7b35
                    // Block 0x7B35
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x7b64
                        // Block 0x7B64
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x7b99
                            // Block 0x7B99
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x7bf3
                                // Block 0x7BF3
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0x10
                            } else {
                                // Block 0x7B9E
                                $1 = $2;
                                mov word ptr es:[di + 0x22], dx;
                                $1 = $2;
                                push($1);
                                lcall 0x620, 0x219;
                                or ax, ax;
                                if (a != b) {  // jne 0x7bc7
                                    // Block 0x7BC7
                                    *($1) = $2;
                                    jmp 0x7bf3;
                                    // Block 0x7BF3
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0x10
                                } else {
                                    // Block 0x7BB1
                                    mov word ptr es:[di + 0x24], bx;
                                    mov word ptr es:[di + 0x26], 0;
                                    $1 = $2;
                                    push($1);
                                    lcall 0x620, 0x219;
                                    or ax, ax;
                                    if (a == b) {  // je 0x7bcc
                                        // Block 0x7BCC
                                        mov word ptr es:[di + 0x1a], bx;
                                        mov word ptr es:[di + 0x18], ax;
                                        $1 = $2;
                                        mov word ptr es:[di + 0x1c], ax;
                                        $1 = 0;
                                        mov word ptr es:[di + 0x1e], ax;
                                        mov word ptr es:[di + 0x20], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        mov word ptr es:[di + 0x74], ax;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7BC7
                                        *($1) = $2;
                                        jmp 0x7bf3;
                                        // Block 0x7BF3
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 0x10
                                    }
                                }
                            }
                        } else {
                            // Block 0x7B69
                            $1 = $2;
                            mov word ptr es:[di + 0x22], dx;
                            $1 = $2;
                            push($1);
                            lcall 0xb95, 0x179;
                            or ax, ax;
                            if (a != b) {  // jne 0x7b92
                                // Block 0x7B92
                                mov word ptr [bp - 2], 0xffdb;
                                jmp 0x7bf3;
                                // Block 0x7BF3
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0x10
                            } else {
                                // Block 0x7B7C
                                mov word ptr es:[di + 0x24], bx;
                                mov word ptr es:[di + 0x26], 0;
                                $1 = $2;
                                push($1);
                                lcall 0xb95, 0x179;
                                or ax, ax;
                                if (a == b) {  // je 0x7bcc
                                    // Block 0x7BCC
                                    mov word ptr es:[di + 0x1a], bx;
                                    mov word ptr es:[di + 0x18], ax;
                                    $1 = $2;
                                    mov word ptr es:[di + 0x1c], ax;
                                    $1 = 0;
                                    mov word ptr es:[di + 0x1e], ax;
                                    mov word ptr es:[di + 0x20], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    mov word ptr es:[di + 0x74], ax;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7B92
                                    mov word ptr [bp - 2], 0xffdb;
                                    jmp 0x7bf3;
                                    // Block 0x7BF3
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0x10
                                }
                            }
                        }
                    } else {
                        // Block 0x7B3A
                        $1 = $2;
                        mov word ptr es:[di + 0x22], dx;
                        $1 = $2;
                        int 0x67;
                        or ah, ah;
                        if (a != b) {  // jne 0x7b5c
                            // Block 0x7B5C
                            mov word ptr [bp - 2], 0xffea;
                            jmp 0x7bf3;
                            // Block 0x7BF3
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0x10
                        } else {
                            // Block 0x7B49
                            mov word ptr es:[di + 0x24], bx;
                            mov word ptr es:[di + 0x26], 0;
                            $1 = $2;
                            int 0x67;
                            and ax, 0xff00;
                            if (a == b) {  // je 0x7bcc
                                // Block 0x7BCC
                                mov word ptr es:[di + 0x1a], bx;
                                mov word ptr es:[di + 0x18], ax;
                                $1 = $2;
                                mov word ptr es:[di + 0x1c], ax;
                                $1 = 0;
                                mov word ptr es:[di + 0x1e], ax;
                                mov word ptr es:[di + 0x20], ax;
                                $1 = $2;
                                $1 = 0;
                                mov word ptr es:[di + 0x74], ax;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7B5C
                                mov word ptr [bp - 2], 0xffea;
                                jmp 0x7bf3;
                                // Block 0x7BF3
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0x10
                            }
                        }
                    }
                } else {
                    // Block 0x7B2C
                    $1 = $2;
                    $1 = $2;
                    jmp 0x7bcc;
                    // Block 0x7BCC
                    mov word ptr es:[di + 0x1a], bx;
                    mov word ptr es:[di + 0x18], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x1c], ax;
                    $1 = 0;
                    mov word ptr es:[di + 0x1e], ax;
                    mov word ptr es:[di + 0x20], ax;
                    $1 = $2;
                    $1 = 0;
                    mov word ptr es:[di + 0x74], ax;
                    mov word ptr [bp - 2], 0;
                }
            } else {
                // Block 0x7AF9
                inc ax;
            }
        } else {
            // Block 0x7AEF
            inc ax;
        }
    } else {
        // Block 0x7A78
        mov word ptr [bp - 2], 0xfc19;
        jmp 0x7bf3;
        // Block 0x7BF3
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0x10
    }

    // Function calls:
    sub_7A56(); // Closes a file and manipulates strings or memory blocks and performs calculations
}

void sub_8346(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 9

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0x8346
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x8364
        // Block 0x8364
        $1 = $2;
        $1 = $2;
        $1 = $2;
        mov word ptr [bp - 2], ax;
    } else {
        // Block 0x835F
        *($1) = $2;
        jmp 0x836f;
        // Block 0x836F
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_8346(); // Manipulates strings or memory blocks and performs calculations
    sub_85ED(); // Performs video operations and performs calculations
    sub_8346(); // Manipulates strings or memory blocks and performs calculations
    sub_8791(); // Performs video operations and manipulates strings or memory blocks and performs calculations
    sub_8346(); // Manipulates strings or memory blocks and performs calculations
    sub_85ED(); // Performs video operations and performs calculations
    sub_8346(); // Manipulates strings or memory blocks and performs calculations
    sub_8791(); // Performs video operations and manipulates strings or memory blocks and performs calculations
    sub_8346(); // Manipulates strings or memory blocks and performs calculations
    sub_85ED(); // Performs video operations and performs calculations
    sub_8346(); // Manipulates strings or memory blocks and performs calculations
    sub_8791(); // Performs video operations and manipulates strings or memory blocks and performs calculations
}

void sub_85ED(int) {
    // Purpose: Performs video operations and performs calculations

    // Complexity: 11

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 19 if statements

    // Block 0x85ED
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    cmp word ptr [bp + 0xa], 0;
    if (a != b) {  // jne 0x861a
        // Block 0x861A
        cmp word ptr [bp + 0xe], 0;
        if (a != b) {  // jne 0x8623
            // Block 0x8623
            cmp word ptr [bp + 0xe], 1;
            if (a != b) {  // jne 0x866b
                // Block 0x866B
                cmp word ptr [bp + 0xe], 2;
                if (a != b) {  // jne 0x867e
                    // Block 0x867E
                    cmp word ptr [bp + 0xe], 3;
                    if (a != b) {  // jne 0x86c2
                        // Block 0x86C2
                        cmp word ptr [bp + 0xe], 4;
                        if (a != b) {  // jne 0x8721
                            // Block 0x8721
                            cmp word ptr [bp + 0xe], 5;
                            if (a != b) {  // jne 0x877f
                                // Block 0x877F
                                mov word ptr [bp - 2], 0xfff7;
                            } else {
                                // Block 0x8727
                                $1 = $2;
                                $1 += $2;
                                // Compare $1 with $2
                                if (a <= b (unsigned)) {  // jbe 0x8735
                                    // Block 0x8735
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    inc dx;
                                } else {
                                    // Block 0x8733
                                    jmp 0x877f;
                                    // Block 0x877F
                                    mov word ptr [bp - 2], 0xfff7;
                                }
                            }
                        } else {
                            // Block 0x86C8
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 += $2;
                            // Compare $1 with $2
                            if (a <= b (unsigned)) {  // jbe 0x86da
                                // Block 0x86DA
                                mov dx, word ptr [bp - 4];
                            } else {
                                // Block 0x86D7
                                jmp 0x877f;
                                // Block 0x877F
                                mov word ptr [bp - 2], 0xfff7;
                            }
                        }
                    } else {
                        // Block 0x8684
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        // Compare $1 with $2
                        if (a <= b (unsigned)) {  // jbe 0x8696
                            // Block 0x8696
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0x86ae
                                // Block 0x86AE
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                INT_10_AH10();  // int 0x10
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1++;
                                loop 0x86ae;
                                jmp 0x8778;
                                // Block 0x8778
                                mov word ptr [bp - 2], 0;
                                jmp 0x8784;
                                // Block 0x8784
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            } else {
                                // Block 0x869B
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = pop();
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH10();  // int 0x10
                                $1 = pop();
                                jmp 0x8778;
                                // Block 0x8778
                                mov word ptr [bp - 2], 0;
                                jmp 0x8784;
                                // Block 0x8784
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x8693
                            jmp 0x877f;
                            // Block 0x877F
                            mov word ptr [bp - 2], 0xfff7;
                        }
                    }
                } else {
                    // Block 0x8671
                    $1 = $2;
                    $1 = 0;
                    push($1);
                    $1 = $2;
                    INT_10_AH0B();  // int 0x10
                    $1 = pop();
                    jmp 0x8778;
                    // Block 0x8778
                    mov word ptr [bp - 2], 0;
                    jmp 0x8784;
                    // Block 0x8784
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                }
            } else {
                // Block 0x8629
                $1 = $2;
                $1 = $2;
                // Compare $1 with $2
                if (a < b) {  // jl 0x8634
                    // Block 0x8634
                    or al, al;
                    if (a != b) {  // jne 0x863c
                        // Block 0x863C
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x8647
                            // Block 0x8647
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x864f
                                // Block 0x864F
                                $1 = $2;
                                or dh, 0x10;
                            } else {
                                // Block 0x864B
                                $1 = $2;
                                jmp 0x8654;
                                // Block 0x8654
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH0B();  // int 0x10
                                $1 = pop();
                                $1 = 0;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH0B();  // int 0x10
                                $1 = pop();
                                jmp 0x8778;
                                // Block 0x8778
                                mov word ptr [bp - 2], 0;
                                jmp 0x8784;
                                // Block 0x8784
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x8640
                            $1 = 0;
                            or dh, 0x10;
                            jmp 0x8654;
                            // Block 0x8654
                            $1 = $2;
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH0B();  // int 0x10
                            $1 = pop();
                            $1 = 0;
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH0B();  // int 0x10
                            $1 = pop();
                            jmp 0x8778;
                            // Block 0x8778
                            mov word ptr [bp - 2], 0;
                            jmp 0x8784;
                            // Block 0x8784
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        }
                    } else {
                        // Block 0x8638
                        $1 = 0;
                        jmp 0x8654;
                        // Block 0x8654
                        $1 = $2;
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        INT_10_AH0B();  // int 0x10
                        $1 = pop();
                        $1 = 0;
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        INT_10_AH0B();  // int 0x10
                        $1 = pop();
                        jmp 0x8778;
                        // Block 0x8778
                        mov word ptr [bp - 2], 0;
                        jmp 0x8784;
                        // Block 0x8784
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 0xa
                    }
                } else {
                    // Block 0x8632
                    sub al, 4;
                }
            }
        } else {
            // Block 0x8620
            jmp 0x877f;
            // Block 0x877F
            mov word ptr [bp - 2], 0xfff7;
        }
    } else {
        // Block 0x8617
        jmp 0x8778;
        // Block 0x8778
        mov word ptr [bp - 2], 0;
        jmp 0x8784;
        // Block 0x8784
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_8791(int) {
    // Purpose: Performs video operations and manipulates strings or memory blocks and performs calculations

    // Complexity: 6

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 15 if statements

    // Block 0x8791
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cmp word ptr [bp + 0xe], 0;
    if (a != b) {  // jne 0x87ac
        // Block 0x87AC
        cmp word ptr [bp + 0xe], 1;
        if (a == b) {  // je 0x87ba
            // Block 0x87BA
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 = $2;
            and bl, 0xf;
            mov byte ptr es:[di], bl;
            $1 = $2;
            and bl, 0x20;
            $1 = $2;
            shr bl, cl;
            $1 = $2;
            $1 = $2;
            and bl, 0x10;
            $1 = $2;
            shr bl, cl;
            $1 += $2;
            mov byte ptr es:[di + 1], bl;
            jmp 0x88d8;
            // Block 0x88D8
            mov word ptr [bp - 2], 0;
            jmp 0x88e4;
            // Block 0x88E4
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xa
        } else {
            // Block 0x87B2
            cmp word ptr [bp + 0xe], 2;
            if (a == b) {  // je 0x87ba
                // Block 0x87BA
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                $1 = $2;
                $1 = $2;
                $1 = $2;
                and bl, 0xf;
                mov byte ptr es:[di], bl;
                $1 = $2;
                and bl, 0x20;
                $1 = $2;
                shr bl, cl;
                $1 = $2;
                $1 = $2;
                and bl, 0x10;
                $1 = $2;
                shr bl, cl;
                $1 += $2;
                mov byte ptr es:[di + 1], bl;
                jmp 0x88d8;
                // Block 0x88D8
                mov word ptr [bp - 2], 0;
                jmp 0x88e4;
                // Block 0x88E4
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xa
            } else {
                // Block 0x87B8
                jmp 0x87eb;
                // Block 0x87EB
                cmp word ptr [bp + 0xe], 3;
                if (a != b) {  // jne 0x8859
                    // Block 0x8859
                    cmp word ptr [bp + 0xe], 4;
                    if (a != b) {  // jne 0x88b7
                        // Block 0x88B7
                        cmp word ptr [bp + 0xe], 5;
                        if (a != b) {  // jne 0x88df
                            // Block 0x88DF
                            mov word ptr [bp - 2], 0xfff7;
                        } else {
                            // Block 0x88BD
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 += $2;
                            // Compare $1 with $2
                            if (a <= b (unsigned)) {  // jbe 0x88ce
                                // Block 0x88CE
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH10();  // int 0x10
                                pop bp;
                            } else {
                                // Block 0x88CC
                                jmp 0x88df;
                                // Block 0x88DF
                                mov word ptr [bp - 2], 0xfff7;
                            }
                        }
                    } else {
                        // Block 0x885F
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        INT_10_AH10();  // int 0x10
                        $1 = pop();
                        $1 = $2;
                        shl bl, 1;
                        $1 -= $2;
                        $1 = $2;
                        shl bl, cl;
                        $1 = $2;
                        shl bh, cl;
                        not bh;
                        *($1) = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        // Compare $1 with $2
                        if (a <= b (unsigned)) {  // jbe 0x888b
                            // Block 0x888B
                            push($1);
                            push($1);
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH10();  // int 0x10
                            $1 = pop();
                            $1 = $2;
                            and bh, ah;
                            or bh, al;
                            $1 = $2;
                            $1 = 0;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH10();  // int 0x10
                            $1 = pop();
                            $1 += $2;
                            $1 = pop();
                            $1 = pop();
                            $1++;
                            loop 0x888b;
                            jmp 0x88d8;
                            // Block 0x88D8
                            mov word ptr [bp - 2], 0;
                            jmp 0x88e4;
                            // Block 0x88E4
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        } else {
                            // Block 0x8889
                            jmp 0x88df;
                            // Block 0x88DF
                            mov word ptr [bp - 2], 0xfff7;
                        }
                    }
                } else {
                    // Block 0x87F1
                    lcall 0x98e, 0x35e;
                    *($1) = $2;
                    $1 = $2;
                    $1 += $2;
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x8807
                        // Block 0x8807
                        push($1);
                        $1 = $2;
                        $1 = $2;
                        $1 = pop();
                        lds si, ptr [0xa8];
                        lds si, ptr [si + 4];
                        $1 = $2;
                        or ax, si;
                        if (a != b) {  // jne 0x8848
                            // Block 0x8848
                            $1 = $2;
                            $1 += $2;
                            rep movsb byte ptr es:[di], byte ptr [si];
                            cmp word ptr [bp + 0xa], 0x10;
                            if (a != b) {  // jne 0x8857
                                // Block 0x8857
                                jmp 0x88d8;
                                // Block 0x88D8
                                mov word ptr [bp - 2], 0;
                                jmp 0x88e4;
                                // Block 0x88E4
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            } else {
                                // Block 0x8856
                                movsb byte ptr es:[di], byte ptr [si];
                            }
                        } else {
                            // Block 0x881B
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            $1 = pop();
                            lea si, [bp - 0x18];
                            xor bx, bx;
                        }
                    } else {
                        // Block 0x8804
                        jmp 0x88df;
                        // Block 0x88DF
                        mov word ptr [bp - 2], 0xfff7;
                    }
                }
            }
        }
    } else {
        // Block 0x87A9
        jmp 0x88df;
        // Block 0x88DF
        mov word ptr [bp - 2], 0xfff7;
    }
}

void sub_893A(int) {
    // Purpose: Performs video operations and performs calculations

    // Complexity: 51

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 73 if statements

    // Block 0x893A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 0x36], 0x78;
    mov byte ptr [bp - 0x35], 0x7e;
    mov byte ptr [bp - 0x34], 0x28;
    mov byte ptr [bp - 0x33], 0x28;
    mov byte ptr [bp - 0x32], 0x28;
    mov byte ptr [bp - 0x31], 0x28;
    mov byte ptr [bp - 0x30], 0x18;
    mov byte ptr [bp - 0x2f], 8;
    mov byte ptr [bp - 0x2e], 0x18;
    mov byte ptr [bp - 0x2d], 7;
    mov byte ptr [bp - 0x2c], 8;
    mov byte ptr [bp - 0x2b], 8;
    mov byte ptr [bp - 0x2a], 8;
    mov byte ptr [bp - 0x29], 8;
    mov byte ptr [bp - 0x28], 8;
    mov byte ptr [bp - 0x27], 8;
    mov byte ptr [bp - 0x26], 8;
    mov byte ptr [bp - 0x25], 8;
    mov byte ptr [bp - 0x24], 8;
    mov byte ptr [bp - 0x23], 8;
    mov byte ptr [bp - 0x22], 8;
    mov byte ptr [bp - 0x21], 8;
    mov byte ptr [bp - 0x20], 8;
    mov byte ptr [bp - 0x1f], 8;
    mov byte ptr [bp - 0x1e], 8;
    mov byte ptr [bp - 0x1d], 8;
    mov byte ptr [bp - 0x1c], 8;
    mov byte ptr [bp - 0x1b], 8;
    mov byte ptr [bp - 0x1a], 8;
    mov byte ptr [bp - 0x19], 8;
    mov byte ptr [bp - 0x18], 8;
    mov byte ptr [bp - 0x17], 8;
    mov byte ptr [bp - 0x16], 8;
    mov byte ptr [bp - 0x15], 8;
    mov byte ptr [bp - 0x14], 8;
    mov byte ptr [bp - 0x13], 8;
    mov byte ptr [bp - 0x12], 8;
    mov byte ptr [bp - 0x11], 8;
    mov byte ptr [bp - 0x10], 8;
    mov byte ptr [bp - 0xf], 8;
    mov byte ptr [bp - 0xe], 8;
    mov byte ptr [bp - 0x60], 0x78;
    mov byte ptr [bp - 0x5f], 0x78;
    mov byte ptr [bp - 0x5e], 0x38;
    mov byte ptr [bp - 0x5d], 0x38;
    mov byte ptr [bp - 0x5c], 0x98;
    mov byte ptr [bp - 0x5b], 0x38;
    mov byte ptr [bp - 0x5a], 0x18;
    mov byte ptr [bp - 0x59], 0x18;
    mov byte ptr [bp - 0x58], 0x18;
    mov byte ptr [bp - 0x57], 0xa0;
    mov byte ptr [bp - 0x56], 0x18;
    mov byte ptr [bp - 0x55], 0x18;
    mov byte ptr [bp - 0x54], 0x18;
    mov byte ptr [bp - 0x53], 0x18;
    mov byte ptr [bp - 0x52], 0x18;
    mov byte ptr [bp - 0x51], 0x98;
    mov byte ptr [bp - 0x50], 0x18;
    mov byte ptr [bp - 0x4f], 0x18;
    mov byte ptr [bp - 0x4e], 0x18;
    mov byte ptr [bp - 0x4d], 0x18;
    mov byte ptr [bp - 0x4c], 0x18;
    mov byte ptr [bp - 0x4b], 0x18;
    mov byte ptr [bp - 0x4a], 0x18;
    mov byte ptr [bp - 0x49], 0x18;
    mov byte ptr [bp - 0x48], 0x18;
    mov byte ptr [bp - 0x47], 0x18;
    mov byte ptr [bp - 0x46], 0x18;
    mov byte ptr [bp - 0x45], 0x18;
    mov byte ptr [bp - 0x44], 0x18;
    mov byte ptr [bp - 0x43], 0x18;
    mov byte ptr [bp - 0x42], 0x18;
    mov byte ptr [bp - 0x41], 0x18;
    mov byte ptr [bp - 0x40], 0x18;
    mov byte ptr [bp - 0x3f], 0x18;
    mov byte ptr [bp - 0x3e], 0x18;
    mov byte ptr [bp - 0x3d], 0x18;
    mov byte ptr [bp - 0x3c], 0x18;
    mov byte ptr [bp - 0x3b], 0x18;
    mov byte ptr [bp - 0x3a], 0x18;
    mov byte ptr [bp - 0x39], 0x18;
    mov byte ptr [bp - 0x38], 0x18;
    mov byte ptr [bp - 0x80], 0x88;
    mov byte ptr [bp - 0x7f], 0x88;
    mov byte ptr [bp - 0x7e], 0x88;
    mov byte ptr [bp - 0x7d], 0x88;
    mov byte ptr [bp - 0x7c], 0x40;
    mov byte ptr [bp - 0x7b], 0x40;
    mov byte ptr [bp - 0x7a], 0x40;
    mov byte ptr [bp - 0x79], 0x40;
    mov byte ptr [bp - 0x78], 0x20;
    mov byte ptr [bp - 0x77], 0x20;
    mov byte ptr [bp - 0x76], 0x20;
    mov byte ptr [bp - 0x75], 0x20;
    mov byte ptr [bp - 0x74], 0x10;
    mov byte ptr [bp - 0x73], 0x10;
    mov byte ptr [bp - 0x72], 0x10;
    mov byte ptr [bp - 0x71], 0x10;
    mov byte ptr [bp - 0x70], 8;
    mov byte ptr [bp - 0x6f], 0x40;
    mov byte ptr [bp - 0x6e], 0x40;
    mov byte ptr [bp - 0x6d], 0x20;
    mov byte ptr [bp - 0x6c], 0x10;
    mov byte ptr [bp - 0x6b], 4;
    mov byte ptr [bp - 0x6a], 4;
    mov byte ptr [bp - 0x69], 4;
    mov byte ptr [bp - 0x68], 4;
    mov byte ptr [bp - 0x67], 4;
    mov byte ptr [bp - 0x66], 0xfc;
    mov byte ptr [bp - 0x65], 0xfc;
    mov byte ptr [bp - 0x64], 0xfc;
    mov byte ptr [bp - 0x63], 0xfc;
    mov byte ptr [bp - 0x62], 0xfc;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0x8b19
        // Block 0x8B19
        push($1);
        lea ax, [bp - 6];
        push($1);
        lcall 0xae3, 0;
        or ax, ax;
        if (a == b) {  // je 0x8b2d
            // Block 0x8B2D
            // Compare $1 with $2
            if (a == b) {  // je 0x8b37
                // Block 0x8B37
                cmp byte ptr [bp - 4], 0;
                if (a == b) {  // je 0x8b40
                    // Block 0x8B40
                    cmp byte ptr [bp - 6], 0x80;
                    if (a < b (unsigned)) {  // jb 0x8b4a
                        // Block 0x8B4A
                        $1 = $2;
                        $1 = $2;
                        clc ;
                        shl al, cl;
                        if (a < b (unsigned)) {  // jb 0x8b58
                            // Block 0x8B58
                            $1 = $2;
                            $1 = $2;
                            clc ;
                            shl al, cl;
                            if (a < b (unsigned)) {  // jb 0x8b66
                                // Block 0x8B66
                                // Compare $1 with $2
                                if (a >= b (unsigned)) {  // jae 0x8b6e
                                    // Block 0x8B6E
                                    lcall 0x921, 0x1a5;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x8bb9
                                        // Block 0x8BB9
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0x8bca
                                            // Block 0x8BCA
                                            push($1);
                                            push($1);
                                            lea ax, [bp - 0xc];
                                            push($1);
                                            lcall 0x921, 0x1fc;
                                            or ax, ax;
                                            if (a == b) {  // je 0x8bde
                                                // Block 0x8BDE
                                                $1 = $2;
                                                $1 = $2;
                                                clc ;
                                                shl al, cl;
                                                if (a < b (unsigned)) {  // jb 0x8bec
                                                    // Block 0x8BEC
                                                    // Compare $1 with $2
                                                    if (a < b (unsigned)) {  // jb 0x8c05
                                                        // Block 0x8C05
                                                        // Compare $1 with $2
                                                        if (a > b (unsigned)) {  // ja 0x8c11
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        } else {
                                                            // Block 0x8C0A
                                                            mov word ptr [bp - 2], 0;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    } else {
                                                        // Block 0x8BF1
                                                        push($1);
                                                        push($1);
                                                        lcall 0x98e, 0xc;
                                                        $1 = $2;
                                                        or si, si;
                                                        if (a >= b) {  // jge 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8C00
                                                            *($1) = $2;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x8BEA
                                                    jmp 0x8c11;
                                                    // Block 0x8C11
                                                    mov word ptr [bp - 2], 0xfffa;
                                                }
                                            } else {
                                                // Block 0x8BD9
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8BBE
                                            lcall 0x921, 0x55;
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0x8bca
                                                // Block 0x8BCA
                                                push($1);
                                                push($1);
                                                lea ax, [bp - 0xc];
                                                push($1);
                                                lcall 0x921, 0x1fc;
                                                or ax, ax;
                                                if (a == b) {  // je 0x8bde
                                                    // Block 0x8BDE
                                                    $1 = $2;
                                                    $1 = $2;
                                                    clc ;
                                                    shl al, cl;
                                                    if (a < b (unsigned)) {  // jb 0x8bec
                                                        // Block 0x8BEC
                                                        // Compare $1 with $2
                                                        if (a < b (unsigned)) {  // jb 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8BF1
                                                            push($1);
                                                            push($1);
                                                            lcall 0x98e, 0xc;
                                                            $1 = $2;
                                                            or si, si;
                                                            if (a >= b) {  // jge 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8C00
                                                                *($1) = $2;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x8BEA
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BD9
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8BC8
                                                jmp 0x8c11;
                                                // Block 0x8C11
                                                mov word ptr [bp - 2], 0xfffa;
                                            }
                                        }
                                    } else {
                                        // Block 0x8B78
                                        // Compare $1 with $2
                                        if (a >= b (unsigned)) {  // jae 0x8b80
                                            // Block 0x8B80
                                            push($1);
                                            lcall 0x98e, 0xdf;
                                            if (a >= b (unsigned)) {  // jae 0x8b8e
                                                // Block 0x8B8E
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                INT_10_AH4F();  // int 0x10
                                                // Compare $1 with $2
                                                if (a == b) {  // je 0x8bb0
                                                    // Block 0x8BB0
                                                    test word ptr es:[di], 1;
                                                    if (a != b) {  // jne 0x8c0a
                                                        // Block 0x8C0A
                                                        mov word ptr [bp - 2], 0;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    } else {
                                                        // Block 0x8BB7
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BA9
                                                    mov word ptr [bp - 2], 0xffd8;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8B88
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8B7D
                                            jmp 0x8c11;
                                            // Block 0x8C11
                                            mov word ptr [bp - 2], 0xfffa;
                                        }
                                    }
                                } else {
                                    // Block 0x8B6B
                                    jmp 0x8c0a;
                                    // Block 0x8C0A
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x8c16;
                                    // Block 0x8C16
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 2
                                }
                            } else {
                                // Block 0x8B63
                                jmp 0x8c11;
                                // Block 0x8C11
                                mov word ptr [bp - 2], 0xfffa;
                            }
                        } else {
                            // Block 0x8B55
                            jmp 0x8c11;
                            // Block 0x8C11
                            mov word ptr [bp - 2], 0xfffa;
                        }
                    } else {
                        // Block 0x8B46
                        sub byte ptr [bp - 6], 0x7a;
                    }
                } else {
                    // Block 0x8B3D
                    jmp 0x8c11;
                    // Block 0x8C11
                    mov word ptr [bp - 2], 0xfffa;
                }
            } else {
                // Block 0x8B32
                // Compare $1 with $2
                if (a != b) {  // jne 0x8b40
                    // Block 0x8B40
                    cmp byte ptr [bp - 6], 0x80;
                    if (a < b (unsigned)) {  // jb 0x8b4a
                        // Block 0x8B4A
                        $1 = $2;
                        $1 = $2;
                        clc ;
                        shl al, cl;
                        if (a < b (unsigned)) {  // jb 0x8b58
                            // Block 0x8B58
                            $1 = $2;
                            $1 = $2;
                            clc ;
                            shl al, cl;
                            if (a < b (unsigned)) {  // jb 0x8b66
                                // Block 0x8B66
                                // Compare $1 with $2
                                if (a >= b (unsigned)) {  // jae 0x8b6e
                                    // Block 0x8B6E
                                    lcall 0x921, 0x1a5;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x8bb9
                                        // Block 0x8BB9
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0x8bca
                                            // Block 0x8BCA
                                            push($1);
                                            push($1);
                                            lea ax, [bp - 0xc];
                                            push($1);
                                            lcall 0x921, 0x1fc;
                                            or ax, ax;
                                            if (a == b) {  // je 0x8bde
                                                // Block 0x8BDE
                                                $1 = $2;
                                                $1 = $2;
                                                clc ;
                                                shl al, cl;
                                                if (a < b (unsigned)) {  // jb 0x8bec
                                                    // Block 0x8BEC
                                                    // Compare $1 with $2
                                                    if (a < b (unsigned)) {  // jb 0x8c05
                                                        // Block 0x8C05
                                                        // Compare $1 with $2
                                                        if (a > b (unsigned)) {  // ja 0x8c11
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        } else {
                                                            // Block 0x8C0A
                                                            mov word ptr [bp - 2], 0;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    } else {
                                                        // Block 0x8BF1
                                                        push($1);
                                                        push($1);
                                                        lcall 0x98e, 0xc;
                                                        $1 = $2;
                                                        or si, si;
                                                        if (a >= b) {  // jge 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8C00
                                                            *($1) = $2;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x8BEA
                                                    jmp 0x8c11;
                                                    // Block 0x8C11
                                                    mov word ptr [bp - 2], 0xfffa;
                                                }
                                            } else {
                                                // Block 0x8BD9
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8BBE
                                            lcall 0x921, 0x55;
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0x8bca
                                                // Block 0x8BCA
                                                push($1);
                                                push($1);
                                                lea ax, [bp - 0xc];
                                                push($1);
                                                lcall 0x921, 0x1fc;
                                                or ax, ax;
                                                if (a == b) {  // je 0x8bde
                                                    // Block 0x8BDE
                                                    $1 = $2;
                                                    $1 = $2;
                                                    clc ;
                                                    shl al, cl;
                                                    if (a < b (unsigned)) {  // jb 0x8bec
                                                        // Block 0x8BEC
                                                        // Compare $1 with $2
                                                        if (a < b (unsigned)) {  // jb 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8BF1
                                                            push($1);
                                                            push($1);
                                                            lcall 0x98e, 0xc;
                                                            $1 = $2;
                                                            or si, si;
                                                            if (a >= b) {  // jge 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8C00
                                                                *($1) = $2;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x8BEA
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BD9
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8BC8
                                                jmp 0x8c11;
                                                // Block 0x8C11
                                                mov word ptr [bp - 2], 0xfffa;
                                            }
                                        }
                                    } else {
                                        // Block 0x8B78
                                        // Compare $1 with $2
                                        if (a >= b (unsigned)) {  // jae 0x8b80
                                            // Block 0x8B80
                                            push($1);
                                            lcall 0x98e, 0xdf;
                                            if (a >= b (unsigned)) {  // jae 0x8b8e
                                                // Block 0x8B8E
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                INT_10_AH4F();  // int 0x10
                                                // Compare $1 with $2
                                                if (a == b) {  // je 0x8bb0
                                                    // Block 0x8BB0
                                                    test word ptr es:[di], 1;
                                                    if (a != b) {  // jne 0x8c0a
                                                        // Block 0x8C0A
                                                        mov word ptr [bp - 2], 0;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    } else {
                                                        // Block 0x8BB7
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BA9
                                                    mov word ptr [bp - 2], 0xffd8;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8B88
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8B7D
                                            jmp 0x8c11;
                                            // Block 0x8C11
                                            mov word ptr [bp - 2], 0xfffa;
                                        }
                                    }
                                } else {
                                    // Block 0x8B6B
                                    jmp 0x8c0a;
                                    // Block 0x8C0A
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x8c16;
                                    // Block 0x8C16
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 2
                                }
                            } else {
                                // Block 0x8B63
                                jmp 0x8c11;
                                // Block 0x8C11
                                mov word ptr [bp - 2], 0xfffa;
                            }
                        } else {
                            // Block 0x8B55
                            jmp 0x8c11;
                            // Block 0x8C11
                            mov word ptr [bp - 2], 0xfffa;
                        }
                    } else {
                        // Block 0x8B46
                        sub byte ptr [bp - 6], 0x7a;
                    }
                } else {
                    // Block 0x8B37
                    cmp byte ptr [bp - 4], 0;
                    if (a == b) {  // je 0x8b40
                        // Block 0x8B40
                        cmp byte ptr [bp - 6], 0x80;
                        if (a < b (unsigned)) {  // jb 0x8b4a
                            // Block 0x8B4A
                            $1 = $2;
                            $1 = $2;
                            clc ;
                            shl al, cl;
                            if (a < b (unsigned)) {  // jb 0x8b58
                                // Block 0x8B58
                                $1 = $2;
                                $1 = $2;
                                clc ;
                                shl al, cl;
                                if (a < b (unsigned)) {  // jb 0x8b66
                                    // Block 0x8B66
                                    // Compare $1 with $2
                                    if (a >= b (unsigned)) {  // jae 0x8b6e
                                        // Block 0x8B6E
                                        lcall 0x921, 0x1a5;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x8bb9
                                            // Block 0x8BB9
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0x8bca
                                                // Block 0x8BCA
                                                push($1);
                                                push($1);
                                                lea ax, [bp - 0xc];
                                                push($1);
                                                lcall 0x921, 0x1fc;
                                                or ax, ax;
                                                if (a == b) {  // je 0x8bde
                                                    // Block 0x8BDE
                                                    $1 = $2;
                                                    $1 = $2;
                                                    clc ;
                                                    shl al, cl;
                                                    if (a < b (unsigned)) {  // jb 0x8bec
                                                        // Block 0x8BEC
                                                        // Compare $1 with $2
                                                        if (a < b (unsigned)) {  // jb 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8BF1
                                                            push($1);
                                                            push($1);
                                                            lcall 0x98e, 0xc;
                                                            $1 = $2;
                                                            or si, si;
                                                            if (a >= b) {  // jge 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8C00
                                                                *($1) = $2;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x8BEA
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BD9
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8BBE
                                                lcall 0x921, 0x55;
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0x8bca
                                                    // Block 0x8BCA
                                                    push($1);
                                                    push($1);
                                                    lea ax, [bp - 0xc];
                                                    push($1);
                                                    lcall 0x921, 0x1fc;
                                                    or ax, ax;
                                                    if (a == b) {  // je 0x8bde
                                                        // Block 0x8BDE
                                                        $1 = $2;
                                                        $1 = $2;
                                                        clc ;
                                                        shl al, cl;
                                                        if (a < b (unsigned)) {  // jb 0x8bec
                                                            // Block 0x8BEC
                                                            // Compare $1 with $2
                                                            if (a < b (unsigned)) {  // jb 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8BF1
                                                                push($1);
                                                                push($1);
                                                                lcall 0x98e, 0xc;
                                                                $1 = $2;
                                                                or si, si;
                                                                if (a >= b) {  // jge 0x8c05
                                                                    // Block 0x8C05
                                                                    // Compare $1 with $2
                                                                    if (a > b (unsigned)) {  // ja 0x8c11
                                                                        // Block 0x8C11
                                                                        mov word ptr [bp - 2], 0xfffa;
                                                                    } else {
                                                                        // Block 0x8C0A
                                                                        mov word ptr [bp - 2], 0;
                                                                        jmp 0x8c16;
                                                                        // Block 0x8C16
                                                                        $1 = $2;
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        $1 = $2;
                                                                        $1 = pop();
                                                                        return;  // retf 2
                                                                    }
                                                                } else {
                                                                    // Block 0x8C00
                                                                    *($1) = $2;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x8BEA
                                                            jmp 0x8c11;
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        }
                                                    } else {
                                                        // Block 0x8BD9
                                                        *($1) = $2;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    }
                                                } else {
                                                    // Block 0x8BC8
                                                    jmp 0x8c11;
                                                    // Block 0x8C11
                                                    mov word ptr [bp - 2], 0xfffa;
                                                }
                                            }
                                        } else {
                                            // Block 0x8B78
                                            // Compare $1 with $2
                                            if (a >= b (unsigned)) {  // jae 0x8b80
                                                // Block 0x8B80
                                                push($1);
                                                lcall 0x98e, 0xdf;
                                                if (a >= b (unsigned)) {  // jae 0x8b8e
                                                    // Block 0x8B8E
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    INT_10_AH4F();  // int 0x10
                                                    // Compare $1 with $2
                                                    if (a == b) {  // je 0x8bb0
                                                        // Block 0x8BB0
                                                        test word ptr es:[di], 1;
                                                        if (a != b) {  // jne 0x8c0a
                                                            // Block 0x8C0A
                                                            mov word ptr [bp - 2], 0;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        } else {
                                                            // Block 0x8BB7
                                                            jmp 0x8c11;
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        }
                                                    } else {
                                                        // Block 0x8BA9
                                                        mov word ptr [bp - 2], 0xffd8;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    }
                                                } else {
                                                    // Block 0x8B88
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8B7D
                                                jmp 0x8c11;
                                                // Block 0x8C11
                                                mov word ptr [bp - 2], 0xfffa;
                                            }
                                        }
                                    } else {
                                        // Block 0x8B6B
                                        jmp 0x8c0a;
                                        // Block 0x8C0A
                                        mov word ptr [bp - 2], 0;
                                        jmp 0x8c16;
                                        // Block 0x8C16
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 2
                                    }
                                } else {
                                    // Block 0x8B63
                                    jmp 0x8c11;
                                    // Block 0x8C11
                                    mov word ptr [bp - 2], 0xfffa;
                                }
                            } else {
                                // Block 0x8B55
                                jmp 0x8c11;
                                // Block 0x8C11
                                mov word ptr [bp - 2], 0xfffa;
                            }
                        } else {
                            // Block 0x8B46
                            sub byte ptr [bp - 6], 0x7a;
                        }
                    } else {
                        // Block 0x8B3D
                        jmp 0x8c11;
                        // Block 0x8C11
                        mov word ptr [bp - 2], 0xfffa;
                    }
                }
            }
        } else {
            // Block 0x8B27
            *($1) = $2;
            jmp 0x8c16;
            // Block 0x8C16
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    } else {
        // Block 0x8B16
        jmp 0x8c11;
        // Block 0x8C11
        mov word ptr [bp - 2], 0xfffa;
    }

    // Function calls:
    sub_893A(); // Performs video operations and performs calculations
    sub_893A(); // Performs video operations and performs calculations
    sub_893A(); // Performs video operations and performs calculations
    sub_893A(); // Performs video operations and performs calculations
    sub_901A(); // Allocates memory and manipulates strings or memory blocks and performs calculations
}

void sub_901A(int, int) {
    // Purpose: Allocates memory and manipulates strings or memory blocks and performs calculations

    // Complexity: 55

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 107 if statements

    // Block 0x901A
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x5ab;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x637;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov byte ptr [0x55f3], 1;
    return;  // retf 

    // Function calls:
    sub_987E(); // Opens a file and manipulates strings or memory blocks and performs calculations
}

void sub_987E(int, int) {
    // Purpose: Opens a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 5

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 50 if statements

    // Block 0x987E
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x2dd;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x31e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov byte ptr [0x55f1], 1;
    return;  // retf 

    // Function calls:
    sub_9EBD(); // Reads data from a file and performs calculations
}

void sub_9EBD(int) {
    // Purpose: Reads data from a file and performs calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x9EBD
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    cmp byte ptr es:[di], 1;
    if (a == b) {  // je 0x9ee3
        // Block 0x9EE3
        $1 = $2;
        // Compare $1 with $2
        if (a != b) {  // jne 0x9eee
            // Block 0x9EEE
            // Compare $1 with $2
            if (a <= b (unsigned)) {  // jbe 0x9efb
                // Block 0x9EFB
                $1 = $2;
                $1 -= $2;
                if (condition_jns) {  // jns 0x9f07
                    // Block 0x9F07
                    // Compare $1 with $2
                    if (a < b (unsigned)) {  // jb 0x9f0d
                        // Block 0x9F0D
                        *($1) = $2;
                        $1 = $2;
                        mul bx;
                        $1 += $2;
                        adc dx, word ptr es:[di + 0x48];
                        $1 += $2;
                        adc dx, 0;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        DOS_MoveFilePointer();  // int 0x21
                        $1 = $2;
                        // Compare $1 with $2
                        if (a < b (unsigned)) {  // jb 0x9f3f
                            // Block 0x9F3F
                            $1 = $2;
                            mul bx;
                            lds si, ptr es:[di + 0x50];
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_ReadFile();  // int 0x21
                            if (a >= b (unsigned)) {  // jae 0x9f5d
                                // Block 0x9F5D
                                $1 = $2;
                                mov word ptr es:[di + 0x4a], ax;
                                $1 = $2;
                                mov word ptr es:[di + 0x4c], ax;
                            } else {
                                // Block 0x9F56
                                mov word ptr [bp - 2], 0xfffd;
                                jmp 0x9f70;
                                // Block 0x9F70
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            }
                        } else {
                            // Block 0x9F3B
                            mov ax, word ptr es:[di + 0x44];
                        }
                    } else {
                        // Block 0x9F0B
                        mov ax, bx;
                    }
                } else {
                    // Block 0x9F05
                    xor bx, bx;
                }
            } else {
                // Block 0x9EF4
                mov word ptr [bp - 2], 0xfc19;
                jmp 0x9f70;
                // Block 0x9F70
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 6
            }
        } else {
            // Block 0x9EEC
            jmp 0x9f6b;
            // Block 0x9F6B
            mov word ptr [bp - 2], 0;
        }
    } else {
        // Block 0x9ED5
        cmp byte ptr es:[di], 2;
        if (a == b) {  // je 0x9ee3
            // Block 0x9EE3
            $1 = $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x9eee
                // Block 0x9EEE
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0x9efb
                    // Block 0x9EFB
                    $1 = $2;
                    $1 -= $2;
                    if (condition_jns) {  // jns 0x9f07
                        // Block 0x9F07
                        // Compare $1 with $2
                        if (a < b (unsigned)) {  // jb 0x9f0d
                            // Block 0x9F0D
                            *($1) = $2;
                            $1 = $2;
                            mul bx;
                            $1 += $2;
                            adc dx, word ptr es:[di + 0x48];
                            $1 += $2;
                            adc dx, 0;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_MoveFilePointer();  // int 0x21
                            $1 = $2;
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0x9f3f
                                // Block 0x9F3F
                                $1 = $2;
                                mul bx;
                                lds si, ptr es:[di + 0x50];
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                DOS_ReadFile();  // int 0x21
                                if (a >= b (unsigned)) {  // jae 0x9f5d
                                    // Block 0x9F5D
                                    $1 = $2;
                                    mov word ptr es:[di + 0x4a], ax;
                                    $1 = $2;
                                    mov word ptr es:[di + 0x4c], ax;
                                } else {
                                    // Block 0x9F56
                                    mov word ptr [bp - 2], 0xfffd;
                                    jmp 0x9f70;
                                    // Block 0x9F70
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 6
                                }
                            } else {
                                // Block 0x9F3B
                                mov ax, word ptr es:[di + 0x44];
                            }
                        } else {
                            // Block 0x9F0B
                            mov ax, bx;
                        }
                    } else {
                        // Block 0x9F05
                        xor bx, bx;
                    }
                } else {
                    // Block 0x9EF4
                    mov word ptr [bp - 2], 0xfc19;
                    jmp 0x9f70;
                    // Block 0x9F70
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 6
                }
            } else {
                // Block 0x9EEC
                jmp 0x9f6b;
                // Block 0x9F6B
                mov word ptr [bp - 2], 0;
            }
        } else {
            // Block 0x9EDB
            mov word ptr [bp - 2], 0xfff4;
            jmp 0x9f70;
            // Block 0x9F70
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 6
        }
    }
}

void sub_9F7D(int) {
    // Purpose: Opens a file and manipulates strings or memory blocks and performs calculations

    // Complexity: 19

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 65 if statements

    // Block 0x9F7D
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    cmp byte ptr [si], 0;
    if (a == b) {  // je 0x9faa
        // Block 0x9FAA
        $1 = $2;
        INT_21();  // int 0x21
        $1 = $2;
        *($1) = $2;
        *($1) = $2;
        push($1);
        $1 = $2;
        $1 = $2;
        lea dx, [bp - 0x96];
        $1 = $2;
        INT_21_AH1A();  // int 0x21
        $1 = pop();
        cmp word ptr [bp + 6], -1;
        if (a == b) {  // je 0x9fde
            // Block 0x9FDE
            $1 = $2;
            $1 = $2;
            push($1);
            cld ;
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 -= $2;
            *($1) = $2;
            mov word ptr [bp + 0xc], di;
        } else {
            // Block 0x9FCA
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            INT_21_AH1A();  // int 0x21
            $1 = pop();
            cmp word ptr [bp + 6], 1;
            if (a == b) {  // je 0xa024
                // Block 0xA024
                $1 = $2;
                INT_21();  // int 0x21
                if (a >= b (unsigned)) {  // jae 0xa031
                    // Block 0xA031
                    $1 = $2;
                    INT_21();  // int 0x21
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    $1 = pop();
                    $1 = $2;
                    les di, ptr [bp + 8];
                    mov byte ptr es:[di], 0;
                    $1 = 0;
                    mov word ptr es:[di + 0xe], ax;
                    mov word ptr es:[di + 0x10], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x12], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x14], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x16], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x18], ax;
                    $1 += $2;
                    $1 += $2;
                    $1 = $2;
                    cmp byte ptr [si], 0;
                    if (a == b) {  // je 0xa08e
                        // Block 0xA08E
                        mov byte ptr es:[di], 0x20;
                        $1++;
                        loop 0xa08e;
                    } else {
                        // Block 0xA078
                        cmp byte ptr [si], 0x2e;
                        if (a != b) {  // jne 0xa089
                            // Block 0xA089
                            movsb byte ptr es:[di], byte ptr [si];
                            loop 0xa073;
                            jmp 0xa095;
                            // Block 0xA095
                            mov byte ptr es:[di - 4], 0x2e;
                            mov byte ptr es:[di], 0;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0xA07D
                            // Compare $1 with $2
                            if (a == b) {  // je 0xa089
                                // Block 0xA089
                                movsb byte ptr es:[di], byte ptr [si];
                                loop 0xa073;
                                jmp 0xa095;
                                // Block 0xA095
                                mov byte ptr es:[di - 4], 0x2e;
                                mov byte ptr es:[di], 0;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xA082
                                mov byte ptr es:[di], 0x20;
                                $1++;
                                loop 0xa07d;
                            }
                        }
                    }
                } else {
                    // Block 0xA02A
                    mov word ptr [bp - 2], 0xfff2;
                    jmp 0xa0a3;
                    // Block 0xA0A3
                    lds dx, ptr [bp - 8];
                    $1 = $2;
                    INT_21_AH1A();  // int 0x21
                    jmp 0xa21f;
                    // Block 0xA21F
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xe
                }
            } else {
                // Block 0x9FDE
                $1 = $2;
                $1 = $2;
                push($1);
                cld ;
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                $1 = $2;
                $1 = $2;
                $1 -= $2;
                *($1) = $2;
                mov word ptr [bp + 0xc], di;
            }
        }
    } else {
        // Block 0x9F95
        cmp byte ptr [si], 1;
        if (a == b) {  // je 0x9fa7
            // Block 0x9FA7
            jmp 0xa0ad;
            // Block 0xA0AD
            push($1);
            cld ;
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 -= $2;
            *($1) = $2;
            mov word ptr [bp + 0xc], di;
        } else {
            // Block 0x9F9A
            cmp byte ptr [si], 2;
            if (a == b) {  // je 0x9fa7
                // Block 0x9FA7
                jmp 0xa0ad;
                // Block 0xA0AD
                push($1);
                cld ;
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                $1 = $2;
                $1 = $2;
                $1 -= $2;
                *($1) = $2;
                mov word ptr [bp + 0xc], di;
            } else {
                // Block 0x9F9F
                mov word ptr [bp - 2], 0xfff4;
                jmp 0xa21f;
                // Block 0xA21F
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xe
            }
        }
    }

    // Function calls:
    sub_9EBD(); // Reads data from a file and performs calculations
    sub_9F7D(); // Opens a file and manipulates strings or memory blocks and performs calculations
    sub_A70D(); // Manipulates strings or memory blocks and performs calculations
}

void sub_A70D(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 26

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 76 if statements

    // Block 0xA70D
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x4ba;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x548;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov byte ptr [0x55f0], 1;
    return;  // retf 
}

void sub_AE16(int) {
    // Purpose: Performs video operations and performs calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0xAE16
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffd9;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    INT_10_AH4F();  // int 0x10
    // Compare $1 with $2
    if (a != b) {  // jne 0xae58
        // Block 0xAE58
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    } else {
        // Block 0xAE38
        cmp byte ptr es:[di], 0x56;
        if (a != b) {  // jne 0xae58
            // Block 0xAE58
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        } else {
            // Block 0xAE3E
            cmp byte ptr es:[di + 1], 0x45;
            if (a != b) {  // jne 0xae58
                // Block 0xAE58
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            } else {
                // Block 0xAE45
                cmp byte ptr es:[di + 2], 0x53;
                if (a != b) {  // jne 0xae58
                    // Block 0xAE58
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                } else {
                    // Block 0xAE4C
                    cmp byte ptr es:[di + 3], 0x41;
                    if (a != b) {  // jne 0xae58
                        // Block 0xAE58
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 4
                    } else {
                        // Block 0xAE53
                        mov word ptr [bp - 2], 0;
                    }
                }
            }
        }
    }
}

void sub_AE65(int) {
    // Purpose: Performs video operations and performs calculations

    // Complexity: 11

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0xAE65
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0xae3, 0;
    cmp byte ptr [bp - 6], 5;
    if (a == b) {  // je 0xae87
        // Block 0xAE87
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = $2;
        cmp byte ptr es:[di], 0x33;
        if (a != b) {  // jne 0xaea6
            // Block 0xAEA6
            $1 = 0;
            push($1);
            $1 = $2;
            INT_10_AH6F();  // int 0x10
            $1 = pop();
            // Compare $1 with $2
            if (a != b) {  // jne 0xaebc
                // Block 0xAEBC
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1++;
                $1 = $2;
                out dx, al;
                $1--;
                $1 = $2;
                out dx, al;
                $1++;
                in al, dx;
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1 = 0;
                in al, dx;
                // Compare $1 with $2
                if (a != b) {  // jne 0xaeec
                    // Block 0xAEEC
                    $1 = $2;
                    in al, dx;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    in al, dx;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xaf4a
                        // Block 0xAF4A
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        test al, 0xe;
                        if (a == b) {  // je 0xaf5d
                            // Block 0xAF5D
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0xAF56
                            mov word ptr [bp - 2], 6;
                            jmp 0xaf62;
                            // Block 0xAF62
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xAEFA
                        $1 = $2;
                        out dx, al;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaf4a
                            // Block 0xAF4A
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            test al, 0xe;
                            if (a == b) {  // je 0xaf5d
                                // Block 0xAF5D
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xAF56
                                mov word ptr [bp - 2], 6;
                                jmp 0xaf62;
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xAF02
                            $1 = $2;
                            out dx, al;
                            mov word ptr [bp - 2], 1;
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            $1 = pop();
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            $1 = $2;
                            $1--;
                            $1 = $2;
                            out dx, ax;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            and al, 0xf;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf62
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xAF2D
                                $1--;
                                $1 = $2;
                                out dx, ax;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                and al, 0xf;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf62
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xAF3D
                                    $1--;
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, ax;
                                    mov word ptr [bp - 2], 5;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            }
                        }
                    }
                } else {
                    // Block 0xAED8
                    $1 = $2;
                    out dx, al;
                    $1 = 0;
                    in al, dx;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xaeec
                        // Block 0xAEEC
                        $1 = $2;
                        in al, dx;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaf4a
                            // Block 0xAF4A
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            test al, 0xe;
                            if (a == b) {  // je 0xaf5d
                                // Block 0xAF5D
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xAF56
                                mov word ptr [bp - 2], 6;
                                jmp 0xaf62;
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xAEFA
                            $1 = $2;
                            out dx, al;
                            in al, dx;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf4a
                                // Block 0xAF4A
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                test al, 0xe;
                                if (a == b) {  // je 0xaf5d
                                    // Block 0xAF5D
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0xAF56
                                    mov word ptr [bp - 2], 6;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xAF02
                                $1 = $2;
                                out dx, al;
                                mov word ptr [bp - 2], 1;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = pop();
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                $1 = $2;
                                $1--;
                                $1 = $2;
                                out dx, ax;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                and al, 0xf;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf62
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xAF2D
                                    $1--;
                                    $1 = $2;
                                    out dx, ax;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    and al, 0xf;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xaf62
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xAF3D
                                        $1--;
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, ax;
                                        mov word ptr [bp - 2], 5;
                                        jmp 0xaf62;
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xAEE2
                        $1 = $2;
                        out dx, al;
                        mov word ptr [bp - 2], 2;
                        jmp 0xaf62;
                        // Block 0xAF62
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0xAEB4
                mov word ptr [bp - 2], 3;
                jmp 0xaf62;
                // Block 0xAF62
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        } else {
            // Block 0xAE97
            cmp byte ptr es:[di + 1], 0x31;
            if (a != b) {  // jne 0xaea6
                // Block 0xAEA6
                $1 = 0;
                push($1);
                $1 = $2;
                INT_10_AH6F();  // int 0x10
                $1 = pop();
                // Compare $1 with $2
                if (a != b) {  // jne 0xaebc
                    // Block 0xAEBC
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    $1 = $2;
                    out dx, al;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1 = 0;
                    in al, dx;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xaeec
                        // Block 0xAEEC
                        $1 = $2;
                        in al, dx;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaf4a
                            // Block 0xAF4A
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            test al, 0xe;
                            if (a == b) {  // je 0xaf5d
                                // Block 0xAF5D
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xAF56
                                mov word ptr [bp - 2], 6;
                                jmp 0xaf62;
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xAEFA
                            $1 = $2;
                            out dx, al;
                            in al, dx;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf4a
                                // Block 0xAF4A
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                test al, 0xe;
                                if (a == b) {  // je 0xaf5d
                                    // Block 0xAF5D
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0xAF56
                                    mov word ptr [bp - 2], 6;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xAF02
                                $1 = $2;
                                out dx, al;
                                mov word ptr [bp - 2], 1;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = pop();
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                $1 = $2;
                                $1--;
                                $1 = $2;
                                out dx, ax;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                and al, 0xf;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf62
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xAF2D
                                    $1--;
                                    $1 = $2;
                                    out dx, ax;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    and al, 0xf;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xaf62
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xAF3D
                                        $1--;
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, ax;
                                        mov word ptr [bp - 2], 5;
                                        jmp 0xaf62;
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xAED8
                        $1 = $2;
                        out dx, al;
                        $1 = 0;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaeec
                            // Block 0xAEEC
                            $1 = $2;
                            in al, dx;
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            in al, dx;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf4a
                                // Block 0xAF4A
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                test al, 0xe;
                                if (a == b) {  // je 0xaf5d
                                    // Block 0xAF5D
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0xAF56
                                    mov word ptr [bp - 2], 6;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xAEFA
                                $1 = $2;
                                out dx, al;
                                in al, dx;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf4a
                                    // Block 0xAF4A
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    test al, 0xe;
                                    if (a == b) {  // je 0xaf5d
                                        // Block 0xAF5D
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0xAF56
                                        mov word ptr [bp - 2], 6;
                                        jmp 0xaf62;
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                } else {
                                    // Block 0xAF02
                                    $1 = $2;
                                    out dx, al;
                                    mov word ptr [bp - 2], 1;
                                    push($1);
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    $1 = $2;
                                    $1--;
                                    $1 = $2;
                                    out dx, ax;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    and al, 0xf;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xaf62
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xAF2D
                                        $1--;
                                        $1 = $2;
                                        out dx, ax;
                                        $1 = $2;
                                        out dx, al;
                                        $1++;
                                        in al, dx;
                                        and al, 0xf;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xaf62
                                            // Block 0xAF62
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xAF3D
                                            $1--;
                                            $1 = $2;
                                            $1 = $2;
                                            out dx, ax;
                                            mov word ptr [bp - 2], 5;
                                            jmp 0xaf62;
                                            // Block 0xAF62
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0xAEE2
                            $1 = $2;
                            out dx, al;
                            mov word ptr [bp - 2], 2;
                            jmp 0xaf62;
                            // Block 0xAF62
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0xAEB4
                    mov word ptr [bp - 2], 3;
                    jmp 0xaf62;
                    // Block 0xAF62
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0xAE9E
                mov word ptr [bp - 2], 4;
                jmp 0xaf62;
                // Block 0xAF62
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        }
    } else {
        // Block 0xAE84
        jmp 0xaf5d;
        // Block 0xAF5D
        mov word ptr [bp - 2], 0;
    }

    // Function calls:
    sub_AE16(); // Performs video operations and performs calculations
}

void sub_AFB5(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xAFB5
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_AFB5(); // Performs arithmetic calculations
    sub_AE65(); // Performs video operations and performs calculations
    sub_B00C(); // Manipulates strings or memory blocks and performs calculations
}

void sub_B00C(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 22

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 39 if statements

    // Block 0xB00C
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    les di, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0xb034
        // Block 0xB034
        // Compare $1 with $2
        if (a != b) {  // jne 0xb060
            // Block 0xB060
            // Compare $1 with $2
            if (a != b) {  // jne 0xb08c
                // Block 0xB08C
                // Compare $1 with $2
                if (a != b) {  // jne 0xb0dd
                    // Block 0xB0DD
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xb110
                        // Block 0xB110
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xb143
                            // Block 0xB143
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xb17b
                                // Block 0xB17B
                                mov word ptr [bp - 2], 0xffde;
                                $1 = $2;
                                *($1) = $2;
                                $1 = 0;
                                mov cx, 0xffff;
                            } else {
                                // Block 0xB148
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                call 0xae16;
                                // Block 0xB156
                                or ax, ax;
                                if (a != b) {  // jne 0xb17b
                                    // Block 0xB17B
                                    mov word ptr [bp - 2], 0xffde;
                                    $1 = $2;
                                    *($1) = $2;
                                    $1 = 0;
                                    mov cx, 0xffff;
                                } else {
                                    // Block 0xB15A
                                    $1 = $2;
                                    $1 = $2;
                                    for (ax = 0x10; ax < $2_2; ax++) {
                                    cmp ax, 0x10;
                                    if (a >= b (unsigned)) {  // jae 0xb179
                                        // Block 0xB179
                                        jmp 0xb18b;
                                        // Block 0xB18B
                                        $1 = $2;
                                        mov word ptr es:[di], ax;
                                        mov word ptr es:[di + 2], bx;
                                        mov word ptr es:[di + 4], cx;
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 6
                                    } else {
                                        // Block 0xB168
                                        $1 = $2;
                                        for (ax = 8; ax < $2_2; ax++) {
                                        cmp ax, 8;
                                        if (a >= b (unsigned)) {  // jae 0xb179
                                            // Block 0xB179
                                            jmp 0xb18b;
                                            // Block 0xB18B
                                            $1 = $2;
                                            mov word ptr es:[di], ax;
                                            mov word ptr es:[di + 2], bx;
                                            mov word ptr es:[di + 4], cx;
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 6
                                        } else {
                                            // Block 0xB173
                                            $1 = $2;
                                            mov cx, 0x24;
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0xB115
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            $1 = pop();
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            and al, 3;
                            $1 = $2;
                            for (al = 3; al < $2_2; al++) {
                            cmp al, 3;
                            if (a == b) {  // je 0xb141
                                // Block 0xB141
                                jmp 0xb18b;
                                // Block 0xB18B
                                $1 = $2;
                                mov word ptr es:[di], ax;
                                mov word ptr es:[di + 2], bx;
                                mov word ptr es:[di + 4], cx;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            } else {
                                // Block 0xB131
                                $1 = $2;
                                for (al = 1; al < $2_2; al++) {
                                cmp al, 1;
                                if (a == b) {  // je 0xb141
                                    // Block 0xB141
                                    jmp 0xb18b;
                                    // Block 0xB18B
                                    $1 = $2;
                                    mov word ptr es:[di], ax;
                                    mov word ptr es:[di + 2], bx;
                                    mov word ptr es:[di + 4], cx;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 6
                                } else {
                                    // Block 0xB13B
                                    $1 = $2;
                                    mov cx, 0x20;
                                }
                            }
                        }
                    } else {
                        // Block 0xB0E2
                        push($1);
                        $1 = $2;
                        $1 = $2;
                        $1 = pop();
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        and al, 3;
                        $1 = $2;
                        for (al = 3; al < $2_2; al++) {
                        cmp al, 3;
                        if (a == b) {  // je 0xb10e
                            // Block 0xB10E
                            jmp 0xb18b;
                            // Block 0xB18B
                            $1 = $2;
                            mov word ptr es:[di], ax;
                            mov word ptr es:[di + 2], bx;
                            mov word ptr es:[di + 4], cx;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 6
                        } else {
                            // Block 0xB0FE
                            $1 = $2;
                            for (al = 2; al < $2_2; al++) {
                            cmp al, 2;
                            if (a == b) {  // je 0xb10e
                                // Block 0xB10E
                                jmp 0xb18b;
                                // Block 0xB18B
                                $1 = $2;
                                mov word ptr es:[di], ax;
                                mov word ptr es:[di + 2], bx;
                                mov word ptr es:[di + 4], cx;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            } else {
                                // Block 0xB108
                                $1 = $2;
                                mov cx, 0xb;
                            }
                        }
                    }
                } else {
                    // Block 0xB091
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    for (bl = 0x33; bl < $2_2; bl++) {
                    cmp bl, 0x33;
                    if (a >= b (unsigned)) {  // jae 0xb0ba
                        // Block 0xB0BA
                        cli ;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        sti ;
                        test al, 0x10;
                        if (a == b) {  // je 0xb0ca
                            // Block 0xB0CA
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0xb0d8
                                // Block 0xB0D8
                                $1 = 0;
                                jmp 0xb18b;
                                // Block 0xB18B
                                $1 = $2;
                                mov word ptr es:[di], ax;
                                mov word ptr es:[di + 2], bx;
                                mov word ptr es:[di + 4], cx;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            } else {
                                // Block 0xB0CF
                                test al, 8;
                                if (a == b) {  // je 0xb0d8
                                    // Block 0xB0D8
                                    $1 = 0;
                                    jmp 0xb18b;
                                    // Block 0xB18B
                                    $1 = $2;
                                    mov word ptr es:[di], ax;
                                    mov word ptr es:[di + 2], bx;
                                    mov word ptr es:[di + 4], cx;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 6
                                } else {
                                    // Block 0xB0D3
                                    $1 = $2;
                                    mov cx, 0x1e;
                                }
                            }
                        } else {
                            // Block 0xB0C5
                            $1 = $2;
                            mov cx, 0x19;
                        }
                    } else {
                        // Block 0xB0A8
                        cli ;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        sti ;
                        test al, 0x20;
                        if (a == b) {  // je 0xb0d8
                            // Block 0xB0D8
                            $1 = 0;
                            jmp 0xb18b;
                            // Block 0xB18B
                            $1 = $2;
                            mov word ptr es:[di], ax;
                            mov word ptr es:[di + 2], bx;
                            mov word ptr es:[di + 4], cx;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 6
                        } else {
                            // Block 0xB0B3
                            $1 = $2;
                            $1 = $2;
                            jmp 0xb0d8;
                            // Block 0xB0D8
                            $1 = 0;
                            jmp 0xb18b;
                            // Block 0xB18B
                            $1 = $2;
                            mov word ptr es:[di], ax;
                            mov word ptr es:[di + 2], bx;
                            mov word ptr es:[di + 4], cx;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 6
                        }
                    }
                }
            } else {
                // Block 0xB065
                $1 = $2;
                INT_10();  // int 0x10
                and ah, 0x7f;
                $1 = $2;
                for (ah = 4; ah < $2_2; ah++) {
                cmp ah, 4;
                if (a >= b (unsigned)) {  // jae 0xb089
                    // Block 0xB089
                    jmp 0xb18b;
                    // Block 0xB18B
                    $1 = $2;
                    mov word ptr es:[di], ax;
                    mov word ptr es:[di + 2], bx;
                    mov word ptr es:[di + 4], cx;
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 6
                } else {
                    // Block 0xB078
                    $1 = $2;
                    for (ah = 2; ah < $2_2; ah++) {
                    cmp ah, 2;
                    if (a >= b (unsigned)) {  // jae 0xb089
                        // Block 0xB089
                        jmp 0xb18b;
                        // Block 0xB18B
                        $1 = $2;
                        mov word ptr es:[di], ax;
                        mov word ptr es:[di + 2], bx;
                        mov word ptr es:[di + 4], cx;
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 6
                    } else {
                        // Block 0xB083
                        $1 = $2;
                        mov cx, 0x13;
                    }
                }
            }
        } else {
            // Block 0xB039
            $1 = $2;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            and al, 0xc0;
            $1 = $2;
            for (al = 0xc0; al < $2_2; al++) {
            cmp al, 0xc0;
            if (a == b) {  // je 0xb05d
                // Block 0xB05D
                jmp 0xb18b;
                // Block 0xB18B
                $1 = $2;
                mov word ptr es:[di], ax;
                mov word ptr es:[di + 2], bx;
                mov word ptr es:[di + 4], cx;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 6
            } else {
                // Block 0xB04D
                $1 = $2;
                for (al = 0x80; al < $2_2; al++) {
                cmp al, 0x80;
                if (a == b) {  // je 0xb05d
                    // Block 0xB05D
                    jmp 0xb18b;
                    // Block 0xB18B
                    $1 = $2;
                    mov word ptr es:[di], ax;
                    mov word ptr es:[di + 2], bx;
                    mov word ptr es:[di + 4], cx;
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 6
                } else {
                    // Block 0xB057
                    $1 = $2;
                    mov cx, 0x10;
                }
            }
        }
    } else {
        // Block 0xB02B
        $1 = $2;
        $1 = $2;
        jmp 0xb18b;
        // Block 0xB18B
        $1 = $2;
        mov word ptr es:[di], ax;
        mov word ptr es:[di + 2], bx;
        mov word ptr es:[di + 4], cx;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 6
    }

    // Function calls:
    sub_AE16(); // Performs video operations and performs calculations
}

void sub_B316(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Block 0xB316
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 8
}

void sub_B350(int, int) {
    // Purpose: Reads data from a file and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xB350
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    cmp word ptr [0x54c6], -1;
    if (a != b) {  // jne 0xb371
        // Block 0xB371
        les di, ptr [0x54c1];
        $1 = $2;
        $1 -= $2;
        add word ptr [0x54ca], ax;
        adc word ptr [0x54c8], 0;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_MoveFilePointer();  // int 0x21
        $1 = $2;
        $1 = $2;
        $1 = $2;
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        $1 = pop();
        mov word ptr [bp - 2], di;
    } else {
        // Block 0xB369
        stc ;
        mov word ptr [bp - 2], 0xffff;
        jmp 0xb3ac;
        // Block 0xB3AC
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_B316(); // Performs arithmetic calculations
    sub_B350(); // Reads data from a file and performs calculations
}

void sub_B4EC(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xB4EC
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0xb508
        // Block 0xB508
        mov word ptr [bp - 2], 0xfffa;
        jmp 0xb535;
        // Block 0xB535
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    } else {
        // Block 0xB503
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0xb50f
            // Block 0xB50F
            $1 = $2;
            $1 = $2;
            for (bl = byte; bl < $2_2; bl++) {
            cmp bl, byte ptr [si + 1];
            if (a != b) {  // jne 0xb52b
                // Block 0xB52B
                $1 += $2;
                loop 0xb518;
                mov word ptr [bp - 2], 0xfffa;
            } else {
                // Block 0xB51D
                // Compare $1 with $2
                if (a != b) {  // jne 0xb52b
                    // Block 0xB52B
                    $1 += $2;
                    loop 0xb518;
                    mov word ptr [bp - 2], 0xfffa;
                } else {
                    // Block 0xB522
                    $1 = $2;
                    $1 = 0;
                    *($1) = $2;
                    jmp 0xb535;
                    // Block 0xB535
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                }
            }
        } else {
            // Block 0xB508
            mov word ptr [bp - 2], 0xfffa;
            jmp 0xb535;
            // Block 0xB535
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        }
    }

    // Function calls:
    sub_B5BF(); // Performs arithmetic calculations
}

void sub_B586(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xB586
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    call 0xb5bf;
    // Block 0xB59C
    if (a >= b (unsigned)) {  // jae 0xb5a5
        // Block 0xB5A5
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = 0;
        mov word ptr [bp - 2], ax;
    } else {
        // Block 0xB59E
        mov word ptr [bp - 2], 0xfc19;
        jmp 0xb5b2;
        // Block 0xB5B2
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_B5BF(); // Performs arithmetic calculations
}

void sub_B5BF(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0xB5BF
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0xb5de
        // Block 0xB5DE
        $1 = $2;
        for (al = byte; al < $2_2; al++) {
        cmp al, byte ptr [si];
        if (a == b) {  // je 0xb5f5
            // Block 0xB5F5
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            clc ;
        } else {
            // Block 0xB5E8
            $1 += $2;
            loop 0xb5e4;
            mov word ptr [bp - 2], 0xfc19;
            stc ;
            jmp 0xb5fd;
            // Block 0xB5FD
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    } else {
        // Block 0xB5D6
        mov word ptr [bp - 2], 0xfffa;
        stc ;
        jmp 0xb5fd;
        // Block 0xB5FD
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }
}

void sub_B60A(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0xB60A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0xb629
        // Block 0xB629
        push($1);
        push($1);
        call 0xb5bf;
        // Block 0xB62E
        if (a >= b (unsigned)) {  // jae 0xb636
            // Block 0xB636
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            mul byte ptr es:[di + 3];
            $1 += $2;
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0xb655
                // Block 0xB655
                $1 = $2;
                $1 = $2;
                *($1) = $2;
                clc ;
            } else {
                // Block 0xB64D
                mov word ptr [bp - 2], 0xfc19;
                stc ;
                jmp 0xb65d;
                // Block 0xB65D
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            }
        } else {
            // Block 0xB630
            *($1) = $2;
            stc ;
            jmp 0xb65d;
            // Block 0xB65D
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    } else {
        // Block 0xB621
        mov word ptr [bp - 2], 0xfffa;
        stc ;
        jmp 0xb65d;
        // Block 0xB65D
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_B5BF(); // Performs arithmetic calculations
}

void sub_B66A(int) {
    // Purpose: Performs video operations and performs calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0xB66A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x43b9], 7;
    if (a != b) {  // jne 0xb691
        // Block 0xB691
        push($1);
        $1 = $2;
        INT_10_AH0F();  // int 0x10
        $1 = pop();
        and ax, 0x7f;
    } else {
        // Block 0xB680
        $1 = $2;
        $1 = $2;
        INT_10();  // int 0x10
        xchg bx, ax;
        // Compare $1 with $2
        if (a == b) {  // je 0xb69a
            // Block 0xB69A
            mov word ptr [bp - 2], ax;
        } else {
            // Block 0xB68C
            $1 = $2;
            jmp 0xb69d;
            // Block 0xB69D
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    }
}

void sub_B6A8(int) {
    // Purpose: Sets video mode and performs calculations

    // Complexity: 15

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 29 if statements

    // Block 0xB6A8
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ah, ah;
    if (a == b) {  // je 0xb6e0
        // Block 0xB6E0
        push($1);
        $1 = $2;
        VIDEO_SetVideoMode();  // int 0x10
        pop bp;
    } else {
        // Block 0xB6BE
        cmp word ptr [0x43b9], 7;
        if (a == b) {  // je 0xb6cc
            // Block 0xB6CC
            $1 = $2;
            $1 = $2;
            $1 = $2;
            INT_10_AH4F();  // int 0x10
            // Compare $1 with $2
            if (a == b) {  // je 0xb6e6
                // Block 0xB6E6
                mov word ptr [bp - 2], 0;
            } else {
                // Block 0xB6D9
                mov word ptr [bp - 2], 0xffd8;
                jmp 0xb6eb;
                // Block 0xB6EB
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            }
        } else {
            // Block 0xB6C5
            mov word ptr [bp - 2], 0xfffa;
            jmp 0xb6eb;
            // Block 0xB6EB
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    }

    // Function calls:
    sub_B4EC(); // Performs arithmetic calculations
    sub_B5BF(); // Performs arithmetic calculations
    sub_B60A(); // Performs arithmetic calculations
    sub_B586(); // Performs arithmetic calculations
    sub_B60A(); // Performs arithmetic calculations
    sub_B4EC(); // Performs arithmetic calculations
    sub_B5BF(); // Performs arithmetic calculations
    sub_B66A(); // Performs video operations and performs calculations
    sub_B6A8(); // Sets video mode and performs calculations
    sub_B66A(); // Performs video operations and performs calculations
    sub_B995(); // Manipulates strings or memory blocks and performs calculations
    sub_B6A8(); // Sets video mode and performs calculations
    sub_B995(); // Manipulates strings or memory blocks and performs calculations
}

void sub_B995(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 8

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 58 if statements

    // Block 0xB995
    push($1);
    // Compare $1 with $2
    if (a == b) {  // je 0xb9a7
        // Block 0xB9A7
        $1 = $2;
        $1 = 0;
        push($1);
        $1 = $2;
        push bx;
    } else {
        // Block 0xB99A
        $1 = $2;
        $1 = $2;
        push($1);
        $1 = $2;
        push($1);
        jmp 0xb9b1;
        // Block 0xB9B1
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1 = $2;
        $1 = 0;
        cld ;
        $1 = $2;
        $1 = $2;
        out dx, al;
        lodsb al, byte ptr [si];
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1++;
        loop 0xb9bf;
        $1 = pop();
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = 0;
        $1 = pop();
        rep stosw word ptr es:[di], ax;
        $1 = pop();
        $1 += $2;
        $1 = $2;
        $1 = $2;
        out dx, al;
        return;  // retf 
    }

    // Function calls:
    sub_BFC3(); // Performs video operations and performs calculations
}

void sub_BFC3(int, int) {
    // Purpose: Performs video operations and performs calculations

    // Complexity: 18

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 35 if statements

    // Block 0xBFC3
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    mov word ptr [bp - 2], 0;
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0xbff8
        // Block 0xBFF8
        // Compare $1 with $2
        if (a != b) {  // jne 0xc011
            // Block 0xC011
            // Compare $1 with $2
            if (a != b) {  // jne 0xc05e
                // Block 0xC05E
                // Compare $1 with $2
                if (a != b) {  // jne 0xc083
                    // Block 0xC083
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xc0ac
                        // Block 0xC0AC
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xc0c9
                            // Block 0xC0C9
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xc0f0
                                // Block 0xC0F0
                                mov word ptr [bp - 2], 0xffde;
                            } else {
                                // Block 0xC0CE
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                mul bl;
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                INT_10_AH4F();  // int 0x10
                                $1 = pop();
                                $1 = 0;
                                $1 = $2;
                                $1 = $2;
                                INT_10_AH4F();  // int 0x10
                                $1 = pop();
                                jmp 0xc0f5;
                                // Block 0xC0F5
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 4
                            }
                        } else {
                            // Block 0xC0B1
                            $1 = $2;
                            and al, 0xf;
                            xor al, 2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            and al, 0xf0;
                            or al, ah;
                            out dx, al;
                            jmp 0xc0f5;
                            // Block 0xC0F5
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 4
                        }
                    } else {
                        // Block 0xC088
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        and ah, 0xf;
                        $1 = $2;
                        shl al, 1;
                        shl al, 1;
                        shl al, 1;
                        shl al, 1;
                        or al, ah;
                        $1 = $2;
                        out dx, al;
                        jmp 0xc0f5;
                        // Block 0xC0F5
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 4
                    }
                } else {
                    // Block 0xC063
                    push($1);
                    $1 = $2;
                    cli ;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    $1 = $2;
                    and ah, 0xe1;
                    shl ch, 1;
                    or ah, ch;
                    $1--;
                    $1 = $2;
                    out dx, ax;
                    sti ;
                    $1 = pop();
                    jmp 0xc0f5;
                    // Block 0xC0F5
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                }
            } else {
                // Block 0xC016
                push($1);
                $1 = $2;
                $1 = $2;
                and bl, 1;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                out dx, ax;
                $1 = $2;
                and bl, 2;
                shl bl, 1;
                shl bl, 1;
                shl bl, 1;
                shl bl, 1;
                $1 = $2;
                in al, dx;
                and al, 0xdf;
                or bl, al;
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1++;
                in al, dx;
                and al, 0xf0;
                and bh, 0xc;
                $1 = $2;
                shr bl, 1;
                shr bl, 1;
                or al, bh;
                or al, bl;
                out dx, al;
                $1 = pop();
                jmp 0xc0f5;
                // Block 0xC0F5
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            }
        } else {
            // Block 0xBFFD
            push($1);
            $1 = $2;
            $1 = $2;
            shl ch, cl;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = pop();
            jmp 0xc0f5;
            // Block 0xC0F5
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        }
    } else {
        // Block 0xBFE2
        $1 = $2;
        $1 = $2;
        shl ah, 1;
        shl ah, 1;
        shl ah, 1;
        or al, ah;
        or al, 0x40;
        $1 = $2;
        out dx, al;
        jmp 0xc0f5;
        // Block 0xC0F5
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_BFC3(); // Performs video operations and performs calculations
    sub_C3B3(); // Manipulates strings or memory blocks and performs calculations
}

void sub_C3B3(int, int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 65

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 99 if statements

    // Block 0xC3B3
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x639;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x6ce;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov byte ptr [0x55f2], 1;
    return;  // retf 

    // Function calls:
    sub_CA9B(); // Performs video operations and performs calculations
    sub_CB80(); // Sets video mode
    sub_CBCF(); // Unknown function purpose
    sub_CBE1(); // Unknown function purpose
    sub_CC40(); // Unknown function purpose
}

void sub_CA9B(int) {
    // Purpose: Performs video operations and performs calculations

    // Complexity: 10

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0xCA9B
    $1 = 0;
    push($1);
    $1 = $2;
    INT_10_AH1A();  // int 0x10
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0xcaaa
        // Block 0xCAAA
        mov cx, 2;
    } else {
        // Block 0xCAA7
        jmp 0xcb7f;
        // Block 0xCB7F
        return;  // retf 
    }
}

void sub_CB80(void) {
    // Purpose: Sets video mode

    // Complexity: 5

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0xCB80
    $1 = $2;
    push($1);
    $1 = $2;
    INT_10_AH12();  // int 0x10
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0xcbce
        // Block 0xCBCE
        return;  // retf 
    } else {
        // Block 0xCB8D
        $1 = $2;
        // Compare $1 with $2
        if (a > b (unsigned)) {  // ja 0xcb97
            // Block 0xCB97
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0xcb9f
                // Block 0xCB9F
                // Compare $1 with $2
                if (a > b (unsigned)) {  // ja 0xcba7
                    // Block 0xCBA7
                    // Compare $1 with $2
                    if (a > b (unsigned)) {  // ja 0xcbaf
                        // Block 0xCBAF
                        // Compare $1 with $2
                        if (a > b (unsigned)) {  // ja 0xcbb7
                            // Block 0xCBB7
                            mov ah, 1;
                        } else {
                            // Block 0xCBB3
                            $1 = $2;
                            jmp 0xcbb9;
                            // Block 0xCBB9
                            $1 = $2;
                            push($1);
                            call 0xcc7a;
                            // Block 0xCBBF
                            // Compare $1 with $2
                            if (a == b) {  // je 0xcbca
                                // Block 0xCBCA
                                mov byte ptr [bp - 0xa], 0;
                            } else {
                                // Block 0xCBC4
                                mov byte ptr [bp - 8], 0;
                                jmp 0xcbce;
                                // Block 0xCBCE
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0xCBAB
                        $1 = $2;
                        jmp 0xcbb9;
                        // Block 0xCBB9
                        $1 = $2;
                        push($1);
                        call 0xcc7a;
                        // Block 0xCBBF
                        // Compare $1 with $2
                        if (a == b) {  // je 0xcbca
                            // Block 0xCBCA
                            mov byte ptr [bp - 0xa], 0;
                        } else {
                            // Block 0xCBC4
                            mov byte ptr [bp - 8], 0;
                            jmp 0xcbce;
                            // Block 0xCBCE
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0xCBA3
                    $1 = $2;
                    jmp 0xcbb9;
                    // Block 0xCBB9
                    $1 = $2;
                    push($1);
                    call 0xcc7a;
                    // Block 0xCBBF
                    // Compare $1 with $2
                    if (a == b) {  // je 0xcbca
                        // Block 0xCBCA
                        mov byte ptr [bp - 0xa], 0;
                    } else {
                        // Block 0xCBC4
                        mov byte ptr [bp - 8], 0;
                        jmp 0xcbce;
                        // Block 0xCBCE
                        return;  // retf 
                    }
                }
            } else {
                // Block 0xCB9B
                $1 = $2;
                jmp 0xcbb9;
                // Block 0xCBB9
                $1 = $2;
                push($1);
                call 0xcc7a;
                // Block 0xCBBF
                // Compare $1 with $2
                if (a == b) {  // je 0xcbca
                    // Block 0xCBCA
                    mov byte ptr [bp - 0xa], 0;
                } else {
                    // Block 0xCBC4
                    mov byte ptr [bp - 8], 0;
                    jmp 0xcbce;
                    // Block 0xCBCE
                    return;  // retf 
                }
            }
        } else {
            // Block 0xCB93
            $1 = $2;
            jmp 0xcbb9;
            // Block 0xCBB9
            $1 = $2;
            push($1);
            call 0xcc7a;
            // Block 0xCBBF
            // Compare $1 with $2
            if (a == b) {  // je 0xcbca
                // Block 0xCBCA
                mov byte ptr [bp - 0xa], 0;
            } else {
                // Block 0xCBC4
                mov byte ptr [bp - 8], 0;
                jmp 0xcbce;
                // Block 0xCBCE
                return;  // retf 
            }
        }
    }

    // Function calls:
    sub_CC7A(); // Manipulates strings or memory blocks and performs calculations
}

void sub_CBCF(int) {
    // Purpose: Unknown function purpose

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xCBCF
    $1 = $2;
    push($1);
    call 0xcc23;
    // Block 0xCBD6
    if (a < b (unsigned)) {  // jb 0xcbe0
        // Block 0xCBE0
        return;  // retf 
    } else {
        // Block 0xCBD8
        $1 = $2;
        $1 = $2;
        push($1);
        call 0xcc7a;
        // Block 0xCBE0
        return;  // retf 
    }

    // Function calls:
    sub_CC23(); // Unknown function purpose
    sub_CC7A(); // Manipulates strings or memory blocks and performs calculations
}

void sub_CBE1(int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0xCBE1
    $1 = $2;
    push($1);
    call 0xcc23;
    // Block 0xCBE8
    if (a < b (unsigned)) {  // jb 0xcc22
        // Block 0xCC22
        return;  // retf 
    } else {
        // Block 0xCBEA
        $1 = $2;
        in al, dx;
        and al, 0x80;
        $1 = $2;
        $1 = $2;
        in al, dx;
        and al, 0x80;
        // Compare $1 with $2
        loope 0xcbf5;
        if (a != b) {  // jne 0xcc04
            // Block 0xCC04
            in al, dx;
            $1 = $2;
            and dl, 0x70;
            $1 = $2;
            for (dl = 0x10; dl < $2_2; dl++) {
            cmp dl, 0x10;
            if (a == b) {  // je 0xcc1e
                // Block 0xCC1E
                push($1);
                call 0xcc7a;
                // Block 0xCC22
                return;  // retf 
            } else {
                // Block 0xCC13
                for (dl = 0x50; dl < $2_2; dl++) {
                cmp dl, 0x50;
                if (a != b) {  // jne 0xcc1e
                    // Block 0xCC1E
                    push($1);
                    call 0xcc7a;
                    // Block 0xCC22
                    return;  // retf 
                } else {
                    // Block 0xCC1A
                    $1 = $2;
                    mov ah, 3;
                }
            }
        } else {
            // Block 0xCBFE
            $1 = $2;
            $1 = $2;
            jmp 0xcc1e;
            // Block 0xCC1E
            push($1);
            call 0xcc7a;
            // Block 0xCC22
            return;  // retf 
        }
    }

    // Function calls:
    sub_CC23(); // Unknown function purpose
    sub_CC7A(); // Manipulates strings or memory blocks and performs calculations
}

void sub_CC23(int) {
    // Purpose: Unknown function purpose

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xCC23
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    loop 0xcc30;
    in al, dx;
    xchg al, ah;
    out dx, al;
    // Compare $1 with $2
    if (a == b) {  // je 0xcc3e
        // Block 0xCC3E
        clc ;
    } else {
        // Block 0xCC3B
        stc ;
        jmp 0xcc3f;
        // Block 0xCC3F
        return;  // retf 
    }
}

void sub_CC40(void) {
    // Purpose: Unknown function purpose

    // Complexity: 5

    // Variable declarations
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xCC40
    cmp byte ptr es:[di + 2], 0;
    if (a == b) {  // je 0xcc79
        // Block 0xCC79
        return;  // retf 
    } else {
        // Block 0xCC47
        cmp byte ptr es:[di], 4;
        if (a >= b) {  // jge 0xcc79
            // Block 0xCC79
            return;  // retf 
        } else {
            // Block 0xCC4D
            cmp byte ptr es:[di + 2], 4;
            if (a >= b) {  // jge 0xcc79
                // Block 0xCC79
                return;  // retf 
            } else {
                // Block 0xCC54
                lcall 0x98e, 0x18a;
                and al, 7;
                // Compare $1 with $2
                if (a == b) {  // je 0xcc68
                    // Block 0xCC68
                    cmp byte ptr es:[di + 1], 1;
                    if (a == b) {  // je 0xcc79
                        // Block 0xCC79
                        return;  // retf 
                    } else {
                        // Block 0xCC6F
                        $1 = $2;
                        xchg word ptr es:[di + 2], ax;
                        mov word ptr es:[di], ax;
                    }
                } else {
                    // Block 0xCC5F
                    cmp byte ptr es:[di + 1], 1;
                    if (a != b) {  // jne 0xcc79
                        // Block 0xCC79
                        return;  // retf 
                    } else {
                        // Block 0xCC66
                        jmp 0xcc6f;
                        // Block 0xCC6F
                        $1 = $2;
                        xchg word ptr es:[di + 2], ax;
                        mov word ptr es:[di], ax;
                    }
                }
            }
        }
    }
}

void sub_CC7A(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 66

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 109 if statements

    // Block 0xCC7A
    cmp byte ptr es:[di], 0;
    if (a != b) {  // jne 0xcc85
        // Block 0xCC85
        mov word ptr es:[di + 2], ax;
    } else {
        // Block 0xCC80
        mov word ptr es:[di], ax;
        jmp 0xcc89;
        // Block 0xCC89
        return;  // retf 
    }
}

void sub_D552(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 27

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 50 if statements

    // Block 0xD552
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x2f;
    // Compare $1 with $2
    if (a == b) {  // je 0xd571
        // Block 0xD571
        $1 = $2;
        int 0x2f;
        *($1) = $2;
        *($1) = $2;
        $1 = $2;
        lcall [0x5ab2];
        // Compare $1 with $2
        if (a >= b (unsigned)) {  // jae 0xd590
            // Block 0xD590
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0xD589
            mov word ptr [bp - 2], 0xffdc;
            jmp 0xd595;
            // Block 0xD595
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0xD56A
        mov word ptr [bp - 2], 0xffdc;
        jmp 0xd595;
        // Block 0xD595
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_D552(); // Performs arithmetic calculations
    sub_D552(); // Performs arithmetic calculations
    sub_DA6E(); // Performs arithmetic calculations
}

void sub_DA6E(int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 16 if statements

    // Block 0xDA6E
    $1 = $2;
    mov word ptr [bx + 0xa], 0x275;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x335;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x61a;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x3e9;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    $1 = $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov byte ptr [0x6d35], 1;
    return;  // retf 
}

void sub_DE14(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0xDE14
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_DE14(); // Manipulates strings or memory blocks and performs calculations
    sub_DE14(); // Manipulates strings or memory blocks and performs calculations
}

void sub_DFD5(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 14

    // Variable declarations
    // Parameters:
    // int data_dx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 34 if statements

    // Block 0xDFD5
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_DFD5(); // Manipulates strings or memory blocks and performs calculations
}

void sub_E3A5(int, int) {
    // Purpose: Unknown function purpose

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int base_bx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0xE3A5
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (a < b) {  // jl 0xe3c8
        // Block 0xE3C8
        stc ;
    } else {
        // Block 0xE3B6
        // Compare $1 with $2
        if (a < b) {  // jl 0xe3c8
            // Block 0xE3C8
            stc ;
        } else {
            // Block 0xE3BB
            // Compare $1 with $2
            if (a > b) {  // jg 0xe3c8
                // Block 0xE3C8
                stc ;
            } else {
                // Block 0xE3C0
                // Compare $1 with $2
                if (a > b) {  // jg 0xe3c8
                    // Block 0xE3C8
                    stc ;
                } else {
                    // Block 0xE3C5
                    clc ;
                    jmp 0xe3c9;
                    // Block 0xE3C9
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            }
        }
    }
}

void sub_E3CC(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0xE3CC
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    mov si, 0x6cda;

    // Function calls:
    sub_E58D(); // Performs arithmetic calculations
}

void sub_E4E0(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 4

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0xE4E0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    mov si, 0x6cda;

    // Function calls:
    sub_E58D(); // Performs arithmetic calculations
}

void sub_E58D(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int count_cx; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 24 if statements

    // Block 0xE58D
    $1 = 0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a >= b) {  // jge 0xe59c
        // Block 0xE59C
        // Compare $1 with $2
        if (a >= b) {  // jge 0xe5a3
            // Block 0xE5A3
            // Compare $1 with $2
            if (a <= b) {  // jle 0xe5aa
                // Block 0xE5AA
                // Compare $1 with $2
                if (a <= b) {  // jle 0xe5b1
                    // Block 0xE5B1
                    $1 = $2;
                    $1 = $2;
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xe5bf
                        // Block 0xE5BF
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0xe5c7
                            // Block 0xE5C7
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0xe5cf
                                // Block 0xE5CF
                                // Compare $1 with $2
                                if (a <= b) {  // jle 0xe5d7
                                    // Block 0xE5D7
                                    return;  // retf 
                                } else {
                                    // Block 0xE5D4
                                    or ah, 8;
                                }
                            } else {
                                // Block 0xE5CC
                                or ah, 4;
                            }
                        } else {
                            // Block 0xE5C4
                            or ah, 2;
                        }
                    } else {
                        // Block 0xE5BC
                        or ah, 1;
                    }
                } else {
                    // Block 0xE5AF
                    or al, 8;
                }
            } else {
                // Block 0xE5A8
                or al, 4;
            }
        } else {
            // Block 0xE5A1
            or al, 2;
        }
    } else {
        // Block 0xE59A
        or al, 1;
    }

    // Function calls:
    sub_E3A5(); // Unknown function purpose
    sub_E3CC(); // Performs arithmetic calculations
    sub_E4E0(); // Performs arithmetic calculations
    sub_ECFD(); // Performs arithmetic calculations
    sub_ECFD(); // Performs arithmetic calculations
    sub_E9D0(); // Performs arithmetic calculations
    sub_E9D0(); // Performs arithmetic calculations
    sub_ED84(); // Manipulates strings or memory blocks and performs calculations
}

void sub_E9D0(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 29

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 55 if statements

    // Block 0xE9D0
    push($1);
    push($1);
    // Compare $1 with $2
    if (a != b) {  // jne 0xe9da
        // Block 0xE9DA
        or cx, cx;
        if (a != b) {  // jne 0xe9e1
            // Block 0xE9E1
            push($1);
            call 0xed11;
            // Block 0xE9E5
            // Compare $1 with $2
            if (a < b) {  // jl 0xea2d
                // Block 0xEA2D
                $1 = pop();
                $1 = pop();
                push($1);
                push($1);
                neg bx;
                push($1);
                call 0xed11;
                // Block 0xEA37
                // Compare $1 with $2
                if (a < b) {  // jl 0xea7f
                    // Block 0xEA7F
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xea8b
                        // Block 0xEA8B
                        neg cx;
                        push($1);
                        call 0xed11;
                        // Block 0xEA91
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xead9
                            // Block 0xEAD9
                            $1 = pop();
                            $1 = pop();
                            push($1);
                            push($1);
                            neg bx;
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEAE5
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xeb2d
                                // Block 0xEB2D
                                jmp 0xec72;
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xEAEA
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEF
                                    // Compare $1 with $2
                                    if (a >= b) {  // jge 0xeaff
                                        // Block 0xEAFF
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xeb0f
                                            // Block 0xEB0F
                                            $1 = $2;
                                            $1 += $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xeb26
                                                // Block 0xEB26
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            } else {
                                                // Block 0xEB1F
                                                lcall 0xc6c, 0xe5;
                                                if (a < b (unsigned)) {  // jb 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                }
                                            }
                                        } else {
                                            // Block 0xEB04
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEAF4
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                }
                            }
                        } else {
                            // Block 0xEA96
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xead9
                                // Block 0xEAD9
                                $1 = pop();
                                $1 = pop();
                                push($1);
                                push($1);
                                neg bx;
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEAE5
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEA
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEF
                                        // Compare $1 with $2
                                        if (a >= b) {  // jge 0xeaff
                                            // Block 0xEAFF
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xeb0f
                                                // Block 0xEB0F
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xeb26
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEB1F
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEB04
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAF4
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA9B
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xeaab
                                    // Block 0xEAAB
                                    // Compare $1 with $2
                                    if (a <= b) {  // jle 0xeabb
                                        // Block 0xEABB
                                        $1 = $2;
                                        $1 += $2;
                                        $1 = $2;
                                        $1 += $2;
                                        cmp word ptr [bp - 0x28], 1;
                                        if (a != b) {  // jne 0xead2
                                            // Block 0xEAD2
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        } else {
                                            // Block 0xEACB
                                            lcall 0xc6c, 0xe5;
                                            if (a < b (unsigned)) {  // jb 0xead9
                                                // Block 0xEAD9
                                                $1 = pop();
                                                $1 = pop();
                                                push($1);
                                                push($1);
                                                neg bx;
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEAE5
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEAEA
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEF
                                                        // Compare $1 with $2
                                                        if (a >= b) {  // jge 0xeaff
                                                            // Block 0xEAFF
                                                            // Compare $1 with $2
                                                            if (a < b) {  // jl 0xeb0f
                                                                // Block 0xEB0F
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xeb26
                                                                    // Block 0xEB26
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEB1F
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEB04
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAF4
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEAD2
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            }
                                        }
                                    } else {
                                        // Block 0xEAB0
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af8], cx;
                                    }
                                } else {
                                    // Block 0xEAA0
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af4], cx;
                                }
                            }
                        }
                    } else {
                        // Block 0xEA88
                        jmp 0xec72;
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0xEA3C
                    // Compare $1 with $2
                    if (a > b) {  // jg 0xea7f
                        // Block 0xEA7F
                        $1 = pop();
                        $1 = pop();
                        push($1);
                        push($1);
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xea8b
                            // Block 0xEA8B
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEA91
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xead9
                                // Block 0xEAD9
                                $1 = pop();
                                $1 = pop();
                                push($1);
                                push($1);
                                neg bx;
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEAE5
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEA
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEF
                                        // Compare $1 with $2
                                        if (a >= b) {  // jge 0xeaff
                                            // Block 0xEAFF
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xeb0f
                                                // Block 0xEB0F
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xeb26
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEB1F
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEB04
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAF4
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA96
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xead9
                                    // Block 0xEAD9
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    neg cx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEAE5
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEA
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEF
                                            // Compare $1 with $2
                                            if (a >= b) {  // jge 0xeaff
                                                // Block 0xEAFF
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb0f
                                                    // Block 0xEB0F
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xeb26
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEB1F
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEB04
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEAF4
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA9B
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeaab
                                        // Block 0xEAAB
                                        // Compare $1 with $2
                                        if (a <= b) {  // jle 0xeabb
                                            // Block 0xEABB
                                            $1 = $2;
                                            $1 += $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xead2
                                                // Block 0xEAD2
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            } else {
                                                // Block 0xEACB
                                                lcall 0xc6c, 0xe5;
                                                if (a < b (unsigned)) {  // jb 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEAD2
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                }
                                            }
                                        } else {
                                            // Block 0xEAB0
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEAA0
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                }
                            }
                        } else {
                            // Block 0xEA88
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEA41
                        // Compare $1 with $2
                        if (a > b) {  // jg 0xea51
                            // Block 0xEA51
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0xea61
                                // Block 0xEA61
                                $1 = $2;
                                $1 += $2;
                                $1 = $2;
                                $1 += $2;
                                cmp word ptr [bp - 0x28], 1;
                                if (a != b) {  // jne 0xea78
                                    // Block 0xEA78
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                } else {
                                    // Block 0xEA71
                                    lcall 0xc6c, 0xe5;
                                    if (a < b (unsigned)) {  // jb 0xea7f
                                        // Block 0xEA7F
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xea8b
                                            // Block 0xEA8B
                                            neg cx;
                                            push($1);
                                            call 0xed11;
                                            // Block 0xEA91
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xead9
                                                // Block 0xEAD9
                                                $1 = pop();
                                                $1 = pop();
                                                push($1);
                                                push($1);
                                                neg bx;
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEAE5
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEAEA
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEF
                                                        // Compare $1 with $2
                                                        if (a >= b) {  // jge 0xeaff
                                                            // Block 0xEAFF
                                                            // Compare $1 with $2
                                                            if (a < b) {  // jl 0xeb0f
                                                                // Block 0xEB0F
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xeb26
                                                                    // Block 0xEB26
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEB1F
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEB04
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAF4
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA96
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA9B
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeaab
                                                        // Block 0xEAAB
                                                        // Compare $1 with $2
                                                        if (a <= b) {  // jle 0xeabb
                                                            // Block 0xEABB
                                                            $1 = $2;
                                                            $1 += $2;
                                                            $1 = $2;
                                                            $1 += $2;
                                                            cmp word ptr [bp - 0x28], 1;
                                                            if (a != b) {  // jne 0xead2
                                                                // Block 0xEAD2
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            } else {
                                                                // Block 0xEACB
                                                                lcall 0xc6c, 0xe5;
                                                                if (a < b (unsigned)) {  // jb 0xead9
                                                                    // Block 0xEAD9
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    push($1);
                                                                    push($1);
                                                                    neg bx;
                                                                    neg cx;
                                                                    push($1);
                                                                    call 0xed11;
                                                                    // Block 0xEAE5
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEAEA
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEF
                                                                            // Compare $1 with $2
                                                                            if (a >= b) {  // jge 0xeaff
                                                                                // Block 0xEAFF
                                                                                // Compare $1 with $2
                                                                                if (a < b) {  // jl 0xeb0f
                                                                                    // Block 0xEB0F
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    cmp word ptr [bp - 0x28], 1;
                                                                                    if (a != b) {  // jne 0xeb26
                                                                                        // Block 0xEB26
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    } else {
                                                                                        // Block 0xEB1F
                                                                                        lcall 0xc6c, 0xe5;
                                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEB04
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af8], cx;
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAF4
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af4], cx;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0xEAB0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af8], cx;
                                                        }
                                                    } else {
                                                        // Block 0xEAA0
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af4], cx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0xEA88
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    } else {
                                        // Block 0xEA78
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    }
                                }
                            } else {
                                // Block 0xEA56
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af8], cx;
                            }
                        } else {
                            // Block 0xEA46
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af4], cx;
                        }
                    }
                }
            } else {
                // Block 0xE9EA
                // Compare $1 with $2
                if (a > b) {  // jg 0xea2d
                    // Block 0xEA2D
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    neg bx;
                    push($1);
                    call 0xed11;
                    // Block 0xEA37
                    // Compare $1 with $2
                    if (a < b) {  // jl 0xea7f
                        // Block 0xEA7F
                        $1 = pop();
                        $1 = pop();
                        push($1);
                        push($1);
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xea8b
                            // Block 0xEA8B
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEA91
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xead9
                                // Block 0xEAD9
                                $1 = pop();
                                $1 = pop();
                                push($1);
                                push($1);
                                neg bx;
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEAE5
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEA
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEF
                                        // Compare $1 with $2
                                        if (a >= b) {  // jge 0xeaff
                                            // Block 0xEAFF
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xeb0f
                                                // Block 0xEB0F
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xeb26
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEB1F
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEB04
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAF4
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA96
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xead9
                                    // Block 0xEAD9
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    neg cx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEAE5
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEA
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEF
                                            // Compare $1 with $2
                                            if (a >= b) {  // jge 0xeaff
                                                // Block 0xEAFF
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb0f
                                                    // Block 0xEB0F
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xeb26
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEB1F
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEB04
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEAF4
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA9B
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeaab
                                        // Block 0xEAAB
                                        // Compare $1 with $2
                                        if (a <= b) {  // jle 0xeabb
                                            // Block 0xEABB
                                            $1 = $2;
                                            $1 += $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xead2
                                                // Block 0xEAD2
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            } else {
                                                // Block 0xEACB
                                                lcall 0xc6c, 0xe5;
                                                if (a < b (unsigned)) {  // jb 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEAD2
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                }
                                            }
                                        } else {
                                            // Block 0xEAB0
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEAA0
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                }
                            }
                        } else {
                            // Block 0xEA88
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEA3C
                        // Compare $1 with $2
                        if (a > b) {  // jg 0xea7f
                            // Block 0xEA7F
                            $1 = pop();
                            $1 = pop();
                            push($1);
                            push($1);
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xea8b
                                // Block 0xEA8B
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEA91
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xead9
                                    // Block 0xEAD9
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    neg cx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEAE5
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEA
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEF
                                            // Compare $1 with $2
                                            if (a >= b) {  // jge 0xeaff
                                                // Block 0xEAFF
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb0f
                                                    // Block 0xEB0F
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xeb26
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEB1F
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEB04
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEAF4
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA96
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xead9
                                        // Block 0xEAD9
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        neg bx;
                                        neg cx;
                                        push($1);
                                        call 0xed11;
                                        // Block 0xEAE5
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEA
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0xeb2d
                                                // Block 0xEB2D
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEAEF
                                                // Compare $1 with $2
                                                if (a >= b) {  // jge 0xeaff
                                                    // Block 0xEAFF
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb0f
                                                        // Block 0xEB0F
                                                        $1 = $2;
                                                        $1 += $2;
                                                        $1 = $2;
                                                        $1 += $2;
                                                        cmp word ptr [bp - 0x28], 1;
                                                        if (a != b) {  // jne 0xeb26
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        } else {
                                                            // Block 0xEB1F
                                                            lcall 0xc6c, 0xe5;
                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEB26
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEB04
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af8], cx;
                                                    }
                                                } else {
                                                    // Block 0xEAF4
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af4], cx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0xEA9B
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeaab
                                            // Block 0xEAAB
                                            // Compare $1 with $2
                                            if (a <= b) {  // jle 0xeabb
                                                // Block 0xEABB
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xead2
                                                    // Block 0xEAD2
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEACB
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                        // Block 0xEAD9
                                                        $1 = pop();
                                                        $1 = pop();
                                                        push($1);
                                                        push($1);
                                                        neg bx;
                                                        neg cx;
                                                        push($1);
                                                        call 0xed11;
                                                        // Block 0xEAE5
                                                        // Compare $1 with $2
                                                        if (a < b) {  // jl 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEA
                                                            // Compare $1 with $2
                                                            if (a > b) {  // jg 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEAEF
                                                                // Compare $1 with $2
                                                                if (a >= b) {  // jge 0xeaff
                                                                    // Block 0xEAFF
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb0f
                                                                        // Block 0xEB0F
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        cmp word ptr [bp - 0x28], 1;
                                                                        if (a != b) {  // jne 0xeb26
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        } else {
                                                                            // Block 0xEB1F
                                                                            lcall 0xc6c, 0xe5;
                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEB26
                                                                                push($1);
                                                                                push($1);
                                                                                push($1);
                                                                                lcall [si];
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEB04
                                                                        *($1) = $2;
                                                                        *($1) = $2;
                                                                        mov word ptr [0x5af8], cx;
                                                                    }
                                                                } else {
                                                                    // Block 0xEAF4
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af4], cx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEAD2
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEAB0
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAA0
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA88
                                jmp 0xec72;
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xEA41
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xea51
                                // Block 0xEA51
                                // Compare $1 with $2
                                if (a <= b) {  // jle 0xea61
                                    // Block 0xEA61
                                    $1 = $2;
                                    $1 += $2;
                                    $1 = $2;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x28], 1;
                                    if (a != b) {  // jne 0xea78
                                        // Block 0xEA78
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    } else {
                                        // Block 0xEA71
                                        lcall 0xc6c, 0xe5;
                                        if (a < b (unsigned)) {  // jb 0xea7f
                                            // Block 0xEA7F
                                            $1 = pop();
                                            $1 = pop();
                                            push($1);
                                            push($1);
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xea8b
                                                // Block 0xEA8B
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEA91
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA96
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xead9
                                                        // Block 0xEAD9
                                                        $1 = pop();
                                                        $1 = pop();
                                                        push($1);
                                                        push($1);
                                                        neg bx;
                                                        neg cx;
                                                        push($1);
                                                        call 0xed11;
                                                        // Block 0xEAE5
                                                        // Compare $1 with $2
                                                        if (a < b) {  // jl 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEA
                                                            // Compare $1 with $2
                                                            if (a > b) {  // jg 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEAEF
                                                                // Compare $1 with $2
                                                                if (a >= b) {  // jge 0xeaff
                                                                    // Block 0xEAFF
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb0f
                                                                        // Block 0xEB0F
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        cmp word ptr [bp - 0x28], 1;
                                                                        if (a != b) {  // jne 0xeb26
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        } else {
                                                                            // Block 0xEB1F
                                                                            lcall 0xc6c, 0xe5;
                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEB26
                                                                                push($1);
                                                                                push($1);
                                                                                push($1);
                                                                                lcall [si];
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEB04
                                                                        *($1) = $2;
                                                                        *($1) = $2;
                                                                        mov word ptr [0x5af8], cx;
                                                                    }
                                                                } else {
                                                                    // Block 0xEAF4
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af4], cx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEA9B
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeaab
                                                            // Block 0xEAAB
                                                            // Compare $1 with $2
                                                            if (a <= b) {  // jle 0xeabb
                                                                // Block 0xEABB
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xead2
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEACB
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                                        // Block 0xEAD9
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        push($1);
                                                                        push($1);
                                                                        neg bx;
                                                                        neg cx;
                                                                        push($1);
                                                                        call 0xed11;
                                                                        // Block 0xEAE5
                                                                        // Compare $1 with $2
                                                                        if (a < b) {  // jl 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEA
                                                                            // Compare $1 with $2
                                                                            if (a > b) {  // jg 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEAEF
                                                                                // Compare $1 with $2
                                                                                if (a >= b) {  // jge 0xeaff
                                                                                    // Block 0xEAFF
                                                                                    // Compare $1 with $2
                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                        // Block 0xEB0F
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                        if (a != b) {  // jne 0xeb26
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        } else {
                                                                                            // Block 0xEB1F
                                                                                            lcall 0xc6c, 0xe5;
                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEB26
                                                                                                push($1);
                                                                                                push($1);
                                                                                                push($1);
                                                                                                lcall [si];
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEB04
                                                                                        *($1) = $2;
                                                                                        *($1) = $2;
                                                                                        mov word ptr [0x5af8], cx;
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEAF4
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af4], cx;
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEAD2
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEAB0
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAA0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA88
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        } else {
                                            // Block 0xEA78
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        }
                                    }
                                } else {
                                    // Block 0xEA56
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af8], cx;
                                }
                            } else {
                                // Block 0xEA46
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af4], cx;
                            }
                        }
                    }
                } else {
                    // Block 0xE9EF
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xe9ff
                        // Block 0xE9FF
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xea0f
                            // Block 0xEA0F
                            $1 = $2;
                            $1 += $2;
                            $1 = $2;
                            $1 += $2;
                            cmp word ptr [bp - 0x28], 1;
                            if (a != b) {  // jne 0xea26
                                // Block 0xEA26
                                push($1);
                                push($1);
                                push($1);
                                lcall [si];
                            } else {
                                // Block 0xEA1F
                                lcall 0xc6c, 0xe5;
                                if (a < b (unsigned)) {  // jb 0xea2d
                                    // Block 0xEA2D
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEA37
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xea7f
                                        // Block 0xEA7F
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xea8b
                                            // Block 0xEA8B
                                            neg cx;
                                            push($1);
                                            call 0xed11;
                                            // Block 0xEA91
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xead9
                                                // Block 0xEAD9
                                                $1 = pop();
                                                $1 = pop();
                                                push($1);
                                                push($1);
                                                neg bx;
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEAE5
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEAEA
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEF
                                                        // Compare $1 with $2
                                                        if (a >= b) {  // jge 0xeaff
                                                            // Block 0xEAFF
                                                            // Compare $1 with $2
                                                            if (a < b) {  // jl 0xeb0f
                                                                // Block 0xEB0F
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xeb26
                                                                    // Block 0xEB26
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEB1F
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEB04
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAF4
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA96
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA9B
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeaab
                                                        // Block 0xEAAB
                                                        // Compare $1 with $2
                                                        if (a <= b) {  // jle 0xeabb
                                                            // Block 0xEABB
                                                            $1 = $2;
                                                            $1 += $2;
                                                            $1 = $2;
                                                            $1 += $2;
                                                            cmp word ptr [bp - 0x28], 1;
                                                            if (a != b) {  // jne 0xead2
                                                                // Block 0xEAD2
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            } else {
                                                                // Block 0xEACB
                                                                lcall 0xc6c, 0xe5;
                                                                if (a < b (unsigned)) {  // jb 0xead9
                                                                    // Block 0xEAD9
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    push($1);
                                                                    push($1);
                                                                    neg bx;
                                                                    neg cx;
                                                                    push($1);
                                                                    call 0xed11;
                                                                    // Block 0xEAE5
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEAEA
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEF
                                                                            // Compare $1 with $2
                                                                            if (a >= b) {  // jge 0xeaff
                                                                                // Block 0xEAFF
                                                                                // Compare $1 with $2
                                                                                if (a < b) {  // jl 0xeb0f
                                                                                    // Block 0xEB0F
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    cmp word ptr [bp - 0x28], 1;
                                                                                    if (a != b) {  // jne 0xeb26
                                                                                        // Block 0xEB26
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    } else {
                                                                                        // Block 0xEB1F
                                                                                        lcall 0xc6c, 0xe5;
                                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEB04
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af8], cx;
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAF4
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af4], cx;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0xEAB0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af8], cx;
                                                        }
                                                    } else {
                                                        // Block 0xEAA0
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af4], cx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0xEA88
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    } else {
                                        // Block 0xEA3C
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xea7f
                                            // Block 0xEA7F
                                            $1 = pop();
                                            $1 = pop();
                                            push($1);
                                            push($1);
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xea8b
                                                // Block 0xEA8B
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEA91
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA96
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xead9
                                                        // Block 0xEAD9
                                                        $1 = pop();
                                                        $1 = pop();
                                                        push($1);
                                                        push($1);
                                                        neg bx;
                                                        neg cx;
                                                        push($1);
                                                        call 0xed11;
                                                        // Block 0xEAE5
                                                        // Compare $1 with $2
                                                        if (a < b) {  // jl 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEA
                                                            // Compare $1 with $2
                                                            if (a > b) {  // jg 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEAEF
                                                                // Compare $1 with $2
                                                                if (a >= b) {  // jge 0xeaff
                                                                    // Block 0xEAFF
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb0f
                                                                        // Block 0xEB0F
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        cmp word ptr [bp - 0x28], 1;
                                                                        if (a != b) {  // jne 0xeb26
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        } else {
                                                                            // Block 0xEB1F
                                                                            lcall 0xc6c, 0xe5;
                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEB26
                                                                                push($1);
                                                                                push($1);
                                                                                push($1);
                                                                                lcall [si];
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEB04
                                                                        *($1) = $2;
                                                                        *($1) = $2;
                                                                        mov word ptr [0x5af8], cx;
                                                                    }
                                                                } else {
                                                                    // Block 0xEAF4
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af4], cx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEA9B
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeaab
                                                            // Block 0xEAAB
                                                            // Compare $1 with $2
                                                            if (a <= b) {  // jle 0xeabb
                                                                // Block 0xEABB
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xead2
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEACB
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                                        // Block 0xEAD9
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        push($1);
                                                                        push($1);
                                                                        neg bx;
                                                                        neg cx;
                                                                        push($1);
                                                                        call 0xed11;
                                                                        // Block 0xEAE5
                                                                        // Compare $1 with $2
                                                                        if (a < b) {  // jl 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEA
                                                                            // Compare $1 with $2
                                                                            if (a > b) {  // jg 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEAEF
                                                                                // Compare $1 with $2
                                                                                if (a >= b) {  // jge 0xeaff
                                                                                    // Block 0xEAFF
                                                                                    // Compare $1 with $2
                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                        // Block 0xEB0F
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                        if (a != b) {  // jne 0xeb26
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        } else {
                                                                                            // Block 0xEB1F
                                                                                            lcall 0xc6c, 0xe5;
                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEB26
                                                                                                push($1);
                                                                                                push($1);
                                                                                                push($1);
                                                                                                lcall [si];
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEB04
                                                                                        *($1) = $2;
                                                                                        *($1) = $2;
                                                                                        mov word ptr [0x5af8], cx;
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEAF4
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af4], cx;
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEAD2
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEAB0
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAA0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA88
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        } else {
                                            // Block 0xEA41
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0xea51
                                                // Block 0xEA51
                                                // Compare $1 with $2
                                                if (a <= b) {  // jle 0xea61
                                                    // Block 0xEA61
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xea78
                                                        // Block 0xEA78
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEA71
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xea7f
                                                            // Block 0xEA7F
                                                            $1 = pop();
                                                            $1 = pop();
                                                            push($1);
                                                            push($1);
                                                            // Compare $1 with $2
                                                            if (a != b) {  // jne 0xea8b
                                                                // Block 0xEA8B
                                                                neg cx;
                                                                push($1);
                                                                call 0xed11;
                                                                // Block 0xEA91
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xead9
                                                                    // Block 0xEAD9
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    push($1);
                                                                    push($1);
                                                                    neg bx;
                                                                    neg cx;
                                                                    push($1);
                                                                    call 0xed11;
                                                                    // Block 0xEAE5
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEAEA
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEF
                                                                            // Compare $1 with $2
                                                                            if (a >= b) {  // jge 0xeaff
                                                                                // Block 0xEAFF
                                                                                // Compare $1 with $2
                                                                                if (a < b) {  // jl 0xeb0f
                                                                                    // Block 0xEB0F
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    cmp word ptr [bp - 0x28], 1;
                                                                                    if (a != b) {  // jne 0xeb26
                                                                                        // Block 0xEB26
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    } else {
                                                                                        // Block 0xEB1F
                                                                                        lcall 0xc6c, 0xe5;
                                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEB04
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af8], cx;
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAF4
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af4], cx;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEA96
                                                                    // Compare $1 with $2
                                                                    if (a > b) {  // jg 0xead9
                                                                        // Block 0xEAD9
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        push($1);
                                                                        push($1);
                                                                        neg bx;
                                                                        neg cx;
                                                                        push($1);
                                                                        call 0xed11;
                                                                        // Block 0xEAE5
                                                                        // Compare $1 with $2
                                                                        if (a < b) {  // jl 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEA
                                                                            // Compare $1 with $2
                                                                            if (a > b) {  // jg 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEAEF
                                                                                // Compare $1 with $2
                                                                                if (a >= b) {  // jge 0xeaff
                                                                                    // Block 0xEAFF
                                                                                    // Compare $1 with $2
                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                        // Block 0xEB0F
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                        if (a != b) {  // jne 0xeb26
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        } else {
                                                                                            // Block 0xEB1F
                                                                                            lcall 0xc6c, 0xe5;
                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEB26
                                                                                                push($1);
                                                                                                push($1);
                                                                                                push($1);
                                                                                                lcall [si];
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEB04
                                                                                        *($1) = $2;
                                                                                        *($1) = $2;
                                                                                        mov word ptr [0x5af8], cx;
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEAF4
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af4], cx;
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEA9B
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeaab
                                                                            // Block 0xEAAB
                                                                            // Compare $1 with $2
                                                                            if (a <= b) {  // jle 0xeabb
                                                                                // Block 0xEABB
                                                                                $1 = $2;
                                                                                $1 += $2;
                                                                                $1 = $2;
                                                                                $1 += $2;
                                                                                cmp word ptr [bp - 0x28], 1;
                                                                                if (a != b) {  // jne 0xead2
                                                                                    // Block 0xEAD2
                                                                                    push($1);
                                                                                    push($1);
                                                                                    push($1);
                                                                                    lcall [si];
                                                                                } else {
                                                                                    // Block 0xEACB
                                                                                    lcall 0xc6c, 0xe5;
                                                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                                                        // Block 0xEAD9
                                                                                        $1 = pop();
                                                                                        $1 = pop();
                                                                                        push($1);
                                                                                        push($1);
                                                                                        neg bx;
                                                                                        neg cx;
                                                                                        push($1);
                                                                                        call 0xed11;
                                                                                        // Block 0xEAE5
                                                                                        // Compare $1 with $2
                                                                                        if (a < b) {  // jl 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEAEA
                                                                                            // Compare $1 with $2
                                                                                            if (a > b) {  // jg 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEAEF
                                                                                                // Compare $1 with $2
                                                                                                if (a >= b) {  // jge 0xeaff
                                                                                                    // Block 0xEAFF
                                                                                                    // Compare $1 with $2
                                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                                        // Block 0xEB0F
                                                                                                        $1 = $2;
                                                                                                        $1 += $2;
                                                                                                        $1 = $2;
                                                                                                        $1 += $2;
                                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                                        if (a != b) {  // jne 0xeb26
                                                                                                            // Block 0xEB26
                                                                                                            push($1);
                                                                                                            push($1);
                                                                                                            push($1);
                                                                                                            lcall [si];
                                                                                                        } else {
                                                                                                            // Block 0xEB1F
                                                                                                            lcall 0xc6c, 0xe5;
                                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                                // Block 0xEB2D
                                                                                                                jmp 0xec72;
                                                                                                                // Block 0xEC72
                                                                                                                $1 = pop();
                                                                                                                $1 = pop();
                                                                                                                return;  // retf 
                                                                                                            } else {
                                                                                                                // Block 0xEB26
                                                                                                                push($1);
                                                                                                                push($1);
                                                                                                                push($1);
                                                                                                                lcall [si];
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        // Block 0xEB04
                                                                                                        *($1) = $2;
                                                                                                        *($1) = $2;
                                                                                                        mov word ptr [0x5af8], cx;
                                                                                                    }
                                                                                                } else {
                                                                                                    // Block 0xEAF4
                                                                                                    *($1) = $2;
                                                                                                    *($1) = $2;
                                                                                                    mov word ptr [0x5af4], cx;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEAD2
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAB0
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af8], cx;
                                                                            }
                                                                        } else {
                                                                            // Block 0xEAA0
                                                                            *($1) = $2;
                                                                            *($1) = $2;
                                                                            mov word ptr [0x5af4], cx;
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEA88
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            }
                                                        } else {
                                                            // Block 0xEA78
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA56
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEA46
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA26
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                }
                            }
                        } else {
                            // Block 0xEA04
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af8], cx;
                        }
                    } else {
                        // Block 0xE9F4
                        *($1) = $2;
                        *($1) = $2;
                        mov word ptr [0x5af4], cx;
                    }
                }
            }
        } else {
            // Block 0xE9DE
            jmp 0xebd4;
            // Block 0xEBD4
            push($1);
            call 0xed11;
            // Block 0xEBD8
            // Compare $1 with $2
            if (a < b) {  // jl 0xec1e
                // Block 0xEC1E
                $1 = pop();
                $1 = pop();
                push($1);
                push($1);
                or bx, bx;
                if (a == b) {  // je 0xec72
                    // Block 0xEC72
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0xEC26
                    neg bx;
                    push($1);
                    call 0xed11;
                    // Block 0xEC2C
                    // Compare $1 with $2
                    if (a < b) {  // jl 0xec72
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0xEC31
                        // Compare $1 with $2
                        if (a > b) {  // jg 0xec72
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0xEC36
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xec46
                                // Block 0xEC46
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xec56
                                    // Block 0xEC56
                                    $1 = $2;
                                    $1 += $2;
                                    $1 = $2;
                                    cmp word ptr [bp - 0x28], 1;
                                    if (a != b) {  // jne 0xec6b
                                        // Block 0xEC6B
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    } else {
                                        // Block 0xEC64
                                        lcall 0xc6c, 0xe5;
                                        if (a < b (unsigned)) {  // jb 0xec72
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEC6B
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        }
                                    }
                                } else {
                                    // Block 0xEC4B
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af8], cx;
                                }
                            } else {
                                // Block 0xEC3B
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af4], cx;
                            }
                        }
                    }
                }
            } else {
                // Block 0xEBDD
                // Compare $1 with $2
                if (a > b) {  // jg 0xec1e
                    // Block 0xEC1E
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    or bx, bx;
                    if (a == b) {  // je 0xec72
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0xEC26
                        neg bx;
                        push($1);
                        call 0xed11;
                        // Block 0xEC2C
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xec72
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0xEC31
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xec72
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xEC36
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xec46
                                    // Block 0xEC46
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xec56
                                        // Block 0xEC56
                                        $1 = $2;
                                        $1 += $2;
                                        $1 = $2;
                                        cmp word ptr [bp - 0x28], 1;
                                        if (a != b) {  // jne 0xec6b
                                            // Block 0xEC6B
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        } else {
                                            // Block 0xEC64
                                            lcall 0xc6c, 0xe5;
                                            if (a < b (unsigned)) {  // jb 0xec72
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEC6B
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            }
                                        }
                                    } else {
                                        // Block 0xEC4B
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af8], cx;
                                    }
                                } else {
                                    // Block 0xEC3B
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af4], cx;
                                }
                            }
                        }
                    }
                } else {
                    // Block 0xEBE2
                    // Compare $1 with $2
                    if (a > b) {  // jg 0xebf2
                        // Block 0xEBF2
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xec02
                            // Block 0xEC02
                            $1 = $2;
                            $1 += $2;
                            $1 = $2;
                            cmp word ptr [bp - 0x28], 1;
                            if (a != b) {  // jne 0xec17
                                // Block 0xEC17
                                push($1);
                                push($1);
                                push($1);
                                lcall [si];
                            } else {
                                // Block 0xEC10
                                lcall 0xc6c, 0xe5;
                                if (a < b (unsigned)) {  // jb 0xec1e
                                    // Block 0xEC1E
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    or bx, bx;
                                    if (a == b) {  // je 0xec72
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEC26
                                        neg bx;
                                        push($1);
                                        call 0xed11;
                                        // Block 0xEC2C
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xec72
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEC31
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0xec72
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEC36
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0xec46
                                                    // Block 0xEC46
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xec56
                                                        // Block 0xEC56
                                                        $1 = $2;
                                                        $1 += $2;
                                                        $1 = $2;
                                                        cmp word ptr [bp - 0x28], 1;
                                                        if (a != b) {  // jne 0xec6b
                                                            // Block 0xEC6B
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        } else {
                                                            // Block 0xEC64
                                                            lcall 0xc6c, 0xe5;
                                                            if (a < b (unsigned)) {  // jb 0xec72
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEC6B
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEC4B
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af8], cx;
                                                    }
                                                } else {
                                                    // Block 0xEC3B
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af4], cx;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEC17
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                }
                            }
                        } else {
                            // Block 0xEBF7
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af8], cx;
                        }
                    } else {
                        // Block 0xEBE7
                        *($1) = $2;
                        *($1) = $2;
                        mov word ptr [0x5af4], cx;
                    }
                }
            }
        }
    } else {
        // Block 0xE9D7
        jmp 0xeb30;
        // Block 0xEB30
        push($1);
        call 0xed11;
        // Block 0xEB34
        // Compare $1 with $2
        if (a < b) {  // jl 0xeb70
            // Block 0xEB70
            $1 = pop();
            $1 = pop();
            push($1);
            push($1);
            // Compare $1 with $2
            if (a != b) {  // jne 0xeb7c
                // Block 0xEB7C
                neg cx;
                push($1);
                call 0xed11;
                // Block 0xEB82
                // Compare $1 with $2
                if (a >= b) {  // jge 0xeb8a
                    // Block 0xEB8A
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0xeb92
                        // Block 0xEB92
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0xeba2
                            // Block 0xEBA2
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xebb2
                                // Block 0xEBB2
                                $1 = $2;
                                $1 = $2;
                                $1 += $2;
                                cmp word ptr [bp - 0x28], 1;
                                if (a != b) {  // jne 0xebca
                                    // Block 0xEBCA
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEBC0
                                    lcall 0xc6c, 0xe5;
                                    if (a >= b (unsigned)) {  // jae 0xebca
                                        // Block 0xEBCA
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEBC7
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0xEBA7
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af8], cx;
                            }
                        } else {
                            // Block 0xEB97
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af4], cx;
                        }
                    } else {
                        // Block 0xEB8F
                        jmp 0xec72;
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0xEB87
                    jmp 0xec72;
                    // Block 0xEC72
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0xEB79
                jmp 0xec72;
                // Block 0xEC72
                $1 = pop();
                $1 = pop();
                return;  // retf 
            }
        } else {
            // Block 0xEB39
            // Compare $1 with $2
            if (a > b) {  // jg 0xeb70
                // Block 0xEB70
                $1 = pop();
                $1 = pop();
                push($1);
                push($1);
                // Compare $1 with $2
                if (a != b) {  // jne 0xeb7c
                    // Block 0xEB7C
                    neg cx;
                    push($1);
                    call 0xed11;
                    // Block 0xEB82
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xeb8a
                        // Block 0xEB8A
                        // Compare $1 with $2
                        if (a <= b) {  // jle 0xeb92
                            // Block 0xEB92
                            // Compare $1 with $2
                            if (a >= b) {  // jge 0xeba2
                                // Block 0xEBA2
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xebb2
                                    // Block 0xEBB2
                                    $1 = $2;
                                    $1 = $2;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x28], 1;
                                    if (a != b) {  // jne 0xebca
                                        // Block 0xEBCA
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEBC0
                                        lcall 0xc6c, 0xe5;
                                        if (a >= b (unsigned)) {  // jae 0xebca
                                            // Block 0xEBCA
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEBC7
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0xEBA7
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af8], cx;
                                }
                            } else {
                                // Block 0xEB97
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af4], cx;
                            }
                        } else {
                            // Block 0xEB8F
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEB87
                        jmp 0xec72;
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0xEB79
                    jmp 0xec72;
                    // Block 0xEC72
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0xEB3E
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                $1 = $2;
                $1 += $2;
                cmp word ptr [bp - 0x28], 1;
                if (a != b) {  // jne 0xeb69
                    // Block 0xEB69
                    push($1);
                    push($1);
                    push($1);
                    lcall [si];
                } else {
                    // Block 0xEB62
                    lcall 0xc6c, 0xe5;
                    if (a < b (unsigned)) {  // jb 0xeb70
                        // Block 0xEB70
                        $1 = pop();
                        $1 = pop();
                        push($1);
                        push($1);
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xeb7c
                            // Block 0xEB7C
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEB82
                            // Compare $1 with $2
                            if (a >= b) {  // jge 0xeb8a
                                // Block 0xEB8A
                                // Compare $1 with $2
                                if (a <= b) {  // jle 0xeb92
                                    // Block 0xEB92
                                    // Compare $1 with $2
                                    if (a >= b) {  // jge 0xeba2
                                        // Block 0xEBA2
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xebb2
                                            // Block 0xEBB2
                                            $1 = $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xebca
                                                // Block 0xEBCA
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEBC0
                                                lcall 0xc6c, 0xe5;
                                                if (a >= b (unsigned)) {  // jae 0xebca
                                                    // Block 0xEBCA
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEBC7
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0xEBA7
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEB97
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                } else {
                                    // Block 0xEB8F
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xEB87
                                jmp 0xec72;
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xEB79
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEB69
                        push($1);
                        push($1);
                        push($1);
                        lcall [si];
                    }
                }
            }
        }
    }

    // Function calls:
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
    sub_ED11(); // Performs arithmetic calculations
}

void sub_ECFD(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xECFD
    push($1);
    $1 = $2;
    mul cx;
    or dx, dx;
    if (a == b) {  // je 0xed0a
        // Block 0xED0A
        xchg cx, ax;
        $1 = pop();
        mul dx;
        add dx, cx;
    } else {
        // Block 0xED06
        $1 = pop();
        stc ;
        jmp 0xed10;
        // Block 0xED10
        return;  // retf 
    }
}

void sub_ED11(int, int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // int data_dx; // from parameter 3
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0xED11
    push($1);
    push($1);
    push($1);
    push($1);
    neg cx;
    // Compare $1 with $2
    if (a < b) {  // jl 0xed26
        // Block 0xED26
        $1 = $2;
        jmp 0xed2e;
        // Block 0xED2E
        push($1);
        // Compare $1 with $2
        if (a != b) {  // jne 0xed40
            // Block 0xED40
            $1 = $2;
            $1 = 0;
            xor cx, bx;
            if (a >= b) {  // jge 0xed49
                // Block 0xED49
                push($1);
                // Compare $1 with $2
                if (a >= b) {  // jge 0xed51
                    // Block 0xED51
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xed58
                        // Block 0xED58
                        $1 = $2;
                        mul dx;
                        div bx;
                        $1 = $2;
                        for (ax = word; ax < $2_2; ax++) {
                        cmp ax, word ptr [si];
                        if (a <= b (unsigned)) {  // jbe 0xed6d
                            // Block 0xED6D
                            $1 = $2;
                            $1 -= $2;
                            shr ax, 1;
                            $1 = pop();
                            // Compare $1 with $2
                            if (a >= b) {  // jge 0xed7c
                                // Block 0xED7C
                                $1 = pop();
                                $1 += $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xED7A
                                neg ax;
                            }
                        } else {
                            // Block 0xED69
                            $1++;
                            $1++;
                            loop 0xed65;
                        }
                    } else {
                        // Block 0xED56
                        neg bx;
                    }
                } else {
                    // Block 0xED4F
                    neg ax;
                }
            } else {
                // Block 0xED48
                dec dx;
            }
        } else {
            // Block 0xED34
            for (cx = 0; cx < $2_2; cx++) {
            cmp cx, 0;
            if (a >= b) {  // jge 0xed7c
                // Block 0xED7C
                $1 = pop();
                $1 += $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0xED3C
                neg ax;
                jmp 0xed7c;
                // Block 0xED7C
                $1 = pop();
                $1 += $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            }
        }
    } else {
        // Block 0xED1C
        // Compare $1 with $2
        if (a < b) {  // jl 0xed2b
            // Block 0xED2B
            mov dx, 0x168;
        } else {
            // Block 0xED21
            $1 = $2;
            jmp 0xed2e;
            // Block 0xED2E
            push($1);
            // Compare $1 with $2
            if (a != b) {  // jne 0xed40
                // Block 0xED40
                $1 = $2;
                $1 = 0;
                xor cx, bx;
                if (a >= b) {  // jge 0xed49
                    // Block 0xED49
                    push($1);
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xed51
                        // Block 0xED51
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0xed58
                            // Block 0xED58
                            $1 = $2;
                            mul dx;
                            div bx;
                            $1 = $2;
                            for (ax = word; ax < $2_2; ax++) {
                            cmp ax, word ptr [si];
                            if (a <= b (unsigned)) {  // jbe 0xed6d
                                // Block 0xED6D
                                $1 = $2;
                                $1 -= $2;
                                shr ax, 1;
                                $1 = pop();
                                // Compare $1 with $2
                                if (a >= b) {  // jge 0xed7c
                                    // Block 0xED7C
                                    $1 = pop();
                                    $1 += $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xED7A
                                    neg ax;
                                }
                            } else {
                                // Block 0xED69
                                $1++;
                                $1++;
                                loop 0xed65;
                            }
                        } else {
                            // Block 0xED56
                            neg bx;
                        }
                    } else {
                        // Block 0xED4F
                        neg ax;
                    }
                } else {
                    // Block 0xED48
                    dec dx;
                }
            } else {
                // Block 0xED34
                for (cx = 0; cx < $2_2; cx++) {
                cmp cx, 0;
                if (a >= b) {  // jge 0xed7c
                    // Block 0xED7C
                    $1 = pop();
                    $1 += $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0xED3C
                    neg ax;
                    jmp 0xed7c;
                    // Block 0xED7C
                    $1 = pop();
                    $1 += $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            }
        }
    }
}

void sub_ED84(int) {
    // Purpose: Manipulates strings or memory blocks and performs calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;
    int var_F2_i;
    int var_F4_i;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0xED84
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    shr ax, 1;
    shr ax, 1;
    $1 -= $2;
    if (a >= b) {  // jge 0xedbb
        // Block 0xEDBB
        *($1) = $2;
        mov word ptr [bp - 0x14], 0;
        $1 = $2;
        cmp word ptr [si + 0x3c], 1;
        if (a != b) {  // jne 0xedf8
            // Block 0xEDF8
            $1 = $2;
            // Compare $1 with $2
            if (a >= b) {  // jge 0xee06
                // Block 0xEE06
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0xee14
                    // Block 0xEE14
                    $1 = $2;
                    *($1) = $2;
                    add word ptr [bp + 0x12], ax;
                    add word ptr [bp + 0xe], ax;
                    $1 = $2;
                    *($1) = $2;
                    add word ptr [bp + 0x10], ax;
                    add word ptr [bp + 0xc], ax;
                    mov word ptr [si + 0x30], 0;
                    mov word ptr [si + 0x32], 0;
                    $1 = $2;
                    *($1) = $2;
                    mov word ptr [si + 0x3c], 0;
                    $1 = $2;
                    $1 -= $2;
                    $1++;
                    shr ax, 1;
                    *($1) = $2;
                    $1 += $2;
                    *($1) = $2;
                    $1 = $2;
                    $1 -= $2;
                    $1++;
                    shr ax, 1;
                    *($1) = $2;
                    $1 += $2;
                    *($1) = $2;
                    $1 = $2;
                    $1 = $2;
                    imul dx;
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    *($1) = $2;
                    $1 = $2;
                    // Compare $1 with $2
                    if (a > b) {  // jg 0xee83
                        // Block 0xEE83
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        *($1) = $2;
                        $1 -= $2;
                        *($1) = $2;
                        $1 = $2;
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        push($1);
                        call 0xeffc;
                        // Block 0xEEAD
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        $1 = 0;
                        lcall 0x7ff, 0x50;
                        $1 += $2;
                        *($1) = $2;
                        stosw word ptr es:[di], ax;
                        $1 = pop();
                        call 0xf03c;
                        // Block 0xEEC7
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        $1 = 0;
                        lcall 0x7ff, 0x50;
                        $1 += $2;
                        *($1) = $2;
                        stosw word ptr es:[di], ax;
                        inc word ptr [bp - 0x14];
                    } else {
                        // Block 0xEE80
                        add ax, 0x168;
                    }
                } else {
                    // Block 0xEE0E
                    xchg word ptr [bp + 0x12], ax;
                    mov word ptr [bp + 0xe], ax;
                }
            } else {
                // Block 0xEE00
                xchg word ptr [bp + 0x10], ax;
                mov word ptr [bp + 0xc], ax;
            }
        } else {
            // Block 0xEDCC
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            mov word ptr [bp + 0xc], ax;
        }
    } else {
        // Block 0xEDB3
        mov word ptr [bp - 2], 0xfffe;
        jmp 0xefef;
        // Block 0xEFEF
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xe
    }

    // Function calls:
    sub_EFFC(); // Performs arithmetic calculations
    sub_F03C(); // Performs arithmetic calculations
    sub_EFFC(); // Performs arithmetic calculations
    sub_F03C(); // Performs arithmetic calculations
    sub_EFFC(); // Performs arithmetic calculations
    sub_F03C(); // Performs arithmetic calculations
}

void sub_EFFC(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 2

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0xEFFC
    // Compare $1 with $2
    if (a < b) {  // jl 0xf004
        // Block 0xF004
        // Compare $1 with $2
        if (a <= b) {  // jle 0xf012
            // Block 0xF012
            // Compare $1 with $2
            if (a <= b) {  // jle 0xf02b
                // Block 0xF02B
                xor dx, dx;
            } else {
                // Block 0xF017
                for (ax = 0xb4; ax < $2_2; ax++) {
                cmp ax, 0xb4;
                if (a <= b) {  // jle 0xf024
                    // Block 0xF024
                    $1 -= $2;
                    neg ax;
                    jmp 0xf02d;
                    // Block 0xF02D
                    $1 = $2;
                    shl bx, 1;
                    $1 = $2;
                    or dx, dx;
                    if (a == b) {  // je 0xf03b
                        // Block 0xF03B
                        return;  // ret 
                    } else {
                        // Block 0xF039
                        neg ax;
                    }
                } else {
                    // Block 0xF01F
                    $1 -= $2;
                    jmp 0xf02d;
                    // Block 0xF02D
                    $1 = $2;
                    shl bx, 1;
                    $1 = $2;
                    or dx, dx;
                    if (a == b) {  // je 0xf03b
                        // Block 0xF03B
                        return;  // ret 
                    } else {
                        // Block 0xF039
                        neg ax;
                    }
                }
            }
        } else {
            // Block 0xF009
            $1 = 0;
            $1 -= $2;
            neg ax;
            jmp 0xf02d;
            // Block 0xF02D
            $1 = $2;
            shl bx, 1;
            $1 = $2;
            or dx, dx;
            if (a == b) {  // je 0xf03b
                // Block 0xF03B
                return;  // ret 
            } else {
                // Block 0xF039
                neg ax;
            }
        }
    } else {
        // Block 0xF001
        sub ax, 0x168;
    }
}

void sub_F03C(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 1

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xF03C
    // Compare $1 with $2
    if (a < b) {  // jl 0xf044
        // Block 0xF044
        // Compare $1 with $2
        if (a <= b) {  // jle 0xf05c
            // Block 0xF05C
            for (ax = 0x5a; ax < $2_2; ax++) {
            cmp ax, 0x5a;
            if (a <= b) {  // jle 0xf069
                // Block 0xF069
                $1 = $2;
                $1 -= $2;
                shl bx, 1;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0xf07a
                    // Block 0xF07A
                    return;  // ret 
                } else {
                    // Block 0xF078
                    neg ax;
                }
            } else {
                // Block 0xF064
                $1 -= $2;
                neg ax;
            }
        } else {
            // Block 0xF049
            $1 = 0;
            // Compare $1 with $2
            if (a <= b) {  // jle 0xf057
                // Block 0xF057
                $1 -= $2;
                jmp 0xf069;
                // Block 0xF069
                $1 = $2;
                $1 -= $2;
                shl bx, 1;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0xf07a
                    // Block 0xF07A
                    return;  // ret 
                } else {
                    // Block 0xF078
                    neg ax;
                }
            } else {
                // Block 0xF050
                $1 -= $2;
                neg ax;
                jmp 0xf069;
                // Block 0xF069
                $1 = $2;
                $1 -= $2;
                shl bx, 1;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0xf07a
                    // Block 0xF07A
                    return;  // ret 
                } else {
                    // Block 0xF078
                    neg ax;
                }
            }
        }
    } else {
        // Block 0xF041
        sub ax, 0x168;
    }

    // Function calls:
    sub_F100(); // Performs arithmetic calculations
}

void sub_F100(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 3

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 13 if statements

    // Block 0xF100
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (a != b) {  // jne 0xf144
        // Block 0xF144
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        add word ptr [bp + 0xe], ax;
        add word ptr [bp + 0xc], bx;
        $1 = $2;
        and dx, 2;
        if (a == b) {  // je 0xf1a0
            // Block 0xF1A0
            cmp word ptr [si], 1;
            if (a != b) {  // jne 0xf1ad
                // Block 0xF1AD
                $1 = $2;
                $1 = $2;
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0xf1c0
                    // Block 0xF1C0
                    shl ax, 1;
                    shl ax, 1;
                    $1 += $2;
                    lcall 0xc6c, 0x3e;
                    mov word ptr [bp - 0x24], ax;
                } else {
                    // Block 0xF1B8
                    mov word ptr [bp - 2], 0xfffa;
                    jmp 0xf400;
                    // Block 0xF400
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                }
            } else {
                // Block 0xF1A5
                $1 = $2;
                $1 = $2;
                jmp 0xf1c0;
                // Block 0xF1C0
                shl ax, 1;
                shl ax, 1;
                $1 += $2;
                lcall 0xc6c, 0x3e;
                mov word ptr [bp - 0x24], ax;
            }
        } else {
            // Block 0xF15E
            $1 = $2;
            *($1) = $2;
            mov word ptr [si + 0x3c], 0;
            *($1) = $2;
            *($1) = $2;
            mov word ptr [si + 0x30], 0;
            mov word ptr [si + 0x32], 0;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            mov word ptr [si + 0x2a], 1;
            $1 = $2;
            $1 = $2;
            mul bx;
            $1 = $2;
            $1 += $2;
            mov word ptr [bp - 0x32], di;
        }
    } else {
        // Block 0xF118
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x26c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x2cf;
        mov word ptr [bp + 8], ax;
    }

    // Function calls:
    sub_F5DB(); // Performs arithmetic calculations
    sub_F5DB(); // Performs arithmetic calculations
    sub_F40D(); // Performs arithmetic calculations
    sub_F40D(); // Performs arithmetic calculations
    sub_F40D(); // Performs arithmetic calculations
}

void sub_F40D(int, int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 14

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // int count_cx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0xF40D
    push($1);
    push($1);
    cmp word ptr [bp + 6], 2;
    if (a >= b) {  // jge 0xf418
        // Block 0xF418
        // Compare $1 with $2
        if (a != b) {  // jne 0xf420
            // Block 0xF420
            $1 = $2;
            cmp word ptr [bx + 0x26], 1;
            if (a == b) {  // je 0xf488
                // Block 0xF488
                $1 = $2;
                $1 = $2;
                $1 -= $2;
                push($1);
                $1 = $2;
                $1 += $2;
                push($1);
                $1 = $2;
                $1 += $2;
                push($1);
                push($1);
                and cx, 7;
                and bx, 7;
                $1 = $2;
                $1 = $2;
                rol ax, cl;
                $1 = $2;
                *($1) = $2;
                lcall 0xd9f, 0x178;
                $1 = $2;
                $1 += $2;
                $1 = $2;
                $1 -= $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0xf4cb
                    // Block 0xF4CB
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    push($1);
                    and cx, 7;
                    and bx, 7;
                    $1 = $2;
                    $1 = $2;
                    rol ax, cl;
                    $1 = $2;
                    *($1) = $2;
                    lcall 0xd9f, 0x178;
                    jmp 0xf5d2;
                    // Block 0xF5D2
                    $1 = pop();
                    $1 = pop();
                    *($1) = $2;
                    *($1) = $2;
                    return;  // retf 
                } else {
                    // Block 0xF4C8
                    jmp 0xf5d2;
                    // Block 0xF5D2
                    $1 = pop();
                    $1 = pop();
                    *($1) = $2;
                    *($1) = $2;
                    return;  // retf 
                }
            } else {
                // Block 0xF429
                cmp word ptr [bx + 0x22], 0;
                if (a == b) {  // je 0xf488
                    // Block 0xF488
                    $1 = $2;
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    push($1);
                    and cx, 7;
                    and bx, 7;
                    $1 = $2;
                    $1 = $2;
                    rol ax, cl;
                    $1 = $2;
                    *($1) = $2;
                    lcall 0xd9f, 0x178;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    $1 -= $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xf4cb
                        // Block 0xF4CB
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 += $2;
                        push($1);
                        push($1);
                        and cx, 7;
                        and bx, 7;
                        $1 = $2;
                        $1 = $2;
                        rol ax, cl;
                        $1 = $2;
                        *($1) = $2;
                        lcall 0xd9f, 0x178;
                        jmp 0xf5d2;
                        // Block 0xF5D2
                        $1 = pop();
                        $1 = pop();
                        *($1) = $2;
                        *($1) = $2;
                        return;  // retf 
                    } else {
                        // Block 0xF4C8
                        jmp 0xf5d2;
                        // Block 0xF5D2
                        $1 = pop();
                        $1 = pop();
                        *($1) = $2;
                        *($1) = $2;
                        return;  // retf 
                    }
                } else {
                    // Block 0xF42F
                    mov word ptr [bx + 0x28], 0xffff;
                    $1 = $2;
                    *($1) = $2;
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    push($1);
                    lcall 0xd9f, 0x178;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    $1 -= $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0xf481
                        // Block 0xF481
                        $1 = pop();
                        $1 = $2;
                        mov word ptr [bx + 0xc], ax;
                    } else {
                        // Block 0xF466
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 += $2;
                        push($1);
                        push($1);
                        lcall 0xd9f, 0x178;
                    }
                }
            }
        } else {
            // Block 0xF41D
            jmp 0xf5d2;
            // Block 0xF5D2
            $1 = pop();
            $1 = pop();
            *($1) = $2;
            *($1) = $2;
            return;  // retf 
        }
    } else {
        // Block 0xF415
        jmp 0xf4fb;
        // Block 0xF4FB
        // Compare $1 with $2
        if (a != b) {  // jne 0xf503
            // Block 0xF503
            $1 = $2;
            $1 += $2;
            $1 = $2;
            $1 += $2;
            cmp word ptr [bp - 0x24], 1;
            if (a != b) {  // jne 0xf51a
                // Block 0xF51A
                push($1);
                push($1);
                push($1);
                lcall [si];
            } else {
                // Block 0xF513
                lcall 0xc6c, 0xe5;
                if (a < b (unsigned)) {  // jb 0xf521
                    // Block 0xF521
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    $1 = $2;
                    $1 += $2;
                    cmp word ptr [bp - 0x24], 1;
                    if (a != b) {  // jne 0xf53c
                        // Block 0xF53C
                        push($1);
                        push($1);
                        push($1);
                        lcall [si];
                    } else {
                        // Block 0xF535
                        lcall 0xc6c, 0xe5;
                        if (a < b (unsigned)) {  // jb 0xf543
                            // Block 0xF543
                            $1 = pop();
                            $1 = pop();
                            push($1);
                            push($1);
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xf54f
                                // Block 0xF54F
                                $1 = $2;
                                $1 += $2;
                                $1 = $2;
                                $1 -= $2;
                                cmp word ptr [bp - 0x24], 1;
                                if (a != b) {  // jne 0xf566
                                    // Block 0xF566
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                } else {
                                    // Block 0xF55F
                                    lcall 0xc6c, 0xe5;
                                    if (a < b (unsigned)) {  // jb 0xf56d
                                        // Block 0xF56D
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        $1 = $2;
                                        $1 -= $2;
                                        $1 = $2;
                                        $1 -= $2;
                                        cmp word ptr [bp - 0x24], 1;
                                        if (a != b) {  // jne 0xf588
                                            // Block 0xF588
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                            jmp 0xf5d2;
                                            // Block 0xF5D2
                                            $1 = pop();
                                            $1 = pop();
                                            *($1) = $2;
                                            *($1) = $2;
                                            return;  // retf 
                                        } else {
                                            // Block 0xF581
                                            lcall 0xc6c, 0xe5;
                                            if (a < b (unsigned)) {  // jb 0xf5d2
                                                // Block 0xF5D2
                                                $1 = pop();
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                return;  // retf 
                                            } else {
                                                // Block 0xF588
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                                jmp 0xf5d2;
                                                // Block 0xF5D2
                                                $1 = pop();
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0xF566
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    }
                                }
                            } else {
                                // Block 0xF54C
                                jmp 0xf5d2;
                                // Block 0xF5D2
                                $1 = pop();
                                $1 = pop();
                                *($1) = $2;
                                *($1) = $2;
                                return;  // retf 
                            }
                        } else {
                            // Block 0xF53C
                            push($1);
                            push($1);
                            push($1);
                            lcall [si];
                        }
                    }
                } else {
                    // Block 0xF51A
                    push($1);
                    push($1);
                    push($1);
                    lcall [si];
                }
            }
        } else {
            // Block 0xF500
            jmp 0xf591;
            // Block 0xF591
            $1 = $2;
            $1 = $2;
            $1 += $2;
            cmp word ptr [bp - 0x24], 1;
            if (a != b) {  // jne 0xf5a6
                // Block 0xF5A6
                push($1);
                push($1);
                push($1);
                lcall [si];
            } else {
                // Block 0xF59F
                lcall 0xc6c, 0xe5;
                if (a < b (unsigned)) {  // jb 0xf5ad
                    // Block 0xF5AD
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    // Compare $1 with $2
                    if (a == b) {  // je 0xf5d2
                        // Block 0xF5D2
                        $1 = pop();
                        $1 = pop();
                        *($1) = $2;
                        *($1) = $2;
                        return;  // retf 
                    } else {
                        // Block 0xF5B6
                        $1 = $2;
                        $1 = $2;
                        $1 -= $2;
                        cmp word ptr [bp - 0x24], 1;
                        if (a != b) {  // jne 0xf5cb
                            // Block 0xF5CB
                            push($1);
                            push($1);
                            push($1);
                            lcall [si];
                        } else {
                            // Block 0xF5C4
                            lcall 0xc6c, 0xe5;
                            if (a < b (unsigned)) {  // jb 0xf5d2
                                // Block 0xF5D2
                                $1 = pop();
                                $1 = pop();
                                *($1) = $2;
                                *($1) = $2;
                                return;  // retf 
                            } else {
                                // Block 0xF5CB
                                push($1);
                                push($1);
                                push($1);
                                lcall [si];
                            }
                        }
                    }
                } else {
                    // Block 0xF5A6
                    push($1);
                    push($1);
                    push($1);
                    lcall [si];
                }
            }
        }
    }
}

void sub_F5DB(int, int) {
    // Purpose: Performs arithmetic calculations

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // int data_dx; // from parameter 2
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0xF5DB
    push($1);
    $1 = $2;
    mul cx;
    or dx, dx;
    if (a == b) {  // je 0xf5e8
        // Block 0xF5E8
        xchg cx, ax;
        $1 = pop();
        mul dx;
        add dx, cx;
    } else {
        // Block 0xF5E4
        $1 = pop();
        stc ;
        jmp 0xf5ee;
        // Block 0xF5EE
        return;  // retf 
    }

    // Function calls:
    sub_F768(); // Performs arithmetic calculations
    sub_F768(); // Performs arithmetic calculations
}

void sub_F768(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 7

    // Variable declarations
    // Parameters:
    // int result_ax; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 15 if statements

    // Block 0xF768
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    cmp byte ptr [0x6d33], 1;
    if (a == b) {  // je 0xf783
        // Block 0xF783
        mov byte ptr [bp - 0x4e], 0;
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        cmp word ptr [si + 0x3c], 1;
        if (a != b) {  // jne 0xf7c2
            // Block 0xF7C2
            $1 = $2;
            $1 = $2;
            or bx, word ptr [si + 0x32];
            if (a == b) {  // je 0xf7db
                // Block 0xF7DB
                $1 = $2;
                // Compare $1 with $2
                if (a <= b) {  // jle 0xf7f6
                    // Block 0xF7F6
                    cmp word ptr [si + 0x18], 1;
                    if (a != b) {  // jne 0xf835
                        // Block 0xF835
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        shr ax, 1;
                        *($1) = $2;
                        cmp word ptr [si], 1;
                        if (a != b) {  // jne 0xf85c
                            // Block 0xF85C
                            $1 = $2;
                            $1 = $2;
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0xf86d
                                // Block 0xF86D
                                mov word ptr [bp - 2], 0xfffa;
                                jmp 0xf8b4;
                                // Block 0xF8B4
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 8
                            } else {
                                // Block 0xF868
                                // Compare $1 with $2
                                if (a <= b (unsigned)) {  // jbe 0xf874
                                    // Block 0xF874
                                    $1 = $2;
                                    mul dx;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x2c], 0;
                                    if (a != b) {  // jne 0xf8a7
                                        // Block 0xF8A7
                                        nop ;
                                        nop ;
                                        jmp 0xf9de;
                                        // Block 0xF9DE
                                    } else {
                                        // Block 0xF881
                                        cmp word ptr [bp - 0x2a], -1;
                                        if (a == b) {  // je 0xf89e
                                            // Block 0xF89E
                                            $1 = $2;
                                            *($1) = $2;
                                            ljmp [si + 4];
                                        } else {
                                            // Block 0xF887
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF88F
                                                $1 = $2;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0xf8ac
                                                    // Block 0xF8AC
                                                    nop ;
                                                    nop ;
                                                    goto $1;
                                                    mov word ptr [bp - 2], ax;
                                                    // Block 0xFBCF
                                                } else {
                                                    // Block 0xF897
                                                    $1 = $2;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0xf8ac
                                                        // Block 0xF8AC
                                                        nop ;
                                                        nop ;
                                                        goto $1;
                                                        mov word ptr [bp - 2], ax;
                                                        // Block 0xFBCF
                                                    } else {
                                                        // Block 0xF89E
                                                        $1 = $2;
                                                        *($1) = $2;
                                                        ljmp [si + 4];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xF86D
                                    mov word ptr [bp - 2], 0xfffa;
                                    jmp 0xf8b4;
                                    // Block 0xF8B4
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 8
                                }
                            }
                        } else {
                            // Block 0xF854
                            $1 = $2;
                            $1 = $2;
                            jmp 0xf874;
                            // Block 0xF874
                            $1 = $2;
                            mul dx;
                            $1 += $2;
                            cmp word ptr [bp - 0x2c], 0;
                            if (a != b) {  // jne 0xf8a7
                                // Block 0xF8A7
                                nop ;
                                nop ;
                                jmp 0xf9de;
                                // Block 0xF9DE
                            } else {
                                // Block 0xF881
                                cmp word ptr [bp - 0x2a], -1;
                                if (a == b) {  // je 0xf89e
                                    // Block 0xF89E
                                    $1 = $2;
                                    *($1) = $2;
                                    ljmp [si + 4];
                                } else {
                                    // Block 0xF887
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xf8ac
                                        // Block 0xF8AC
                                        nop ;
                                        nop ;
                                        goto $1;
                                        mov word ptr [bp - 2], ax;
                                        // Block 0xFBCF
                                    } else {
                                        // Block 0xF88F
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xf8ac
                                            // Block 0xF8AC
                                            nop ;
                                            nop ;
                                            goto $1;
                                            mov word ptr [bp - 2], ax;
                                            // Block 0xFBCF
                                        } else {
                                            // Block 0xF897
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF89E
                                                $1 = $2;
                                                *($1) = $2;
                                                ljmp [si + 4];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xF7FC
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        lcall 0xc6c, 0x10c;
                        if (a >= b (unsigned)) {  // jae 0xf817
                            // Block 0xF817
                            // Compare $1 with $2
                            if (a == b) {  // je 0xf829
                                // Block 0xF829
                                *($1) = $2;
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [bp + 6], dx;
                            } else {
                                // Block 0xF81C
                                push($1);
                                $1 = $2;
                                $1 -= $2;
                                and cl, 7;
                                ror word ptr [bp - 0x2a], cl;
                                pop cx;
                            }
                        } else {
                            // Block 0xF80F
                            mov word ptr [bp - 2], 0;
                            jmp 0xf8b4;
                            // Block 0xF8B4
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    }
                } else {
                    // Block 0xF7E3
                    xchg word ptr [bp + 8], ax;
                    *($1) = $2;
                    $1 = $2;
                    xchg word ptr [bp + 6], ax;
                    *($1) = $2;
                    mov byte ptr [bp - 0x4e], 1;
                }
            } else {
                // Block 0xF7CC
                $1 = $2;
                add word ptr [bp + 0xc], ax;
                add word ptr [bp + 0xa], bx;
                add word ptr [bp + 8], ax;
                add word ptr [bp + 6], bx;
            }
        } else {
            // Block 0xF796
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            mov word ptr [bp + 6], ax;
        }
    } else {
        // Block 0xF77F
        push($1);
        call 0xf8c1;
        // Block 0xF783
        mov byte ptr [bp - 0x4e], 0;
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        cmp word ptr [si + 0x3c], 1;
        if (a != b) {  // jne 0xf7c2
            // Block 0xF7C2
            $1 = $2;
            $1 = $2;
            or bx, word ptr [si + 0x32];
            if (a == b) {  // je 0xf7db
                // Block 0xF7DB
                $1 = $2;
                // Compare $1 with $2
                if (a <= b) {  // jle 0xf7f6
                    // Block 0xF7F6
                    cmp word ptr [si + 0x18], 1;
                    if (a != b) {  // jne 0xf835
                        // Block 0xF835
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        shr ax, 1;
                        *($1) = $2;
                        cmp word ptr [si], 1;
                        if (a != b) {  // jne 0xf85c
                            // Block 0xF85C
                            $1 = $2;
                            $1 = $2;
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0xf86d
                                // Block 0xF86D
                                mov word ptr [bp - 2], 0xfffa;
                                jmp 0xf8b4;
                                // Block 0xF8B4
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 8
                            } else {
                                // Block 0xF868
                                // Compare $1 with $2
                                if (a <= b (unsigned)) {  // jbe 0xf874
                                    // Block 0xF874
                                    $1 = $2;
                                    mul dx;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x2c], 0;
                                    if (a != b) {  // jne 0xf8a7
                                        // Block 0xF8A7
                                        nop ;
                                        nop ;
                                        jmp 0xf9de;
                                        // Block 0xF9DE
                                    } else {
                                        // Block 0xF881
                                        cmp word ptr [bp - 0x2a], -1;
                                        if (a == b) {  // je 0xf89e
                                            // Block 0xF89E
                                            $1 = $2;
                                            *($1) = $2;
                                            ljmp [si + 4];
                                        } else {
                                            // Block 0xF887
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF88F
                                                $1 = $2;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0xf8ac
                                                    // Block 0xF8AC
                                                    nop ;
                                                    nop ;
                                                    goto $1;
                                                    mov word ptr [bp - 2], ax;
                                                    // Block 0xFBCF
                                                } else {
                                                    // Block 0xF897
                                                    $1 = $2;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0xf8ac
                                                        // Block 0xF8AC
                                                        nop ;
                                                        nop ;
                                                        goto $1;
                                                        mov word ptr [bp - 2], ax;
                                                        // Block 0xFBCF
                                                    } else {
                                                        // Block 0xF89E
                                                        $1 = $2;
                                                        *($1) = $2;
                                                        ljmp [si + 4];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xF86D
                                    mov word ptr [bp - 2], 0xfffa;
                                    jmp 0xf8b4;
                                    // Block 0xF8B4
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 8
                                }
                            }
                        } else {
                            // Block 0xF854
                            $1 = $2;
                            $1 = $2;
                            jmp 0xf874;
                            // Block 0xF874
                            $1 = $2;
                            mul dx;
                            $1 += $2;
                            cmp word ptr [bp - 0x2c], 0;
                            if (a != b) {  // jne 0xf8a7
                                // Block 0xF8A7
                                nop ;
                                nop ;
                                jmp 0xf9de;
                                // Block 0xF9DE
                            } else {
                                // Block 0xF881
                                cmp word ptr [bp - 0x2a], -1;
                                if (a == b) {  // je 0xf89e
                                    // Block 0xF89E
                                    $1 = $2;
                                    *($1) = $2;
                                    ljmp [si + 4];
                                } else {
                                    // Block 0xF887
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xf8ac
                                        // Block 0xF8AC
                                        nop ;
                                        nop ;
                                        goto $1;
                                        mov word ptr [bp - 2], ax;
                                        // Block 0xFBCF
                                    } else {
                                        // Block 0xF88F
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xf8ac
                                            // Block 0xF8AC
                                            nop ;
                                            nop ;
                                            goto $1;
                                            mov word ptr [bp - 2], ax;
                                            // Block 0xFBCF
                                        } else {
                                            // Block 0xF897
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF89E
                                                $1 = $2;
                                                *($1) = $2;
                                                ljmp [si + 4];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xF7FC
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        lcall 0xc6c, 0x10c;
                        if (a >= b (unsigned)) {  // jae 0xf817
                            // Block 0xF817
                            // Compare $1 with $2
                            if (a == b) {  // je 0xf829
                                // Block 0xF829
                                *($1) = $2;
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [bp + 6], dx;
                            } else {
                                // Block 0xF81C
                                push($1);
                                $1 = $2;
                                $1 -= $2;
                                and cl, 7;
                                ror word ptr [bp - 0x2a], cl;
                                pop cx;
                            }
                        } else {
                            // Block 0xF80F
                            mov word ptr [bp - 2], 0;
                            jmp 0xf8b4;
                            // Block 0xF8B4
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    }
                } else {
                    // Block 0xF7E3
                    xchg word ptr [bp + 8], ax;
                    *($1) = $2;
                    $1 = $2;
                    xchg word ptr [bp + 6], ax;
                    *($1) = $2;
                    mov byte ptr [bp - 0x4e], 1;
                }
            } else {
                // Block 0xF7CC
                $1 = $2;
                add word ptr [bp + 0xc], ax;
                add word ptr [bp + 0xa], bx;
                add word ptr [bp + 8], ax;
                add word ptr [bp + 6], bx;
            }
        } else {
            // Block 0xF796
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            mov word ptr [bp + 6], ax;
        }
    }

    // Function calls:
    sub_F8C1(); // Performs arithmetic calculations
}

void sub_F8C1(int) {
    // Purpose: Performs arithmetic calculations

    // Complexity: 40

    // Variable declarations
    // Parameters:
    // int base_bx; // from parameter 1
    // Local variables:
    int base_bx;
    int count_cx;
    int data_dx;
    int dest_di;
    char[] dos_cmd_line;
    char dos_cmd_line_len;
    int dos_env_segment;
    struct dos_fcb1;
    struct dos_fcb2;
    int frame_bp;
    int result_ax;
    int source_si;

    // Control flow structures identified:
    // - 96 if statements

    // Block 0xF8C1
    $1 = $2;
    mov word ptr [bx + 4], 0x7b9;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x968;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xff1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xb0f;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    $1 = $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov byte ptr [0x6d33], 1;
    return;  // retf 

    // Function calls:
    sub_F768(); // Performs arithmetic calculations
    sub_F768(); // Performs arithmetic calculations
    sub_F768(); // Performs arithmetic calculations
    sub_F768(); // Performs arithmetic calculations
    sub_F768(); // Performs arithmetic calculations
}
