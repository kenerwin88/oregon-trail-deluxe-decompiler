// Enhanced Pseudocode for OREGON.EXE with Control Flow and Data Flow Analysis
// Generated with Capstone-based disassembler

// Function declarations
void entry();
void entry();
void sub_102B1();
void sub_106BF();
void sub_10BCD();
void sub_10DC0();
void sub_10E6D();
void sub_10E93();
void sub_10ECE();
void sub_110C1();
void sub_11249();
void sub_114B2();
void sub_114F8();
void sub_11576();
void sub_117C2();
void sub_1183C();
void sub_1193C();
void sub_11A23();
void sub_11A48();
void sub_11A68();
void sub_11D00();
void sub_11DD9();
void sub_11E61();
void sub_12166();
void sub_12524();
void sub_12580();
void sub_14286();
void sub_1485A();
void sub_14D0E();
void sub_14E1F();
void sub_15048();
void sub_15454();
void sub_154D0();
void sub_156C6();
void sub_15798();
void sub_15AB6();
void sub_15E6E();
void sub_16504();
void sub_177DA();
void sub_17F32();
void sub_1867D();
void sub_18B44();
void sub_19038();
void sub_19831();
void sub_19B03();
void sub_19D41();
void sub_19F12();
void sub_1A25E();
void sub_1A2DE();
void sub_1A78A();
void sub_1A878();
void sub_1A97C();
void sub_1ABE3();
void sub_1AD1A();
void sub_1AE4A();
void sub_1AEBF();
void sub_1AECB();
void sub_1AF10();
void sub_1AF6D();
void sub_1AF95();
void sub_1AFA5();
void sub_1B025();
void sub_1B0F2();
void sub_1B12B();
void sub_1B170();
void sub_1B264();
void sub_1B2AE();
void sub_1B329();
void sub_1B341();
void sub_1B37C();
void sub_1B39D();
void sub_1B3BB();
void sub_1B3EE();
void sub_1B43F();
void sub_1B45D();
void sub_1B469();
void sub_1B48F();
void sub_1B4AB();
void sub_1B4B7();
void sub_1D57();
void sub_1D6A();
void sub_1D6B();
void sub_1D7D();
void sub_1DC0();
void sub_1DED();
void sub_1E31();
void sub_1E72();
void sub_1F91();
void sub_2128();
void sub_2495();
void sub_2827();
void sub_2A03();
void sub_2A40();
void sub_2A52();
void sub_2A69();
void sub_2AC0();
void sub_2ACF();
void sub_2B2E();
void sub_2B71();
void sub_2C9B();
void sub_2CBC();
void sub_2D1C();
void sub_2D44();
void sub_2D7D();
void sub_2F4E();
void sub_2F5F();
void sub_2FE1();
void sub_3001();
void sub_302A();
void sub_30E0();
void sub_30F7();
void sub_3118();
void sub_3147();
void sub_315B();
void sub_32DA();
void sub_32F5();
void sub_3319();
void sub_33BE();
void sub_363B();
void sub_3666();
void sub_3808();
void sub_3905();
void sub_391D();
void sub_3924();
void sub_392D();
void sub_3935();
void sub_394F();
void sub_395C();
void sub_3965();
void sub_3DF8();
void sub_3E1D();
void sub_3E97();
void sub_3EF4();
void sub_3F21();
void sub_3F2F();
void sub_3FD7();
void sub_40C4();
void sub_4127();
void sub_4198();
void sub_41C1();
void sub_41F8();
void sub_4221();
void sub_4285();
void sub_42DF();
void sub_4302();
void sub_430C();
void sub_4389();
void sub_4405();
void sub_44EA();
void sub_4560();
void sub_459F();
void sub_467A();
void sub_46D0();
void sub_4754();
void sub_47B4();
void sub_47EF();
void sub_488C();
void sub_4890();
void sub_4894();
void sub_4898();
void sub_489C();
void sub_48D4();
void sub_4908();
void sub_49D2();
void sub_4A0E();
void sub_4A63();
void sub_4A85();
void sub_4C86();
void sub_4D1C();
void sub_4D38();
void sub_4D9B();
void sub_4E21();
void sub_4E3E();
void sub_4E66();
void sub_4E84();
void sub_4EFB();
void sub_4FB3();
void sub_50E0();
void sub_5122();
void sub_51DE();
void sub_52AF();
void sub_534A();
void sub_54CC();
void sub_554E();
void sub_5739();
void sub_5777();
void sub_57EF();
void sub_5807();
void sub_59FF();
void sub_5A23();
void sub_5A3E();
void sub_5A50();
void sub_5BBF();
void sub_5C29();
void sub_5C45();
void sub_5DEE();
void sub_5FF1();
void sub_60C5();
void sub_61E2();
void sub_623B();
void sub_629B();
void sub_65B8();
void sub_65F7();
void sub_6661();
void sub_6680();
void sub_679C();
void sub_68ED();
void sub_70A0();
void sub_715E();
void sub_7229();
void sub_731C();
void sub_7353();
void sub_7426();
void sub_74D9();
void sub_756A();
void sub_7678();
void sub_770A();
void sub_7A56();
void sub_8346();
void sub_85ED();
void sub_8791();
void sub_893A();
void sub_901A();
void sub_987E();
void sub_9EBD();
void sub_9F7D();
void sub_A70D();
void sub_AE16();
void sub_AE65();
void sub_AFB5();
void sub_B00C();
void sub_B316();
void sub_B350();
void sub_B4EC();
void sub_B586();
void sub_B5BF();
void sub_B60A();
void sub_B66A();
void sub_B6A8();
void sub_B995();
void sub_BFC3();
void sub_C3B3();
void sub_CA9B();
void sub_CB80();
void sub_CBCF();
void sub_CBE1();
void sub_CC23();
void sub_CC40();
void sub_CC7A();
void sub_D552();
void sub_DA6E();
void sub_DE14();
void sub_DFD5();
void sub_E3A5();
void sub_E3CC();
void sub_E4E0();
void sub_E58D();
void sub_E9D0();
void sub_ECFD();
void sub_ED11();
void sub_ED84();
void sub_EFFC();
void sub_F03C();
void sub_F100();
void sub_F40D();
void sub_F5DB();
void sub_F768();
void sub_F8C1();

void entry() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x3E
    $1 = $2;
    mov word ptr cs:[0x291], dx;
    $1 = $2;
    INT_21_AH30();  // int 0x21
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    call 0x1d7d;
    // Block 0x1C28
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;

    // Function calls:
    sub_1D7D();
    sub_1DED();
    sub_2AC0();
}

void entry() {
    $1 = $2;
    mov word ptr cs:[0x291], dx;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1();
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    repne scasb al, byte ptr es:[di];
    jcxz 0x1c7e;
    $1++;
    cmp byte ptr es:[di], al;
    if (!ZF) goto $1;
    or ch, 0x80;
    neg cx;
    *($1) = $2;
    $1 = $2;
    shl bx, cl;
    $1 += $2;
    and bx, 0xfff0;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0x1c75;
    $1 = $2;
    mov word ptr es:[0x94], di;
    $1 = $2;
    shr di, cl;
    $1++;
    // Compare $1 with $2
    jae 0x1c81;
    goto $1;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    push($1);
    int 0x21;
    $1 = pop();
    shl di, cl;
    cli ;
    $1 = $2;
    $1 = $2;
    sti ;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x94], di;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    cld ;
    rep stosb byte ptr es:[di], al;
    cmp word ptr [0x74d0], 0x14;
    jbe 0x1d0c;
    cmp byte ptr [0x7d], 3;
    jb 0x1d0c;
    ja 0x1cd5;
    cmp byte ptr [0x7e], 0x1e;
    jb 0x1d0c;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x1d09;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x1d09;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x1d09;
    $1++;
    *($1) = $2;
    $1--;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x1d09;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x1d0c;
    goto $1;
    $1 = $2;
    int 0x1a;
    *($1) = $2;
    *($1) = $2;
    or al, al;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], 1;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x4e6, 8;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    retf ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    goto $1;
    push($1);
    $1 = $2;
    int 0x21;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    int 0x21;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    int 0x21;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    int 0x21;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    lds dx, ptr [0x5b];
    int 0x21;
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x5f];
    int 0x21;
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x63];
    int 0x21;
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x67];
    int 0x21;
    $1 = pop();
    retf ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp byte ptr es:[bx], 0xff;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jae 0x1e0c;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    cmp byte ptr es:[bx], 0;
    mov byte ptr es:[bx], 0xff;
    push($1);
    if (ZF) goto $1;
    lcall es:[bx + 2];
    $1 = pop();
    goto $1;
    $1();
    $1 = pop();
    goto $1;
    ret ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp byte ptr es:[bx], 0xff;
    if (ZF) goto $1;
    cmp byte ptr es:[bx + 1], ah;
    jb 0x1e4d;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    cmp byte ptr es:[bx], 0;
    mov byte ptr es:[bx], 0xff;
    push($1);
    if (ZF) goto $1;
    lcall es:[bx + 2];
    $1 = pop();
    goto $1;
    $1();
    $1 = pop();
    goto $1;
    ret ;
    $1 = $2;
    $1 = $2;
    int 0x21;
    ret ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    add byte ptr [bx + si], al;
    $1 += $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    lds si, ptr [bp + 6];
    int 0x66;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    $1 = $2;
    int 0x66;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    stosb byte ptr es:[di], al;
    $1++;
    or al, al;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    or ax, ax;
    if (!ZF) goto $1;
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lds si, ptr [bp + 6];
    $1 = $2;
    int 0x66;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    $1();
    retf ;
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lds si, ptr [si];
    or si, si;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 -= $2;
    cmp word ptr [si], 0x494d;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp word ptr [si + 2], 0x4944;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 = $2;
    int 0x66;
    or ax, ax;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp word ptr [si], 0x454b;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp word ptr [si + 2], 0x4e52;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret ;
    $1 = 0;
    goto $1;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bp + si], al;
    add byte ptr [bx + si], al;
    $1 += $2;
    add byte ptr [bx + si], al;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    les dx, ptr [bp + 6];
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    or dx, dx;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr cs:[0x3e7], ax;
    mov word ptr cs:[0x3e9], dx;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    cmp byte ptr es:[3], 0x44;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[4], 0x49;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[5], 0x47;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[6], 0x50;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[7], 0x41;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[8], 0x4b;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    mov word ptr cs:[0x3ef], ax;
    mov word ptr cs:[0x3f3], ax;
    lcall cs:[0x3ed];
    or ax, ax;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    push($1);
    $1 = 0;
    push($1);
    lcall 0x1a10, 0x34;
    $1 += $2;
    $1 = 0;
    mov word ptr cs:[0x3eb], ax;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    cmp word ptr cs:[0x3eb], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    lcall cs:[0x3f1];
    push($1);
    push($1);
    lcall 0x1a10, 0x34;
    $1 += $2;
    mov word ptr cs:[0x3eb], 0;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    $1();
    retf ;
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lds si, ptr [si];
    or si, si;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 -= $2;
    cmp word ptr [si], 0x494d;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp word ptr [si + 2], 0x4944;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret ;
    $1 = 0;
    goto $1;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    $1 = $2;
    int 0x66;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bp + si], al;
    add byte ptr [bx + si], al;
    $1 += $2;
    add byte ptr [bx + si], al;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    les dx, ptr [bp + 6];
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    or dx, dx;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr cs:[0x5ae], ax;
    mov word ptr cs:[0x5b0], dx;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    cmp byte ptr es:[3], 0x4d;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[4], 0x49;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[5], 0x44;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[6], 0x50;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[7], 0x41;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    cmp byte ptr es:[8], 0x4b;
    if (!ZF) goto $1;
    nop ;
    nop ;
    nop ;
    mov word ptr cs:[0x5b6], ax;
    mov word ptr cs:[0x5ba], ax;
    lcall cs:[0x5b4];
    or ax, ax;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    push($1);
    $1 = 0;
    push($1);
    lcall 0x1a10, 0x34;
    $1 += $2;
    $1 = 0;
    mov word ptr cs:[0x5b2], ax;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    cmp word ptr cs:[0x5b2], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    lcall cs:[0x5b8];
    push($1);
    push($1);
    lcall 0x1a10, 0x34;
    $1 += $2;
    mov word ptr cs:[0x5b2], 0;
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x66;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lds dx, ptr [bp + 6];
    $1 = $2;
    or al, al;
    if (!ZF) goto $1;
    $1 = 0;
    $1 = $2;
    int 0x21;
    jb 0x230a;
    jae 0x22d9;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x230a;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    int 0x21;
    jb 0x230a;
    lds di, ptr [bp + 0xa];
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    jcxz 0x22f7;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    $1 = 0;
    int 0x21;
    jb 0x230a;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x2322;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    int 0x21;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x234e;
    $1 = pop();
    retf ;
    $1 = 0;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 6];
    $1 = $2;
    cmp word ptr [bp + 0xc], 0;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0x2371;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x23ab;
    // Compare $1 with $2
    if (!ZF) goto $1;
    sub word ptr [bp + 0xa], cx;
    sbb word ptr [bp + 0xc], 0;
    $1 = $2;
    and ax, 0xf;
    $1 += $2;
    shr cx, 1;
    shr cx, 1;
    shr cx, 1;
    shr cx, 1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp + 0xa], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp + 0xc], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 6];
    $1 = $2;
    cmp word ptr [bp + 0xc], 0;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0x23cf;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x2409;
    // Compare $1 with $2
    if (!ZF) goto $1;
    sub word ptr [bp + 0xa], cx;
    sbb word ptr [bp + 0xc], 0;
    $1 = $2;
    and ax, 0xf;
    $1 += $2;
    shr cx, 1;
    shr cx, 1;
    shr cx, 1;
    shr cx, 1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp + 0xa], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp + 0xc], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    int 0x21;
    jb 0x248c;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    int 0x21;
    jb 0x2488;
    lds di, ptr [bp + 0xa];
    or di, di;
    if (ZF) goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    lcall 0x1a10, 0x2f;
    $1 += $2;
    $1 = $2;
    or ax, ax;
    if (!ZF) goto $1;
    or dx, dx;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    $1 = 0;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x21;
    $1 = 0;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    int 0x21;
    jae 0x24ab;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    int 0x21;
    jb 0x2532;
    lds di, ptr [bp + 0xa];
    or di, di;
    if (ZF) goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, 0;
    push($1);
    push($1);
    lcall 0x1a10, 0x2f;
    $1 += $2;
    $1 = $2;
    or ax, ax;
    if (!ZF) goto $1;
    or dx, dx;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    $1 = 0;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    and dx, 0xfff0;
    $1 = $2;
    int 0x21;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    $1 += $2;
    lds bx, ptr [bp + 0xe];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x21;
    $1 = 0;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x16;
    if (!ZF) goto $1;
    $1 = 0;
    retf ;
    $1 = $2;
    retf ;
    $1 = $2;
    int 0x21;
    $1 = 0;
    or al, al;
    if (!ZF) goto $1;
    $1 = $2;
    int 0x21;
    $1 = 0;
    $1 += $2;
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    lodsb al, byte ptr [si];
    stosb byte ptr es:[di], al;
    or al, al;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    les di, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1--;
    lds si, ptr [bp + 0xa];
    lodsb al, byte ptr [si];
    stosb byte ptr es:[di], al;
    or al, al;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    or dx, dx;
    if (!ZF) goto $1;
    $1 = $2;
    $1++;
    $1 = $2;
    int 0x21;
    jae 0x25c2;
    $1 = 0;
    $1 = $2;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x25da;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lds si, ptr [bp + 6];
    $1 = $2;
    lodsb al, byte ptr [si];
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    int 0x10;
    $1 = $2;
    $1 = $2;
    int 0x10;
    goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    cli ;
    push($1);
    $1 = 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    out 0x43, al;
    goto $1;
    $1 = $2;
    out 0x40, al;
    goto $1;
    $1 = $2;
    out 0x40, al;
    sti ;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 6];
    $1 = $2;
    int 0x21;
    jae 0x264d;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    les di, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1 = $2;
    $1--;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    $1 = 0;
    lds si, ptr [bp + 6];
    push($1);
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1 = $2;
    lodsb al, byte ptr [si];
    // Compare $1 with $2
    jl 0x2696;
    // Compare $1 with $2
    jg 0x2696;
    $1 -= $2;
    stosb byte ptr es:[di], al;
    loop 0x268b;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    push($1);
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1 = pop();
    repe cmpsb byte ptr [si], byte ptr es:[di];
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    int 0x21;
    jb 0x26ec;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = 0;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    lds si, ptr [bp + 0xc];
    cmp word ptr [bp + 0xa], 0;
    if (!ZF) goto $1;
    or si, si;
    if (ZF) goto $1;
    nop ;
    nop ;
    nop ;
    $1 = $2;
    push($1);
    $1 = pop();
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    neg cx;
    $1--;
    *($1) = $2;
    $1 = $2;
    or ax, ax;
    js 0x2784;
    // Compare $1 with $2
    jg 0x2784;
    $1 = $2;
    // Compare $1 with $2
    jg 0x2784;
    or ax, ax;
    jns 0x2745;
    neg ax;
    or si, si;
    if (ZF) goto $1;
    $1 += $2;
    sub word ptr [bp + 0xa], ax;
    js 0x2784;
    if (ZF) goto $1;
    mov word ptr [bp + 6], 0;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jle 0x2756;
    $1 -= $2;
    sub word ptr [bp + 0xa], ax;
    js 0x2784;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    shl ax, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or si, si;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    or al, al;
    if (ZF) goto $1;
    stosw word ptr es:[di], ax;
    loop 0x2776;
    goto $1;
    $1 = $2;
    rep stosw word ptr es:[di], ax;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    $1 = $2;
    mul word ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    shl ax, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    stosb byte ptr es:[di], al;
    $1++;
    loop 0x27af;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    shl ax, 1;
    rcl dx, 1;
    shl ax, 1;
    rcl dx, 1;
    shl ax, 1;
    rcl dx, 1;
    shl ax, 1;
    rcl dx, 1;
    $1 += $2;
    adc dx, 0;
    $1 += $2;
    adc dx, word ptr [bp + 0xc];
    push($1);
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    $1 = $2;
    $1 = pop();
    and ax, 0xf;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 6];
    push($1);
    push($1);
    $1 = pop();
    $1 = $2;
    int 0x21;
    $1 += $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0x28b7;
    repne scasb al, byte ptr es:[di];
    scasb al, byte ptr es:[di];
    if (!ZF) goto $1;
    xchg ah, al;
    scasb al, byte ptr es:[di];
    xchg ah, al;
    if (!ZF) goto $1;
    scasb al, byte ptr es:[di];
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    push($1);
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = 0;
    stosb byte ptr es:[di], al;
    $1 = pop();
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    push($1);
    $1 = pop();
    std ;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    cld ;
    if (ZF) goto $1;
    les ax, ptr [bp + 6];
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    goto $1;
    $1++;
    $1 = 0;
    stosb byte ptr es:[di], al;
    $1++;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    lds si, ptr [bp + 6];
    cmp byte ptr [si + 1], 0x3a;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    // Compare $1 with $2
    jb 0x28ec;
    // Compare $1 with $2
    ja 0x28ec;
    $1 -= $2;
    // Compare $1 with $2
    jb 0x2911;
    // Compare $1 with $2
    ja 0x2911;
    $1 -= $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x2911;
    $1++;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x2911;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = 0;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    lds dx, ptr [bp + 6];
    or dx, dx;
    if (!ZF) goto $1;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 = 0;
    $1 = $2;
    int 0x21;
    jae 0x2944;
    $1 = 0;
    goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    lea si, [si + 0x1e];
    $1 = $2;
    les di, ptr [bp + 0xa];
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    int 0x21;
    jae 0x2944;
    $1 = 0;
    goto $1;
    push($1);
    if (!ZF) goto $1;
    if (ZF) goto $1;
    insw word ptr es:[di], dx;
    and byte ptr gs:[bx + 0x76], ch;
    jb 0x29e9;
    popaw ;
    jns 0x29a0;
    jb 0x29f5;
    outsw dx, word ptr [si];
    jb 0x2993;
    or bh, byte ptr [bx + di + 0x17];
    $1 = $2;
    push($1);
    $1 = pop();
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    nop ;
    push($1);
    $1();
    retf ;
    push($1);
    $1 = $2;
    cmp word ptr [0x7230], 0x20;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    shl bx, cl;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1++;
    $1 = 0;
    $1 = pop();
    retf ;
    int 0x11;
    retf ;
    int 0x12;
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x1a;
    xchg dx, ax;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21;
    $1 = pop();
    jb 0x29fd;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    lds dx, ptr [bp + 6];
    int 0x21;
    $1 = pop();
    jb 0x2a1d;
    les bx, ptr [bp + 0xa];
    mov word ptr es:[bx], cx;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    $1 = $2;
    int 0x21;
    $1 = pop();
    jb 0x2a3a;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1++;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], ax;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1--;
    $1 = $2;
    int 0x21;
    $1 = $2;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], ax;
    $1 = pop();
    retf ;
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    goto $1;
    $1--;
    $1 = $2;
    $1 = $2;
    shl bx, cl;
    lcall [bx - 0x78fe];
    cmp word ptr [0x7230], 0;
    if (!ZF) goto $1;
    nop ;
    push($1);
    $1();
    lcall [0x7334];
    nop ;
    push($1);
    $1();
    nop ;
    push($1);
    $1();
    cmp word ptr [bp + 6], 0;
    if (!ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    lcall [0x7338];
    lcall [0x733c];
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    ret 6;
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1();
    $1 = pop();
    retf ;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    $1();
    retf ;
    $1 = $2;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1();
    retf ;
    push($1);
    xchg si, ax;
    xchg dx, ax;
    test ax, ax;
    if (ZF) goto $1;
    mul bx;
    jcxz 0x2b0b;
    xchg cx, ax;
    mul si;
    $1 += $2;
    xchg si, ax;
    mul bx;
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    cld ;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    adc cx, cx;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 8];
    int 0x21;
    $1 = pop();
    jb 0x2b44;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], cx;
    mov word ptr es:[bx + 2], dx;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], cx;
    mov word ptr es:[bx + 2], dx;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lea ax, [bp - 2];
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1--;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lea ax, [bp - 2];
    push($1);
    $1 = $2;
    $1++;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x2bc6;
    les di, ptr [bp + 8];
    mov word ptr es:[di], cx;
    mov word ptr es:[di + 2], dx;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    xchg bx, ax;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 8];
    int 0x21;
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = pop();
    push($1);
    push($1);
    $1 = 0;
    goto $1;
    $1 = pop();
    push($1);
    push($1);
    $1 = $2;
    goto $1;
    $1 = pop();
    push($1);
    push($1);
    $1 = $2;
    goto $1;
    $1 = pop();
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, cx;
    if (!ZF) goto $1;
    or dx, dx;
    if (ZF) goto $1;
    or bx, bx;
    if (ZF) goto $1;
    test di, 1;
    if (!ZF) goto $1;
    or dx, dx;
    jns 0x2c3d;
    neg dx;
    neg ax;
    sbb dx, 0;
    or di, 0xc;
    or cx, cx;
    jns 0x2c4b;
    neg cx;
    neg bx;
    sbb cx, 0;
    xor di, 4;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    shl ax, 1;
    rcl dx, 1;
    rcl si, 1;
    rcl di, 1;
    // Compare $1 with $2
    jb 0x2c6c;
    ja 0x2c67;
    // Compare $1 with $2
    jb 0x2c6c;
    $1 -= $2;
    sbb di, bp;
    $1++;
    loop 0x2c55;
    $1 = pop();
    test bx, 2;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shr bx, 1;
    test bx, 4;
    if (ZF) goto $1;
    neg dx;
    neg ax;
    sbb dx, 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf 8;
    div bx;
    test di, 2;
    if (ZF) goto $1;
    xchg dx, ax;
    $1 = 0;
    goto $1;
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    jae 0x2cb3;
    $1 = $2;
    shl ax, cl;
    shl dx, cl;
    neg cl;
    $1 += $2;
    shr bx, cl;
    or dx, bx;
    retf ;
    $1 -= $2;
    xchg dx, ax;
    $1 = 0;
    shl dx, cl;
    retf ;
    $1 = pop();
    push($1);
    push($1);
    or cx, cx;
    jge 0x2ccf;
    not bx;
    not cx;
    $1 += $2;
    adc cx, 0;
    goto $1;
    $1 += $2;
    jae 0x2cd7;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shl ch, cl;
    $1 += $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    $1 = $2;
    and ax, 0xf;
    retf ;
    $1 = pop();
    push($1);
    push($1);
    or cx, cx;
    jge 0x2cfe;
    not bx;
    not cx;
    $1 += $2;
    adc cx, 0;
    goto $1;
    $1 -= $2;
    jae 0x2d06;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    shl bh, cl;
    $1 = 0;
    $1 -= $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    $1 = $2;
    and ax, 0xf;
    retf ;
    $1 = pop();
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl dx, cl;
    shr ch, cl;
    $1 += $2;
    adc ch, 0;
    $1 = $2;
    shl di, cl;
    shr ah, cl;
    $1 += $2;
    adc ah, 0;
    $1 -= $2;
    sbb ch, ah;
    $1 = $2;
    cwde ;
    xchg dx, ax;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or si, si;
    jl 0x2d64;
    // Compare $1 with $2
    jle 0x2d57;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cwde ;
    $1 = $2;
    goto $1;
    neg si;
    // Compare $1 with $2
    jg 0x2d54;
    mov word ptr [0x74fe], 0xffff;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret 2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret 2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0xe;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    cmp word ptr [bp + 6], 0x80;
    jae 0x2db0;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0xc;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0x20;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x2dff;
    // Compare $1 with $2
    jg 0x2dff;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 8;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x2e2a;
    // Compare $1 with $2
    jg 0x2e2a;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0x40;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 1;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 4;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    and ax, 0x12;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    les bx, ptr [bp + 6];
    $1--;
    jl 0x2e97;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1--;
    jl 0x2ebc;
    les bx, ptr [0x734c];
    $1++;
    $1 = $2;
    $1 = $2;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1++;
    jge 0x2ef1;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    $1 = $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1++;
    jge 0x2f20;
    les bx, ptr [0x7360];
    $1++;
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1 = $2;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    and ax, 0x20;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    and ax, 0x10;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    xchg dx, ax;
    and ax, 0x80;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    les di, ptr [bp + 0xa];
    $1 = $2;
    // Compare $1 with $2
    ja 0x2fcf;
    // Compare $1 with $2
    jb 0x2fcf;
    $1 = $2;
    $1 = $2;
    or cx, cx;
    jge 0x2f94;
    cmp byte ptr [bp + 6], 0;
    if (ZF) goto $1;
    mov byte ptr es:[di], 0x2d;
    $1++;
    neg cx;
    neg ax;
    sbb cx, 0;
    lea si, [bp - 0x22];
    jcxz 0x2fa9;
    xchg cx, ax;
    $1 -= $2;
    div bx;
    xchg cx, ax;
    div bx;
    mov byte ptr ss:[si], dl;
    $1++;
    jcxz 0x2fb1;
    goto $1;
    $1 -= $2;
    div bx;
    mov byte ptr ss:[si], dl;
    $1++;
    or ax, ax;
    if (!ZF) goto $1;
    lea cx, [bp - 0x22];
    neg cx;
    $1 += $2;
    cld ;
    $1--;
    $1 = $2;
    $1 -= $2;
    jae 0x2fc9;
    $1 += $2;
    goto $1;
    $1 += $2;
    stosb byte ptr es:[di], al;
    loop 0x2fbd;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret 0xe;
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = pop();
    ret 6;
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    and word ptr [bx + 0x74d2], 0xfdff;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x3023;
    goto $1;
    push($1);
    $1();
    cdq ;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (!ZF) goto $1;
    *($1) = $2;
    mov word ptr [bp + 0xa], 0x8782;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    push($1);
    $1();
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx], -1;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    les bx, ptr [bp + 4];
    add word ptr es:[bx], ax;
    $1 = $2;
    push($1);
    $1();
    *($1) = $2;
    *($1) = $2;
    push($1);
    lea ax, [bp - 2];
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    ret 8;
    push($1);
    xchg si, ax;
    xchg dx, ax;
    test ax, ax;
    if (ZF) goto $1;
    mul bx;
    jcxz 0x30f0;
    xchg cx, ax;
    mul si;
    $1 += $2;
    xchg si, ax;
    mul bx;
    $1 += $2;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    and ax, 0xf;
    and bx, 0xf;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    ret ;
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 2;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 8];
    int 0x21;
    $1 = pop();
    jb 0x3141;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 0;
    goto $1;
    les di, ptr [bp + 0x10];
    test byte ptr [bp - 1], 0x20;
    if (ZF) goto $1;
    les di, ptr es:[di];
    add word ptr [bp + 0x10], 4;
    ret ;
    $1 = $2;
    push($1);
    $1 = pop();
    add word ptr [bp + 0x10], 2;
    ret ;
    push($1);
    cld ;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr es:[si];
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    cwde ;
    xchg di, ax;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jl 0x31c6;
    cwde ;
    or di, di;
    js 0x31db;
    cmp byte ptr [di + 0x7564], 1;
    if (!ZF) goto $1;
    xchg bx, ax;
    or bl, bl;
    js 0x31c9;
    cmp byte ptr [bx + 0x7564], 1;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jg 0x31a8;
    goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    goto $1;
    goto $1;
    mov word ptr [bp - 0xa], 0xffff;
    $1 = $2;
    mov byte ptr [bp - 1], 0x20;
    lodsb al, byte ptr es:[si];
    cwde ;
    *($1) = $2;
    xchg di, ax;
    or di, di;
    jl 0x3225;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jbe 0x321a;
    goto $1;
    shl bx, 1;
    goto $1;
    xchg di, ax;
    goto $1;
    goto $1;
    or byte ptr [bp - 1], 1;
    goto $1;
    $1 -= $2;
    xchg word ptr [bp - 0xa], di;
    or di, di;
    jl 0x3201;
    $1 = $2;
    mul di;
    add word ptr [bp - 0xa], ax;
    goto $1;
    or byte ptr [bp - 1], 8;
    goto $1;
    or byte ptr [bp - 1], 4;
    goto $1;
    or byte ptr [bp - 1], 2;
    goto $1;
    and byte ptr [bp - 1], 0xdf;
    goto $1;
    or byte ptr [bp - 1], 0x20;
    goto $1;
    $1 = $2;
    $1 -= $2;
    test byte ptr [bp - 1], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    test di, 0x20;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr [bp - 1], 4;
    push($1);
    lea ax, [bp - 8];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    $1 = $2;
    and ax, 0x7fff;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    cmp word ptr [bp - 8], 0;
    jle 0x32cf;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1++;
    $1();
    stosw word ptr es:[di], ax;
    test byte ptr [bp - 1], 4;
    if (ZF) goto $1;
    xchg dx, ax;
    stosw word ptr es:[di], ax;
    goto $1;
    jl 0x32d4;
    goto $1;
    goto $1;
    $1();
    goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    and word ptr [bp - 0xa], 0x7fff;
    $1();
    goto $1;
    push($1);
    // Compare $1 with $2
    if (ZF) goto $1;
    or ax, ax;
    jle 0x3311;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    $1 = pop();
    $1 = $2;
    goto $1;
    $1();
    goto $1;
    $1 = pop();
    or ax, ax;
    jle 0x3335;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    $1 = pop();
    $1 = pop();
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1();
    $1++;
    xchg dx, ax;
    stosw word ptr es:[di], ax;
    test byte ptr [bp - 1], 0x20;
    if (ZF) goto $1;
    xchg bx, ax;
    stosw word ptr es:[di], ax;
    goto $1;
    goto $1;
    push($1);
    lea ax, [bp - 8];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    $1 = $2;
    and ax, word ptr [bp - 0xa];
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    cmp word ptr [bp - 8], 0;
    jle 0x33b3;
    $1 = $2;
    cwde ;
    test ax, 1;
    if (!ZF) goto $1;
    $1();
    $1++;
    test byte ptr [bp - 1], 4;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    test byte ptr [bp - 1], 8;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    goto $1;
    $1();
    goto $1;
    $1();
    jl 0x334e;
    goto $1;
    $1();
    goto $1;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1();
    $1++;
    and word ptr [bp - 0xa], 0x7fff;
    if (ZF) goto $1;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    stosb byte ptr es:[di], al;
    $1++;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jle 0x3401;
    or al, al;
    js 0x33fc;
    xchg bx, ax;
    cmp byte ptr [bx + 0x7564], 1;
    xchg bx, ax;
    jle 0x3401;
    $1--;
    jg 0x33d4;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1--;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    goto $1;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1();
    $1 = $2;
    or si, si;
    jge 0x3432;
    $1 = $2;
    if (ZF) goto $1;
    $1++;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jl 0x345e;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    stosb byte ptr es:[di], al;
    $1--;
    jg 0x3434;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1++;
    goto $1;
    goto $1;
    push($1);
    $1 -= $2;
    cld ;
    push($1);
    $1 = pop();
    lea di, [bp - 0x2a];
    $1 = $2;
    rep stosw word ptr es:[di], ax;
    $1 = pop();
    lodsb al, byte ptr es:[si];
    and byte ptr [bp - 1], 0xef;
    // Compare $1 with $2
    if (!ZF) goto $1;
    or byte ptr [bp - 1], 0x10;
    lodsb al, byte ptr es:[si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr di, cl;
    $1 = $2;
    and cl, dl;
    shl ch, cl;
    or byte ptr [bp + di - 0x2a], ch;
    lodsb al, byte ptr es:[si];
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    ja 0x3482;
    cmp byte ptr es:[si], 0x5d;
    if (ZF) goto $1;
    lodsb al, byte ptr es:[si];
    $1 -= $2;
    if (ZF) goto $1;
    $1 += $2;
    rol ch, 1;
    adc di, 0;
    or byte ptr [bp + di - 0x2a], ch;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    *($1) = $2;
    and word ptr [bp - 0xa], 0x7fff;
    $1 = $2;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1();
    $1--;
    jl 0x3535;
    $1++;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jl 0x354a;
    xchg si, ax;
    $1 = $2;
    $1 = $2;
    shr si, cl;
    $1 = $2;
    and cl, bl;
    shl ch, cl;
    test byte ptr [bp + si - 0x2a], ch;
    xchg si, ax;
    xchg bx, ax;
    if (ZF) goto $1;
    test byte ptr [bp - 1], 0x10;
    if (ZF) goto $1;
    goto $1;
    test byte ptr [bp - 1], 0x10;
    if (ZF) goto $1;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    stosb byte ptr es:[di], al;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1--;
    $1++;
    // Compare $1 with $2
    jge 0x353e;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1++;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    goto $1;
    $1++;
    // Compare $1 with $2
    jge 0x355c;
    test byte ptr [bp - 1], 1;
    if (!ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1++;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 += $2;
    cmp word ptr [bp - 4], 1;
    sbb word ptr [bp - 4], 0;
    $1 = pop();
    $1 = $2;
    goto $1;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jle 0x35a0;
    or al, al;
    js 0x359a;
    xchg bx, ax;
    cmp byte ptr [bx + 0x7564], 1;
    xchg bx, ax;
    if (ZF) goto $1;
    $1 = pop();
    $1 += $2;
    goto $1;
    if (ZF) goto $1;
    $1 = pop();
    goto $1;
    $1 -= $2;
    $1 = $2;
    $1--;
    jl 0x35f8;
    push($1);
    push($1);
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jle 0x35fa;
    $1--;
    jl 0x35fa;
    $1 = $2;
    $1 -= $2;
    jb 0x35fa;
    // Compare $1 with $2
    jb 0x35ec;
    $1 -= $2;
    jb 0x35fa;
    // Compare $1 with $2
    jb 0x35e9;
    $1 -= $2;
    jb 0x35fa;
    // Compare $1 with $2
    jae 0x35fa;
    $1 += $2;
    shl dx, 1;
    shl dx, 1;
    shl dx, 1;
    shl dx, 1;
    $1 += $2;
    goto $1;
    $1 -= $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = pop();
    $1 += $2;
    goto $1;
    $1 = pop();
    goto $1;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret ;
    if (ZF) goto $1;
    if (ZF) goto $1;
    if (ZF) goto $1;
    and word ptr [0x1628], dx;
    push($1);
    $1 = pop();
    sbb byte ptr [bp + si + 0x16], dh;
    jb 0x3637;
    jl 0x3639;
    push($1);
    $1 = pop();
    $1++;
    push($1);
    $1--;
    push($1);
    $1--;
    push($1);
    insw word ptr es:[di], dx;
    push($1);
    $1 = $2;
    sbb byte ptr [bx + si + 0x16], ah;
    ja 0x364b;
    xlatb ;
    push($1);
    push($1);
    push($1);
    $1 = pop();
    push($1);
    push($1);
    $1 -= $2;
    jb 0x3663;
    // Compare $1 with $2
    jbe 0x3658;
    // Compare $1 with $2
    ja 0x3650;
    $1 -= $2;
    goto $1;
    $1 -= $2;
    // Compare $1 with $2
    jbe 0x3663;
    // Compare $1 with $2
    jae 0x3663;
    $1++;
    $1++;
    clc ;
    $1 = $2;
    goto $1;
    $1 = pop();
    stc ;
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov byte ptr [bp - 1], 0;
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 1;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jl 0x36ff;
    cwde ;
    xchg bx, ax;
    test bl, 0x80;
    if (!ZF) goto $1;
    $1 = $2;
    test byte ptr [bx + di], 1;
    if (!ZF) goto $1;
    xchg bx, ax;
    $1--;
    jl 0x3706;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1++;
    $1--;
    jl 0x3706;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    jl 0x36ff;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    jcxz 0x3724;
    // Compare $1 with $2
    ja 0x3706;
    // Compare $1 with $2
    jb 0x3706;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1--;
    jl 0x3721;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 6], 0xffff;
    goto $1;
    mov word ptr [bp - 6], 0;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    $1 -= $2;
    cdq ;
    goto $1;
    goto $1;
    // Compare $1 with $2
    mov word ptr [bp + 0xc], 0xa;
    if (!ZF) goto $1;
    $1--;
    jl 0x3721;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    mov word ptr [bp + 0xc], 8;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp + 0xc], 0x10;
    goto $1;
    $1 = $2;
    xchg bx, ax;
    $1();
    xchg bx, ax;
    jb 0x3706;
    xchg si, ax;
    goto $1;
    xchg si, ax;
    mul word ptr [bp + 0xc];
    $1 += $2;
    adc di, dx;
    if (!ZF) goto $1;
    $1--;
    jl 0x37c8;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    xchg bx, ax;
    $1();
    xchg bx, ax;
    jae 0x3761;
    goto $1;
    xchg si, ax;
    mul cx;
    xchg di, ax;
    xchg dx, cx;
    mul dx;
    $1 += $2;
    adc ax, cx;
    xchg di, ax;
    adc dl, dh;
    if (!ZF) goto $1;
    $1--;
    jl 0x37c8;
    $1++;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    xchg bx, ax;
    $1();
    xchg bx, ax;
    jae 0x378a;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1--;
    $1 = $2;
    xchg si, ax;
    cmp byte ptr [bp - 1], 0;
    if (ZF) goto $1;
    neg dx;
    neg ax;
    sbb dx, 0;
    les di, ptr [bp + 0x10];
    $1 = $2;
    add word ptr es:[di], bx;
    les di, ptr [bp + 0x14];
    $1 = $2;
    mov word ptr es:[di], bx;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc ah, 0;
    adc dx, 0;
    mov word ptr [bp - 6], 2;
    goto $1;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    les si, ptr [bp + 6];
    mov word ptr es:[si], bx;
    $1 = $2;
    mov word ptr es:[si + 2], ax;
    mov word ptr es:[si + 4], ss;
    mov word ptr es:[si + 6], ds;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x3844;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = $2;
    // Compare $1 with $2
    jae 0x388c;
    $1 = $2;
    shl bx, 1;
    mov word ptr [bx + 0x74d2], 0;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    mov byte ptr [bx + 0x7344], 0xff;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = pop();
    *($1) = $2;
    $1++;
    // Compare $1 with $2
    jb 0x3854;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    and word ptr [0x7342], 0xfdff;
    $1 = $2;
    push($1);
    test word ptr [0x7342], 0x200;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    and word ptr [0x7356], 0xfdff;
    $1 = $2;
    push($1);
    test word ptr [0x7356], 0x200;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    ret ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21;
    $1 = pop();
    jb 0x3917;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    $1 = $2;
    $1();
    $1 = $2;
    aam 0x10;
    xchg al, ah;
    $1();
    xchg al, ah;
    $1 += $2;
    daa ;
    adc al, 0x40;
    daa ;
    stosb byte ptr es:[di], al;
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 0x12], 0;
    mov word ptr [bp - 0x14], 0x50;
    mov word ptr [bp - 0x16], 0;
    goto $1;
    push($1);
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1 = pop();
    ret ;
    mov byte ptr ss:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x96];
    $1 -= $2;
    push($1);
    lea ax, [bp - 0x96];
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr [bp - 0x16], 1;
    mov word ptr [bp - 0x14], 0x50;
    add word ptr [bp - 0x12], di;
    lea di, [bp - 0x96];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    ret ;
    push($1);
    cld ;
    lea di, [bp - 0x96];
    *($1) = $2;
    $1 = $2;
    les si, ptr [bp + 6];
    lodsb al, byte ptr es:[si];
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov byte ptr ss:[di], al;
    $1++;
    $1--;
    jg 0x39a8;
    $1();
    goto $1;
    goto $1;
    *($1) = $2;
    lodsb al, byte ptr es:[si];
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    mov word ptr [bp - 2], 0x20;
    *($1) = $2;
    mov word ptr [bp - 8], 0xffff;
    mov word ptr [bp - 0xa], 0xffff;
    goto $1;
    lodsb al, byte ptr es:[si];
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    jae 0x3a0b;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x3a04;
    goto $1;
    shl bx, 1;
    goto $1;
    goto $1;
    // Compare $1 with $2
    ja 0x3a0b;
    or word ptr [bp - 2], 1;
    goto $1;
    // Compare $1 with $2
    ja 0x3a0b;
    or word ptr [bp - 2], 2;
    goto $1;
    // Compare $1 with $2
    ja 0x3a0b;
    cmp byte ptr [bp - 0xb], 0x2b;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    and word ptr [bp - 2], 0xffdf;
    goto $1;
    or word ptr [bp - 2], 0x20;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    ja 0x3a94;
    test word ptr [bp - 2], 2;
    if (!ZF) goto $1;
    or word ptr [bp - 2], 8;
    $1 = $2;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    add word ptr [bp + 4], 2;
    // Compare $1 with $2
    jae 0x3a7a;
    or ax, ax;
    jns 0x3a72;
    neg ax;
    or word ptr [bp - 2], 2;
    *($1) = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    *($1) = $2;
    $1++;
    goto $1;
    // Compare $1 with $2
    jae 0x3a56;
    $1 = $2;
    $1++;
    goto $1;
    xchg dx, ax;
    $1 -= $2;
    cwde ;
    // Compare $1 with $2
    ja 0x3ab6;
    $1 = $2;
    xchg word ptr [bp - 8], ax;
    or ax, ax;
    jl 0x3a77;
    shl ax, 1;
    $1 = $2;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    add word ptr [bp - 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    xchg word ptr [bp - 0xa], ax;
    or ax, ax;
    if (ZF) goto $1;
    shl ax, 1;
    $1 = $2;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    add word ptr [bp - 0xa], ax;
    goto $1;
    or word ptr [bp - 2], 0x10;
    goto $1;
    or word ptr [bp - 2], 0x100;
    and word ptr [bp - 2], 0xffef;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    mov byte ptr [bp - 0xb], 0;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    mov byte ptr [bp - 6], 1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    cdq ;
    $1++;
    $1++;
    *($1) = $2;
    test word ptr [bp - 2], 0x10;
    if (ZF) goto $1;
    $1 = $2;
    $1++;
    $1++;
    *($1) = $2;
    lea di, [bp - 0x45];
    or ax, ax;
    if (!ZF) goto $1;
    or dx, dx;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0xa], 0;
    if (!ZF) goto $1;
    mov byte ptr ss:[di], 0;
    $1 = $2;
    goto $1;
    or word ptr [bp - 2], 4;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    push($1);
    $1 = pop();
    $1 = $2;
    or dx, dx;
    jge 0x3b64;
    goto $1;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    lea di, [bp - 0x46];
    $1 = $2;
    push($1);
    $1++;
    $1++;
    *($1) = $2;
    test word ptr [bp - 2], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1++;
    $1++;
    *($1) = $2;
    push($1);
    $1 = pop();
    $1();
    $1 = $2;
    stosb byte ptr es:[di], al;
    push($1);
    $1 = pop();
    $1 = pop();
    $1();
    mov byte ptr ss:[di], 0;
    mov byte ptr [bp - 6], 0;
    and word ptr [bp - 2], 0xfffb;
    lea cx, [bp - 0x46];
    $1 -= $2;
    xchg di, cx;
    $1 = $2;
    // Compare $1 with $2
    jg 0x3bb4;
    $1 = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [bp + 4], 2;
    push($1);
    $1 = pop();
    lea di, [bp - 0x45];
    $1 = 0;
    mov word ptr ss:[di], ax;
    $1 = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    test word ptr [bp - 2], 0x20;
    if (!ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 4], 2;
    push($1);
    $1 = pop();
    or di, di;
    goto $1;
    les di, ptr ss:[di];
    add word ptr [bp + 4], 4;
    $1 = $2;
    or ax, di;
    if (!ZF) goto $1;
    push($1);
    $1 = pop();
    $1 = $2;
    $1();
    // Compare $1 with $2
    jbe 0x3c11;
    $1 = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or cx, cx;
    jge 0x3c27;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lea bx, [bp - 0x45];
    push($1);
    push($1);
    $1 = $2;
    and ax, word ptr [bp - 2];
    push($1);
    $1 = $2;
    test ax, 0x100;
    if (ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 4], 0xa;
    goto $1;
    add word ptr [bp + 4], 8;
    $1 = $2;
    push($1);
    $1();
    push($1);
    $1 = pop();
    lea di, [bp - 0x45];
    test word ptr [bp - 2], 8;
    if (ZF) goto $1;
    $1 = $2;
    or dx, dx;
    jle 0x3c77;
    $1();
    cmp byte ptr es:[di], 0x2d;
    if (!ZF) goto $1;
    $1--;
    $1 -= $2;
    jle 0x3c77;
    *($1) = $2;
    cmp byte ptr es:[di], 0x2d;
    if (ZF) goto $1;
    $1 = $2;
    or al, al;
    if (ZF) goto $1;
    $1--;
    mov byte ptr es:[di], al;
    cmp word ptr [bp - 0xe], 0;
    jle 0x3c98;
    $1 = $2;
    or cx, cx;
    jge 0x3c98;
    $1--;
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and ax, word ptr [bp - 2];
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr [bp - 0xe], 0;
    jg 0x3cc1;
    mov word ptr [bp - 0xe], 1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    or word ptr [bp - 2], 0x40;
    $1--;
    $1--;
    sub word ptr [bp - 0xe], 2;
    jge 0x3cde;
    mov word ptr [bp - 0xe], 0;
    $1 += $2;
    test word ptr [bp - 2], 2;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1();
    $1--;
    // Compare $1 with $2
    jg 0x3cea;
    test word ptr [bp - 2], 0x40;
    if (ZF) goto $1;
    $1 = $2;
    $1();
    $1 = $2;
    $1();
    $1 = $2;
    or dx, dx;
    jle 0x3d34;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    lodsb al, byte ptr es:[si];
    $1();
    $1--;
    $1--;
    xchg dx, cx;
    jcxz 0x3d32;
    $1 = $2;
    $1();
    loop 0x3d2b;
    xchg dx, cx;
    jcxz 0x3d48;
    $1 -= $2;
    lodsb al, byte ptr es:[si];
    mov byte ptr ss:[di], al;
    $1++;
    $1--;
    jg 0x3d46;
    $1();
    loop 0x3d38;
    or bx, bx;
    jle 0x3d55;
    $1 = $2;
    $1 = $2;
    $1();
    loop 0x3d4e;
    goto $1;
    *($1) = $2;
    $1 = $2;
    test word ptr [bp - 2], 0x20;
    if (!ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 4], 2;
    push($1);
    $1 = pop();
    goto $1;
    les di, ptr ss:[di];
    add word ptr [bp + 4], 4;
    $1 = $2;
    $1 -= $2;
    $1 += $2;
    mov word ptr es:[di], ax;
    test word ptr [bp - 2], 0x10;
    if (ZF) goto $1;
    $1++;
    $1++;
    mov word ptr es:[di], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    lodsb al, byte ptr es:[si];
    or al, al;
    if (!ZF) goto $1;
    cmp byte ptr [bp - 0x14], 0x50;
    jge 0x3db1;
    $1();
    $1 = pop();
    cmp word ptr [bp - 0x16], 0;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret 0xc;
    and al, 0x1e;
    push($1);
    push($1);
    $1 = pop();
    push($1);
    sbb word ptr [0x1e87], bx;
    xchg sp, ax;
    push($1);
    rcr byte ptr [0x1ed9], cl;
    ficomp word ptr [0x1e42];
    $1 = pop();
    $1 = pop();
    in ax, 0x1e;
    goto $1;
    push($1);
    $1 = pop();
    adc al, 0x20;
    $1 = $2;
    xlatb ;
    $1 = pop();
    $1 = pop();
    and word ptr [si - 0x6bdf], dx;
    and word ptr [si + 0x3421], dx;
    push($1);
    // Compare $1 with $2
    in al, dx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--;
    imul dx;
    push($1);
    $1 = $2;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1--;
    $1 += $2;
    shl ax, 1;
    $1 = $2;
    $1 = pop();
    ret 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    jcxz 0x3e8d;
    les di, ptr [bp + 0xa];
    lds si, ptr [bp + 6];
    cld ;
    // Compare $1 with $2
    jae 0x3e48;
    $1 = $2;
    $1--;
    shl ax, 1;
    $1 += $2;
    $1 += $2;
    std ;
    cmp word ptr [bp - 2], 0;
    if (!ZF) goto $1;
    rep movsw word ptr es:[di], word ptr [si];
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cli ;
    in al, dx;
    ror al, 1;
    jb 0x3e5e;
    in al, dx;
    ror al, 1;
    jae 0x3e63;
    movsw word ptr es:[di], word ptr [si];
    sti ;
    loop 0x3e5d;
    goto $1;
    cli ;
    in al, dx;
    ror al, 1;
    jb 0x3e6f;
    in al, dx;
    ror al, 1;
    jae 0x3e74;
    lodsw ax, word ptr [si];
    sti ;
    $1 = $2;
    in al, dx;
    ror al, 1;
    jb 0x3e7d;
    in al, dx;
    ror al, 1;
    jae 0x3e82;
    $1 = $2;
    stosw word ptr es:[di], ax;
    sti ;
    loop 0x3e6e;
    cld ;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1++;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    retf ;
    push($1);
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 4];
    $1++;
    $1 = $2;
    les bx, ptr [bp + 8];
    $1++;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = 0;
    goto $1;
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    ret 8;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    $1 += $2;
    $1 = $2;
    ret ;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    int 0x10;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    and byte ptr [0x87], 0xfe;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    int 0x10;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr [0x87], 1;
    $1 = $2;
    $1 = $2;
    int 0x10;
    goto $1;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1();
    or al, al;
    $1 = pop();
    if (ZF) goto $1;
    cmp byte ptr [0x84], 0x18;
    if (ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret ;
    $1 = $2;
    $1();
    push($1);
    $1();
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1();
    and ah, 0x7f;
    *($1) = $2;
    *($1) = $2;
    ret ;
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1();
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    cmp byte ptr [0x7652], 3;
    jbe 0x401d;
    cmp byte ptr [0x7652], 0x40;
    jae 0x401d;
    cmp byte ptr [0x7652], 7;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    *($1) = $2;
    cmp byte ptr [0x7652], 0x40;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    *($1) = $2;
    cmp byte ptr [0x7652], 7;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    *($1) = $2;
    cmp byte ptr [0x7652], 7;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x7657], 0;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    $1 = pop();
    ret ;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    goto $1;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [2], 0;
    if (ZF) goto $1;
    mov word ptr cs:[0x24ba], ds;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    mov word ptr cs:[0x24ba], ax;
    push($1);
    $1 = 0;
    push($1);
    $1();
    $1 = $2;
    goto $1;
    $1 = $2;
    mov word ptr cs:[0x24b8], 0;
    mov word ptr cs:[0x24ba], 0;
    mov word ptr cs:[0x24bc], 0;
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    $1();
    $1 += $2;
    ret ;
    $1 = $2;
    push($1);
    $1 = $2;
    mov word ptr [2], 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp word ptr es:[2], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    push($1);
    add word ptr es:[0], ax;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr es:[2], 0;
    if (!ZF) goto $1;
    mov word ptr es:[8], cx;
    goto $1;
    mov word ptr es:[2], cx;
    goto $1;
    $1();
    $1 = pop();
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr [2], 0;
    if (ZF) goto $1;
    ret ;
    $1 = $2;
    add word ptr es:[0], ax;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    mov word ptr es:[2], ax;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[4], ds;
    mov word ptr cs:[0x24bc], ds;
    $1 = $2;
    ret ;
    mov word ptr cs:[0x24bc], 0;
    ret ;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    mov word ptr ss:[6], ds;
    *($1) = $2;
    $1 = $2;
    popf ;
    mov word ptr es:[4], ds;
    *($1) = $2;
    ret ;
    mov word ptr cs:[0x24bc], ds;
    *($1) = $2;
    *($1) = $2;
    ret ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    $1 = $2;
    or dx, dx;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1();
    goto $1;
    $1();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    $1();
    $1 += $2;
    and ax, 0xf;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    push($1);
    $1 = 0;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    shl ax, cl;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr cs:[0x24b8], dx;
    mov word ptr cs:[0x24ba], dx;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    ret ;
    $1 = 0;
    cdq ;
    ret ;
    push($1);
    $1 = 0;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    shl ax, cl;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    and ax, 0xf;
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr cs:[0x24ba], dx;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    ret ;
    push($1);
    push($1);
    neg ax;
    $1 += $2;
    $1 = 0;
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    $1++;
    goto $1;
    $1 = 0;
    cdq ;
    ret ;
    $1 = $2;
    sub word ptr [0], ax;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    ret ;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, dx;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    if (ZF) goto $1;
    $1 += $2;
    adc dx, 0;
    jb 0x436b;
    test dx, 0xfff0;
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, cl;
    shl dx, cl;
    or ah, dl;
    $1 = $2;
    or dx, dx;
    if (ZF) goto $1;
    $1 = $2;
    or dx, dx;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [0], ax;
    jae 0x4370;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1();
    goto $1;
    $1();
    goto $1;
    $1();
    goto $1;
    $1 = 0;
    cdq ;
    goto $1;
    ja 0x4366;
    $1();
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 += $2;
    or dx, dx;
    if (!ZF) goto $1;
    $1 = pop();
    ret ;
    $1 = pop();
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    cld ;
    $1--;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    or dx, dx;
    if (ZF) goto $1;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x43d6;
    $1 = $2;
    shl cx, 1;
    shl cx, 1;
    shl cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    $1 -= $2;
    jbe 0x43f4;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1 = $2;
    ret ;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    mov word ptr es:[0], si;
    mov word ptr es:[2], bx;
    push($1);
    push($1);
    $1 = $2;
    mov word ptr es:[0], ax;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr es:[2], 0;
    if (ZF) goto $1;
    mov word ptr es:[2], di;
    goto $1;
    mov word ptr es:[8], di;
    $1 = $2;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    ret ;
    push($1);
    $1 = $2;
    mov word ptr es:[0], ax;
    $1 += $2;
    push($1);
    $1 = 0;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1 = $2;
    ret ;
    push($1);
    $1 = $2;
    $1 = 0;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    mov word ptr cs:[0x24c0], dx;
    mov word ptr cs:[0x24c2], ax;
    or bx, bx;
    if (ZF) goto $1;
    $1 = $2;
    or cx, dx;
    if (ZF) goto $1;
    $1 += $2;
    adc dx, 0;
    jb 0x44de;
    test dx, 0xfff0;
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, cl;
    shl dx, cl;
    or ah, dl;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0x44c5;
    ja 0x44c0;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1();
    goto $1;
    $1();
    goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = 0;
    cdq ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1++;
    $1 -= $2;
    $1 += $2;
    $1 = $2;
    shr si, cl;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    shl si, cl;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x452d;
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    cmp dx, -1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    mov word ptr [0x8f], 0;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    ret 4;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    jb 0x4596;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    ja 0x4596;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1();
    $1 += $2;
    adc dx, 0;
    $1 += $2;
    adc dx, word ptr [bp + 6];
    // Compare $1 with $2
    jl 0x45d0;
    jg 0x45c8;
    // Compare $1 with $2
    jbe 0x45d0;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1();
    jb 0x45c8;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    ja 0x45c8;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    mov word ptr [bp - 2], 0;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp - 2], 0;
    jb 0x4668;
    ja 0x4660;
    cmp word ptr [bp - 4], 0x10;
    jbe 0x4668;
    sub word ptr [bp - 4], 0x10;
    sbb word ptr [bp - 2], 0;
    and word ptr [bp - 4], 0xfff0;
    and word ptr [bp - 2], 0xffff;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    push($1);
    push($1);
    push($1);
    $1();
    $1 = $2;
    shl ax, 1;
    add word ptr [bp + 0xe], ax;
    $1++;
    // Compare $1 with $2
    jle 0x46a6;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = $2;
    shl ax, 1;
    add word ptr [bp + 0xe], ax;
    $1++;
    // Compare $1 with $2
    jle 0x46fc;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lea ax, [bp - 8];
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    push($1);
    lea ax, [bp - 8];
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 0xe];
    push($1);
    push($1);
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    push($1);
    int 0x21;
    $1 = pop();
    pushf ;
    pushf ;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 0xe];
    $1 = pop();
    $1 = pop();
    lds si, ptr [bp + 0xa];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    and word ptr [si + 0xc], 1;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop();
    if (ZF) goto $1;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jb 0x47d7;
    cmp word ptr [bp + 8], 0;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    cmp byte ptr [0x7698], 0;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    int 0x21;
    cwde ;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 1;
    // Compare $1 with $2
    jge 0x484c;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0xffff;
    $1 = $2;
    goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1();
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    $1++;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    goto $1;
    goto $1;
    goto $1;
    goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    shr ax, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = pop();
    div bx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    ret 4;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1 = $2;
    les bx, ptr [bp + 4];
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1();
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], dx;
    $1++;
    // Compare $1 with $2
    jb 0x48fe;
    $1++;
    $1 = $2;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], dx;
    $1 = pop();
    ret 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    goto $1;
    cmp word ptr [bp - 0xc], 0;
    if (ZF) goto $1;
    push($1);
    lea ax, [bp - 4];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    add word ptr [bp + 6], 2;
    cmp word ptr [bp - 0xa], 0;
    if (ZF) goto $1;
    push($1);
    lea ax, [bp - 2];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    goto $1;
    les bx, ptr [bp + 0xa];
    mov word ptr es:[bx], si;
    add word ptr [bp + 0xa], 2;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (!ZF) goto $1;
    cmp word ptr [0x765b], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0x4a5b;
    // Compare $1 with $2
    ja 0x4a5b;
    // Compare $1 with $2
    jg 0x4a5b;
    // Compare $1 with $2
    ja 0x4a5b;
    cmp word ptr [bp + 4], dx;
    ja 0x4a5b;
    // Compare $1 with $2
    jg 0x4a5b;
    or bx, bx;
    jle 0x4a5b;
    or di, di;
    jle 0x4a5b;
    or si, si;
    jle 0x4a5b;
    cmp word ptr [bp + 4], 0;
    jle 0x4a5b;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    ret 8;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], cx;
    add word ptr [bp + 8], 2;
    $1++;
    // Compare $1 with $2
    jle 0x4a71;
    $1 = pop();
    ret 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [0x765b], 0;
    if (!ZF) goto $1;
    goto $1;
    cmp byte ptr [bp + 4], 1;
    if (ZF) goto $1;
    goto $1;
    $1++;
    $1++;
    $1++;
    $1++;
    cmp byte ptr [bp + 0xe], 6;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1++;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    lea ax, [bp - 0xa0];
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    lea ax, [bp - 0xa0];
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    push($1);
    lea ax, [bp - 0xa0];
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1++;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1--;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    lea ax, [bp - 0xa0];
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    lea ax, [bp - 0xa0];
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    push($1);
    lea ax, [bp - 0xa0];
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    $1 = pop();
    ret 0xc;
    add byte ptr [bx + si], al;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    mov word ptr cs:[0x2ff1], ds;
    *($1) = $2;
    *($1) = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    lodsb al, byte ptr es:[si];
    $1++;
    $1 = $2;
    xchg si, dx;
    xchg bx, ax;
    $1 = $2;
    $1++;
    $1++;
    $1 = $2;
    cmp byte ptr [0x7d], 3;
    jb 0x4c3f;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    jcxz 0x4cae;
    xor cl, 0x7f;
    push($1);
    $1 = $2;
    $1 += $2;
    $1++;
    and ax, 0xfffe;
    $1 = $2;
    $1 -= $2;
    jb 0x4cae;
    $1 = $2;
    push($1);
    $1 = pop();
    push($1);
    $1 = pop();
    push($1);
    $1--;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = 0;
    stosb byte ptr es:[di], al;
    $1 = $2;
    xchg dx, si;
    xchg cx, bx;
    $1 = $2;
    $1 = $2;
    $1++;
    $1();
    ja 0x4c76;
    jb 0x4cb3;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1();
    ja 0x4c6b;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    or ax, ax;
    if (ZF) goto $1;
    $1++;
    stosb byte ptr es:[di], al;
    or al, al;
    if (!ZF) goto $1;
    $1++;
    xchg al, ah;
    $1 = 0;
    stc ;
    jcxz 0x4cad;
    lodsb al, byte ptr [si];
    $1--;
    $1 -= $2;
    if (ZF) goto $1;
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp byte ptr [si], 0x22;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    $1--;
    or si, si;
    ret ;
    nop ;
    nop ;
    goto $1;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1++;
    $1 += $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jb 0x4cae;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    jcxz 0x4ce9;
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    lodsb al, byte ptr ss:[si];
    or al, al;
    loopne 0x4ce1;
    if (ZF) goto $1;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x4d30;
    $1 = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    ret ;
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    retf ;
    $1();
    $1 = $2;
    shr ax, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    retf ;
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    cmp dx, -1;
    if (ZF) goto $1;
    test word ptr [bp + 0xa], 2;
    if (ZF) goto $1;
    test dx, 1;
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    mov word ptr [0x7f], 5;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    les si, ptr [bp + 6];
    cld ;
    $1 -= $2;
    cdq ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    test byte ptr [bx + di], 1;
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1++;
    $1 = $2;
    $1++;
    // Compare $1 with $2
    ja 0x4e00;
    $1 -= $2;
    jb 0x4e00;
    mul cx;
    $1 += $2;
    adc dl, dh;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    mul cx;
    xchg di, ax;
    xchg cx, dx;
    mul dx;
    xchg dx, ax;
    xchg di, ax;
    $1 += $2;
    adc dx, cx;
    $1 = $2;
    $1++;
    // Compare $1 with $2
    ja 0x4e00;
    $1 -= $2;
    jae 0x4de0;
    $1--;
    jl 0x4e0a;
    neg dx;
    neg ax;
    sbb dx, 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21;
    $1 = pop();
    jb 0x4e38;
    xchg cx, ax;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0x4e53;
    $1 = $2;
    push($1);
    $1();
    goto $1;
    $1 = $2;
    shl bx, 1;
    mov word ptr [bx + 0x74d2], 0;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x4e7e;
    shl bx, 1;
    mov word ptr [bx + 0x74d2], 0;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0x4e99;
    $1 = $2;
    push($1);
    goto $1;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 0x200;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x4ef3;
    test dl, 0x80;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    int 0x21;
    jb 0x4ef3;
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    int 0x21;
    *($1) = $2;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jb 0x4ef3;
    $1 = $2;
    int 0x21;
    jb 0x4ef3;
    // Compare $1 with $2
    jb 0x4eef;
    ja 0x4eed;
    // Compare $1 with $2
    jb 0x4eef;
    goto $1;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (!ZF) goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx + 6], 0;
    if (ZF) goto $1;
    cmp word ptr es:[bx], 0;
    jge 0x4f3b;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 4;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    les bx, ptr [bp + 6];
    cmp byte ptr es:[bx + 4], 0;
    jl 0x4f6d;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = $2;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx + 2], 0;
    mov word ptr es:[bx + 6], 0;
    mov word ptr es:[bx], 0;
    mov byte ptr es:[bx + 4], 0xff;
    cmp word ptr es:[bx + 0x10], 0;
    if (ZF) goto $1;
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    les bx, ptr [bp + 6];
    mov word ptr es:[bx + 0x10], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (!ZF) goto $1;
    nop ;
    push($1);
    $1();
    goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0;
    jl 0x5033;
    test word ptr es:[bx + 2], 8;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    cmp word ptr es:[bx + 0xc], dx;
    if (!ZF) goto $1;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], 0;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr es:[bx + 0xc], dx;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    $1 += $2;
    $1++;
    $1 = $2;
    sub word ptr es:[bx], si;
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 0x200;
    if (!ZF) goto $1;
    or word ptr es:[bx + 2], 0x10;
    goto $1;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x21;
    push($1);
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 0xa];
    int 0x21;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21;
    pushf ;
    $1 = pop();
    xchg bx, ax;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    int 0x21;
    push($1);
    popf ;
    $1 = pop();
    jb 0x50ad;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x21;
    push($1);
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21;
    $1 = $2;
    int 0x21;
    pushf ;
    $1 = pop();
    xchg bx, ax;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    int 0x21;
    push($1);
    popf ;
    $1 = pop();
    jb 0x50da;
    $1 = 0;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    goto $1;
    les bx, ptr [bp - 4];
    test word ptr es:[bx + 2], 3;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1++;
    add word ptr [bp - 4], 0x14;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = 0;
    les bx, ptr [bp + 0xc];
    $1++;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = 0;
    goto $1;
    les bx, ptr [bp + 0xc];
    $1 = $2;
    $1++;
    // Compare $1 with $2
    if (ZF) goto $1;
    les bx, ptr [bp + 0xc];
    cmp byte ptr es:[bx], 0x2b;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    les bx, ptr [bp + 0xc];
    $1 = $2;
    and dx, 0xfffc;
    or dx, 4;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    or dx, 0x4000;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    or dx, 0x8000;
    goto $1;
    $1 = $2;
    and ax, 0xc000;
    or dx, ax;
    $1 = $2;
    test ax, 0x8000;
    if (ZF) goto $1;
    or si, 0x40;
    mov word ptr [0x733a], 0;
    mov word ptr [0x7338], 0x4d2c;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], dx;
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], di;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    ret 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 2];
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    $1();
    les bx, ptr [bp + 0xe];
    mov word ptr es:[bx + 2], ax;
    or ax, ax;
    if (ZF) goto $1;
    cmp byte ptr es:[bx + 4], 0;
    jge 0x5240;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 4];
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    les bx, ptr [bp + 0xe];
    mov byte ptr es:[bx + 4], al;
    or al, al;
    jge 0x5240;
    les bx, ptr [bp + 0xe];
    mov byte ptr es:[bx + 4], 0xff;
    mov word ptr es:[bx + 2], 0;
    $1 = 0;
    $1 = 0;
    goto $1;
    les bx, ptr [bp + 0xe];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    or ax, ax;
    if (ZF) goto $1;
    les bx, ptr [bp + 0xe];
    or word ptr es:[bx + 2], 0x200;
    $1 = $2;
    push($1);
    les bx, ptr [bp + 0xe];
    test word ptr es:[bx + 2], 0x200;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    goto $1;
    les bx, ptr [bp + 0xe];
    mov word ptr es:[bx + 0x10], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    ret 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx + 4], 0;
    jl 0x52df;
    $1 = $2;
    add word ptr [bp - 4], 0x14;
    push($1);
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 += $2;
    $1 = pop();
    // Compare $1 with $2
    jb 0x52bd;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx + 4], 0;
    jl 0x52ef;
    $1 = 0;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    or ax, dx;
    if (!ZF) goto $1;
    $1 = 0;
    $1 = 0;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp + 0xe];
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    goto $1;
    $1++;
    les bx, ptr [bp + 4];
    $1 = $2;
    // Compare $1 with $2
    jbe 0x5366;
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x40;
    if (ZF) goto $1;
    cmp word ptr es:[bx + 6], 0;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    jae 0x53e9;
    cmp word ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1--;
    $1 = 0;
    goto $1;
    les bx, ptr [bp + 4];
    $1 += $2;
    $1 = $2;
    sub word ptr [bp + 8], ax;
    les bx, ptr [bp + 4];
    $1 = $2;
    // Compare $1 with $2
    jbe 0x5397;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    add word ptr [bp + 0xa], dx;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    add word ptr [bp + 8], ax;
    les bx, ptr [bp + 4];
    or word ptr es:[bx + 2], 0x20;
    goto $1;
    les bx, ptr [bp + 0xa];
    mov byte ptr es:[bx], dl;
    $1++;
    $1--;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1--;
    if (ZF) goto $1;
    les bx, ptr [bp + 4];
    $1--;
    jl 0x5413;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp dx, -1;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    or di, di;
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = 0;
    $1();
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    ja 0x548d;
    jb 0x546e;
    or ax, ax;
    jae 0x548d;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = 0;
    $1 = pop();
    div di;
    goto $1;
    $1 = $2;
    $1++;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    $1--;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx], 0;
    jge 0x54e8;
    $1 = $2;
    $1 += $2;
    $1++;
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 4];
    $1 = $2;
    cdq ;
    xor ax, dx;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x40;
    if (!ZF) goto $1;
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr es:[bx], 0;
    jge 0x553e;
    goto $1;
    $1--;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0xa;
    if (!ZF) goto $1;
    $1++;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    les bx, ptr [bp - 4];
    $1++;
    cmp byte ptr es:[bx], 0xa;
    if (!ZF) goto $1;
    $1++;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret 4;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0;
    jle 0x5587;
    push($1);
    push($1);
    $1();
    cdq ;
    sub word ptr [bp + 0xa], ax;
    sbb word ptr [bp + 0xc], dx;
    les bx, ptr [bp + 6];
    and word ptr es:[bx + 2], 0xfe5f;
    mov word ptr es:[bx], 0;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    cmp dx, -1;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    cmp dx, -1;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0;
    jl 0x560e;
    goto $1;
    $1 = $2;
    cwde ;
    shl ax, 1;
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    cmp dx, -1;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    cmp dx, -1;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1();
    cdq ;
    add word ptr [bp - 4], ax;
    adc word ptr [bp - 2], dx;
    goto $1;
    push($1);
    push($1);
    $1();
    cdq ;
    sub word ptr [bp - 4], ax;
    sbb word ptr [bp - 2], dx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    or di, di;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = 0;
    $1();
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    ja 0x56f2;
    jb 0x56da;
    or ax, ax;
    jae 0x56f2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = 0;
    div di;
    goto $1;
    $1 = 0;
    // Compare $1 with $2
    jae 0x5730;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = 0;
    or dx, dx;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1();
    *($1) = $2;
    *($1) = $2;
    $1++;
    // Compare $1 with $2
    jb 0x56f9;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    goto $1;
    les bx, ptr [bp - 4];
    $1 = $2;
    and ax, 0x300;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    add word ptr [bp - 4], 0x14;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x200;
    if (ZF) goto $1;
    $1();
    les bx, ptr [bp + 4];
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], ax;
    or ax, ax;
    jle 0x57c2;
    and word ptr es:[bx + 2], 0xffdf;
    $1 = 0;
    goto $1;
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = $2;
    and ax, 0xfe7f;
    or ax, 0x20;
    mov word ptr es:[bx + 2], ax;
    goto $1;
    les bx, ptr [bp + 4];
    mov word ptr es:[bx], 0;
    or word ptr es:[bx + 2], 0x10;
    $1 = $2;
    $1 = pop();
    ret 4;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    $1++;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    $1 = pop();
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0;
    jle 0x583c;
    les bx, ptr [bp + 6];
    $1--;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    goto $1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0;
    jl 0x58b4;
    test word ptr es:[bx + 2], 0x110;
    if (!ZF) goto $1;
    test word ptr es:[bx + 2], 1;
    if (ZF) goto $1;
    les bx, ptr [bp + 6];
    or word ptr es:[bx + 2], 0x80;
    cmp word ptr es:[bx + 6], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 0x200;
    if (ZF) goto $1;
    $1();
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    or ax, ax;
    if (!ZF) goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    les bx, ptr [bp + 6];
    or word ptr es:[bx + 2], 0x10;
    goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    and ax, 0xfe7f;
    or ax, 0x20;
    mov word ptr es:[bx + 2], ax;
    goto $1;
    cmp byte ptr [0x8790], 0xd;
    if (!ZF) goto $1;
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 0x40;
    if (ZF) goto $1;
    les bx, ptr [bp + 6];
    and word ptr es:[bx + 2], 0xffdf;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    nop ;
    push($1);
    $1();
    $1 += $2;
    *($1) = $2;
    mov byte ptr [bp - 0x43], 0x3a;
    mov byte ptr [bp - 0x42], 0x5c;
    push($1);
    lea ax, [bp - 0x41];
    push($1);
    $1 = 0;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1 = 0;
    goto $1;
    push($1);
    lea ax, [bp - 0x44];
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    // Compare $1 with $2
    jb 0x5950;
    mov word ptr [0x7f], 0x22;
    goto $1;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (!ZF) goto $1;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    *($1) = $2;
    *($1) = $2;
    or ax, dx;
    if (!ZF) goto $1;
    mov word ptr [0x7f], 8;
    goto $1;
    push($1);
    lea ax, [bp - 0x44];
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    cdq ;
    goto $1;
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    shr cx, 1;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    jae 0x5a17;
    movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    int 0x21;
    $1 = pop();
    jb 0x5a36;
    goto $1;
    push($1);
    $1();
    $1 = pop();
    ret 6;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    ret 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test si, 0xc000;
    if (!ZF) goto $1;
    $1 = $2;
    and ax, 0xc000;
    or si, ax;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    *($1) = $2;
    test si, 0x100;
    if (!ZF) goto $1;
    goto $1;
    and di, word ptr [0x74fc];
    $1 = $2;
    test ax, 0x180;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    $1();
    cmp word ptr [bp - 2], -1;
    if (!ZF) goto $1;
    cmp word ptr [0x74fe], 2;
    if (ZF) goto $1;
    push($1);
    $1();
    goto $1;
    test di, 0x80;
    if (ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test si, 0x400;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    goto $1;
    test si, 0xf0;
    if (ZF) goto $1;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1();
    $1 = $2;
    or ax, ax;
    jge 0x5aeb;
    goto $1;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = $2;
    or ax, ax;
    jge 0x5b84;
    goto $1;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    or ax, ax;
    jl 0x5b84;
    $1 = 0;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    *($1) = $2;
    test ax, 0x80;
    if (ZF) goto $1;
    or si, 0x2000;
    test si, 0x8000;
    if (ZF) goto $1;
    and ax, 0xff;
    or ax, 0x20;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    goto $1;
    test si, 0x200;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 2], 1;
    if (ZF) goto $1;
    test si, 0x100;
    if (ZF) goto $1;
    test si, 0xf0;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    or di, di;
    jl 0x5bb7;
    test si, 0x300;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = $2;
    and dx, 0xf8ff;
    or dx, ax;
    push($1);
    test word ptr [bp - 2], 1;
    if (ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = pop();
    or dx, ax;
    $1 = $2;
    shl bx, 1;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    test cx, 2;
    if (!ZF) goto $1;
    $1 = $2;
    test cx, 4;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 6];
    $1 = $2;
    and cl, byte ptr [bp + 0xa];
    or al, cl;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jb 0x5c06;
    *($1) = $2;
    $1 = $2;
    and ax, 0xb8ff;
    or ax, 0x8000;
    $1 = $2;
    shl bx, 1;
    *($1) = $2;
    $1 = $2;
    goto $1;
    push($1);
    $1();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lea ax, [bp + 0xa];
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1--;
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 8];
    cmp word ptr es:[bx], -1;
    jge 0x5cac;
    $1++;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    test word ptr es:[bx + 2], 8;
    if (!ZF) goto $1;
    goto $1;
    cmp byte ptr [0x8792], 0xa;
    if (ZF) goto $1;
    cmp byte ptr [0x8792], 0xd;
    if (ZF) goto $1;
    goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    goto $1;
    les bx, ptr [bp + 8];
    test word ptr es:[bx + 2], 0x90;
    if (!ZF) goto $1;
    test word ptr es:[bx + 2], 2;
    if (!ZF) goto $1;
    les bx, ptr [bp + 8];
    or word ptr es:[bx + 2], 0x10;
    goto $1;
    les bx, ptr [bp + 8];
    or word ptr es:[bx + 2], 0x100;
    cmp word ptr es:[bx + 6], 0;
    if (ZF) goto $1;
    cmp word ptr es:[bx], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    les bx, ptr [bp + 8];
    $1 = $2;
    neg ax;
    mov word ptr es:[bx], ax;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    test word ptr es:[bx + 2], 8;
    if (!ZF) goto $1;
    goto $1;
    cmp byte ptr [0x8792], 0xa;
    if (ZF) goto $1;
    cmp byte ptr [0x8792], 0xd;
    if (ZF) goto $1;
    goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    goto $1;
    les bx, ptr [bp + 8];
    $1 = $2;
    cwde ;
    shl ax, 1;
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    cmp byte ptr [0x8792], 0xa;
    if (!ZF) goto $1;
    les bx, ptr [bp + 8];
    test word ptr es:[bx + 2], 0x40;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    les bx, ptr [bp + 8];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    les bx, ptr [bp + 8];
    test word ptr es:[bx + 2], 0x200;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 8;
    if (ZF) goto $1;
    goto $1;
    push($1);
    push($1);
    les bx, ptr [bp + 0xa];
    $1++;
    $1 = $2;
    cwde ;
    push($1);
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x40;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr es:[bx + 6], 0;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr es:[bx + 6], di;
    jae 0x5ebc;
    cmp word ptr es:[bx], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (!ZF) goto $1;
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    shl ax, 1;
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    push($1);
    push($1);
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    goto $1;
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 += $2;
    jl 0x5eec;
    cmp word ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    mov word ptr es:[bx], ax;
    goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    push($1);
    push($1);
    push($1);
    les bx, ptr [bp + 4];
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 += $2;
    mov word ptr es:[bx], ax;
    add word ptr es:[bx + 0xc], di;
    goto $1;
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    shl ax, 1;
    $1 = $2;
    test word ptr [bx + 0x74d2], 0x800;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    push($1);
    push($1);
    push($1);
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    goto $1;
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx + 6], 0;
    if (ZF) goto $1;
    goto $1;
    les bx, ptr [bp + 4];
    $1++;
    jge 0x5f9f;
    $1 = $2;
    $1 = $2;
    $1++;
    les bx, ptr [bp + 0xa];
    $1++;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[si], dl;
    $1 = $2;
    $1 = $2;
    goto $1;
    push($1);
    push($1);
    les bx, ptr [bp + 0xa];
    $1++;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1--;
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    push($1);
    push($1);
    push($1);
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    jb 0x600c;
    $1 = $2;
    push($1);
    $1();
    goto $1;
    $1 = $2;
    $1++;
    // Compare $1 with $2
    jb 0x6022;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 0x200;
    if (ZF) goto $1;
    $1 = 0;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    *($1) = $2;
    $1++;
    // Compare $1 with $2
    jb 0x6051;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 0x4000;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    les si, ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    cld ;
    lodsb al, byte ptr es:[si];
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    stosb byte ptr es:[di], al;
    loop 0x6061;
    goto $1;
    loop 0x6061;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lea ax, [bp - 3];
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1 = pop();
    cld ;
    $1 = $2;
    stosb byte ptr es:[di], al;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    neg cx;
    sbb ax, ax;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    shl bx, 1;
    or word ptr [bx + 0x74d2], 0x200;
    $1 = pop();
    $1 -= $2;
    xchg di, ax;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    jg 0x60e7;
    // Compare $1 with $2
    jbe 0x60ed;
    $1 = $2;
    goto $1;
    cmp word ptr [0x76ae], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp + 6], 0x7354;
    if (!ZF) goto $1;
    mov word ptr [0x76ae], 1;
    goto $1;
    cmp word ptr [0x76ac], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp + 6], 0x7340;
    if (!ZF) goto $1;
    mov word ptr [0x76ac], 1;
    les bx, ptr [bp + 6];
    cmp word ptr es:[bx], 0;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    les bx, ptr [bp + 6];
    test word ptr es:[bx + 2], 4;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    les bx, ptr [bp + 6];
    and word ptr es:[bx + 2], 0xfff3;
    mov word ptr es:[bx + 6], 0;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    mov word ptr es:[bx + 0xa], ax;
    mov word ptr es:[bx + 8], dx;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    // Compare $1 with $2
    if (ZF) goto $1;
    or si, si;
    jbe 0x61dc;
    mov word ptr [0x7336], 0;
    mov word ptr [0x7334], 0x4d69;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (!ZF) goto $1;
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    *($1) = $2;
    *($1) = $2;
    or ax, dx;
    if (!ZF) goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    or word ptr es:[bx + 2], 4;
    goto $1;
    goto $1;
    les bx, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + 0xe], ax;
    mov word ptr es:[bx + 0xc], dx;
    mov word ptr es:[bx + 0xa], ax;
    mov word ptr es:[bx + 8], dx;
    mov word ptr es:[bx + 6], si;
    // Compare $1 with $2
    if (!ZF) goto $1;
    or word ptr es:[bx + 2], 8;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    // Compare $1 with $2
    jb 0x6222;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    les bx, ptr [bp + 0xa];
    $1 += $2;
    mov byte ptr es:[bx], 0;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx - 1], 0x2e;
    if (!ZF) goto $1;
    $1--;
    $1--;
    les bx, ptr [bp + 4];
    $1 = $2;
    cwde ;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    loop 0x6261;
    goto $1;
    goto $1;
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx - 2], 0;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = $2;
    $1 = pop();
    ret 4;
    add byte ptr [bx + si], al;
    das ;
    add byte ptr [bp + si], bh;
    add byte ptr [si], bl;
    jle 0x62db;
    jle 0x62dd;
    if (ZF) goto $1;
    jle 0x62e1;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (ZF) goto $1;
    les bx, ptr [bp + 0xa];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    or ax, word ptr [bp + 0x10];
    if (ZF) goto $1;
    les bx, ptr [bp + 0xe];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    or ax, word ptr [bp + 0x14];
    if (ZF) goto $1;
    les bx, ptr [bp + 0x12];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    or ax, word ptr [bp + 0x18];
    if (ZF) goto $1;
    les bx, ptr [bp + 0x16];
    mov byte ptr es:[bx], 0;
    lea ax, [bp - 0x58];
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1++;
    les bx, ptr [bp + 6];
    cmp byte ptr es:[bx], 0x20;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    // Compare $1 with $2
    jle 0x630d;
    $1 = $2;
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1++;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    add word ptr [bp - 4], si;
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1 = 0;
    $1--;
    les bx, ptr [bp - 4];
    $1 = $2;
    cwde ;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    loop 0x634b;
    goto $1;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx + 1], 0;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1();
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    test di, 2;
    if (!ZF) goto $1;
    or di, 2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1();
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    goto $1;
    $1 = $2;
    lea dx, [bp - 0x56];
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    or si, si;
    if (ZF) goto $1;
    $1++;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (ZF) goto $1;
    or di, 8;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1();
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1--;
    goto $1;
    or si, si;
    if (ZF) goto $1;
    goto $1;
    $1++;
    $1++;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (ZF) goto $1;
    or di, 4;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1();
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0;
    $1--;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (ZF) goto $1;
    cmp byte ptr es:[bx], 0x3a;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    lea dx, [bp - 0x56];
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    goto $1;
    or si, si;
    if (ZF) goto $1;
    goto $1;
    or di, 1;
    goto $1;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0x3a;
    if (!ZF) goto $1;
    cmp byte ptr [bp - 0x57], 0;
    if (ZF) goto $1;
    or di, 0x10;
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x57];
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [bx + si], al;
    $1 -= $2;
    add byte ptr cs:[bx], ch;
    add byte ptr [bp + si], bh;
    add byte ptr [bx], bh;
    add byte ptr [si], bl;
    lodsw ax, word ptr [si];
    $1++;
    // Compare $1 with $2
    $1 = pop();
    $1++;
    fild word ptr [bx - 0x62];
    $1++;
    // Compare $1 with $2
    fild word ptr [bx + 0x55];
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    les bx, ptr [bp + 4];
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    les bx, ptr [bp + 4];
    add word ptr es:[bx], si;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret 0xa;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp + 6];
    push($1);
    push($1);
    push($1);
    lea ax, [bp + 0xe];
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    mov byte ptr es:[bx], 0;
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp + 6];
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    les bx, ptr [bp + 4];
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or al, al;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    $1--;
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    push($1);
    lea ax, [bp + 0xe];
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp + 6];
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp + 6];
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1();
    $1 += $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    push($1);
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    push($1);
    lea si, [di - 1];
    les di, ptr [bp + 0xa];
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1 -= $2;
    push($1);
    $1 = pop();
    $1 = pop();
    xchg di, si;
    test si, 1;
    if (ZF) goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    $1--;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    jae 0x65ef;
    movsb byte ptr es:[di], byte ptr [si];
    xchg dx, ax;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    cld ;
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    $1 = 0;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    or al, al;
    if (ZF) goto $1;
    scasb al, byte ptr es:[di];
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x664a;
    // Compare $1 with $2
    ja 0x664a;
    $1 -= $2;
    // Compare $1 with $2
    jb 0x6655;
    // Compare $1 with $2
    ja 0x6655;
    $1 -= $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 -= $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    les di, ptr [bp + 6];
    $1 = 0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    cld ;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    xchg cx, ax;
    not ax;
    $1--;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    xchg bx, cx;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    les bx, ptr [bp - 4];
    $1 = $2;
    les bx, ptr [0x8794];
    // Compare $1 with $2
    if (ZF) goto $1;
    $1++;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (ZF) goto $1;
    $1++;
    les bx, ptr [0x8794];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    les bx, ptr [0x8794];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = 0;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    les bx, ptr [bp - 4];
    $1 = $2;
    les bx, ptr [0x8794];
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[bx], 0;
    $1++;
    goto $1;
    $1++;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1++;
    les bx, ptr [0x8794];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    cld ;
    push($1);
    lds si, ptr [bp + 6];
    $1 = $2;
    goto $1;
    $1 -= $2;
    // Compare $1 with $2
    ja 0x6790;
    $1 += $2;
    *($1) = $2;
    lodsb al, byte ptr [si];
    and al, al;
    if (!ZF) goto $1;
    xchg dx, ax;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    jb 0x67b8;
    $1 = $2;
    push($1);
    $1();
    goto $1;
    $1 = $2;
    $1++;
    // Compare $1 with $2
    jae 0x67c6;
    $1 = 0;
    goto $1;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 0x800;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 0x4000;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    goto $1;
    $1 = $2;
    shl bx, 1;
    and word ptr [bx + 0x74d2], 0xfdff;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1--;
    les bx, ptr [bp - 0xc];
    $1++;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    les bx, ptr [bp - 4];
    mov byte ptr es:[bx], 0xd;
    $1++;
    les bx, ptr [bp - 4];
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1++;
    lea ax, [bp - 0x8e];
    $1 = $2;
    $1 = 0;
    $1 -= $2;
    sbb bx, 0;
    or bx, bx;
    jl 0x68a3;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jb 0x68a3;
    lea ax, [bp - 0x8e];
    $1 = $2;
    $1 = 0;
    $1 -= $2;
    sbb dx, 0;
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp dx, -1;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 -= $2;
    goto $1;
    lea ax, [bp - 0x8e];
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp - 6], 0;
    if (ZF) goto $1;
    goto $1;
    lea ax, [bp - 0x8e];
    $1 = $2;
    $1 = 0;
    $1 -= $2;
    sbb dx, 0;
    $1 = $2;
    or ax, ax;
    jbe 0x68e4;
    push($1);
    push($1);
    lea ax, [bp - 0x8e];
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp dx, -1;
    if (ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 -= $2;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 1;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 8];
    int 0x21;
    $1 = pop();
    jb 0x6923;
    push($1);
    $1 = $2;
    shl bx, 1;
    or word ptr [bx + 0x74d2], 0x1000;
    $1 = pop();
    goto $1;
    push($1);
    $1();
    $1 = pop();
    retf ;
    goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = 0;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    // Compare $1 with $2
    jae 0x6964;
    les bx, ptr [bp - 4];
    test word ptr es:[bx + 2], 3;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    add word ptr [bp - 4], 0x14;
    $1++;
    // Compare $1 with $2
    jb 0x6943;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    goto $1;
    les bx, ptr [bp - 4];
    test word ptr es:[bx + 2], 3;
    if (ZF) goto $1;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1--;
    add word ptr [bp - 4], 0x14;
    or si, si;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    les bx, ptr [bp - 4];
    $1 = $2;
    les bx, ptr [0x8798];
    // Compare $1 with $2
    if (ZF) goto $1;
    $1++;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (ZF) goto $1;
    $1++;
    les bx, ptr [0x8798];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    les bx, ptr [0x8798];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = 0;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    les bx, ptr [bp - 4];
    $1 = $2;
    les bx, ptr [0x8798];
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[bx], 0;
    $1++;
    goto $1;
    $1++;
    les bx, ptr [bp - 4];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1++;
    les bx, ptr [0x8798];
    cmp byte ptr es:[bx], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 0;
    mov word ptr [bp - 8], 0;
    lcall 0, 0xf71;
    *($1) = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0x3d01;
    $1 += $2;
    cmp word ptr [bp + 6], 1;
    jg 0x6aa2;
    goto $1;
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x6abb;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    lcall 0, 0x4b78;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1;
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    lcall 0, 0x4b78;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1;
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr [bp - 8], 1;
    goto $1;
    $1 = $2;
    $1 = $2;
    les di, ptr es:[bx];
    $1 = $2;
    $1 = $2;
    $1 = 0;
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1;
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    les di, ptr es:[bx];
    $1 = $2;
    $1 = $2;
    $1 = 0;
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1;
    sbb ax, ax;
    sbb ax, 0xffff;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr [bp - 6], 1;
    add word ptr [bp - 0x24], 4;
    $1++;
    $1 = $2;
    // Compare $1 with $2
    jge 0x6b71;
    goto $1;
    push($1);
    lea ax, [bp - 0x22];
    push($1);
    push($1);
    lea ax, [bp - 0x1c];
    push($1);
    push($1);
    lea ax, [bp - 0x80];
    push($1);
    push($1);
    lea ax, [bp - 0x12];
    push($1);
    les bx, ptr [bp + 8];
    push($1);
    push($1);
    lcall 0, 0x4891;
    $1 += $2;
    $1 = $2;
    cwde ;
    $1 += $2;
    push($1);
    lcall 0, 0xf8b;
    $1 += $2;
    push($1);
    $1 = pop();
    lea di, [bp - 0x80];
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1--;
    lea ax, [bp - 0x80];
    $1 += $2;
    $1 = $2;
    mov byte ptr ss:[bx], 0;
    push($1);
    push($1);
    lcall 0, 0xdeb;
    $1 += $2;
    push($1);
    push($1);
    lcall 0x19fe, 0x2f;
    $1 += $2;
    cmp word ptr [bp - 8], 0;
    if (ZF) goto $1;
    goto $1;
    lcall 0, 0x38d;
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 0x3e];
    push($1);
    $1 = 0;
    push($1);
    lcall 0x80c, 0x2bd;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc ax, 0;
    push($1);
    push($1);
    lcall 0x1a10, 0x20;
    *($1) = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x7f4, 0xa;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [0x7736], 0x2328;
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0x2bb;
    $1 += $2;
    mov word ptr [0x772a], 1;
    mov word ptr [0x7728], 1;
    lcall 0x1a05, 0x20;
    lcall 0x1a7e, 0x20;
    goto $1;
    lcall 0x1a08, 0x20;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    jg 0x6c8e;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    lcall 0x1a92, 0x20;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 4], 1;
    goto $1;
    $1 = $2;
    push($1);
    lcall 0x1a1b, 0x20;
    $1 += $2;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 4], 1;
    goto $1;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    lcall 0x1a10, 0x20;
    *($1) = $2;
    *($1) = $2;
    lcall 0x1a7e, 0x25;
    lcall 0x1a7e, 0x20;
    push($1);
    push($1);
    lcall 0x1a43, 0x25;
    $1 += $2;
    *($1) = $2;
    cmp word ptr [bp - 4], 1;
    jg 0x6d00;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    push($1);
    push($1);
    lcall 0x1a2b, 0x20;
    $1 += $2;
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    $1 = 0;
    push($1);
    lcall 0xeec, 0x789;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    lcall 0x10b4, 0x136;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x104d, 0x96;
    push($1);
    push($1);
    lcall 0x185d, 4;
    push($1);
    push($1);
    lcall 0x183e, 2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x183e, 0x47;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x17b8, 0x50;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x183e, 0x47;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    lcall 0x54a, 0x1c5;
    $1 = $2;
    push($1);
    lcall 0xeec, 0x789;
    lcall 0x1a83, 0x20;
    push($1);
    push($1);
    lcall 0x1a8b, 0x20;
    $1 += $2;
    goto $1;
    lcall 0x1a83, 0x25;
    goto $1;
    lcall 0x1a83, 0x20;
    push($1);
    push($1);
    lcall 0x1a8b, 0x20;
    $1 += $2;
    goto $1;
    lcall 0x1a83, 0x25;
    mov word ptr [bp - 4], 0;
    goto $1;
    cmp word ptr [bp - 4], -1;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 0;
    push($1);
    push($1);
    lcall 0x1a10, 0x25;
    cmp word ptr [bp - 4], 0;
    if (!ZF) goto $1;
    goto $1;
    lcall 0x1a7e, 0x25;
    lcall 0, 0x38d;
    or ax, ax;
    if (ZF) goto $1;
    push($1);
    push($1);
    lcall 0x1a10, 0x25;
    goto $1;
    mov word ptr [0x772a], 0;
    mov word ptr [0x7728], 0;
    lcall 0x1a05, 0x20;
    lcall 0x1aab, 0x20;
    lcall 0x19fe, 0x2a;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0, 0xfcd;
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0xfdc;
    $1 += $2;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0xfdc;
    $1 += $2;
    $1 = 0;
    $1 = pop();
    retf ;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    and al, 0xff;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    and al, 1;
    *($1) = $2;
    $1 = $2;
    and al, 0xff;
    *($1) = $2;
    $1 = $2;
    and al, 0xff;
    *($1) = $2;
    $1 = $2;
    and al, 1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    sar ax, 1;
    and al, 3;
    *($1) = $2;
    $1 = $2;
    and al, 8;
    *($1) = $2;
    $1 = $2;
    and al, 0x10;
    *($1) = $2;
    $1 = $2;
    and al, 0x20;
    *($1) = $2;
    mov word ptr [0xe4], 0;
    mov word ptr [0xe2], 0;
    cmp byte ptr [0x7c59], 0xc;
    if (!ZF) goto $1;
    $1++;
    $1 = $2;
    $1 = $2;
    cdq ;
    idiv bx;
    *($1) = $2;
    cmp word ptr [0xe0], 5;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    add word ptr [0xe2], 1;
    adc word ptr [0xe4], 0;
    // Compare $1 with $2
    jb 0x6f2a;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jb 0x6f2a;
    mov word ptr [bp + 0x10], 1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    iret ;
    mov word ptr [0xe0], 0;
    mov byte ptr [0x7bda], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0x48fb;
    $1 += $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0x48fb;
    $1 += $2;
    goto $1;
    mov word ptr [0x7c5b], 1;
    cmp word ptr [0xde], 0;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0x48fb;
    $1 += $2;
    goto $1;
    mov word ptr [bp + 0x10], 3;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    iret ;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0, 0x48fb;
    $1 += $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    lcall 0x10b4, 0x136;
    push($1);
    lcall 0x10b4, 0x343;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x104d, 0x96;
    push($1);
    push($1);
    lcall 0x185d, 4;
    push($1);
    push($1);
    lcall 0x183e, 2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x17b8, 0x50;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x17b8, 0x50;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x17b8, 0x50;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x17b8, 0x50;
    lcall 0, 0x2bdd;
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp + 0x10], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    iret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    nop ;
    nop ;
    nop ;
    nop ;
    nop ;
    nop ;
    nop ;
    nop ;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    cli ;
    $1 = $2;
    $1 = $2;
    sti ;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp + 6], 0;
    if (!ZF) goto $1;
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    $1();
    $1++;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    // Compare $1 with $2
    ja 0x710b;
    // Compare $1 with $2
    ja 0x710b;
    $1 = $2;
    mul cx;
    $1 = $2;
    div cx;
    *($1) = $2;
    mov word ptr [0x54d2], 0;
    goto $1;
    cli ;
    $1 = $2;
    out 0x43, al;
    $1 = 0;
    out 0x40, al;
    out 0x40, al;
    sti ;
    mov word ptr [0x54d2], 1;
    mov word ptr [bp - 2], 0;
    popf ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cmp word ptr [0x54d2], -1;
    if (!ZF) goto $1;
    cli ;
    $1 = $2;
    out 0x43, al;
    $1 = 0;
    out 0x40, al;
    out 0x40, al;
    sti ;
    mov word ptr [0x54d2], 1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    cli ;
    $1 = $2;
    $1 = $2;
    sti ;
    cmp word ptr [0x54d2], 0;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 0;
    goto $1;
    push($1);
    $1 = 0;
    out 0x43, al;
    in al, 0x40;
    xchg al, ah;
    in al, 0x40;
    xchg al, ah;
    not ax;
    *($1) = $2;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp word ptr [bp - 4], 0x8000;
    ja 0x71d0;
    cli ;
    $1 = $2;
    $1 = $2;
    sti ;
    cmp word ptr [0x54ce], dx;
    ja 0x71de;
    jb 0x71e4;
    cmp word ptr [0x54cc], ax;
    jbe 0x71e4;
    $1 += $2;
    adc dx, 0x18;
    $1 -= $2;
    sbb dx, word ptr [0x54ce];
    $1 = $2;
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1);
    push($1);
    $1 = $2;
    mul word ptr [bp - 4];
    $1 = $2;
    lcall 0x7ff, 0x32;
    $1 = $2;
    lcall 0x7ff, 0x32;
    $1 = pop();
    $1 += $2;
    $1 = pop();
    adc dx, bx;
    *($1) = $2;
    popf ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    cmp word ptr [bp + 8], dx;
    ja 0x7248;
    jb 0x724f;
    cmp word ptr [bp + 6], ax;
    jbe 0x724f;
    $1 += $2;
    adc dx, 0x526;
    $1 -= $2;
    sbb dx, word ptr [bp + 8];
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x54d8], 0;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    int 0x16;
    $1 = pop();
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    int 0x16;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    sub word ptr [bp + 6], 1;
    sbb word ptr [bp + 8], 0;
    jl 0x72ce;
    push($1);
    push($1);
    $1();
    goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    ja 0x72ce;
    jb 0x7289;
    // Compare $1 with $2
    jb 0x7289;
    mov word ptr [bp - 2], 0;
    clc ;
    goto $1;
    mov word ptr [bp - 2], 0xffec;
    stc ;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    lodsb al, byte ptr [si];
    $1 -= $2;
    imul al;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 -= $2;
    imul al;
    $1 += $2;
    lodsb al, byte ptr [si];
    $1 -= $2;
    imul al;
    $1 += $2;
    $1 = pop();
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    jae 0x7348;
    $1 = $2;
    $1 = $2;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 0x3f;
    and dx, 0x3f3f;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1();
    goto $1;
    $1 = 0;
    $1 = $2;
    $1();
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and al, 0x3f;
    $1 = $2;
    and ah, al;
    $1 = $2;
    and bh, al;
    $1 = $2;
    and ch, al;
    $1 = 0;
    or ah, ah;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    or bh, bh;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    or ch, ch;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    lodsb al, byte ptr [si];
    $1 = 0;
    $1 = $2;
    shl bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    and bl, 3;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    lodsb al, byte ptr [si];
    $1 = 0;
    $1 = $2;
    shl bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    or cx, cx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xfff6;
    goto $1;
    // Compare $1 with $2
    jbe 0x7504;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and dh, al;
    $1 = $2;
    and dl, al;
    $1 = $2;
    and ah, al;
    $1 = 0;
    or dh, dh;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = 0;
    or dl, dl;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = 0;
    or ah, ah;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    loop 0x7504;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    cmp word ptr [bp + 0xe], 0;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xfff6;
    goto $1;
    $1 = $2;
    push($1);
    lodsb al, byte ptr [si];
    push($1);
    lodsb al, byte ptr [si];
    push($1);
    lodsb al, byte ptr [si];
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = 0;
    cmp word ptr [bp + 0xe], 3;
    jbe 0x75b0;
    mov word ptr [bp + 0xe], 3;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = 0;
    mov word ptr [bp - 6], 0xffff;
    $1 = $2;
    shl ax, 1;
    $1 += $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 -= $2;
    imul al;
    *($1) = $2;
    lodsb al, byte ptr [si];
    $1 -= $2;
    imul al;
    add word ptr [bp - 4], ax;
    lodsb al, byte ptr [si];
    $1 -= $2;
    imul al;
    add word ptr [bp - 4], ax;
    $1++;
    // Compare $1 with $2
    jb 0x75da;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    cmp word ptr [bp - 6], ax;
    jb 0x7620;
    *($1) = $2;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1++;
    // Compare $1 with $2
    jb 0x75b0;
    les di, ptr [bp + 6];
    $1 = $2;
    stosw word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 += $2;
    les di, ptr [bp + 6];
    $1 = $2;
    push($1);
    lodsb al, byte ptr [si];
    push($1);
    lodsb al, byte ptr [si];
    push($1);
    lodsb al, byte ptr [si];
    push($1);
    push($1);
    $1();
    stosb byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 5], 8;
    mov byte ptr [bp - 4], 1;
    mov byte ptr [bp - 3], 9;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    or cx, cx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xfff6;
    goto $1;
    // Compare $1 with $2
    jbe 0x76b5;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl al, 1;
    shl al, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl dh, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or al, dh;
    or al, dl;
    $1 = pop();
    $1 = pop();
    stosb byte ptr es:[di], al;
    loop 0x76b5;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    mul dh;
    $1 = $2;
    lodsb al, byte ptr [si];
    mul dl;
    $1 += $2;
    lodsb al, byte ptr [si];
    mul ch;
    $1 += $2;
    $1 = $2;
    div bl;
    $1 = $2;
    $1 -= $2;
    adc al, 0;
    // Compare $1 with $2
    jbe 0x7747;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xe];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    // Compare $1 with $2
    jbe 0x77a1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    stosb byte ptr es:[di], al;
    loop 0x7798;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    lea di, [bp - 0x32];
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = $2;
    $1 = $2;
    lea di, [bp - 0x32];
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x77f0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = 0;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x7872;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    movsw word ptr es:[di], word ptr [si];
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x7913;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    mov byte ptr es:[di], al;
    $1 += $2;
    $1++;
    $1++;
    // Compare $1 with $2
    jb 0x7939;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x796e;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    mov byte ptr es:[di], al;
    $1 += $2;
    $1++;
    $1++;
    // Compare $1 with $2
    jb 0x7994;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    movsw word ptr es:[di], word ptr [si];
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    mov byte ptr es:[di + 0x10], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 0x10];
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x7a80;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di], 0xca00;
    mov byte ptr es:[di + 2], 2;
    mov byte ptr es:[di + 3], 2;
    $1 = $2;
    mov word ptr es:[di + 4], ax;
    $1 = 0;
    mov word ptr es:[di + 6], ax;
    mov word ptr es:[di + 8], ax;
    $1 = $2;
    mov word ptr es:[di + 0x2c], ax;
    $1--;
    mov word ptr es:[di + 0xa], ax;
    $1 = $2;
    mov word ptr es:[di + 0x2e], ax;
    $1--;
    mov word ptr es:[di + 0xc], ax;
    $1 = 0;
    $1 = $2;
    mov byte ptr es:[di + 0x12], al;
    mul word ptr [bp + 6];
    mov word ptr es:[di + 0x34], ax;
    $1 = $2;
    mov word ptr es:[di + 0xe], ax;
    $1 = $2;
    mov word ptr es:[di + 0x10], ax;
    $1 = 0;
    $1 = $2;
    mov byte ptr es:[di + 0x13], al;
    mul word ptr [bp + 8];
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    mov word ptr es:[di + 0x30], ax;
    test ax, 1;
    if (ZF) goto $1;
    $1++;
    mov word ptr es:[di + 0x14], ax;
    $1 = $2;
    xor cl, 7;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    not ch;
    mov word ptr es:[di + 0x32], cx;
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    mov word ptr es:[di + 0x16], ax;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr es:[di + 0x22], dx;
    $1 = $2;
    int 0x67;
    or ah, ah;
    if (!ZF) goto $1;
    mov word ptr es:[di + 0x24], bx;
    mov word ptr es:[di + 0x26], 0;
    $1 = $2;
    int 0x67;
    and ax, 0xff00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffea;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr es:[di + 0x22], dx;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr es:[di + 0x24], bx;
    mov word ptr es:[di + 0x26], 0;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffdb;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr es:[di + 0x22], dx;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr es:[di + 0x24], bx;
    mov word ptr es:[di + 0x26], 0;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    mov word ptr es:[di + 0x1a], bx;
    mov word ptr es:[di + 0x18], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1c], ax;
    $1 = 0;
    mov word ptr es:[di + 0x1e], ax;
    mov word ptr es:[di + 0x20], ax;
    $1 = $2;
    $1 = 0;
    mov word ptr es:[di + 0x74], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 0xc];
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0x2e7;
    or dx, dx;
    jge 0x7c32;
    *($1) = $2;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    jae 0x7c4d;
    push($1);
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    int 0x67;
    or ah, ah;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jb 0x7c82;
    $1 = $2;
    $1 = $2;
    int 0x67;
    or ah, ah;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xffe9;
    goto $1;
    mov word ptr [bp - 2], 0xffea;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ah, ah;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jb 0x7cc6;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ah, ah;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xffda;
    goto $1;
    mov word ptr [bp - 2], 0xffdb;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ah, ah;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jb 0x7d0b;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ah, ah;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xffe1;
    goto $1;
    mov word ptr [bp - 2], 0xffe2;
    goto $1;
    $1 = 0;
    xchg dx, ax;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 6];
    cmp word ptr es:[di], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    or ah, ah;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe7;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    int 0x67;
    or ah, ah;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffea;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ah, ah;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffdb;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ah, ah;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe2;
    goto $1;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    cld ;
    rep stosb byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    cmp byte ptr [0x54e3], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe3;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x54e3], 1;
    if (!ZF) goto $1;
    goto $1;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si + 1], 0x3a;
    if (!ZF) goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    and byte ptr es:[di - 1], 0xdf;
    movsb byte ptr es:[di], byte ptr [si];
    goto $1;
    $1 = $2;
    int 0x21;
    $1 += $2;
    mov byte ptr es:[di], al;
    $1++;
    mov byte ptr es:[di], 0x3a;
    $1++;
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 0x5c;
    if (ZF) goto $1;
    mov byte ptr es:[di], 0x5c;
    $1++;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = pop();
    jae 0x7ed3;
    mov word ptr [bp - 2], 0xffe0;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cx, cx;
    if (ZF) goto $1;
    $1--;
    cmp byte ptr es:[di - 1], 0x5c;
    if (ZF) goto $1;
    mov byte ptr es:[di], 0x5c;
    $1++;
    cld ;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    movsb byte ptr es:[di], byte ptr [si];
    $1--;
    if (ZF) goto $1;
    cmp byte ptr es:[di - 1], 0;
    if (!ZF) goto $1;
    $1--;
    cmp byte ptr es:[di - 1], 0x5c;
    if (ZF) goto $1;
    mov byte ptr es:[di], 0x5c;
    $1++;
    mov byte ptr es:[di], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x7f33;
    mov word ptr [bp - 2], 0xffe0;
    goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x7f44;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x7f4b;
    mov word ptr [bp - 2], 0xffe0;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 += $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr [si], 0xffff;
    mov word ptr [si + 2], 0xffff;
    mov word ptr [si + 4], 0xffff;
    mov word ptr [si + 6], 0;
    $1 += $2;
    loop 0x7f9b;
    mov byte ptr [0x54e3], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    cmp byte ptr [0x54e3], 0;
    if (ZF) goto $1;
    cmp word ptr [0x4283], 0;
    if (!ZF) goto $1;
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe7;
    goto $1;
    mov byte ptr [0x54e3], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    mov byte ptr [bp + 7], 0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    cmp byte ptr [0x54e3], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe3;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xffe2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    mov word ptr [bp - 0xe], 0xffff;
    cmp word ptr es:[di], dx;
    if (!ZF) goto $1;
    cmp word ptr es:[di + 2], bx;
    if (!ZF) goto $1;
    cmp word ptr es:[di + 4], cx;
    jle 0x80c0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x809e;
    $1 = $2;
    cmp ax, -1;
    if (ZF) goto $1;
    cmp byte ptr [bp + 6], al;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mul bl;
    $1 += $2;
    cmp word ptr es:[di + 4], -1;
    if (ZF) goto $1;
    $1 = $2;
    cmp word ptr es:[di + 4], cx;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr es:[di + 4], cx;
    mov word ptr es:[di + 6], 1;
    goto $1;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp + 6];
    $1 += $2;
    cmp word ptr es:[di], -1;
    if (ZF) goto $1;
    cmp word ptr es:[di + 6], 0;
    if (ZF) goto $1;
    $1 = $2;
    mul word ptr es:[di + 2];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x8147;
    $1 = $2;
    mul word ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0x814a;
    goto $1;
    $1 = $2;
    mov word ptr es:[di], dx;
    $1 = $2;
    mov word ptr es:[di + 2], bx;
    $1 = $2;
    mov word ptr es:[di + 4], cx;
    mov word ptr es:[di + 6], cx;
    cmp byte ptr [bp - 0xe], 0xff;
    if (!ZF) goto $1;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x8197;
    $1 = $2;
    mul word ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0x8206;
    goto $1;
    cmp word ptr [bp - 0x12], 1;
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp - 0xe];
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp - 0xe], 0xffff;
    if (ZF) goto $1;
    cmp word ptr es:[di + 4], 0;
    if (ZF) goto $1;
    cmp word ptr es:[di + 4], cx;
    if (!ZF) goto $1;
    mov word ptr es:[di], 0xffff;
    mov word ptr es:[di + 2], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 6], 0;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffe2;
    goto $1;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    cmp byte ptr [0x54e3], 1;
    if (ZF) goto $1;
    $1 = $2;
    int 0x21;
    $1++;
    $1 = $2;
    goto $1;
    $1 = $2;
    and dl, 0xdf;
    $1 -= $2;
    $1 = $2;
    int 0x21;
    cmp ax, -1;
    if (ZF) goto $1;
    mul cx;
    mul bx;
    $1 = $2;
    div bx;
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffe2;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    div bx;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    mov byte ptr [si], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x82a3;
    mov word ptr [bp - 2], 0xffe0;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    jb 0x82dc;
    loop 0x82a8;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp - 0xc];
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffe0;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si], dx;
    if (!ZF) goto $1;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    $1 += $2;
    loop 0x82ef;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jb 0x8333;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp - 0xc];
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jb 0x8333;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffe2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x8364;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0xe], 0;
    mov word ptr [bp - 0xc], 4;
    mov word ptr [bp - 0xa], 4;
    mov word ptr [bp - 8], 0x10;
    mov word ptr [bp - 6], 0x10;
    mov word ptr [bp - 4], 0x100;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jl 0x83d0;
    push($1);
    push($1);
    $1();
    or ax, ax;
    jl 0x83d0;
    $1 = $2;
    shl si, 1;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0xe], 0;
    mov word ptr [bp - 0xc], 4;
    mov word ptr [bp - 0xa], 4;
    mov word ptr [bp - 8], 0x10;
    mov word ptr [bp - 6], 0x10;
    mov word ptr [bp - 4], 0x100;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jl 0x8434;
    push($1);
    push($1);
    $1();
    or ax, ax;
    jl 0x8434;
    $1 = $2;
    shl si, 1;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x8461;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    or ax, ax;
    jge 0x846f;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp + 6];
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x84b9;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    or ax, ax;
    jge 0x84c7;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x851c;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    or ax, ax;
    jge 0x852a;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x858b;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    or ax, ax;
    jge 0x8599;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = 0;
    les di, ptr [bp + 0xe];
    $1 = $2;
    stosw word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    stosw word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    stosw word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    cmp word ptr [bp + 0xa], 0;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 0xe], 0;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 0xe], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x8634;
    $1 -= $2;
    or al, al;
    if (!ZF) goto $1;
    $1 = 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    or dh, 0x10;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    or dh, 0x10;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = 0;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    goto $1;
    cmp word ptr [bp + 0xe], 2;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    goto $1;
    cmp word ptr [bp + 0xe], 3;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x8696;
    goto $1;
    // Compare $1 with $2
    jb 0x86ae;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1++;
    loop 0x86ae;
    goto $1;
    cmp word ptr [bp + 0xe], 4;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x86da;
    goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    out dx, al;
    $1++;
    $1 = $2;
    out dx, al;
    $1 = $2;
    out dx, al;
    $1 = $2;
    out dx, al;
    $1 += $2;
    $1 = $2;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = pop();
    $1 = pop();
    $1++;
    loop 0x86da;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    goto $1;
    cmp word ptr [bp + 0xe], 5;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x8735;
    goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    $1 = $2;
    cmp word ptr [bp + 0xa], ax;
    jae 0x8748;
    $1 = $2;
    sub word ptr [bp + 0xa], ax;
    $1 = $2;
    shl cx, 1;
    $1 += $2;
    push($1);
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = pop();
    $1 = $2;
    out dx, al;
    $1++;
    loop 0x875b;
    cmp word ptr [bp + 0xa], 0;
    jg 0x873d;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cmp word ptr [bp + 0xe], 0;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 0xe], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 0xe], 2;
    if (ZF) goto $1;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and bl, 0xf;
    mov byte ptr es:[di], bl;
    $1 = $2;
    and bl, 0x20;
    $1 = $2;
    shr bl, cl;
    $1 = $2;
    $1 = $2;
    and bl, 0x10;
    $1 = $2;
    shr bl, cl;
    $1 += $2;
    mov byte ptr es:[di + 1], bl;
    goto $1;
    cmp word ptr [bp + 0xe], 3;
    if (!ZF) goto $1;
    lcall 0x98e, 0x35e;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x8807;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    lds si, ptr [0xa8];
    lds si, ptr [si + 4];
    $1 = $2;
    or ax, si;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    lea si, [bp - 0x18];
    $1 = 0;
    $1 = $2;
    // Compare $1 with $2
    jl 0x882e;
    $1 += $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr [bp - 6], 2;
    if (ZF) goto $1;
    add byte ptr [bx + si], 0xe;
    $1++;
    // Compare $1 with $2
    jl 0x8826;
    mov byte ptr [bp - 8], 0;
    $1 = $2;
    $1 += $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    cmp word ptr [bp + 0xa], 0x10;
    if (!ZF) goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    goto $1;
    cmp word ptr [bp + 0xe], 4;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = $2;
    shl bl, 1;
    $1 -= $2;
    $1 = $2;
    shl bl, cl;
    $1 = $2;
    shl bh, cl;
    not bh;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x888b;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = $2;
    and bh, ah;
    or bh, al;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 += $2;
    $1 = pop();
    $1 = pop();
    $1++;
    loop 0x888b;
    goto $1;
    cmp word ptr [bp + 0xe], 5;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x88ce;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 0x36], 0x78;
    mov byte ptr [bp - 0x35], 0x7e;
    mov byte ptr [bp - 0x34], 0x28;
    mov byte ptr [bp - 0x33], 0x28;
    mov byte ptr [bp - 0x32], 0x28;
    mov byte ptr [bp - 0x31], 0x28;
    mov byte ptr [bp - 0x30], 0x18;
    mov byte ptr [bp - 0x2f], 8;
    mov byte ptr [bp - 0x2e], 0x18;
    mov byte ptr [bp - 0x2d], 7;
    mov byte ptr [bp - 0x2c], 8;
    mov byte ptr [bp - 0x2b], 8;
    mov byte ptr [bp - 0x2a], 8;
    mov byte ptr [bp - 0x29], 8;
    mov byte ptr [bp - 0x28], 8;
    mov byte ptr [bp - 0x27], 8;
    mov byte ptr [bp - 0x26], 8;
    mov byte ptr [bp - 0x25], 8;
    mov byte ptr [bp - 0x24], 8;
    mov byte ptr [bp - 0x23], 8;
    mov byte ptr [bp - 0x22], 8;
    mov byte ptr [bp - 0x21], 8;
    mov byte ptr [bp - 0x20], 8;
    mov byte ptr [bp - 0x1f], 8;
    mov byte ptr [bp - 0x1e], 8;
    mov byte ptr [bp - 0x1d], 8;
    mov byte ptr [bp - 0x1c], 8;
    mov byte ptr [bp - 0x1b], 8;
    mov byte ptr [bp - 0x1a], 8;
    mov byte ptr [bp - 0x19], 8;
    mov byte ptr [bp - 0x18], 8;
    mov byte ptr [bp - 0x17], 8;
    mov byte ptr [bp - 0x16], 8;
    mov byte ptr [bp - 0x15], 8;
    mov byte ptr [bp - 0x14], 8;
    mov byte ptr [bp - 0x13], 8;
    mov byte ptr [bp - 0x12], 8;
    mov byte ptr [bp - 0x11], 8;
    mov byte ptr [bp - 0x10], 8;
    mov byte ptr [bp - 0xf], 8;
    mov byte ptr [bp - 0xe], 8;
    mov byte ptr [bp - 0x60], 0x78;
    mov byte ptr [bp - 0x5f], 0x78;
    mov byte ptr [bp - 0x5e], 0x38;
    mov byte ptr [bp - 0x5d], 0x38;
    mov byte ptr [bp - 0x5c], 0x98;
    mov byte ptr [bp - 0x5b], 0x38;
    mov byte ptr [bp - 0x5a], 0x18;
    mov byte ptr [bp - 0x59], 0x18;
    mov byte ptr [bp - 0x58], 0x18;
    mov byte ptr [bp - 0x57], 0xa0;
    mov byte ptr [bp - 0x56], 0x18;
    mov byte ptr [bp - 0x55], 0x18;
    mov byte ptr [bp - 0x54], 0x18;
    mov byte ptr [bp - 0x53], 0x18;
    mov byte ptr [bp - 0x52], 0x18;
    mov byte ptr [bp - 0x51], 0x98;
    mov byte ptr [bp - 0x50], 0x18;
    mov byte ptr [bp - 0x4f], 0x18;
    mov byte ptr [bp - 0x4e], 0x18;
    mov byte ptr [bp - 0x4d], 0x18;
    mov byte ptr [bp - 0x4c], 0x18;
    mov byte ptr [bp - 0x4b], 0x18;
    mov byte ptr [bp - 0x4a], 0x18;
    mov byte ptr [bp - 0x49], 0x18;
    mov byte ptr [bp - 0x48], 0x18;
    mov byte ptr [bp - 0x47], 0x18;
    mov byte ptr [bp - 0x46], 0x18;
    mov byte ptr [bp - 0x45], 0x18;
    mov byte ptr [bp - 0x44], 0x18;
    mov byte ptr [bp - 0x43], 0x18;
    mov byte ptr [bp - 0x42], 0x18;
    mov byte ptr [bp - 0x41], 0x18;
    mov byte ptr [bp - 0x40], 0x18;
    mov byte ptr [bp - 0x3f], 0x18;
    mov byte ptr [bp - 0x3e], 0x18;
    mov byte ptr [bp - 0x3d], 0x18;
    mov byte ptr [bp - 0x3c], 0x18;
    mov byte ptr [bp - 0x3b], 0x18;
    mov byte ptr [bp - 0x3a], 0x18;
    mov byte ptr [bp - 0x39], 0x18;
    mov byte ptr [bp - 0x38], 0x18;
    mov byte ptr [bp - 0x80], 0x88;
    mov byte ptr [bp - 0x7f], 0x88;
    mov byte ptr [bp - 0x7e], 0x88;
    mov byte ptr [bp - 0x7d], 0x88;
    mov byte ptr [bp - 0x7c], 0x40;
    mov byte ptr [bp - 0x7b], 0x40;
    mov byte ptr [bp - 0x7a], 0x40;
    mov byte ptr [bp - 0x79], 0x40;
    mov byte ptr [bp - 0x78], 0x20;
    mov byte ptr [bp - 0x77], 0x20;
    mov byte ptr [bp - 0x76], 0x20;
    mov byte ptr [bp - 0x75], 0x20;
    mov byte ptr [bp - 0x74], 0x10;
    mov byte ptr [bp - 0x73], 0x10;
    mov byte ptr [bp - 0x72], 0x10;
    mov byte ptr [bp - 0x71], 0x10;
    mov byte ptr [bp - 0x70], 8;
    mov byte ptr [bp - 0x6f], 0x40;
    mov byte ptr [bp - 0x6e], 0x40;
    mov byte ptr [bp - 0x6d], 0x20;
    mov byte ptr [bp - 0x6c], 0x10;
    mov byte ptr [bp - 0x6b], 4;
    mov byte ptr [bp - 0x6a], 4;
    mov byte ptr [bp - 0x69], 4;
    mov byte ptr [bp - 0x68], 4;
    mov byte ptr [bp - 0x67], 4;
    mov byte ptr [bp - 0x66], 0xfc;
    mov byte ptr [bp - 0x65], 0xfc;
    mov byte ptr [bp - 0x64], 0xfc;
    mov byte ptr [bp - 0x63], 0xfc;
    mov byte ptr [bp - 0x62], 0xfc;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x8b19;
    goto $1;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0xae3, 0;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp byte ptr [bp - 4], 0;
    if (ZF) goto $1;
    goto $1;
    cmp byte ptr [bp - 6], 0x80;
    jb 0x8b4a;
    sub byte ptr [bp - 6], 0x7a;
    $1 = $2;
    $1 = $2;
    clc ;
    shl al, cl;
    jb 0x8b58;
    goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    shl al, cl;
    jb 0x8b66;
    goto $1;
    // Compare $1 with $2
    jae 0x8b6e;
    goto $1;
    lcall 0x921, 0x1a5;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    jae 0x8b80;
    goto $1;
    push($1);
    lcall 0x98e, 0xdf;
    jae 0x8b8e;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffd8;
    goto $1;
    test word ptr es:[di], 1;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    jg 0x8bca;
    lcall 0x921, 0x55;
    // Compare $1 with $2
    jg 0x8bca;
    goto $1;
    push($1);
    push($1);
    lea ax, [bp - 0xc];
    push($1);
    lcall 0x921, 0x1fc;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    shl al, cl;
    jb 0x8bec;
    goto $1;
    // Compare $1 with $2
    jb 0x8c05;
    push($1);
    push($1);
    lcall 0x98e, 0xc;
    $1 = $2;
    or si, si;
    jge 0x8c05;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    ja 0x8c11;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x54d4], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 3;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 4;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 6], 2;
    if (ZF) goto $1;
    cmp word ptr [bp + 6], 4;
    if (ZF) goto $1;
    cmp word ptr [bp + 6], 8;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    mov byte ptr [bp - 8], 1;
    mov byte ptr [bp - 7], 4;
    mov byte ptr [bp - 6], 6;
    mov byte ptr [bp - 5], 9;
    mov byte ptr [bp - 4], 0xf;
    mov byte ptr [bp - 0x12], 5;
    mov byte ptr [bp - 0x11], 7;
    mov byte ptr [bp - 0x10], 0xa;
    mov byte ptr [bp - 0xf], 0xe;
    mov byte ptr [bp - 0xe], 0x12;
    mov byte ptr [bp - 0xd], 0x16;
    mov byte ptr [bp - 0xc], 0x1f;
    mov byte ptr [bp - 0xb], 0x26;
    mov byte ptr [bp - 0x26], 8;
    mov byte ptr [bp - 0x25], 0xb;
    mov byte ptr [bp - 0x24], 0xd;
    mov byte ptr [bp - 0x23], 0x1a;
    mov byte ptr [bp - 0x22], 0x10;
    mov byte ptr [bp - 0x21], 0x1b;
    mov byte ptr [bp - 0x20], 0x1c;
    mov byte ptr [bp - 0x1f], 0x13;
    mov byte ptr [bp - 0x1e], 0x15;
    mov byte ptr [bp - 0x1d], 0x1d;
    mov byte ptr [bp - 0x1c], 0x17;
    mov byte ptr [bp - 0x1b], 0x19;
    mov byte ptr [bp - 0x1a], 0x1e;
    mov byte ptr [bp - 0x19], 0x20;
    mov byte ptr [bp - 0x18], 0x22;
    mov byte ptr [bp - 0x17], 0x23;
    mov byte ptr [bp - 0x16], 0x24;
    mov byte ptr [bp - 0x15], 0x27;
    mov byte ptr [bp - 0x14], 0x28;
    cmp word ptr [bp + 8], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 3;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 4;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 6], 2;
    if (ZF) goto $1;
    cmp word ptr [bp + 6], 4;
    if (ZF) goto $1;
    cmp word ptr [bp + 6], 8;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    $1--;
    jge 0x8d3b;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    $1--;
    jge 0x8d61;
    goto $1;
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    $1--;
    jge 0x8d81;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x55f3], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x8ddb;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x8dee;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    cmp byte ptr [si], 9;
    if (ZF) goto $1;
    lcall 0x98e, 0x18a;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff9;
    goto $1;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0x8e39;
    neg ax;
    add word ptr [bp + 8], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jb 0x8e46;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0x8e55;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jb 0x8e61;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 8], ax;
    jbe 0x8e72;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0x8e83;
    $1 = $2;
    *($1) = $2;
    mul word ptr [bp - 0xe];
    *($1) = $2;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    or ax, ax;
    jge 0x8ead;
    neg ax;
    add word ptr [bp + 6], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jb 0x8eba;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0x8ec9;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jb 0x8ed5;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 6], ax;
    jbe 0x8ee6;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0x8ef7;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    mul bx;
    *($1) = $2;
    mov word ptr [bp - 0x2c], 0xffff;
    mov word ptr [bp - 0x2e], 0;
    cmp byte ptr [bp - 0xe], 8;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    mul word ptr [bp - 0xe];
    $1 = $2;
    and cx, 7;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    shr dl, cl;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    and cx, 7;
    $1 = $2;
    shr dh, cl;
    not dh;
    *($1) = $2;
    // Compare $1 with $2
    jl 0x8f5c;
    $1 = $2;
    *($1) = $2;
    or dh, dh;
    if (ZF) goto $1;
    and byte ptr [bp - 0x2c], dh;
    mov byte ptr [bp - 0x2b], 0;
    $1 = $2;
    $1 -= $2;
    mul word ptr [bp - 0xe];
    and ax, 7;
    *($1) = $2;
    mov word ptr [bp - 0x32], 1;
    $1 = $2;
    mul word ptr [bp - 0xe];
    and ax, 7;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0xe];
    and ax, 7;
    // Compare $1 with $2
    jle 0x8f8b;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    div bx;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    mov byte ptr [bp - 0x2b], 0;
    mov word ptr [bp - 0x36], 0;
    // Compare $1 with $2
    jbe 0x8fb0;
    $1++;
    $1 = $2;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    cmp byte ptr [bp - 0x2b], 0;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    neg ax;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    cld ;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x5ab;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x637;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov byte ptr [0x55f3], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    and al, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    cmp byte ptr [bp - 0x32], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    not bl;
    and byte ptr es:[di], bl;
    or byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0x912b;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x911e;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x9143;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x916b;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0x36], 0;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and al, bh;
    not bh;
    and byte ptr es:[di], bh;
    or byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x919d;
    *($1) = $2;
    goto $1;
    xor byte ptr [bp - 6], 1;
    if (ZF) goto $1;
    $1 += $2;
    goto $1;
    $1 -= $2;
    $1 -= $2;
    $1 += $2;
    jae 0x91c7;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x91c7;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 0x26], 0x100;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0x10], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 0x26], 0x400;
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = pop();
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    cmp byte ptr [bp - 0x32], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    not bl;
    and byte ptr es:[di], bl;
    or byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0x9278;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x926b;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x9290;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x92b8;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0x36], 0;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and al, bh;
    not bh;
    and byte ptr es:[di], bh;
    or byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x92ea;
    *($1) = $2;
    goto $1;
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    ja 0x9303;
    $1 = 0;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 += $2;
    jae 0x9326;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x9326;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x9386;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x9381;
    *($1) = $2;
    goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0x936a;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1--;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x93a8;
    *($1) = $2;
    goto $1;
    $1 += $2;
    $1 += $2;
    jae 0x93c3;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x93c3;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = pop();
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr [bp - 0xa];
    $1 = $2;
    $1 = 0;
    and al, 3;
    *($1) = $2;
    $1 = $2;
    cmp byte ptr [bp - 0x32], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    not bl;
    and byte ptr es:[di], bl;
    or byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0x9455;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x9448;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x946d;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x9495;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0x36], 0;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and al, bh;
    not bh;
    and byte ptr es:[di], bh;
    or byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x94c7;
    *($1) = $2;
    goto $1;
    $1 -= $2;
    $1++;
    cmp byte ptr [bp - 6], 4;
    jb 0x94dd;
    $1 -= $2;
    mov byte ptr [bp - 6], 0;
    goto $1;
    $1 += $2;
    $1 += $2;
    jae 0x94f9;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x94f9;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    les di, ptr [bp - 0xa];
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0x956b;
    // Compare $1 with $2
    ja 0x956b;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x956b;
    *($1) = $2;
    goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0x9542;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1 += $2;
    jae 0x95a0;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x95b7;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0x95cf;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x95cf;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    push($1);
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    if (ZF) goto $1;
    push($1);
    push($1);
    lcall [si];
    goto $1;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x9629;
    $1 = 0;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 += $2;
    if (ZF) goto $1;
    push($1);
    push($1);
    lcall [si];
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe7;
    goto $1;
    $1 = $2;
    int 0x21;
    jae 0x9675;
    mov word ptr [bp - 2], 0xffe7;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    if (ZF) goto $1;
    lcall [si];
    goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    mul bx;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 += $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 += $2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x55f1], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp + 0x10];
    push($1);
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x977b;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x978e;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    cmp byte ptr [si], 9;
    if (ZF) goto $1;
    lcall 0x98e, 0x18a;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff9;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 0xe], ax;
    jb 0x97e1;
    mov word ptr [bp - 2], 0;
    goto $1;
    cmp word ptr [bp + 0xa], ax;
    jb 0x97ea;
    $1--;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    or ax, ax;
    jg 0x9803;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    // Compare $1 with $2
    jge 0x981d;
    $1 = 0;
    $1 = $2;
    mul bx;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0xc], ax;
    jb 0x982c;
    mov word ptr [bp - 2], 0;
    goto $1;
    cmp word ptr [bp + 8], ax;
    jb 0x9835;
    $1--;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    or ax, ax;
    jg 0x984e;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    // Compare $1 with $2
    jge 0x9857;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    cld ;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x2dd;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x31e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov byte ptr [0x55f1], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    $1--;
    shl ax, cl;
    and al, 7;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    test ax, 1;
    if (ZF) goto $1;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    les di, ptr es:[di + 0x18];
    push($1);
    $1 = $2;
    lodsw ax, word ptr [si];
    $1--;
    rol ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    and al, 7;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    les di, ptr es:[di + 0x18];
    $1 = $2;
    push($1);
    lodsw ax, word ptr [si];
    $1--;
    rol ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    $1 += $2;
    $1 = pop();
    $1++;
    // Compare $1 with $2
    jb 0x99f1;
    $1 = 0;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr es:[di + 0x18];
    push($1);
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    $1 = $2;
    and al, 7;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    and al, 3;
    mov byte ptr [bp - 6], 4;
    sub byte ptr [bp - 6], al;
    $1 = $2;
    les di, ptr es:[di + 0x18];
    $1 = $2;
    push($1);
    lodsw ax, word ptr [si];
    $1--;
    rol ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall [si + 0x26];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = pop();
    $1 = $2;
    not ax;
    *($1) = $2;
    les di, ptr es:[di + 0x18];
    $1 = $2;
    // Compare $1 with $2
    jbe 0x9b0a;
    movsb byte ptr es:[di], byte ptr [si];
    or si, si;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x9af3;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 += $2;
    $1 += $2;
    jae 0x9b28;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1--;
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    push($1);
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x9b75;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, 0;
    jae 0x9b8b;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    jb 0x9ba1;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    jbe 0x9ba1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, word ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x9bc1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0x9bda;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x80c, 0x640;
    $1 = pop();
    cdq ;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    push($1);
    $1 = $2;
    push($1);
    xchg cx, ax;
    xchg dx, ax;
    mul bx;
    xchg cx, ax;
    mul bx;
    $1 += $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    xchg cx, ax;
    xchg dx, ax;
    mul bx;
    xchg cx, ax;
    or bx, bx;
    jns 0x9c19;
    $1 -= $2;
    mul bx;
    $1 += $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    push($1);
    $1 = 0;
    // Compare $1 with $2
    jb 0x9c35;
    xchg cx, ax;
    xchg dx, ax;
    div bx;
    xchg cx, ax;
    div bx;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xor ah, dh;
    push($1);
    $1 = $2;
    or dx, dx;
    jns 0x9c5b;
    neg dx;
    neg ax;
    sbb dx, 0;
    or cx, cx;
    jns 0x9c66;
    neg cx;
    neg bx;
    sbb cx, 0;
    or cx, cx;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    xchg dx, ax;
    $1 = 0;
    div cx;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 = pop();
    $1 -= $2;
    sbb cx, dx;
    $1 = 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    or cx, cx;
    jns 0x9cac;
    $1 += $2;
    adc cx, di;
    $1 -= $2;
    sbb dx, 0;
    goto $1;
    or bx, bx;
    if (ZF) goto $1;
    $1 = 0;
    // Compare $1 with $2
    jb 0x9ca4;
    xchg cx, ax;
    xchg dx, ax;
    div bx;
    xchg cx, ax;
    div bx;
    xchg cx, dx;
    $1 = 0;
    xchg bx, cx;
    $1 = $2;
    $1 = pop();
    shl bh, 1;
    jae 0x9cba;
    neg dx;
    neg ax;
    sbb dx, 0;
    shl bl, 1;
    $1 = $2;
    jae 0x9cc7;
    neg cx;
    neg bx;
    sbb cx, 0;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    les di, ptr [bp + 0xc];
    $1 = $2;
    mov byte ptr es:[di], al;
    goto $1;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 -= $2;
    les di, ptr [bp + 0xc];
    $1 += $2;
    cld ;
    $1 = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr es:[di - 1], 0;
    if (ZF) goto $1;
    loop 0x9d40;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[di], al;
    $1 = 0;
    mov word ptr es:[di + 0x48], ax;
    mov word ptr es:[di + 0x46], ax;
    push($1);
    $1 = $2;
    int 0x21;
    $1 = 0;
    // Compare $1 with $2
    jbe 0x9d6a;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    or al, ah;
    $1 = $2;
    int 0x21;
    $1 = pop();
    mov word ptr es:[di + 0x42], ax;
    jae 0x9d8b;
    mov word ptr [bp - 2], 0xffff;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 0x14], 2;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x9db0;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    cmp word ptr [si], 0x5a4d;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    $1 = $2;
    cmp word ptr [si + 2], 0;
    if (ZF) goto $1;
    $1--;
    $1 = $2;
    mul bx;
    $1 += $2;
    adc dx, 0;
    mov word ptr es:[di + 0x48], dx;
    mov word ptr es:[di + 0x46], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x9dff;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    cmp word ptr [si], 0xca01;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    $1 = $2;
    mov word ptr es:[di + 0x44], ax;
    mov word ptr es:[di + 0x4e], 6;
    $1 = $2;
    mov word ptr es:[di + 0x52], ax;
    $1 = $2;
    $1 += $2;
    mov word ptr es:[di + 0x50], ax;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 = 0;
    $1 = $2;
    div bx;
    mov word ptr es:[di + 0x4e], ax;
    $1 = $2;
    mov word ptr es:[di + 0x52], ax;
    $1 = $2;
    mov word ptr es:[di + 0x50], ax;
    mov word ptr es:[di + 0x4a], 0xffff;
    mov word ptr es:[di + 0x4c], 0xffff;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cmp byte ptr es:[di], 0;
    if (ZF) goto $1;
    cmp byte ptr es:[di], 1;
    if (ZF) goto $1;
    cmp byte ptr es:[di], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x9eab;
    mov word ptr [bp - 2], 0xffdf;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    cmp byte ptr es:[di], 1;
    if (ZF) goto $1;
    cmp byte ptr es:[di], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    jbe 0x9efb;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 -= $2;
    jns 0x9f07;
    $1 = 0;
    // Compare $1 with $2
    jb 0x9f0d;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    adc dx, word ptr es:[di + 0x48];
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    // Compare $1 with $2
    jb 0x9f3f;
    $1 = $2;
    $1 = $2;
    mul bx;
    lds si, ptr es:[di + 0x50];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x9f5d;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    $1 = $2;
    mov word ptr es:[di + 0x4a], ax;
    $1 = $2;
    mov word ptr es:[di + 0x4c], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 1;
    if (ZF) goto $1;
    cmp byte ptr [si], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    goto $1;
    $1 = $2;
    int 0x21;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lea dx, [bp - 0x96];
    $1 = $2;
    int 0x21;
    $1 = pop();
    cmp word ptr [bp + 6], -1;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    int 0x21;
    jae 0xa031;
    mov word ptr [bp - 2], 0xfff2;
    goto $1;
    $1 = $2;
    int 0x21;
    jae 0xa031;
    mov word ptr [bp - 2], 0xfff2;
    goto $1;
    $1 = $2;
    int 0x21;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr [bp + 8];
    mov byte ptr es:[di], 0;
    $1 = 0;
    mov word ptr es:[di + 0xe], ax;
    mov word ptr es:[di + 0x10], ax;
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x14], ax;
    $1 = $2;
    mov word ptr es:[di + 0x16], ax;
    $1 = $2;
    mov word ptr es:[di + 0x18], ax;
    $1 += $2;
    $1 += $2;
    $1 = $2;
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 0x2e;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov byte ptr es:[di], 0x20;
    $1++;
    loop 0xa07d;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0xa073;
    goto $1;
    mov byte ptr es:[di], 0x20;
    $1++;
    loop 0xa08e;
    mov byte ptr es:[di - 4], 0x2e;
    mov byte ptr es:[di], 0;
    mov word ptr [bp - 2], 0;
    lds dx, ptr [bp - 8];
    $1 = $2;
    int 0x21;
    goto $1;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 -= $2;
    les di, ptr [bp + 0x10];
    $1 += $2;
    cmp word ptr [bp + 6], -1;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    lea di, [bp - 0x16];
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    ja 0xa113;
    // Compare $1 with $2
    jb 0xa113;
    and al, 0xdf;
    *($1) = $2;
    $1++;
    goto $1;
    $1 = pop();
    $1 = 0;
    $1 = $2;
    $1 = $2;
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[bx + di], 0x3f;
    goto $1;
    mov byte ptr es:[bx + di], 0x20;
    goto $1;
    mov byte ptr es:[bx + di], al;
    $1++;
    $1++;
    loop 0xa11e;
    // Compare $1 with $2
    jae 0xa15c;
    mov byte ptr es:[bx + di], 0x2e;
    $1++;
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 0x2e;
    if (ZF) goto $1;
    $1++;
    goto $1;
    $1++;
    $1 = $2;
    goto $1;
    lds si, ptr [bp + 0x10];
    les di, ptr [si + 0x50];
    cmp word ptr [bp + 6], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    mov word ptr [si + 0x4c], 0;
    cmp word ptr [si + 0x44], 0;
    if (ZF) goto $1;
    cmp word ptr [si + 0x4a], 0;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [si + 0x50];
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    lds si, ptr [bp + 0xc];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    loope 0xa1b4;
    if (ZF) goto $1;
    lds si, ptr [bp + 0x10];
    $1++;
    $1 = $2;
    // Compare $1 with $2
    jb 0xa1dc;
    mov word ptr [bp - 2], 0xfff2;
    goto $1;
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    jb 0xa19c;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    les di, ptr [bp + 8];
    cld ;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    lds si, ptr [bp + 0x10];
    les di, ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    add word ptr es:[di + 0xe], ax;
    adc word ptr es:[di + 0x10], dx;
    cmp word ptr [bp + 6], -1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 0xe];
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 1;
    if (ZF) goto $1;
    cmp byte ptr [si], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    $1 = $2;
    int 0x21;
    $1 = 0;
    // Compare $1 with $2
    jbe 0xa2b3;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    or al, ah;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0xa2cf;
    mov word ptr [bp - 2], 0xffff;
    goto $1;
    lds si, ptr [bp + 0xe];
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 1;
    if (ZF) goto $1;
    cmp byte ptr [si], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0xa338;
    mov word ptr [bp - 2], 0xffdf;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 1;
    if (ZF) goto $1;
    cmp byte ptr [si], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0xa3bc;
    mov word ptr [bp - 2], 0xffff;
    goto $1;
    mov word ptr [bp - 2], 0xffff;
    goto $1;
    lds si, ptr [bp + 0xa];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    cmp byte ptr [si], 1;
    if (ZF) goto $1;
    cmp byte ptr [si], 2;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff4;
    goto $1;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    lea dx, [bp - 0x7e];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0xa43e;
    mov word ptr [bp - 2], 0xfffc;
    goto $1;
    mov word ptr [bp - 2], 0xfffc;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    xchg al, ah;
    shr ax, 1;
    $1 += $2;
    $1 = 0;
    $1 += $2;
    shr ax, 1;
    shr ax, 1;
    $1 += $2;
    shr bx, 1;
    shr bx, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, ah;
    xor cl, ah;
    shl cl, 1;
    retf ;
    $1 = $2;
    xchg al, ah;
    shr bx, 1;
    shr ax, 1;
    $1 += $2;
    $1 = 0;
    $1 += $2;
    shr ax, 1;
    shr ax, 1;
    $1 += $2;
    shr bx, 1;
    shr bx, 1;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    $1 = $2;
    shr ax, 1;
    rcr bx, 1;
    shr ax, 1;
    rcr bx, 1;
    shr bx, 1;
    $1 = $2;
    mul ah;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    shr dx, 1;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    xchg al, ah;
    $1 += $2;
    shr ax, 1;
    shr ax, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    $1 = $2;
    mul dx;
    $1 = $2;
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    adc dx, 0;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x55f0], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xe];
    push($1);
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0xa63f;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0xa652;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    cmp byte ptr es:[di], 9;
    if (ZF) goto $1;
    lcall 0x98e, 0x18a;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff9;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    jg 0xa691;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jge 0xa6be;
    $1 = 0;
    $1 = $2;
    mul bx;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    xor cl, 7;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    jg 0xa6d4;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jge 0xa6dc;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    *($1) = $2;
    cld ;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x4ba;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x548;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov byte ptr [0x55f0], 1;
    retf ;
    $1 = $2;
    cmp byte ptr [si + 0x13], 1;
    if (ZF) goto $1;
    shl ax, 1;
    and al, 7;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    test word ptr [bp + 8], 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    lds si, ptr [si + 0x18];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    ror dx, cl;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    and word ptr es:[di], dx;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = $2;
    not al;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    lodsb al, byte ptr [si];
    and al, ch;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    lodsb al, byte ptr [si];
    and al, ch;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    not ch;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    lodsb al, byte ptr [si];
    or al, ch;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    lodsb al, byte ptr [si];
    and al, ch;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    xor al, 7;
    $1++;
    and al, 7;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 0x14], 1;
    mov word ptr [bp - 0x16], 0xf;
    mov byte ptr [bp - 0x12], 0xf;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0x10], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 0x16], 1;
    mov byte ptr [bp - 0x12], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 0x14], 8;
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl bx, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    lds si, ptr [si + 0x18];
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    lodsb al, byte ptr [si];
    and byte ptr es:[di], al;
    $1++;
    loop 0xa99b;
    $1 = pop();
    $1 += $2;
    cmp byte ptr [bp - 0x10], 1;
    if (ZF) goto $1;
    $1 = $2;
    shl byte ptr [bp - 0x12], 1;
    cmp byte ptr [bp - 0x12], dl;
    jbe 0xa9c8;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    $1 = $2;
    $1 = $2;
    cwde ;
    cmp word ptr [bp - 0xa], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    shl ax, cl;
    shl bx, cl;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    lodsw ax, word ptr [si];
    $1--;
    test cl, cl;
    if (!ZF) goto $1;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    rol ax, cl;
    and byte ptr es:[di], ah;
    $1++;
    $1--;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    $1--;
    jle 0xaa2b;
    and byte ptr es:[di], al;
    $1++;
    lodsw ax, word ptr [si];
    $1--;
    rol ax, cl;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di + 1], bh;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 += $2;
    $1 = $2;
    shl byte ptr [bp - 0x12], 1;
    cmp byte ptr [bp - 0x12], dl;
    jbe 0xaa65;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [si + 0x18];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    xor byte ptr es:[di], al;
    $1++;
    loop 0xaaec;
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    and byte ptr es:[di], al;
    $1++;
    loop 0xab01;
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    or byte ptr es:[di], al;
    $1++;
    loop 0xab16;
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 = 0;
    and al, 7;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    and al, 3;
    mov byte ptr [bp - 6], 4;
    sub byte ptr [bp - 6], al;
    $1 = $2;
    lds si, ptr [si + 0x18];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    ror dx, cl;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    and word ptr es:[di], dx;
    lodsb al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = $2;
    not al;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    lodsb al, byte ptr [si];
    and al, ch;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    lodsb al, byte ptr [si];
    and al, ch;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    not ch;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    lodsb al, byte ptr [si];
    or al, ch;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1--;
    push($1);
    test bx, bx;
    if (ZF) goto $1;
    push($1);
    lodsb al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 += $2;
    $1 = pop();
    lodsb al, byte ptr [si];
    and al, ch;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [si + 0x18];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xad3a;
    movsb byte ptr es:[di], byte ptr [si];
    or di, di;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0xad23;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 += $2;
    $1 += $2;
    jae 0xad56;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    xor byte ptr es:[di], al;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0xad61;
    $1 += $2;
    $1 += $2;
    jae 0xad8c;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    and byte ptr es:[di], al;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0xad96;
    $1 += $2;
    $1 += $2;
    jae 0xadc1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    or byte ptr es:[di], al;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0xadcb;
    $1 += $2;
    $1 += $2;
    jae 0xadf6;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    push($1);
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffd9;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp byte ptr es:[di], 0x56;
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 1], 0x45;
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 2], 0x53;
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 3], 0x41;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0xae3, 0;
    cmp byte ptr [bp - 6], 5;
    if (ZF) goto $1;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    cmp byte ptr es:[di], 0x33;
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 1], 0x31;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 4;
    goto $1;
    $1 = 0;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 3;
    goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    $1 = $2;
    out dx, al;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = 0;
    in al, dx;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    out dx, al;
    $1 = 0;
    in al, dx;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    out dx, al;
    mov word ptr [bp - 2], 2;
    goto $1;
    $1 = $2;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    in al, dx;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    out dx, al;
    in al, dx;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    out dx, al;
    mov word ptr [bp - 2], 1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    $1--;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1--;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1--;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 5;
    goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    test al, 0xe;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 6;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffde;
    $1 = $2;
    // Compare $1 with $2
    ja 0xafa8;
    jb 0xaf9f;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffd9;
    goto $1;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1();
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    les di, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xc0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    int 0x10;
    and ah, 0x7f;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xb089;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xb089;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xb0ba;
    cli ;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    sti ;
    test al, 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    cli ;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    sti ;
    test al, 0x10;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0xb0d8;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 3;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 3;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xb179;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xb179;
    $1 = $2;
    $1 = $2;
    goto $1;
    mov word ptr [bp - 2], 0xffde;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr es:[di + 2], bx;
    mov word ptr es:[di + 4], cx;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    push($1);
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    mov byte ptr [bp - 0xe], 0;
    mov byte ptr [bp - 0xd], 0x55;
    mov byte ptr [bp - 0xc], 0xaa;
    mov byte ptr [bp - 0xb], 0xff;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 0x13], 1;
    if (!ZF) goto $1;
    test ax, 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    cmp byte ptr es:[di + 0x13], 2;
    if (!ZF) goto $1;
    and ax, 3;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    goto $1;
    $1 = 0;
    mov byte ptr [bp + si - 0xe], 0xff;
    rcr ax, 1;
    jb 0xb238;
    not byte ptr [bp + si - 0xe];
    $1++;
    // Compare $1 with $2
    jb 0xb22d;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    not bx;
    les di, ptr [bp - 6];
    cld ;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0xb272;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jae 0xb272;
    goto $1;
    stosb byte ptr es:[di], al;
    loop 0xb257;
    goto $1;
    shr cx, 1;
    $1 = $2;
    rep stosw word ptr es:[di], ax;
    $1++;
    // Compare $1 with $2
    jb 0xb285;
    $1 = 0;
    $1--;
    if (ZF) goto $1;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    $1 = pop();
    jae 0xb2a3;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    // Compare $1 with $2
    jae 0xb2ed;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x54c1], 0x44bf;
    mov word ptr [0x54bf], 0x1000;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov byte ptr [0x54c5], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    cmp word ptr [0x54c6], -1;
    if (!ZF) goto $1;
    stc ;
    mov word ptr [bp - 2], 0xffff;
    goto $1;
    les di, ptr [0x54c1];
    $1 = $2;
    $1 -= $2;
    add word ptr [0x54ca], ax;
    adc word ptr [0x54c8], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    cmp word ptr [0x54c6], -1;
    if (!ZF) goto $1;
    stc ;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    les di, ptr [0x54c1];
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    clc ;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    stc ;
    mov word ptr [bp - 2], 0xfffc;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cmp word ptr [bp + 0xe], 0;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1();
    jae 0xb45e;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [0x54c6], 0xffff;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x54c5], 1;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    mov byte ptr [0x54c5], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [0x54c5], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0xb508;
    // Compare $1 with $2
    jbe 0xb50f;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    goto $1;
    $1 += $2;
    loop 0xb518;
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0xb560;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    push($1);
    push($1);
    $1();
    jae 0xb56c;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1();
    jae 0xb5a5;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xb5de;
    mov word ptr [bp - 2], 0xfffa;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    loop 0xb5e4;
    mov word ptr [bp - 2], 0xfc19;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xb629;
    mov word ptr [bp - 2], 0xfffa;
    stc ;
    goto $1;
    push($1);
    push($1);
    $1();
    jae 0xb636;
    *($1) = $2;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr es:[di + 3];
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc19;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x43b9], 7;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    int 0x10;
    xchg bx, ax;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    and ax, 0x7f;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ah, ah;
    if (ZF) goto $1;
    cmp word ptr [0x43b9], 7;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffd8;
    goto $1;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xb74d;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    ja 0xb75b;
    goto $1;
    // Compare $1 with $2
    jg 0xb772;
    lcall 0x921, 0x55;
    // Compare $1 with $2
    jg 0xb772;
    mov word ptr [bp - 2], 0xffde;
    goto $1;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    jae 0xb7a1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    // Compare $1 with $2
    jb 0xb7a1;
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    or ax, ax;
    jge 0xb7a1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    jae 0xb7ae;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 4], 7;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffd8;
    goto $1;
    $1 = $2;
    $1 = $2;
    div cl;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1();
    jae 0xb7f6;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[di + 0x16], al;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr es:[di + 0x1c], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    // Compare $1 with $2
    ja 0xb85d;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1();
    jae 0xb885;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    // Compare $1 with $2
    jb 0xb8d3;
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    jge 0xb8d3;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1();
    jae 0xb8e0;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 6], 1;
    if (!ZF) goto $1;
    mov word ptr [0x43b5], 1;
    mov word ptr [0x43b7], 0;
    cmp byte ptr es:[di], 9;
    if (ZF) goto $1;
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    cmp word ptr [0x54d4], 1;
    if (!ZF) goto $1;
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    push($1);
    $1();
    goto $1;
    cmp word ptr [bp + 6], 0;
    if (!ZF) goto $1;
    mov word ptr [0x43b5], 0;
    mov word ptr [0x43b7], 0;
    cmp byte ptr es:[di], 9;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1();
    goto $1;
    $1 = $2;
    push($1);
    $1();
    goto $1;
    mov word ptr [bp - 2], 0xfff9;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    goto $1;
    $1 = $2;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = 0;
    cld ;
    $1 = $2;
    $1 = $2;
    out dx, al;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    loop 0xb9bf;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = 0;
    $1 = pop();
    rep stosw word ptr es:[di], ax;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    *($1) = $2;
    $1--;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xbabe;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xbb05;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xbb00;
    *($1) = $2;
    goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0xbae8;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xc];
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    *($1) = $2;
    $1--;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0xbb68;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xbbaf;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0xbbaa;
    *($1) = $2;
    goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0xbb92;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    // Compare $1 with $2
    jg 0xbbe6;
    xchg bx, ax;
    *($1) = $2;
    div bx;
    lds si, ptr [bp + 0xa];
    $1 += $2;
    // Compare $1 with $2
    jb 0xbbf9;
    $1 -= $2;
    $1++;
    *($1) = $2;
    lds si, ptr [bp + 0xe];
    add word ptr [si], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x14];
    les di, ptr [bp + 6];
    mov word ptr [bp - 6], 0;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    mov word ptr [bp - 8], 1;
    // Compare $1 with $2
    jge 0xbc43;
    xchg bx, ax;
    mov word ptr [bp - 8], 0;
    *($1) = $2;
    div bx;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1--;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    $1 = $2;
    and bx, 1;
    $1 += $2;
    *($1) = $2;
    cmp word ptr [bp - 8], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rol al, cl;
    and al, 0x80;
    $1 = $2;
    ror al, cl;
    or dl, al;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    $1 = 0;
    $1 = 0;
    $1 = $2;
    $1++;
    $1 += $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0xbcec;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jb 0xbcfe;
    push($1);
    shr cx, 1;
    shr cx, 1;
    shr cx, 1;
    $1 += $2;
    $1 = pop();
    and cx, 7;
    $1 = $2;
    $1--;
    if (!ZF) goto $1;
    or dx, dx;
    if (ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    and al, 0x80;
    rol ah, 1;
    $1++;
    cmp word ptr [bp - 4], 8;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 0;
    $1++;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 += $2;
    // Compare $1 with $2
    jb 0xbd4a;
    $1 -= $2;
    $1++;
    push($1);
    push($1);
    $1 = $2;
    ror al, cl;
    or dl, al;
    $1 = pop();
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    $1 = 0;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    loop 0xbd4a;
    goto $1;
    or dx, dx;
    if (ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    $1++;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    cmp word ptr [bp - 8], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl cl, 1;
    rol al, cl;
    and al, 0xc0;
    $1 = $2;
    ror al, cl;
    or dl, al;
    $1++;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    $1 = 0;
    $1 = 0;
    $1 = $2;
    $1++;
    $1 += $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0xbde9;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jb 0xbdf9;
    push($1);
    shr cx, 1;
    shr cx, 1;
    $1 += $2;
    $1 = pop();
    and cx, 3;
    $1 = $2;
    $1--;
    if (!ZF) goto $1;
    or dx, dx;
    if (ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    and al, 0xc0;
    rol ah, 1;
    rol ah, 1;
    $1++;
    cmp word ptr [bp - 4], 4;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 0;
    $1++;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 += $2;
    // Compare $1 with $2
    jb 0xbe4d;
    $1 -= $2;
    $1++;
    push($1);
    push($1);
    $1 = $2;
    ror al, cl;
    or dl, al;
    $1 = pop();
    $1++;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    $1 = 0;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    loop 0xbe4d;
    goto $1;
    or dx, dx;
    if (ZF) goto $1;
    mov byte ptr es:[di], dl;
    $1++;
    mov word ptr [bp - 2], 0;
    goto $1;
    cmp word ptr [bp - 8], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    movsb byte ptr es:[di], byte ptr [si];
    $1 += $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0xbe9a;
    $1 -= $2;
    $1++;
    loop 0xbe8a;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    stosb byte ptr es:[di], al;
    // Compare $1 with $2
    jl 0xbeba;
    push($1);
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    $1 = pop();
    $1 -= $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0xbecc;
    $1 -= $2;
    // Compare $1 with $2
    jl 0xbecc;
    stosb byte ptr es:[di], al;
    $1--;
    loop 0xbea9;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x5ab0], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 = $2;
    mul word ptr [0x5aae];
    $1 += $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    $1 += $2;
    adc dx, 0xc;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    and ah, 0x7f;
    $1 = 0;
    $1 = $2;
    mul bx;
    $1 = $2;
    div bx;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf3;
    or al, 4;
    out dx, al;
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    mov word ptr [bp - 2], 0;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shl ah, 1;
    shl ah, 1;
    shl ah, 1;
    or al, ah;
    or al, 0x40;
    $1 = $2;
    out dx, al;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    and bl, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    and bl, 2;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    $1 = $2;
    in al, dx;
    and al, 0xdf;
    or bl, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    and bh, 0xc;
    $1 = $2;
    shr bl, 1;
    shr bl, 1;
    or al, bh;
    or al, bl;
    out dx, al;
    $1 = pop();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    cli ;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    and ah, 0xe1;
    shl ch, 1;
    or ah, ch;
    $1--;
    $1 = $2;
    out dx, ax;
    sti ;
    $1 = pop();
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    and ah, 0xf;
    $1 = $2;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    or al, ah;
    $1 = $2;
    out dx, al;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    and al, 0xf;
    xor al, 2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    or al, ah;
    out dx, al;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    mul bl;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = 0;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    goto $1;
    mov word ptr [bp - 2], 0xffde;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    $1();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    cmp byte ptr [0x55f2], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0xc16f;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0xc182;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    cmp byte ptr es:[di], 9;
    if (ZF) goto $1;
    lcall 0x98e, 0x18a;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff9;
    goto $1;
    lds si, ptr [bp + 0x14];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0xc1cf;
    neg ax;
    add word ptr [bp + 0x12], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jb 0xc1dd;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0xc1ec;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jb 0xc1fa;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0x12], ax;
    jbe 0xc20a;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0xc21b;
    $1 = $2;
    *($1) = $2;
    mul word ptr [bp - 0xe];
    *($1) = $2;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    or ax, ax;
    jge 0xc245;
    neg ax;
    add word ptr [bp + 0x10], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jb 0xc253;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0xc262;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jb 0xc270;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0x10], ax;
    jbe 0xc280;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0xc291;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    mul bx;
    *($1) = $2;
    mov word ptr [bp - 0x2a], 0xffff;
    mov word ptr [bp - 0x2c], 0;
    cmp byte ptr [bp - 0xe], 8;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    mul word ptr [bp - 0xe];
    $1 = $2;
    and cx, 7;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    shr dl, cl;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    and cx, 7;
    $1 = $2;
    shr dh, cl;
    not dh;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xc2f5;
    $1 = $2;
    *($1) = $2;
    or dh, dh;
    if (ZF) goto $1;
    and byte ptr [bp - 0x2a], dh;
    mov byte ptr [bp - 0x29], 0;
    $1 = $2;
    $1 -= $2;
    mul word ptr [bp - 0xe];
    and ax, 7;
    *($1) = $2;
    mov word ptr [bp - 0x30], 1;
    $1 = $2;
    mul word ptr [bp - 0xe];
    and ax, 7;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0xe];
    and ax, 7;
    // Compare $1 with $2
    jle 0xc324;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    div bx;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    mov byte ptr [bp - 0x29], 0;
    mov word ptr [bp - 0x34], 0;
    // Compare $1 with $2
    jbe 0xc349;
    $1++;
    $1 = $2;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    cmp byte ptr [bp - 0x29], 0;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    neg ax;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    *($1) = $2;
    cld ;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x639;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x6ce;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov byte ptr [0x55f2], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    and al, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc49d;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    not bl;
    and byte ptr es:[di], bl;
    or byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0xc4e7;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc4da;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc4ff;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc52d;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and al, bh;
    not bh;
    and byte ptr es:[di], bh;
    or byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc559;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0xc571;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc571;
    *($1) = $2;
    goto $1;
    xor byte ptr [bp - 6], 1;
    if (ZF) goto $1;
    $1 += $2;
    goto $1;
    $1 -= $2;
    $1 -= $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 0x26], 0x10f;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0x10], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 0x26], 0x801;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    lds si, ptr [bp - 0xa];
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc62f;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0xc677;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc66a;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc68f;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or ah, ah;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc6c3;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc6e8;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0xc700;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc700;
    *($1) = $2;
    goto $1;
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 -= $2;
    shl dl, 1;
    // Compare $1 with $2
    jae 0xc719;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xc79d;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc798;
    *($1) = $2;
    goto $1;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0xc781;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc7bf;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0xc7d7;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc7d7;
    *($1) = $2;
    goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    $1 = 0;
    and al, 3;
    *($1) = $2;
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc846;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    not bl;
    and byte ptr es:[di], bl;
    or byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0xc890;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc883;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc8a8;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc8d6;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and al, bh;
    not bh;
    and byte ptr es:[di], bh;
    or byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc902;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0xc91a;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc91a;
    *($1) = $2;
    goto $1;
    $1 -= $2;
    $1++;
    cmp byte ptr [bp - 6], 4;
    jb 0xc930;
    $1 -= $2;
    mov byte ptr [bp - 6], 0;
    goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    ja 0xc9af;
    // Compare $1 with $2
    ja 0xc9af;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc99d;
    *($1) = $2;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    movsb byte ptr es:[di], byte ptr [si];
    loop 0xc986;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc9d6;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0xc9ee;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xc9ee;
    *($1) = $2;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1 += $2;
    jae 0xca13;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    goto $1;
    mov word ptr [bp - 2], 0;
    push($1);
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 0;
    mov word ptr es:[di + 2], 0;
    mov byte ptr [bp - 4], 1;
    mov byte ptr [bp - 6], 1;
    mov byte ptr [bp - 8], 1;
    mov byte ptr [bp - 0xa], 1;
    cmp byte ptr [bp - 4], 1;
    if (!ZF) goto $1;
    push($1);
    $1();
    cmp byte ptr [bp - 6], 1;
    if (!ZF) goto $1;
    push($1);
    $1();
    cmp byte ptr [bp - 8], 1;
    if (!ZF) goto $1;
    push($1);
    $1();
    cmp byte ptr [bp - 0xa], 1;
    if (!ZF) goto $1;
    push($1);
    $1();
    push($1);
    $1();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    $1 = 0;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    or bl, bl;
    if (!ZF) goto $1;
    mov byte ptr es:[di], 0;
    mov byte ptr es:[di + 1], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 1;
    mov byte ptr es:[di + 1], 1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 2;
    mov byte ptr es:[di + 1], 2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 3;
    mov byte ptr es:[di + 1], 3;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 3;
    mov byte ptr es:[di + 1], 1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 5;
    mov byte ptr es:[di + 1], 4;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 5;
    mov byte ptr es:[di + 1], 5;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 4;
    mov byte ptr es:[di + 1], 3;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 4;
    mov byte ptr es:[di + 1], 4;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 4;
    mov byte ptr es:[di + 1], 5;
    $1--;
    if (ZF) goto $1;
    $1 = $2;
    $1 += $2;
    goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 8], 0;
    mov byte ptr [bp - 0xa], 0;
    push($1);
    cmp byte ptr es:[di], 1;
    if (ZF) goto $1;
    $1 += $2;
    cmp byte ptr es:[di], 1;
    if (!ZF) goto $1;
    mov byte ptr [bp - 0xa], 1;
    mov word ptr es:[di], 0;
    $1 = pop();
    retf ;
    $1 = $2;
    push($1);
    $1 = $2;
    int 0x10;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    ja 0xcb97;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    ja 0xcb9f;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    ja 0xcba7;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    ja 0xcbaf;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    ja 0xcbb7;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    mov byte ptr [bp - 8], 0;
    goto $1;
    mov byte ptr [bp - 0xa], 0;
    retf ;
    $1 = $2;
    push($1);
    $1();
    jb 0xcbe0;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    retf ;
    $1 = $2;
    push($1);
    $1();
    jb 0xcc22;
    $1 = $2;
    in al, dx;
    and al, 0x80;
    $1 = $2;
    $1 = $2;
    in al, dx;
    and al, 0x80;
    // Compare $1 with $2
    loope 0xcbf5;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    in al, dx;
    $1 = $2;
    and dl, 0x70;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    retf ;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    loop 0xcc30;
    in al, dx;
    xchg al, ah;
    out dx, al;
    // Compare $1 with $2
    if (ZF) goto $1;
    stc ;
    goto $1;
    clc ;
    retf ;
    cmp byte ptr es:[di + 2], 0;
    if (ZF) goto $1;
    cmp byte ptr es:[di], 4;
    jge 0xcc79;
    cmp byte ptr es:[di + 2], 4;
    jge 0xcc79;
    lcall 0x98e, 0x18a;
    and al, 7;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp byte ptr es:[di + 1], 1;
    if (!ZF) goto $1;
    goto $1;
    cmp byte ptr es:[di + 1], 1;
    if (ZF) goto $1;
    $1 = $2;
    xchg word ptr es:[di + 2], ax;
    mov word ptr es:[di], ax;
    retf ;
    cmp byte ptr es:[di], 0;
    if (!ZF) goto $1;
    mov word ptr es:[di], ax;
    goto $1;
    mov word ptr es:[di + 2], ax;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xc];
    cmp word ptr es:[di], 0xca00;
    if (ZF) goto $1;
    $1 = 0;
    $1 = $2;
    goto $1;
    cmp word ptr es:[di + 0x16], 3;
    jbe 0xccba;
    $1 = 0;
    $1 = $2;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 0xa], ax;
    ja 0xcccc;
    $1 = $2;
    cmp word ptr [bp + 8], ax;
    jbe 0xccd4;
    $1 = 0;
    $1 = $2;
    goto $1;
    $1 = 0;
    $1 = $2;
    mul word ptr [bp + 0xa];
    $1 = $2;
    shr ax, cl;
    push($1);
    $1 = 0;
    $1 = $2;
    mul word ptr es:[di + 0x14];
    mul word ptr [bp + 8];
    $1 = pop();
    $1 += $2;
    adc dx, 0;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr es:[di + 0x16], 0;
    if (!ZF) goto $1;
    $1 = $2;
    div bx;
    xchg dx, ax;
    $1 += $2;
    $1 += $2;
    jae 0xcd16;
    $1 += $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    shl ax, 1;
    rcl dx, 1;
    shl ax, 1;
    rcl dx, 1;
    mov word ptr es:[di + 0x26], dx;
    shr ax, 1;
    shr ax, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    ja 0xcd45;
    $1 = 0;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    jbe 0xcd4f;
    $1 = $2;
    cmp word ptr es:[di + 0x16], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1++;
    $1 = $2;
    int 0x67;
    or ah, ah;
    loope 0xcd56;
    if (ZF) goto $1;
    $1 = 0;
    $1 = $2;
    goto $1;
    cmp word ptr es:[di + 0x16], 3;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1++;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ah, ah;
    $1 = pop();
    loope 0xcd80;
    if (ZF) goto $1;
    $1 = 0;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1++;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ah, ah;
    $1 = pop();
    loope 0xcdac;
    if (ZF) goto $1;
    $1 = 0;
    mov word ptr [bp - 2], 0xffe2;
    goto $1;
    $1 = $2;
    mul word ptr es:[di + 0x28];
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    jae 0xce0d;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr [bp - 0xa], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    goto $1;
    add word ptr [bp - 8], 0x1000;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mul bx;
    cmp word ptr [bp - 0xa], 0;
    if (!ZF) goto $1;
    $1 -= $2;
    goto $1;
    sub word ptr [bp - 6], ax;
    $1 = $2;
    $1 -= $2;
    ja 0xce5e;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1--;
    // Compare $1 with $2
    jbe 0xce6d;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    $1++;
    push($1);
    $1 = $2;
    int 0x67;
    or ah, ah;
    $1 = pop();
    loope 0xce6d;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mul bx;
    cmp word ptr [bp - 0xa], 0;
    if (!ZF) goto $1;
    $1 -= $2;
    goto $1;
    sub word ptr [bp - 6], ax;
    $1 = $2;
    $1 -= $2;
    ja 0xceba;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1--;
    // Compare $1 with $2
    jbe 0xcec9;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    $1++;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ah, ah;
    $1 = pop();
    $1 = pop();
    loope 0xcec9;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mul bx;
    cmp word ptr [bp - 0xa], 0;
    if (!ZF) goto $1;
    $1 -= $2;
    goto $1;
    sub word ptr [bp - 6], ax;
    $1 = $2;
    $1 -= $2;
    ja 0xcf1a;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1--;
    // Compare $1 with $2
    jbe 0xcf29;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    $1++;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ah, ah;
    $1 = pop();
    $1 = pop();
    loope 0xcf29;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    stc ;
    goto $1;
    clc ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0xcf87;
    $1 = $2;
    cdq ;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    test ax, 1;
    if (ZF) goto $1;
    $1++;
    $1 = 0;
    $1 = $2;
    mul bx;
    $1 = $2;
    mul bx;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    lcall 0x79e, 0xa7;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    int 0x67;
    or ah, ah;
    if (!ZF) goto $1;
    $1 = $2;
    mul bx;
    goto $1;
    $1 = $2;
    cdq ;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    lcall 0xb95, 0x179;
    or ah, ah;
    if (!ZF) goto $1;
    $1 = $2;
    mul bx;
    goto $1;
    $1 = $2;
    cdq ;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    lcall 0x620, 0x219;
    or ah, ah;
    if (!ZF) goto $1;
    $1 = $2;
    mul bx;
    goto $1;
    $1 = $2;
    cdq ;
    goto $1;
    $1 = $2;
    cdq ;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0x16], 0;
    mov word ptr [bp - 0x20], 0;
    lds si, ptr [bp + 0x18];
    les di, ptr [bp + 0xc];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0xd0a4;
    neg ax;
    add word ptr [bp + 0xa], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jbe 0xd0b1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0xd0c0;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jbe 0xd0cb;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 0xa], ax;
    jbe 0xd0dc;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0xd0ed;
    $1 = $2;
    mul word ptr [bp - 4];
    *($1) = $2;
    $1 = $2;
    div bx;
    $1 = 0;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    $1++;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x28], 1;
    $1--;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    or ax, ax;
    jge 0xd123;
    neg ax;
    add word ptr [bp + 8], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jbe 0xd130;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    or ax, ax;
    jge 0xd13f;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    jbe 0xd14a;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [bp + 8], ax;
    jbe 0xd15b;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0xd16c;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = pop();
    push($1);
    $1 = pop();
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    lea di, [bp - 0xb2];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1);
    push($1);
    rep movsw word ptr es:[di], word ptr [si];
    $1 = pop();
    $1 = pop();
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    *($1) = $2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2;
    mov word ptr [bp - 0x22], 0xff;
    mov word ptr [bp - 0x24], 0;
    cmp byte ptr [bp - 4], 8;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    mul word ptr [bp - 4];
    push($1);
    and ax, 7;
    $1 = $2;
    $1 = $2;
    shr al, cl;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = pop();
    $1 += $2;
    and ax, 7;
    $1 = $2;
    $1 = $2;
    shr ah, cl;
    not ah;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xd21d;
    $1 = $2;
    *($1) = $2;
    or ah, ah;
    if (ZF) goto $1;
    and byte ptr [bp - 0x22], ah;
    mov byte ptr [bp - 0x21], 0;
    $1 = $2;
    $1 -= $2;
    mul word ptr [bp - 4];
    and ax, 7;
    *($1) = $2;
    mov word ptr [bp - 0x28], 1;
    $1 = $2;
    mul word ptr [bp - 4];
    and ax, 7;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 4];
    and ax, 7;
    // Compare $1 with $2
    jle 0xd24c;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    div bx;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    mov byte ptr [bp - 0x21], 0;
    mov word ptr [bp - 0x2c], 0;
    // Compare $1 with $2
    jbe 0xd271;
    $1++;
    $1 = $2;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    cmp byte ptr [bp - 0x21], 0;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 0x2e], 0x34a;
    mov word ptr [bp - 0x30], 0x3bc;
    mov word ptr [bp - 0x32], 0x45f;
    goto $1;
    mov word ptr [bp - 0x2e], 0x337;
    mov word ptr [bp - 0x30], 0x3ad;
    mov word ptr [bp - 0x32], 0x44e;
    goto $1;
    mov word ptr [bp - 0x2e], 0x33c;
    mov word ptr [bp - 0x30], 0x3b2;
    mov word ptr [bp - 0x32], 0x453;
    goto $1;
    mov word ptr [bp - 0x2e], 0x345;
    mov word ptr [bp - 0x30], 0x3b7;
    mov word ptr [bp - 0x32], 0x45a;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    cmp byte ptr [bp - 0x28], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xd368;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    not bl;
    or al, bl;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    not bl;
    and byte ptr es:[di], bl;
    or byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 6], 0;
    if (!ZF) goto $1;
    or cl, cl;
    if (!ZF) goto $1;
    // Compare $1 with $2
    ja 0xd3b1;
    // Compare $1 with $2
    jbe 0xd405;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0xd3ca;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xd3e3;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    mov byte ptr es:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0xd41e;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xd437;
    *($1) = $2;
    goto $1;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0xd461;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0x2c], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xd480;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    not dx;
    and al, bh;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    or al, dh;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0xd4c3;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xd4db;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0xd4eb;
    cmp word ptr [bp - 0x16], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0xd4fe;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0xd4fe;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0xd50e;
    cmp word ptr [bp - 0x20], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0xd521;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0xd521;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp + 0x18];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xc];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x16;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x2f;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffdc;
    goto $1;
    $1 = $2;
    int 0x2f;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    lcall [0x5ab2];
    // Compare $1 with $2
    jae 0xd590;
    mov word ptr [bp - 2], 0xffdc;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    cmp byte ptr [0x54e2], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffdc;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x54e2], 1;
    if (!ZF) goto $1;
    goto $1;
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffdc;
    goto $1;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 += $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr [si], 0xffff;
    mov word ptr [si + 2], 0xffff;
    mov word ptr [si + 4], 0xffff;
    mov word ptr [si + 6], 0;
    $1 += $2;
    loop 0xd63e;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 2], 0;
    mov byte ptr [0x54e2], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    cmp byte ptr [0x54e2], 0;
    if (ZF) goto $1;
    cmp word ptr [0x5ab6], 0;
    if (!ZF) goto $1;
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe7;
    goto $1;
    mov byte ptr [0x54e2], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    mov byte ptr [bp + 7], 0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    cmp byte ptr [0x54e2], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffdc;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xffdb;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    mov word ptr [bp - 0xa], 0xffff;
    cmp word ptr es:[di], dx;
    if (!ZF) goto $1;
    cmp word ptr es:[di + 2], bx;
    if (!ZF) goto $1;
    cmp word ptr es:[di + 4], cx;
    jle 0xd76b;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0xd749;
    $1 = $2;
    cmp ax, -1;
    if (ZF) goto $1;
    cmp byte ptr [bp + 6], al;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mul bl;
    $1 += $2;
    cmp word ptr es:[di + 4], -1;
    if (ZF) goto $1;
    $1 = $2;
    cmp word ptr es:[di + 4], cx;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr es:[di + 4], cx;
    mov word ptr es:[di + 6], 1;
    goto $1;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp + 6];
    $1 += $2;
    cmp word ptr es:[di], -1;
    if (ZF) goto $1;
    cmp word ptr es:[di + 6], 0;
    if (ZF) goto $1;
    mov word ptr [si + 4], 0;
    $1 = $2;
    mul word ptr [si];
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mul word ptr [si];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    mov word ptr es:[di], dx;
    $1 = $2;
    mov word ptr es:[di + 2], bx;
    $1 = $2;
    mov word ptr es:[di + 4], cx;
    mov word ptr es:[di + 6], cx;
    cmp byte ptr [bp - 0xa], 0xff;
    if (!ZF) goto $1;
    *($1) = $2;
    $1 = $2;
    mul word ptr [si];
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0xa], 0;
    $1 = $2;
    mul word ptr [si];
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul cx;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp - 0xa];
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp - 0xa], 0xffff;
    if (ZF) goto $1;
    cmp word ptr es:[di + 4], 0;
    if (ZF) goto $1;
    cmp word ptr es:[di + 4], cx;
    if (!ZF) goto $1;
    mov word ptr es:[di], 0xffff;
    mov word ptr es:[di + 2], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 4], 0xffff;
    mov word ptr es:[di + 6], 0;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffdb;
    goto $1;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    cmp byte ptr [0x54e2], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    lcall [0x5ab2];
    $1 = $2;
    shr ax, cl;
    shr dx, cl;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    shr dx, cl;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffdb;
    goto $1;
    $1 = $2;
    $1 = $2;
    shl dx, cl;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffda;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si], dx;
    if (!ZF) goto $1;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    $1 += $2;
    loop 0xd93e;
    $1 = $2;
    $1 = $2;
    lcall [0x5ab2];
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xffdb;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x6d35], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or bx, word ptr [si + 0x32];
    if (ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 0xc], ax;
    add word ptr [bp + 0xa], bx;
    add word ptr [bp + 8], ax;
    add word ptr [bp + 6], bx;
    cmp word ptr [si + 0x18], 1;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xc6c, 0x220;
    jae 0xda00;
    mov word ptr [bp - 2], 0;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    jns 0xda25;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xa], ax;
    *($1) = $2;
    $1++;
    *($1) = $2;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0xda47;
    // Compare $1 with $2
    jbe 0xda4e;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    mul dx;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    ljmp [si + 0xa];
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    mov word ptr [bx + 0xa], 0x275;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x335;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x61a;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x3e9;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    $1 = $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov byte ptr [0x6d35], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1++;
    // Compare $1 with $2
    jle 0xdbae;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0x55;
    mov byte ptr [0x5af0], 0xaa;
    mov byte ptr [0x5af1], 0xff;
    $1 = $2;
    mov word ptr [bp - 4], 0xe050;
    $1 = $2;
    $1 -= $2;
    jns 0xdc14;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 3;
    xor cl, 3;
    shl cl, 1;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    and al, 3;
    xlatb ;
    $1 = $2;
    test si, di;
    if (ZF) goto $1;
    xchg word ptr [bp - 4], si;
    push($1);
    push($1);
    push($1);
    or dh, dh;
    js 0xdc78;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    $1 = $2;
    and ah, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], ah;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1 += $2;
    xchg word ptr [bp - 4], si;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0xff;
    $1 = $2;
    mov word ptr [bp - 4], 0xe050;
    $1 = $2;
    $1 -= $2;
    jns 0xdcca;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    and al, 1;
    xlatb ;
    $1 = $2;
    test si, di;
    if (ZF) goto $1;
    xchg word ptr [bp - 4], si;
    push($1);
    push($1);
    push($1);
    or dh, dh;
    js 0xdd2c;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    $1 = $2;
    and ah, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], ah;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1 += $2;
    xchg word ptr [bp - 4], si;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0xff;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0x805a;
    $1 = $2;
    $1 -= $2;
    jns 0xdd87;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    and al, 1;
    xlatb ;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    or dh, dh;
    js 0xdde5;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    $1 = $2;
    and ah, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], ah;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 += $2;
    jns 0xddfd;
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 -= $2;
    jns 0xde62;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    not dh;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = pop();
    $1 = $2;
    push($1);
    push($1);
    or bh, bh;
    js 0xdeb1;
    or cx, cx;
    if (!ZF) goto $1;
    and bl, bh;
    goto $1;
    $1 = $2;
    out dx, ax;
    movsb byte ptr es:[di], byte ptr [si];
    $1--;
    $1 = $2;
    out dx, ax;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    out dx, ax;
    movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1 += $2;
    $1 = $2;
    goto $1;
    $1 = 0;
    out dx, ax;
    $1++;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    mov byte ptr [0x5aee], 0;
    mov byte ptr [0x5aef], 0xff;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jns 0xdf06;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    and al, 1;
    xlatb ;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    or dh, dh;
    js 0xdf60;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    $1 = $2;
    and ah, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], ah;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jns 0xdfa0;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = pop();
    $1++;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    push($1);
    rep stosb byte ptr es:[di], al;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jns 0xdffd;
    neg cx;
    $1 = $2;
    xchg word ptr [bp + 0xc], bx;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = pop();
    $1++;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    push($1);
    // Compare $1 with $2
    jb 0xe03f;
    mov byte ptr es:[di], dl;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0xe027;
    goto $1;
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1 += $2;
    jae 0xe020;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    goto $1;
    push($1);
    lcall 0xa36, 0x1a5;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xe0af;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0xe0c5;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bx;
    $1 = $2;
    $1 = $2;
    shr ch, cl;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = pop();
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bx;
    $1 += $2;
    and dl, 7;
    $1 = $2;
    xor cl, 7;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    $1 = 0;
    or word ptr [bp - 0x24], cx;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xe146;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0xe15c;
    $1 = $2;
    $1 = $2;
    mul bx;
    *($1) = $2;
    $1 = $2;
    mov byte ptr [bp - 0x28], 0;
    mov byte ptr [bp - 0x27], 0x55;
    mov byte ptr [bp - 0x26], 0xaa;
    mov byte ptr [bp - 0x25], 0xff;
    cmp word ptr [bp - 0x1a], 1;
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 0x13], 1;
    if (!ZF) goto $1;
    test ax, 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    cmp byte ptr es:[di + 0x13], 2;
    if (!ZF) goto $1;
    and ax, 3;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    goto $1;
    $1 = 0;
    mov byte ptr [bp + si - 0x28], 0xff;
    rcr ax, 1;
    jb 0xe1b6;
    not byte ptr [bp + si - 0x28];
    $1++;
    // Compare $1 with $2
    jb 0xe1ab;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    $1 -= $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0xe1fc;
    and dh, dl;
    goto $1;
    push($1);
    and al, dl;
    not dl;
    $1 = $2;
    and ah, dl;
    or al, ah;
    stosb byte ptr es:[di], al;
    $1 = pop();
    $1--;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jae 0xe22a;
    goto $1;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    jbe 0xe253;
    stosb byte ptr es:[di], al;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jb 0xe2be;
    loop 0xe232;
    goto $1;
    test cx, 1;
    if (ZF) goto $1;
    stosb byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr cx, 1;
    $1 = $2;
    rep stosw word ptr es:[di], ax;
    and al, dh;
    not dh;
    $1 = $2;
    and ah, dh;
    or al, ah;
    stosb byte ptr es:[di], al;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jb 0xe2be;
    $1++;
    // Compare $1 with $2
    jb 0xe293;
    $1 = 0;
    $1 += $2;
    jae 0xe2af;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jb 0xe2be;
    $1--;
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    jl 0xe3c8;
    // Compare $1 with $2
    jl 0xe3c8;
    // Compare $1 with $2
    jg 0xe3c8;
    // Compare $1 with $2
    jg 0xe3c8;
    clc ;
    goto $1;
    stc ;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    push($1);
    $1();
    *($1) = $2;
    or ah, al;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    and ah, al;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    test al, 0xf;
    if (!ZF) goto $1;
    $1 = $2;
    xchg word ptr [bp + 8], ax;
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], ax;
    *($1) = $2;
    $1 = $2;
    xchg al, ah;
    mov word ptr [bp - 6], 1;
    test al, 1;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    imul bx;
    $1 = $2;
    $1 -= $2;
    idiv bx;
    add word ptr [bp + 0xa], ax;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test al, 2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    imul bx;
    $1 = $2;
    $1 -= $2;
    idiv bx;
    add word ptr [bp + 0xc], ax;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test al, 4;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    imul bx;
    $1 = $2;
    $1 -= $2;
    idiv bx;
    add word ptr [bp + 0xa], ax;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    imul bx;
    $1 = $2;
    $1 -= $2;
    idiv bx;
    add word ptr [bp + 0xc], ax;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 6], 1;
    if (!ZF) goto $1;
    xchg cx, ax;
    xchg dx, bx;
    *($1) = $2;
    clc ;
    cmp word ptr [bp - 4], 0;
    if (ZF) goto $1;
    stc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    push($1);
    $1();
    *($1) = $2;
    or ah, al;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    and ah, al;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    test al, 0xf;
    if (!ZF) goto $1;
    $1 = $2;
    xchg word ptr [bp + 8], ax;
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], ax;
    *($1) = $2;
    $1 = $2;
    xchg al, ah;
    mov word ptr [bp - 6], 1;
    test al, 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test al, 2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test al, 4;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 6], 1;
    if (!ZF) goto $1;
    xchg cx, ax;
    xchg dx, bx;
    *($1) = $2;
    clc ;
    cmp word ptr [bp - 4], 0;
    if (ZF) goto $1;
    stc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0xe59c;
    or al, 1;
    // Compare $1 with $2
    jge 0xe5a3;
    or al, 2;
    // Compare $1 with $2
    jle 0xe5aa;
    or al, 4;
    // Compare $1 with $2
    jle 0xe5b1;
    or al, 8;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0xe5bf;
    or ah, 1;
    // Compare $1 with $2
    jge 0xe5c7;
    or ah, 2;
    // Compare $1 with $2
    jle 0xe5cf;
    or ah, 4;
    // Compare $1 with $2
    jle 0xe5d7;
    or ah, 8;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    jae 0xe5fa;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    push($1);
    les di, ptr [bp + 0xe];
    push($1);
    les di, ptr [bp + 0xa];
    push($1);
    les di, ptr [bp + 6];
    push($1);
    push($1);
    $1();
    jae 0xe640;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    les di, ptr [bp + 0x12];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    mov word ptr es:[di], bx;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    push($1);
    les di, ptr [bp + 0xe];
    push($1);
    les di, ptr [bp + 0xa];
    push($1);
    les di, ptr [bp + 6];
    push($1);
    push($1);
    $1();
    jae 0xe69e;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    les di, ptr [bp + 0x12];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    mov word ptr es:[di], bx;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0xe71a;
    xchg word ptr [bp + 0xe], ax;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0xe728;
    xchg word ptr [bp + 0x10], ax;
    *($1) = $2;
    mov word ptr [bp - 0x36], 0;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    shr ax, 1;
    *($1) = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    shr ax, 1;
    *($1) = $2;
    $1 += $2;
    *($1) = $2;
    mov word ptr [bp - 0x2c], 0;
    $1 = $2;
    // Compare $1 with $2
    jge 0xe774;
    *($1) = $2;
    mov word ptr [bp + 6], 0x168;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [bp - 0x20], ax;
    add word ptr [bp - 0x22], bx;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xe7a9;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    lcall 0xc6c, 0x3e;
    *($1) = $2;
    mov word ptr [bp - 0x2e], 0x169;
    mov word ptr [bp - 0x30], 0xffff;
    $1 = $2;
    mul ax;
    *($1) = $2;
    *($1) = $2;
    shl ax, 1;
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    mul ax;
    *($1) = $2;
    *($1) = $2;
    shl ax, 1;
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    jae 0xe805;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    $1 += $2;
    adc dx, word ptr [bp - 0x14];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    sub word ptr [bp - 6], ax;
    sbb word ptr [bp - 4], dx;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0xc];
    jns 0xe88f;
    push($1);
    $1();
    cmp word ptr [bp - 4], 0;
    js 0xe86e;
    $1--;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    sub word ptr [bp - 6], ax;
    sbb word ptr [bp - 4], dx;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    adc dx, word ptr [bp - 0x14];
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0x14];
    $1 = $2;
    $1 = $2;
    sar dx, 1;
    rcr ax, 1;
    $1 += $2;
    adc dx, cx;
    $1 -= $2;
    sbb dx, word ptr [bp - 8];
    $1 -= $2;
    sbb dx, word ptr [bp - 0xc];
    sar dx, 1;
    rcr ax, 1;
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    $1 = pop();
    $1 = pop();
    push($1);
    $1();
    cmp word ptr [bp - 4], 0;
    jns 0xe8e4;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0xc];
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    $1--;
    jns 0xe8c1;
    cmp word ptr [bp - 0x2c], 0;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0x36], 1;
    mov word ptr [bp + 8], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0x2c], 0;
    goto $1;
    cmp word ptr [bp - 0x36], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [0x5af2], ax;
    add word ptr [0x5af4], bx;
    add word ptr [0x5af6], ax;
    add word ptr [0x5af8], bx;
    $1 = 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    push($1);
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    or cx, cx;
    if (!ZF) goto $1;
    goto $1;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xea2d;
    // Compare $1 with $2
    jg 0xea2d;
    // Compare $1 with $2
    jge 0xe9ff;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xea0f;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xea2d;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    neg bx;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xea7f;
    // Compare $1 with $2
    jg 0xea7f;
    // Compare $1 with $2
    jg 0xea51;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jle 0xea61;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xea7f;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    neg cx;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xead9;
    // Compare $1 with $2
    jg 0xead9;
    // Compare $1 with $2
    jg 0xeaab;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jle 0xeabb;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xead9;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    neg bx;
    neg cx;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xeb2d;
    // Compare $1 with $2
    jg 0xeb2d;
    // Compare $1 with $2
    jge 0xeaff;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xeb0f;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xeb2d;
    push($1);
    push($1);
    push($1);
    lcall [si];
    goto $1;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xeb70;
    // Compare $1 with $2
    jg 0xeb70;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xeb70;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    neg cx;
    push($1);
    $1();
    // Compare $1 with $2
    jge 0xeb8a;
    goto $1;
    // Compare $1 with $2
    jle 0xeb92;
    goto $1;
    // Compare $1 with $2
    jge 0xeba2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xebb2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jae 0xebca;
    goto $1;
    push($1);
    push($1);
    push($1);
    lcall [si];
    goto $1;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xec1e;
    // Compare $1 with $2
    jg 0xec1e;
    // Compare $1 with $2
    jg 0xebf2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xec02;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xec1e;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    or bx, bx;
    if (ZF) goto $1;
    neg bx;
    push($1);
    $1();
    // Compare $1 with $2
    jl 0xec72;
    // Compare $1 with $2
    jg 0xec72;
    // Compare $1 with $2
    jg 0xec46;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    // Compare $1 with $2
    jl 0xec56;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xec72;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    $1 -= $2;
    test word ptr [si + 0x3c], 1;
    if (ZF) goto $1;
    push($1);
    lcall 0x1214, 0x307;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 -= $2;
    test word ptr [si + 0x3c], 1;
    if (ZF) goto $1;
    push($1);
    lcall 0x1214, 0x346;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 -= $2;
    test word ptr [si + 0x3c], 1;
    if (ZF) goto $1;
    push($1);
    lcall 0x1214, 0x307;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 -= $2;
    test word ptr [si + 0x3c], 1;
    if (ZF) goto $1;
    push($1);
    lcall 0x1214, 0x346;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    mul cx;
    or dx, dx;
    if (ZF) goto $1;
    $1 = pop();
    stc ;
    goto $1;
    xchg cx, ax;
    $1 = pop();
    mul dx;
    $1 += $2;
    retf ;
    push($1);
    push($1);
    push($1);
    push($1);
    neg cx;
    // Compare $1 with $2
    jl 0xed26;
    // Compare $1 with $2
    jl 0xed2b;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    push($1);
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    jge 0xed7c;
    neg ax;
    goto $1;
    $1 = $2;
    $1 = 0;
    xor cx, bx;
    jge 0xed49;
    $1--;
    push($1);
    // Compare $1 with $2
    jge 0xed51;
    neg ax;
    // Compare $1 with $2
    jge 0xed58;
    neg bx;
    $1 = $2;
    mul dx;
    div bx;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xed6d;
    $1++;
    $1++;
    loop 0xed65;
    $1 = $2;
    $1 -= $2;
    shr ax, 1;
    $1 = pop();
    // Compare $1 with $2
    jge 0xed7c;
    neg ax;
    $1 = pop();
    $1 += $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    shr ax, 1;
    shr ax, 1;
    $1 -= $2;
    jge 0xedbb;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    *($1) = $2;
    mov word ptr [bp - 0x14], 0;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0xee06;
    xchg word ptr [bp + 0x10], ax;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0xee14;
    xchg word ptr [bp + 0x12], ax;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    add word ptr [bp + 0x12], ax;
    add word ptr [bp + 0xe], ax;
    $1 = $2;
    *($1) = $2;
    add word ptr [bp + 0x10], ax;
    add word ptr [bp + 0xc], ax;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    $1 -= $2;
    $1++;
    shr ax, 1;
    *($1) = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    shr ax, 1;
    *($1) = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jg 0xee83;
    $1 += $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1);
    $1();
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = 0;
    lcall 0x7ff, 0x50;
    $1 += $2;
    *($1) = $2;
    stosw word ptr es:[di], ax;
    $1 = pop();
    $1();
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = 0;
    lcall 0x7ff, 0x50;
    $1 += $2;
    *($1) = $2;
    stosw word ptr es:[di], ax;
    $1++;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    // Compare $1 with $2
    jg 0xef41;
    $1 = $2;
    // Compare $1 with $2
    jb 0xeefe;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1);
    $1();
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = 0;
    lcall 0x7ff, 0x50;
    $1 += $2;
    stosw word ptr es:[di], ax;
    $1 = pop();
    $1();
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = 0;
    lcall 0x7ff, 0x50;
    $1 += $2;
    stosw word ptr es:[di], ax;
    $1++;
    goto $1;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    lcall 0x7ff, 0x32;
    push($1);
    $1();
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = 0;
    lcall 0x7ff, 0x50;
    $1 += $2;
    *($1) = $2;
    stosw word ptr es:[di], ax;
    $1 = pop();
    $1();
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 = 0;
    lcall 0x7ff, 0x50;
    $1 += $2;
    *($1) = $2;
    stosw word ptr es:[di], ax;
    $1++;
    test word ptr [bp + 6], 0x8000;
    if (!ZF) goto $1;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1++;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1++;
    $1 = $2;
    shl bx, 1;
    shl bx, 1;
    sub word ptr [0x54bf], bx;
    add word ptr [0x54c1], bx;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    and ax, 0x7fff;
    push($1);
    lcall 0xfe6, 0x5c3;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    // Compare $1 with $2
    jl 0xf004;
    $1 -= $2;
    // Compare $1 with $2
    jle 0xf012;
    $1 = 0;
    $1 -= $2;
    neg ax;
    goto $1;
    // Compare $1 with $2
    jle 0xf02b;
    $1 = $2;
    // Compare $1 with $2
    jle 0xf024;
    $1 -= $2;
    goto $1;
    $1 -= $2;
    neg ax;
    goto $1;
    $1 = 0;
    $1 = $2;
    shl bx, 1;
    $1 = $2;
    or dx, dx;
    if (ZF) goto $1;
    neg ax;
    ret ;
    // Compare $1 with $2
    jl 0xf044;
    $1 -= $2;
    // Compare $1 with $2
    jle 0xf05c;
    $1 = 0;
    // Compare $1 with $2
    jle 0xf057;
    $1 -= $2;
    neg ax;
    goto $1;
    $1 -= $2;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jle 0xf069;
    $1 -= $2;
    neg ax;
    $1 = $2;
    $1 -= $2;
    shl bx, 1;
    $1 = $2;
    or dx, dx;
    if (ZF) goto $1;
    neg ax;
    ret ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [si + 0x3c], 0;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    lcall 0x10b4, 0x84;
    $1 = $2;
    mul bx;
    $1 = $2;
    div bx;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    add word ptr [bp + 0xe], ax;
    add word ptr [bp + 0xc], bx;
    $1 = $2;
    and dx, 2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0xf1c0;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    lcall 0xc6c, 0x3e;
    *($1) = $2;
    $1 = $2;
    mul ax;
    *($1) = $2;
    *($1) = $2;
    shl ax, 1;
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    mul ax;
    *($1) = $2;
    *($1) = $2;
    shl ax, 1;
    rcl dx, 1;
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    jae 0xf212;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    sar dx, 1;
    rcr ax, 1;
    sar dx, 1;
    rcr ax, 1;
    $1 += $2;
    adc dx, word ptr [bp - 0x14];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    sub word ptr [bp - 6], ax;
    sbb word ptr [bp - 4], dx;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0xc];
    jae 0xf2a2;
    push($1);
    $1();
    cmp word ptr [bp - 4], 0;
    js 0xf281;
    $1--;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    sub word ptr [bp - 6], ax;
    sbb word ptr [bp - 4], dx;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    adc dx, word ptr [bp - 0x14];
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0x14];
    $1 = $2;
    $1 = $2;
    sar dx, 1;
    rcr ax, 1;
    $1 += $2;
    adc dx, cx;
    $1 -= $2;
    sbb dx, word ptr [bp - 8];
    $1 -= $2;
    sbb dx, word ptr [bp - 0xc];
    sar dx, 1;
    rcr ax, 1;
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    $1 = pop();
    $1 = pop();
    push($1);
    $1();
    cmp word ptr [bp - 4], 0;
    jns 0xf2f7;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    adc dx, word ptr [bp - 0x1c];
    *($1) = $2;
    *($1) = $2;
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0x18];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [bp - 0xc];
    add word ptr [bp - 6], ax;
    adc word ptr [bp - 4], dx;
    $1--;
    jns 0xf2d4;
    cmp word ptr [bp + 6], 2;
    jge 0xf327;
    goto $1;
    $1 = $2;
    $1++;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    and word ptr [bp + 6], 1;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    test word ptr [bp + 6], 2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, 0x8000;
    push($1);
    lcall 0xcac, 0x6c4;
    $1 = $2;
    test word ptr [bp + 6], 2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    push($1);
    cmp word ptr [bp + 6], 2;
    jge 0xf418;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    cmp word ptr [bx + 0x26], 1;
    if (ZF) goto $1;
    cmp word ptr [bx + 0x22], 0;
    if (ZF) goto $1;
    mov word ptr [bx + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    and cx, 7;
    and bx, 7;
    $1 = $2;
    $1 = $2;
    rol ax, cl;
    $1 = $2;
    *($1) = $2;
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    and cx, 7;
    and bx, 7;
    $1 = $2;
    $1 = $2;
    rol ax, cl;
    $1 = $2;
    *($1) = $2;
    lcall 0xd9f, 0x178;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x24], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xf521;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x24], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xf543;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 -= $2;
    cmp word ptr [bp - 0x24], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xf56d;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    cmp word ptr [bp - 0x24], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xf5d2;
    push($1);
    push($1);
    push($1);
    lcall [si];
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    cmp word ptr [bp - 0x24], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xf5ad;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    cmp word ptr [bp - 0x24], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0xf5d2;
    push($1);
    push($1);
    push($1);
    lcall [si];
    $1 = pop();
    $1 = pop();
    *($1) = $2;
    *($1) = $2;
    retf ;
    push($1);
    $1 = $2;
    mul cx;
    or dx, dx;
    if (ZF) goto $1;
    $1 = pop();
    stc ;
    goto $1;
    xchg cx, ax;
    $1 = pop();
    mul dx;
    $1 += $2;
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    $1 = $2;
    add word ptr [si + 0x12], ax;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    neg ax;
    add word ptr [si + 0x14], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    *($1) = $2;
    $1 = $2;
    push($1);
    *($1) = $2;
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 += $2;
    push($1);
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    neg word ptr [bp + 6];
    $1 += $2;
    push($1);
    *($1) = $2;
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    cmp byte ptr [0x6d33], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    mov byte ptr [bp - 0x4e], 0;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or bx, word ptr [si + 0x32];
    if (ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 0xc], ax;
    add word ptr [bp + 0xa], bx;
    add word ptr [bp + 8], ax;
    add word ptr [bp + 6], bx;
    $1 = $2;
    // Compare $1 with $2
    jle 0xf7f6;
    xchg word ptr [bp + 8], ax;
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], ax;
    *($1) = $2;
    mov byte ptr [bp - 0x4e], 1;
    cmp word ptr [si + 0x18], 1;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xc6c, 0x10c;
    jae 0xf817;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    and cl, 7;
    ror word ptr [bp - 0x2a], cl;
    $1 = pop();
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    shr ax, 1;
    *($1) = $2;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0xf86d;
    // Compare $1 with $2
    jbe 0xf874;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    mul dx;
    $1 += $2;
    cmp word ptr [bp - 0x2c], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x2a], -1;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    ljmp [si + 4];
    nop ;
    nop ;
    goto $1;
    nop ;
    nop ;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    mov word ptr [bx + 4], 0x7b9;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x968;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xff1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xb0f;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    $1 = $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov byte ptr [0x6d33], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x30], 0;
    mov word ptr [si + 0x32], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    or bx, bx;
    jge 0xfa21;
    neg bx;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    jl 0xfa2f;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    neg di;
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1++;
    // Compare $1 with $2
    jle 0xfa39;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    or bx, bx;
    jge 0xfa64;
    neg bx;
    *($1) = $2;
    or ax, ax;
    if (ZF) goto $1;
    jl 0xfa72;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    neg di;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    $1++;
    // Compare $1 with $2
    jle 0xfa7c;
    goto $1;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0xfaa4;
    $1 = $2;
    *($1) = $2;
    cmp word ptr [bp - 0x24], 0;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    ja 0xfac5;
    $1 = $2;
    neg si;
    $1 = 0;
    mov word ptr [bp - 4], 1;
    goto $1;
    $1 = 0;
    $1 = $2;
    neg di;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    $1();
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    $1++;
    // Compare $1 with $2
    jle 0xfad1;
    goto $1;
    $1++;
    // Compare $1 with $2
    jl 0xfad1;
    goto $1;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = 0;
    $1 = $2;
    $1++;
    $1 += $2;
    $1 += $2;
    mov word ptr [bp - 0x10], 0;
    // Compare $1 with $2
    jle 0xfb3c;
    mov word ptr [bp - 0x10], 1;
    $1 -= $2;
    $1 = $2;
    add word ptr [bp - 0x12], ax;
    // Compare $1 with $2
    jle 0xfb4f;
    mov word ptr [bp - 0x10], 1;
    $1 -= $2;
    $1 = $2;
    add word ptr [bp - 0x14], ax;
    cmp word ptr [bp - 0x10], 1;
    if (!ZF) goto $1;
    rol word ptr [bp - 0x2a], 1;
    jae 0xfb97;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0xfb7f;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    $1();
    $1 = pop();
    goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x4e], 1;
    if (!ZF) goto $1;
    $1--;
    rol si, 1;
    jae 0xfc23;
    push($1);
    push($1);
    push($1);
    lcall [bp - 0x4c];
    $1++;
    // Compare $1 with $2
    jle 0xfc19;
    goto $1;
    $1 = $2;
    $1 -= $2;
    jns 0xfc48;
    neg ax;
    $1 = $2;
    xchg word ptr [bp + 8], bx;
    *($1) = $2;
    $1 = $2;
    xchg word ptr [bp + 6], bx;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    jns 0xfc53;
    goto $1;
    // Compare $1 with $2
    jl 0xfca7;
    shl bx, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x4e], 1;
    if (!ZF) goto $1;
    $1--;
    rol word ptr [bp - 0x2a], 1;
    jae 0xfc91;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall [bx];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1++;
    or dx, dx;
    jns 0xfc9e;
    $1 += $2;
    loop 0xfc7f;
    goto $1;
    $1++;
    $1 += $2;
    loop 0xfc7f;
    goto $1;
    shl ax, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x4e], 1;
    if (!ZF) goto $1;
    $1--;
    rol word ptr [bp - 0x2a], 1;
    jae 0xfce1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall [bx];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1++;
    or dx, dx;
    jns 0xfcee;
    $1 += $2;
    loop 0xfccf;
    goto $1;
    $1++;
    $1 += $2;
    loop 0xfccf;
    goto $1;
    neg bx;
    // Compare $1 with $2
    jge 0xfd4b;
    shl bx, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x4e], 1;
    if (!ZF) goto $1;
    $1--;
    rol word ptr [bp - 0x2a], 1;
    jae 0xfd37;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall [bx];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1++;
    or dx, dx;
    jns 0xfd43;
    $1 += $2;
    loop 0xfd25;
    goto $1;
    $1--;
    $1 += $2;
    loop 0xfd25;
    goto $1;
    shl ax, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 0x28], 1;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x4e], 1;
    if (!ZF) goto $1;
    $1--;
    rol word ptr [bp - 0x2a], 1;
    jae 0xfd85;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall [bx];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1--;
    or dx, dx;
    jns 0xfd91;
    $1 += $2;
    loop 0xfd73;
    goto $1;
    $1++;
    $1 += $2;
    loop 0xfd73;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    cmp word ptr [bp - 0x24], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0x55;
    mov byte ptr [0x5c66], 0xaa;
    mov byte ptr [0x5c67], 0xff;
    and byte ptr [bp - 0x26], 3;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    jns 0xfdef;
    neg bx;
    neg si;
    neg di;
    xchg di, si;
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0xfe02;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    shl ax, cl;
    $1 = $2;
    not dh;
    $1 = pop();
    $1++;
    test bx, 0x2000;
    if (ZF) goto $1;
    xchg word ptr [bp - 0xa], si;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0xfe4c;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    lcall 0x885, 0;
    $1 = $2;
    shl ax, cl;
    not ah;
    $1 = pop();
    test si, bx;
    if (ZF) goto $1;
    xchg di, si;
    and byte ptr es:[bx], ah;
    or byte ptr es:[bx], al;
    $1 += $2;
    xchg di, si;
    loop 0xfe64;
    goto $1;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 3;
    xor cl, 3;
    shl cl, 1;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh;
    js 0xfec8;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    and al, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    and ah, dh;
    or ah, dl;
    ror dl, 1;
    ror dl, 1;
    ror dh, 1;
    ror dh, 1;
    jae 0xff04;
    or di, di;
    jns 0xfef5;
    $1 += $2;
    loop 0xfed9;
    mov byte ptr es:[bx], ah;
    goto $1;
    $1 += $2;
    mov byte ptr es:[bx], ah;
    $1 += $2;
    xchg word ptr [bp - 0xa], si;
    loop 0xfed6;
    goto $1;
    mov byte ptr es:[bx], ah;
    $1++;
    or di, di;
    jns 0xff13;
    $1 += $2;
    loop 0xfed6;
    goto $1;
    $1 += $2;
    $1 += $2;
    xchg word ptr [bp - 0xa], si;
    loop 0xfed6;
    goto $1;
    and byte ptr es:[bx], dh;
    or byte ptr es:[bx], dl;
    $1 += $2;
    xchg word ptr [bp - 0xa], si;
    or di, di;
    jns 0xff35;
    $1 += $2;
    loop 0xff1f;
    goto $1;
    $1 += $2;
    ror dl, 1;
    ror dl, 1;
    ror dh, 1;
    ror dh, 1;
    cmc ;
    adc bx, 0;
    loop 0xff1f;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    cmp word ptr [bp - 0x24], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0xff;
    and byte ptr [bp - 0x26], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    jns 0xff94;
    neg bx;
    neg si;
    neg di;
    xchg di, si;
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0xffa7;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    shl ax, cl;
    $1 = $2;
    not dh;
    $1 = pop();
    $1++;
    test bx, 0x2000;
    if (ZF) goto $1;
    xchg word ptr [bp - 0xa], si;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0xfff1;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    lcall 0x885, 0x24;
    $1 = $2;
    shl ax, cl;
    not ah;
    $1 = pop();
    test si, bx;
    if (ZF) goto $1;
    xchg di, si;
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    $1 += $2;
    xchg di, si;
    loop 0x1000d;
    goto $1;
    and byte ptr es:[bx], ah;
    $1 += $2;
    xchg di, si;
    loop 0x10018;
    goto $1;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh;
    js 0x10077;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    and al, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    and ah, dh;
    or ah, dl;
    ror dl, 1;
    ror dh, 1;
    jae 0x100af;
    or di, di;
    jns 0x100a0;
    $1 += $2;
    loop 0x10088;
    mov byte ptr es:[bx], ah;
    goto $1;
    $1 += $2;
    mov byte ptr es:[bx], ah;
    $1 += $2;
    xchg word ptr [bp - 0xa], si;
    loop 0x10085;
    goto $1;
    mov byte ptr es:[bx], ah;
    $1++;
    or di, di;
    jns 0x100be;
    $1 += $2;
    loop 0x10085;
    goto $1;
    $1 += $2;
    $1 += $2;
    xchg word ptr [bp - 0xa], si;
    loop 0x10085;
    goto $1;
    and byte ptr es:[bx], dh;
    or byte ptr es:[bx], dl;
    $1 += $2;
    xchg word ptr [bp - 0xa], si;
    or di, di;
    jns 0x100e0;
    $1 += $2;
    loop 0x100ca;
    goto $1;
    $1 += $2;
    ror dl, 1;
    ror dh, 1;
    cmc ;
    adc bx, 0;
    loop 0x100ca;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    cmp word ptr [bp - 0x24], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0xff;
    and byte ptr [bp - 0x26], 1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    jns 0x10142;
    neg bx;
    neg si;
    neg di;
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0x10155;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 += $2;
    $1 = $2;
    shl ax, cl;
    $1 = $2;
    not dh;
    $1 = pop();
    $1++;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0x10199;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    lcall 0x885, 0x4a;
    $1 += $2;
    $1 = $2;
    shl ax, cl;
    not ah;
    $1 = pop();
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    $1 += $2;
    jns 0x101bb;
    $1 += $2;
    loop 0x101b2;
    goto $1;
    and byte ptr es:[bx], ah;
    $1 += $2;
    jns 0x101c8;
    $1 += $2;
    loop 0x101bf;
    goto $1;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh;
    js 0x10223;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    and al, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    and ah, dh;
    or ah, dl;
    ror dl, 1;
    ror dh, 1;
    jae 0x1025d;
    or di, di;
    jns 0x1024c;
    $1 += $2;
    loop 0x10234;
    mov byte ptr es:[bx], ah;
    goto $1;
    $1 += $2;
    mov byte ptr es:[bx], ah;
    $1 += $2;
    jns 0x10259;
    $1 += $2;
    loop 0x10231;
    goto $1;
    mov byte ptr es:[bx], ah;
    $1++;
    or di, di;
    jns 0x1026c;
    $1 += $2;
    loop 0x10231;
    goto $1;
    $1 += $2;
    $1 += $2;
    jns 0x10276;
    $1 += $2;
    loop 0x10231;
    goto $1;
    and byte ptr es:[bx], dh;
    or byte ptr es:[bx], dl;
    $1 += $2;
    jns 0x10287;
    $1 += $2;
    or di, di;
    jns 0x10292;
    $1 += $2;
    loop 0x1027a;
    goto $1;
    $1 += $2;
    ror dl, 1;
    ror dh, 1;
    cmc ;
    adc bx, 0;
    loop 0x1027a;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    shl ah, cl;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    jns 0x10314;
    neg bx;
    neg si;
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0x10327;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    shl ah, cl;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1++;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0x10366;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    push($1);
    $1();
    shl ah, cl;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    or byte ptr es:[bx], al;
    $1 += $2;
    loop 0x10375;
    goto $1;
    push($1);
    $1 = $2;
    and cx, 7;
    ror byte ptr [bp - 0x2a], cl;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    not dh;
    shl dh, cl;
    not dh;
    and dh, byte ptr [bp - 0x2a];
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    shl dl, cl;
    and dl, byte ptr [bp - 0x2a];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = pop();
    $1 = $2;
    or bh, bh;
    js 0x103dc;
    or cx, cx;
    if (!ZF) goto $1;
    and bl, bh;
    goto $1;
    $1 = $2;
    out dx, ax;
    movsb byte ptr es:[di], byte ptr [si];
    $1--;
    $1 = $2;
    out dx, ax;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    out dx, ax;
    movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    goto $1;
    $1 = $2;
    or ah, bl;
    ror bl, 1;
    jb 0x1040e;
    or si, si;
    jns 0x10400;
    $1 += $2;
    loop 0x103eb;
    out dx, ax;
    or byte ptr es:[di], al;
    goto $1;
    $1 += $2;
    out dx, ax;
    or byte ptr es:[di], al;
    $1 += $2;
    loop 0x103e9;
    goto $1;
    out dx, ax;
    or byte ptr es:[di], al;
    $1++;
    or si, si;
    jns 0x1041e;
    $1 += $2;
    loop 0x103e9;
    goto $1;
    $1 += $2;
    $1 += $2;
    loop 0x103e9;
    goto $1;
    $1 = $2;
    out dx, ax;
    or byte ptr es:[di], al;
    $1 += $2;
    or si, si;
    jns 0x1043c;
    $1 += $2;
    loop 0x1042b;
    goto $1;
    $1 += $2;
    ror ah, 1;
    adc di, 0;
    loop 0x1042b;
    $1 = 0;
    out dx, ax;
    $1++;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    cmp word ptr [bp - 0x24], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    mov byte ptr [0x5c64], 0;
    mov byte ptr [0x5c65], 0xff;
    and byte ptr [bp - 0x26], 1;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    jns 0x10498;
    neg bx;
    neg si;
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0x104a8;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    shl ax, cl;
    $1 = $2;
    not dh;
    $1 = pop();
    $1++;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0x104e8;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 = $2;
    shl ax, cl;
    not ah;
    $1 = pop();
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    $1 += $2;
    loop 0x104fd;
    goto $1;
    and byte ptr es:[bx], ah;
    $1 += $2;
    loop 0x10506;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    not dh;
    $1 = $2;
    shl dh, cl;
    not dh;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    shl dl, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    shr bx, cl;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    xlatb ;
    or dh, dh;
    js 0x10562;
    or cx, cx;
    if (!ZF) goto $1;
    and dl, dh;
    goto $1;
    $1 = $2;
    and ah, dh;
    not dh;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], ah;
    $1++;
    $1--;
    rep stosb byte ptr es:[di], al;
    and al, dl;
    not dl;
    and byte ptr es:[di], dl;
    or byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    and ah, dh;
    or ah, dl;
    ror dl, 1;
    ror dh, 1;
    jae 0x10597;
    or di, di;
    jns 0x1058b;
    $1 += $2;
    loop 0x10573;
    mov byte ptr es:[bx], ah;
    goto $1;
    $1 += $2;
    mov byte ptr es:[bx], ah;
    $1 += $2;
    loop 0x10570;
    goto $1;
    mov byte ptr es:[bx], ah;
    $1++;
    or di, di;
    jns 0x105a6;
    $1 += $2;
    loop 0x10570;
    goto $1;
    $1 += $2;
    $1 += $2;
    loop 0x10570;
    goto $1;
    and byte ptr es:[bx], dh;
    or byte ptr es:[bx], dl;
    $1 += $2;
    or di, di;
    jns 0x105c2;
    $1 += $2;
    loop 0x105af;
    goto $1;
    $1 += $2;
    ror dl, 1;
    ror dh, 1;
    cmc ;
    adc bx, 0;
    loop 0x105af;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    cmp word ptr [bp - 0x24], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    jns 0x10605;
    neg bx;
    neg si;
    push($1);
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0x10616;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = pop();
    $1++;
    $1 = pop();
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0x1064f;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    lcall 0x885, 0xaa;
    $1 = pop();
    $1 = $2;
    $1--;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 += $2;
    loop 0x10660;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = pop();
    $1++;
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    or si, si;
    jns 0x1068d;
    $1 += $2;
    loop 0x10681;
    goto $1;
    $1 += $2;
    $1 += $2;
    loop 0x10681;
    goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 += $2;
    or si, si;
    jns 0x106a8;
    $1 += $2;
    $1--;
    loop 0x10699;
    goto $1;
    $1 += $2;
    loop 0x10699;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    retf ;
    cmp word ptr [bp - 0x24], 0;
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    jns 0x106f8;
    neg bx;
    neg si;
    push($1);
    mov word ptr [bp - 0x1c], 0;
    // Compare $1 with $2
    jle 0x10709;
    mov word ptr [bp - 0x1c], 1;
    xchg cx, bx;
    shl bx, 1;
    *($1) = $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = pop();
    $1++;
    $1 = pop();
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jge 0x1074f;
    neg cx;
    $1 = $2;
    $1++;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = pop();
    $1 = $2;
    mov byte ptr es:[di], dl;
    $1 += $2;
    jae 0x1077f;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x1076a;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1();
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = pop();
    $1++;
    $1 = $2;
    // Compare $1 with $2
    jb 0x107be;
    mov byte ptr es:[di], dl;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x107a8;
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    mov byte ptr es:[di], dl;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    or si, si;
    jns 0x107e8;
    $1 += $2;
    loop 0x107c8;
    goto $1;
    $1 += $2;
    $1 += $2;
    jae 0x10803;
    or bx, bx;
    js 0x1081b;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    goto $1;
    or bx, bx;
    jns 0x1081b;
    cmp word ptr [bp - 0x1e], 0;
    if (ZF) goto $1;
    $1--;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x107c8;
    goto $1;
    $1 = $2;
    mov byte ptr es:[di], dl;
    $1 += $2;
    jae 0x1083d;
    or bx, bx;
    js 0x10855;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    goto $1;
    or bx, bx;
    jns 0x10855;
    cmp word ptr [bp - 0x1e], 0;
    if (ZF) goto $1;
    $1--;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    or si, si;
    jns 0x10860;
    $1 += $2;
    loop 0x10822;
    goto $1;
    $1 += $2;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x10822;
    push($1);
    lcall 0xa36, 0x1a5;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    cmp word ptr [bp - 0x24], 0;
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    nop ;
    nop ;
    goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x108dd;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0x108f3;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bx;
    $1 = $2;
    $1 = $2;
    shr ch, cl;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = pop();
    $1 += $2;
    adc dx, 0;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bx;
    $1 += $2;
    and dl, 7;
    $1 = $2;
    xor cl, 7;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    $1 = 0;
    or word ptr [bp - 0x3c], cx;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x10974;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    mov byte ptr [bp - 0x42], 0;
    mov byte ptr [bp - 0x41], 0x55;
    mov byte ptr [bp - 0x40], 0xaa;
    mov byte ptr [bp - 0x3f], 0xff;
    cmp word ptr [bp - 0x38], 1;
    if (!ZF) goto $1;
    cmp byte ptr es:[di + 0x13], 1;
    if (!ZF) goto $1;
    test ax, 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    cmp byte ptr es:[di + 0x13], 2;
    if (!ZF) goto $1;
    and ax, 3;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    goto $1;
    $1 = 0;
    mov byte ptr [bp + si - 0x42], 0xff;
    rcr ax, 1;
    jb 0x109c6;
    not byte ptr [bp + si - 0x42];
    $1++;
    // Compare $1 with $2
    jb 0x109bb;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 -= $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0x10a06;
    and dh, dl;
    goto $1;
    push($1);
    and al, dl;
    not dl;
    $1 = $2;
    and ah, dl;
    or al, ah;
    stosb byte ptr es:[di], al;
    $1 = pop();
    $1--;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jae 0x10a32;
    goto $1;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    jbe 0x10a59;
    stosb byte ptr es:[di], al;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jb 0x10ab9;
    loop 0x10a3a;
    goto $1;
    test cx, 1;
    if (ZF) goto $1;
    stosb byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr cx, 1;
    $1 = $2;
    rep stosw word ptr es:[di], ax;
    and al, dh;
    not dh;
    $1 = $2;
    and ah, dh;
    or al, ah;
    stosb byte ptr es:[di], al;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jb 0x10ab9;
    $1++;
    $1 += $2;
    jae 0x10aaa;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jb 0x10ab9;
    $1--;
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    xchg word ptr [0x5c70], ax;
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test ax, 0x1e;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    test ax, 0x10;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    test ax, 8;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    test ax, 4;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    test ax, 2;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    test ax, 1;
    if (ZF) goto $1;
    $1 = $2;
    int 0x33;
    add word ptr [0x5c82], si;
    add word ptr [0x5c84], di;
    $1 += $2;
    $1 += $2;
    cmp word ptr [0x5ce6], 0;
    if (ZF) goto $1;
    $1();
    cmp word ptr [0x5c76], 1;
    if (!ZF) goto $1;
    $1();
    $1 = $2;
    and ax, 0x1f;
    and ax, word ptr [0x6d37];
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lea ax, [bp - 8];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lcall 0x107c, 0x1c0;
    $1 = $2;
    $1 = pop();
    mov word ptr [0x5c70], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bl;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    jbe 0x10c91;
    // Compare $1 with $2
    jbe 0x10cb6;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    cld ;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    stosw word ptr es:[di], ax;
    $1++;
    $1++;
    loop 0x10c95;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    stosw word ptr es:[di], ax;
    $1++;
    $1++;
    loop 0x10caa;
    goto $1;
    cld ;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    shl dx, 1;
    rcl ax, 1;
    shl dx, 1;
    rcl ax, 1;
    rol bx, 1;
    jae 0x10cd3;
    or dx, 3;
    loop 0x10cc4;
    xchg al, ah;
    stosw word ptr es:[di], ax;
    $1 = $2;
    xchg al, ah;
    stosw word ptr es:[di], ax;
    $1++;
    $1++;
    $1 = pop();
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    and ax, 3;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    shl dx, 1;
    rcl ax, 1;
    shl dx, 1;
    rcl ax, 1;
    rol bx, 1;
    jae 0x10d11;
    or dx, word ptr [bp - 4];
    loop 0x10d02;
    xchg al, ah;
    stosw word ptr es:[di], ax;
    $1 = $2;
    xchg al, ah;
    stosw word ptr es:[di], ax;
    $1++;
    $1++;
    $1 = pop();
    $1--;
    if (!ZF) goto $1;
    goto $1;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    rep stosw word ptr es:[di], ax;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    ror bl, 1;
    jb 0x10d53;
    $1 = 0;
    mov word ptr es:[di], ax;
    $1++;
    $1++;
    loop 0x10d49;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rol ax, 1;
    jae 0x10d74;
    mov byte ptr es:[di], 0xff;
    goto $1;
    mov byte ptr es:[di], 0;
    $1++;
    loop 0x10d6a;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    rol ax, 1;
    jae 0x10d9e;
    mov byte ptr es:[di], bl;
    goto $1;
    mov byte ptr es:[di], 0;
    $1++;
    loop 0x10d95;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    lcall 0x71a, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    *($1) = $2;
    *($1) = $2;
    ret ;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    ret ;
    // Compare $1 with $2
    jge 0x10e9f;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    jle 0x10ea9;
    $1 = $2;
    // Compare $1 with $2
    jge 0x10eb5;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    jle 0x10ebf;
    $1 = $2;
    pushf ;
    cli ;
    *($1) = $2;
    *($1) = $2;
    popf ;
    $1();
    ret ;
    $1 -= $2;
    $1 -= $2;
    cmp word ptr [0x5c74], 0;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    $1 = 0;
    push($1);
    lcall 0x98e, 0x53a;
    *($1) = $2;
    test byte ptr [0x5c7a], 0xff;
    if (ZF) goto $1;
    $1();
    $1 = pop();
    $1 = $2;
    xchg word ptr [0x5cd4], bx;
    or ax, bx;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [0x5c86], si;
    jg 0x10f33;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    // Compare $1 with $2
    jle 0x10f1f;
    goto $1;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    // Compare $1 with $2
    jle 0x10f44;
    goto $1;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [0x5c88], di;
    jg 0x10f82;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    // Compare $1 with $2
    jle 0x10f6e;
    goto $1;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    // Compare $1 with $2
    jle 0x10f93;
    goto $1;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x71a, 0xc;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xb44, 0xc;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    or bx, bx;
    if (!ZF) goto $1;
    $1();
    test byte ptr [0x5cd4], 0xff;
    if (!ZF) goto $1;
    $1();
    push($1);
    lcall 0x98e, 0x53a;
    test byte ptr [0x5c7a], 0xff;
    if (ZF) goto $1;
    $1();
    ret ;
    $1 = 0;
    mov word ptr [0x5c70], 0;
    mov word ptr [0x5c80], 0xffff;
    mov word ptr [0x5c74], 0xffff;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [0x5c8a], 0xf;
    mov word ptr [0x5c8c], 0xf;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    cmp word ptr [0x5ce6], 0;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    goto $1;
    $1 = $2;
    shr ax, 1;
    push($1);
    $1 = $2;
    shr ax, 1;
    push($1);
    push($1);
    $1();
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    or ax, bx;
    if (ZF) goto $1;
    cmp byte ptr es:[bx], 0xcf;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xf05e;
    mov word ptr [0x5c78], 0;
    goto $1;
    $1 = $2;
    int 0x33;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xf05d;
    mov word ptr [0x5c78], 0;
    goto $1;
    mov word ptr [bp - 2], 0;
    mov word ptr [0x5c78], 1;
    mov word ptr [0x5ce6], 1;
    mov word ptr [0x5c76], 0;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1();
    cmp word ptr [0x5c78], 1;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    int 0x33;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5c78], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf05e;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1();
    mov word ptr [0x5c76], 1;
    $1 = $2;
    push($1);
    push($1);
    $1();
    goto $1;
    mov word ptr [0x5c76], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp + 6], 1;
    if (!ZF) goto $1;
    $1 = $2;
    int 0x33;
    goto $1;
    $1 = $2;
    int 0x33;
    goto $1;
    cmp word ptr [bp + 6], 1;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    or ax, word ptr [0x5cd4];
    if (!ZF) goto $1;
    $1();
    goto $1;
    cmp word ptr [0x5c74], 0;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    $1++;
    push($1);
    or bx, ax;
    xchg word ptr [0x5cd4], ax;
    or bx, ax;
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    push($1);
    $1();
    $1 -= $2;
    $1 -= $2;
    $1();
    $1 = pop();
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    popf ;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    cld ;
    push($1);
    les di, ptr [bp + 0xe];
    movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 0xa];
    movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 6];
    movsw word ptr es:[di], word ptr [si];
    $1 = pop();
    mov word ptr [si], 0;
    popf ;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    cld ;
    push($1);
    les di, ptr [bp + 0xe];
    movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 0xa];
    movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 6];
    movsw word ptr es:[di], word ptr [si];
    $1 = pop();
    mov word ptr [si], 0;
    popf ;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    popf ;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cmp word ptr [0x5ce6], 1;
    if (ZF) goto $1;
    $1 = $2;
    int 0x33;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33;
    $1 = $2;
    push($1);
    push($1);
    $1();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 0;
    if (!ZF) goto $1;
    $1 = $2;
    int 0x33;
    goto $1;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    popf ;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], cx;
    les di, ptr [bp + 6];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 1;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x33;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1();
    pushf ;
    cli ;
    cmp word ptr [0x5c74], 0;
    if (!ZF) goto $1;
    $1();
    popf ;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x11592;
    // Compare $1 with $2
    jle 0x11599;
    mov word ptr [bp - 2], 0xf05c;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1();
    $1();
    $1 = $2;
    push($1);
    push($1);
    $1();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x115ea;
    // Compare $1 with $2
    jle 0x115f1;
    mov word ptr [bp - 2], 0xf05c;
    goto $1;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 += $2;
    cld ;
    les di, ptr [bp + 0x12];
    movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 0xe];
    movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 6];
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    les di, ptr [bp + 0xa];
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x12;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x11642;
    // Compare $1 with $2
    jle 0x11649;
    mov word ptr [bp - 2], 0xf05c;
    goto $1;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 += $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr [0x5c78], 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1();
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0x11727;
    xchg word ptr [bp + 0xa], ax;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0x11735;
    xchg word ptr [bp + 0xc], ax;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1();
    test byte ptr [0x5cd2], 0xff;
    if (ZF) goto $1;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    $1();
    $1();
    popf ;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    *($1) = $2;
    $1();
    goto $1;
    mov word ptr [0x5cd2], 0;
    $1 = 0;
    $1();
    popf ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    lcall 0x98e, 0x12a;
    jb 0x1183b;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 -= $2;
    $1--;
    $1 += $2;
    $1++;
    jge 0x117eb;
    $1 = 0;
    mul bx;
    and ax, 0xfff8;
    $1 = 0;
    div bx;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1--;
    $1 += $2;
    $1++;
    jge 0x11808;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x11819;
    $1 = $2;
    $1--;
    mul bx;
    $1 += $2;
    and ax, 0xfff8;
    $1 = 0;
    div bx;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = pop();
    // Compare $1 with $2
    jb 0x11838;
    $1 = $2;
    $1--;
    *($1) = $2;
    ret ;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    ja 0x118a2;
    // Compare $1 with $2
    jae 0x11856;
    goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    in al, dx;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1--;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    $1 = $2;
    in al, dx;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    in al, dx;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    xor al, 2;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    *($1) = $2;
    ret ;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    ja 0x11990;
    // Compare $1 with $2
    jae 0x11956;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    out dx, al;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, al;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    ret ;
    $1 = $2;
    int 0x10;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = 0;
    goto $1;
    $1 = $2;
    ret ;
    $1 = 0;
    // Compare $1 with $2
    jl 0x11a63;
    // Compare $1 with $2
    jl 0x11a63;
    // Compare $1 with $2
    jg 0x11a63;
    // Compare $1 with $2
    jg 0x11a63;
    $1++;
    and ax, word ptr [0x5cd2];
    ret ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    or bx, ax;
    $1 = $2;
    *($1) = $2;
    or bx, ax;
    or bx, bx;
    if (!ZF) goto $1;
    lds si, ptr [bp + 0x10];
    lds si, ptr [si];
    $1 = $2;
    $1++;
    $1++;
    lodsw ax, word ptr [si];
    $1 = $2;
    $1 = $2;
    $1--;
    $1++;
    $1++;
    lodsw ax, word ptr [si];
    // Compare $1 with $2
    jge 0x11abb;
    $1 = $2;
    loop 0x11aae;
    goto $1;
    // Compare $1 with $2
    jle 0x11ac1;
    $1 = $2;
    loop 0x11aae;
    *($1) = $2;
    *($1) = $2;
    $1 -= $2;
    $1++;
    goto $1;
    $1 = $2;
    shl bx, 1;
    shl bx, 1;
    $1 = $2;
    les di, ptr [0x54c1];
    lds si, ptr [bp + 0x10];
    lds si, ptr [si];
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    $1 += $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    sub word ptr [bp - 0x22], bx;
    jae 0x11b00;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    lodsw ax, word ptr [si];
    $1 = $2;
    lodsw ax, word ptr [si];
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    lcall 0x1214, 0x26c;
    $1 = $2;
    $1 = pop();
    $1 += $2;
    $1 += $2;
    // Compare $1 with $2
    jge 0x11b3f;
    *($1) = $2;
    // Compare $1 with $2
    jle 0x11b47;
    *($1) = $2;
    xchg bx, ax;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    loop 0x11b13;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    shl dx, 1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [0x54c1];
    $1 = $2;
    $1 = 0;
    rep stosw word ptr es:[di], ax;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    lds si, ptr [si];
    $1 = $2;
    $1 -= $2;
    shl bx, 1;
    shl bx, 1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    shl bx, 1;
    shl bx, 1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x11bd5;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[bx + di + 0xa], 0;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    mov word ptr es:[bx + di + 6], ax;
    mov word ptr es:[bx + di + 8], ax;
    goto $1;
    $1 -= $2;
    cdq ;
    $1 = $2;
    $1 -= $2;
    idiv cx;
    push($1);
    $1 = $2;
    imul dx;
    $1 = $2;
    mov word ptr es:[bx + di + 6], ax;
    mov word ptr es:[bx + di + 8], dx;
    $1 = pop();
    $1 = $2;
    imul dx;
    idiv cx;
    cdq ;
    add word ptr es:[bx + di + 6], ax;
    adc word ptr es:[bx + di + 8], dx;
    $1 = $2;
    // Compare $1 with $2
    jle 0x11c58;
    cmp word ptr [bp - 0x16], ax;
    jl 0x11c3a;
    $1--;
    $1 = $2;
    mov word ptr es:[bx + di], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    mov word ptr es:[bx + di + 4], dx;
    mov word ptr es:[bx + di + 2], ax;
    goto $1;
    $1 = $2;
    cmp word ptr [bp - 0xa], ax;
    jl 0x11c61;
    $1--;
    $1 = $2;
    mov word ptr es:[bx + di], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    mov word ptr es:[bx + di + 4], dx;
    mov word ptr es:[bx + di + 2], ax;
    $1 = $2;
    $1 -= $2;
    shl bx, 1;
    cmp word ptr es:[bx + di], 0;
    if (!ZF) goto $1;
    $1 = $2;
    mov word ptr es:[bx + di], ax;
    goto $1;
    $1 = $2;
    cmp word ptr es:[bx + di + 0xa], 0;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1++;
    $1 = $2;
    // Compare $1 with $2
    jge 0x11cdc;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [0x54c1];
    mov word ptr [bp - 6], 0;
    $1 = $2;
    *($1) = $2;
    cmp word ptr [bp - 4], 0;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr es:[bx + di + 0xa], 0;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    ja 0x11d5f;
    jb 0x11d56;
    // Compare $1 with $2
    jae 0x11d5f;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    cmp word ptr [bp - 6], 0;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[bx + di + 0xa], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jle 0x11df9;
    xchg word ptr [bp + 6], ax;
    *($1) = $2;
    cmp word ptr [si + 0x26], 1;
    if (ZF) goto $1;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    and cx, 7;
    $1 = $2;
    and bx, 7;
    $1 = $2;
    $1 = $2;
    rol ax, cl;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    les di, ptr [0x54c1];
    lea ax, [bp + 8];
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x14];
    push($1);
    push($1);
    lea ax, [bp - 0x16];
    push($1);
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    mov word ptr [si + 0x3c], 0;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x1c], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    shl bx, 1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    cmp word ptr es:[bx + di + 0xa], 0;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    mov word ptr es:[bx + di + 0xa], dx;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    idiv cx;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    idiv cx;
    *($1) = $2;
    $1 = $2;
    push($1);
    cmp word ptr [si + 0x22], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = pop();
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    cmp word ptr es:[bx + di], ax;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    cmp word ptr es:[bx + di + 0xa], 0;
    if (ZF) goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[bx + di], ax;
    $1 = pop();
    if (!ZF) goto $1;
    mov word ptr es:[bx + di + 0xa], dx;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    add word ptr es:[bx + di + 2], ax;
    adc word ptr es:[bx + di + 4], dx;
    $1 = $2;
    goto $1;
    $1++;
    $1 = $2;
    // Compare $1 with $2
    jg 0x11fed;
    // Compare $1 with $2
    jg 0x11fed;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 8], 1;
    ja 0x12040;
    mov word ptr [bp - 2], 0xf056;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 6], 2;
    jae 0x1204b;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    and ax, 1;
    if (ZF) goto $1;
    mov word ptr [si + 0x10], 0;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1--;
    push($1);
    push($1);
    $1 += $2;
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1--;
    if (!ZF) goto $1;
    cmp word ptr [bp + 6], 2;
    jl 0x120c1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    mov word ptr [si + 0x10], 1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [si + 0x3c], 0;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x2cf;
    *($1) = $2;
    lcall 0x10b4, 0x84;
    $1 = $2;
    mul bx;
    $1 = $2;
    div bx;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0x121b8;
    xchg word ptr [bp + 0xc], ax;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    jge 0x121c6;
    xchg word ptr [bp + 0xe], ax;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    cmp word ptr [bp + 6], 2;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1--;
    $1 = $2;
    $1 -= $2;
    $1--;
    $1 -= $2;
    // Compare $1 with $2
    jl 0x121fa;
    $1 = $2;
    $1 -= $2;
    $1--;
    $1 -= $2;
    // Compare $1 with $2
    jge 0x12229;
    $1 = $2;
    shr bx, 1;
    sub word ptr [bp + 0xe], bx;
    sub word ptr [bp + 0xc], bx;
    add word ptr [bp + 0xa], bx;
    add word ptr [bp + 8], bx;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cmp word ptr [si + 0x28], -1;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [si + 0x16], 0;
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    shr di, 1;
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1++;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lcall 0xd9f, 0x178;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    lcall 0xd9f, 0x178;
    test word ptr [bp + 6], 2;
    if (!ZF) goto $1;
    goto $1;
    add word ptr [bp + 0xe], di;
    add word ptr [bp + 0xc], di;
    sub word ptr [bp + 0xa], di;
    sub word ptr [bp + 8], di;
    $1 = $2;
    cmp word ptr [si + 0x22], 0;
    if (!ZF) goto $1;
    cmp word ptr [si + 0x16], 0;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xbd7, 8;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1++;
    // Compare $1 with $2
    jle 0x122f5;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    and cx, 7;
    $1 = $2;
    and bx, 7;
    $1 = $2;
    cmp word ptr [si + 0x26], 1;
    if (ZF) goto $1;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    rol ax, cl;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xd9f, 0x178;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1++;
    and bx, 7;
    $1++;
    // Compare $1 with $2
    jle 0x12341;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov word ptr [si + 0x10], 1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xor bx, word ptr [0x6d37];
    and bx, 0x8000;
    if (ZF) goto $1;
    test ax, 0x8000;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    mov word ptr cs:[0x37b], bx;
    mov word ptr cs:[0x37d], es;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    $1 = $2;
    mov word ptr [0x6ab4], 0;
    lds si, ptr [bp + 0xa];
    *($1) = $2;
    lds si, ptr [bp + 6];
    *($1) = $2;
    popf ;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test word ptr [0x6d37], 0xffff;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf049;
    goto $1;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    or bx, word ptr [bp + 8];
    if (ZF) goto $1;
    $1 = 0;
    $1 = $2;
    div cx;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 -= $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    mov word ptr [0x6aaa], 0x6c06;
    mov word ptr [0x6ab0], 0x19;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test word ptr [0x6ab2], 0xffff;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xf04c;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = pop();
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x12566;
    $1 = $2;
    *($1) = $2;
    $1--;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    // Compare $1 with $2
    jb 0x125a7;
    popf ;
    mov word ptr [bp - 2], 0xf04b;
    $1++;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x125c8;
    $1 = $2;
    *($1) = $2;
    $1++;
    popf ;
    push($1);
    $1 = $2;
    lds si, ptr [bp + 6];
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    $1 = pop();
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test word ptr [0x6ab2], 0xffff;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0x12648;
    mov word ptr [bp - 2], 0xf04a;
    goto $1;
    les di, ptr [bp + 8];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, cx;
    if (ZF) goto $1;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x12667;
    $1 = $2;
    loop 0x1265e;
    $1 = $2;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = 0;
    xchg word ptr [0x6d37], ax;
    $1 = $2;
    mov word ptr [0x6ab2], 0;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1++;
    $1++;
    // Compare $1 with $2
    jb 0x126eb;
    $1 = $2;
    mov word ptr es:[0x1a], si;
    push($1);
    $1 = $2;
    $1 -= $2;
    mov word ptr [bp - 0xe], 0x8000;
    lcall 0xeec, 0x85f;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    loop 0x126c5;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    ljmp cs:[0x37b];
    iret ;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x12780;
    *($1) = $2;
    goto $1;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x1278f;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0x127a3;
    mov word ptr [bp - 2], 0xfff8;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mul bx;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x11fc, 0;
    jae 0x127e3;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x11fc, 0;
    jae 0x1281a;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[di + 1], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x128b6;
    // Compare $1 with $2
    jg 0x128b6;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xf05f;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x128e7;
    // Compare $1 with $2
    jle 0x128ee;
    mov word ptr [bp - 2], 0xf05f;
    goto $1;
    $1 = $2;
    mul bx;
    $1 += $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x12934;
    // Compare $1 with $2
    jle 0x1293b;
    mov word ptr [bp - 2], 0xf05f;
    goto $1;
    $1 = $2;
    mul bx;
    $1 += $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    or ax, 1;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    cld ;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di], 0;
    mov word ptr es:[di + 8], 0;
    mov word ptr es:[di + 0xa], 0;
    mov word ptr es:[di + 0xc], 1;
    mov word ptr es:[di + 0xe], 0;
    mov word ptr es:[di + 0x10], 1;
    mov word ptr es:[di + 0x12], 0;
    mov word ptr es:[di + 0x14], 0;
    mov word ptr es:[di + 0x16], 0;
    mov word ptr es:[di + 0x18], 0;
    mov word ptr es:[di + 0x1a], 0;
    mov word ptr es:[di + 0x1c], 0;
    mov word ptr es:[di + 0x1e], 0x3ff;
    mov word ptr es:[di + 0x20], 0x3ff;
    mov word ptr es:[di + 0x22], 0;
    mov word ptr es:[di + 0x24], 0;
    mov word ptr es:[di + 0x26], 1;
    mov word ptr es:[di + 0x28], 0xffff;
    mov word ptr es:[di + 0x2a], 1;
    mov word ptr es:[di + 0x2c], 0;
    mov word ptr es:[di + 0x2e], 0;
    mov word ptr es:[di + 0x30], 0;
    mov word ptr es:[di + 0x32], 0;
    mov word ptr es:[di + 0x34], 0;
    mov word ptr es:[di + 0x36], 0;
    mov word ptr es:[di + 0x38], 0x3ff;
    mov word ptr es:[di + 0x3a], 0x3ff;
    mov word ptr es:[di + 0x3c], 0;
    mov word ptr es:[di + 0x4e], 1;
    mov word ptr es:[di + 0x50], 3;
    mov word ptr es:[di + 0x52], 1;
    mov word ptr es:[di + 0x54], 1;
    mov word ptr es:[di + 0x56], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test word ptr [si + 0x3c], 1;
    if (ZF) goto $1;
    push($1);
    push($1);
    lcall 0x1214, 0x346;
    $1 = pop();
    push($1);
    push($1);
    lcall 0x1214, 0x307;
    $1 = pop();
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    mov word ptr es:[di], bx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x12c62;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul byte ptr [si + 0x17];
    $1 = $2;
    $1 = $2;
    shl ax, cl;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x12ca1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x12cd6;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (!ZF) goto $1;
    push($1);
    lcall 0x1214, 0x21c;
    *($1) = $2;
    push($1);
    lcall 0x1214, 0x26c;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    or bx, word ptr [si + 0x32];
    if (ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 0xa], ax;
    add word ptr [bp + 8], bx;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x18], 1;
    if (!ZF) goto $1;
    lcall 0xc6c, 0xe5;
    jb 0x12d74;
    $1 = $2;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x12d63;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    push($1);
    push($1);
    push($1);
    shl dx, 1;
    shl dx, 1;
    $1 += $2;
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0;
    $1 = $2;
    and al, 3;
    shl ax, cl;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    not ah;
    or al, ah;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    or byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x24;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    test al, al;
    if (!ZF) goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    goto $1;
    test al, al;
    if (ZF) goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    or byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x4a;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    test al, al;
    if (!ZF) goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    goto $1;
    test al, al;
    if (ZF) goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    or byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x6a;
    shl ah, cl;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shl ah, cl;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x8b;
    shl ah, cl;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shl ah, cl;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], ah;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x8b;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    test al, al;
    if (!ZF) goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    goto $1;
    test al, al;
    if (ZF) goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    not ah;
    and byte ptr es:[bx], ah;
    or byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xaa;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xba;
    shl ah, cl;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl ah, cl;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    mov byte ptr es:[bx], al;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    cmp word ptr [0x43b9], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shl ah, 1;
    shl ah, 1;
    shl ah, 1;
    or al, ah;
    or al, 0x40;
    $1 = $2;
    out dx, al;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    and ah, 0xf;
    $1 = $2;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    or al, ah;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    cmp word ptr [0x43b9], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shl ah, 1;
    shl ah, 1;
    shl ah, 1;
    or al, ah;
    or al, 0x40;
    $1 = $2;
    out dx, al;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    and ah, 0xf;
    $1 = $2;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    or al, ah;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1);
    $1 = $2;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1);
    $1 = $2;
    $1 = $2;
    and bl, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    and bl, 2;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    $1 = $2;
    in al, dx;
    and al, 0xdf;
    or bl, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    and bh, 0xc;
    $1 = $2;
    shr bl, 1;
    shr bl, 1;
    or al, bh;
    or al, bl;
    out dx, al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1);
    $1 = $2;
    $1 = $2;
    and bl, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    and bl, 2;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    $1 = $2;
    in al, dx;
    and al, 0xdf;
    or bl, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    and bh, 0xc;
    $1 = $2;
    shr bl, 1;
    shr bl, 1;
    or al, bh;
    or al, bl;
    out dx, al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1);
    $1 = $2;
    cli ;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    and ah, 0xe1;
    shl ch, 1;
    or ah, ch;
    $1--;
    $1 = $2;
    out dx, ax;
    sti ;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1);
    $1 = $2;
    cli ;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    and ah, 0xe1;
    shl ch, 1;
    or ah, ch;
    $1--;
    $1 = $2;
    out dx, ax;
    sti ;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    and ah, 0xf;
    $1 = $2;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    shl al, 1;
    or al, ah;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1);
    $1 = $2;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1);
    $1 = $2;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1);
    $1 = $2;
    $1 = $2;
    and bl, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    and bl, 2;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    shl bl, 1;
    $1 = $2;
    in al, dx;
    and al, 0xdf;
    or bl, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    and bh, 0xc;
    $1 = $2;
    shr bl, 1;
    shr bl, 1;
    or al, bh;
    or al, bl;
    out dx, al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1);
    $1 = $2;
    cli ;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    and ah, 0xe1;
    shl ch, 1;
    or ah, ch;
    $1--;
    $1 = $2;
    out dx, ax;
    sti ;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    $1 = $2;
    and al, 0xf;
    xor al, 2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    or al, ah;
    out dx, al;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    $1 = $2;
    and al, 0xf;
    xor al, 2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    or al, ah;
    out dx, al;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    $1 = $2;
    and al, 0xf;
    xor al, 2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    and al, 0xf0;
    or al, ah;
    out dx, al;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xd9;
    push($1);
    $1 = $2;
    $1 = $2;
    mul bl;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = 0;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0xf3;
    push($1);
    $1 = $2;
    $1 = $2;
    mul bl;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = 0;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x885, 0x10d;
    push($1);
    $1 = $2;
    $1 = $2;
    mul bl;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = 0;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[bx], al;
    goto $1;
    and byte ptr es:[bx], al;
    goto $1;
    xor byte ptr es:[bx], al;
    goto $1;
    mov byte ptr es:[bx], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[di], al;
    goto $1;
    test al, al;
    if (!ZF) goto $1;
    not ah;
    and byte ptr es:[di], ah;
    goto $1;
    test al, al;
    if (ZF) goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    not ah;
    and byte ptr es:[di], ah;
    or byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, ah;
    xor cl, ah;
    shl cl, 1;
    $1 = $2;
    and al, ah;
    shl ax, cl;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[di], al;
    goto $1;
    not ah;
    or al, ah;
    and byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    not ah;
    and byte ptr es:[di], ah;
    or byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    lds si, ptr [si + 4];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    or dl, dl;
    if (!ZF) goto $1;
    not ah;
    $1 = $2;
    $1 = $2;
    and dh, ah;
    or dh, al;
    mov byte ptr es:[di], dh;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    or bl, bl;
    if (ZF) goto $1;
    xor byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    or al, al;
    if (!ZF) goto $1;
    $1 = $2;
    shl al, cl;
    not al;
    and byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    $1 += $2;
    goto $1;
    test bl, bl;
    if (ZF) goto $1;
    $1 = $2;
    or byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    goto $1;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    mov byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jb 0x13bdc;
    // Compare $1 with $2
    jbe 0x13be4;
    mov word ptr [bp - 2], 0xfffa;
    stc ;
    goto $1;
    $1 = $2;
    cmp word ptr [si], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    mul dx;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp word ptr [si], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    $1 = $2;
    $1 = $2;
    mul bl;
    // Compare $1 with $2
    jbe 0x13cb7;
    shr ax, 1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1++;
    $1--;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    mov word ptr es:[di + 4], si;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [si], 0;
    mov word ptr [bp - 2], 0;
    les di, ptr [si + 4];
    cmp word ptr es:[di], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x3c], 0;
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lcall 0xbd7, 8;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    $1 += $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 += $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 += $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 += $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jle 0x13ee7;
    $1 = $2;
    // Compare $1 with $2
    jg 0x13eee;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    imul bx;
    $1 = $2;
    $1 -= $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    imul bx;
    $1 = $2;
    $1 -= $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jbe 0x13f87;
    xchg cx, bx;
    $1--;
    $1 -= $2;
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    or si, si;
    if (ZF) goto $1;
    neg ax;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jbe 0x13fd7;
    xchg cx, bx;
    $1--;
    $1 -= $2;
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    or di, di;
    if (ZF) goto $1;
    neg ax;
    cmp byte ptr [si + 0x4e], 0;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall 0x7ff, 8;
    $1 = $2;
    lcall 0x7ff, 0x32;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cdq ;
    $1 = $2;
    lcall 0x7ff, 0x1a;
    $1 = $2;
    $1 = $2;
    lcall 0x7ff, 0x50;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp byte ptr [si + 0x4e], 0;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    $1 += $2;
    cdq ;
    $1 = $2;
    lcall 0x7ff, 0x1a;
    $1 = $2;
    $1 = $2;
    lcall 0x7ff, 0x50;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], ax;
    $1 = $2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x6f01], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xe];
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x141ed;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    // Compare $1 with $2
    jbe 0x141fc;
    mov word ptr [bp - 2], 0xfc7c;
    goto $1;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x1420b;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 4], 1;
    if (!ZF) goto $1;
    cmp byte ptr es:[di], 9;
    if (ZF) goto $1;
    lcall 0x98e, 0x18a;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff9;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x1423d;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0xa6;
    or ax, ax;
    jge 0x14266;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    shl bx, 1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = pop();
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    mov word ptr [bx], 0x166;
    $1 += $2;
    mov word ptr [bx], 0x166;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x402;
    $1 += $2;
    mov word ptr [bx], 0x4b1;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov byte ptr [0x6f01], 1;
    retf ;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x1431f;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bl;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1--;
    mov word ptr [bp - 0xe], 0;
    or cl, cl;
    if (ZF) goto $1;
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1--;
    sar al, cl;
    *($1) = $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x14367;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    and dx, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 += $2;
    cld ;
    $1 = 0;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and ah, 0xc0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    lodsb al, byte ptr [si];
    or cx, cx;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x143ca;
    ja 0x143cd;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    or ah, byte ptr [bp - 0xc];
    $1 -= $2;
    and al, byte ptr [bp - 0xc];
    or al, ah;
    mov byte ptr es:[di], al;
    $1 = pop();
    goto $1;
    mov byte ptr es:[di], al;
    $1++;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1--;
    if (ZF) goto $1;
    xor dx, 1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 += $2;
    goto $1;
    $1 -= $2;
    $1 -= $2;
    loop 0x143a8;
    // Compare $1 with $2
    jbe 0x14407;
    push($1);
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14407;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    *($1) = $2;
    mov word ptr [bp - 0xe], 0;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jb 0x1444c;
    $1 = $2;
    $1 -= $2;
    test al, 7;
    if (ZF) goto $1;
    $1++;
    and al, 0xf8;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bl;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1--;
    or cl, cl;
    if (ZF) goto $1;
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1--;
    sar al, cl;
    *($1) = $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x1448f;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov byte ptr [bp - 0x18], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 0x1c], 1;
    mov word ptr [bp - 0x1a], 8;
    cmp byte ptr [si + 0x41], 3;
    if (!ZF) goto $1;
    mov word ptr [bp - 0x1a], 4;
    cmp byte ptr [si + 0x41], 1;
    if (!ZF) goto $1;
    mov word ptr [bp - 0x1c], 0xf;
    mov word ptr [bp - 0x1a], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = 0;
    $1 += $2;
    cld ;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and ah, 0xc0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    lodsb al, byte ptr [si];
    or cx, cx;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x1453e;
    ja 0x14541;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = pop();
    mov byte ptr es:[bx + di], al;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    goto $1;
    mov byte ptr es:[bx + di], al;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1 = $2;
    shl byte ptr [bp - 0x18], 1;
    cmp byte ptr [bp - 0x18], dl;
    jbe 0x14562;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = pop();
    loop 0x14514;
    // Compare $1 with $2
    jbe 0x14585;
    push($1);
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14585;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x145c2;
    $1 = $2;
    $1 -= $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x145df;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = 0;
    $1 += $2;
    cld ;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and ah, 0xc0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    lodsb al, byte ptr [si];
    or cx, cx;
    if (ZF) goto $1;
    // Compare $1 with $2
    ja 0x14615;
    mov byte ptr es:[bx + di], al;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    loop 0x1460d;
    // Compare $1 with $2
    jbe 0x1463d;
    push($1);
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x1463d;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x1466a;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    div bl;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1--;
    mov word ptr [bp - 0xe], 0;
    or cl, cl;
    if (ZF) goto $1;
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    $1--;
    sar al, cl;
    *($1) = $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x146b1;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    and al, 3;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    $1 += $2;
    cld ;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and ah, 0xc0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    lodsb al, byte ptr [si];
    or cx, cx;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x14718;
    ja 0x1471b;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    or ah, byte ptr [bp - 0xc];
    $1 -= $2;
    and al, byte ptr [bp - 0xc];
    or al, ah;
    mov byte ptr es:[bx + di], al;
    $1 = pop();
    goto $1;
    mov byte ptr es:[bx + di], al;
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1--;
    if (ZF) goto $1;
    $1++;
    // Compare $1 with $2
    jb 0x14736;
    $1 -= $2;
    $1 = 0;
    goto $1;
    $1 += $2;
    loop 0x146f6;
    // Compare $1 with $2
    jbe 0x14752;
    push($1);
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14752;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x14786;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jbe 0x147a6;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = 0;
    $1 = $2;
    sub word ptr [bp - 0x16], ax;
    $1 += $2;
    cld ;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and ah, 0xc0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    lodsb al, byte ptr [si];
    or cx, cx;
    if (ZF) goto $1;
    // Compare $1 with $2
    ja 0x14803;
    mov byte ptr es:[di], al;
    $1++;
    if (!ZF) goto $1;
    push($1);
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1 = pop();
    $1++;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = 0;
    $1 += $2;
    jae 0x14820;
    push($1);
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    loop 0x147e8;
    // Compare $1 with $2
    jbe 0x1483d;
    push($1);
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x1483d;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    push($1);
    lcall 0xa36, 0x1a5;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp byte ptr [si], 0xa;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    lds si, ptr [bp + 6];
    les di, ptr [bp + 0xa];
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cmp byte ptr es:[di], 0xa;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1++;
    $1++;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    les di, ptr [bp + 0xa];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x14b10;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jbe 0x14b86;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 = 0;
    mul bx;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    xor cl, 7;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    $1 = $2;
    not ch;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jbe 0x14bca;
    $1 = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    $1 += $2;
    les di, ptr [bp - 0x20];
    cld ;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    and ah, 0xc0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    lodsb al, byte ptr [si];
    or cx, cx;
    if (ZF) goto $1;
    $1++;
    // Compare $1 with $2
    jb 0x14c14;
    ja 0x14c37;
    push($1);
    $1 = $2;
    and byte ptr es:[di], ch;
    and cl, al;
    or byte ptr es:[di], cl;
    $1++;
    $1 = pop();
    goto $1;
    stosb byte ptr es:[di], al;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jae 0x14c37;
    cmp word ptr [bp - 0xe], 1;
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    jge 0x14c3f;
    goto $1;
    $1 = 0;
    $1 += $2;
    jae 0x14c64;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jae 0x14c64;
    cmp word ptr [bp - 0xe], 1;
    if (ZF) goto $1;
    goto $1;
    $1--;
    or dx, dx;
    if (!ZF) goto $1;
    $1 = $2;
    cmp word ptr [bp - 0x1c], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    if (ZF) goto $1;
    stosb byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], ah;
    $1++;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    jae 0x14cad;
    cmp word ptr [bp - 0xe], 1;
    if (ZF) goto $1;
    goto $1;
    loop 0x14c80;
    $1 += $2;
    jae 0x14cd2;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jae 0x14cd2;
    cmp word ptr [bp - 0xe], 1;
    if (ZF) goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    goto $1;
    $1--;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    $1--;
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    jb 0x14cf9;
    push($1);
    lcall 0x96b, 0xa0;
    $1 = $2;
    jae 0x14cf9;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x14d30;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shr al, cl;
    mov byte ptr es:[di], al;
    $1++;
    $1 = $2;
    $1 = $2;
    shr al, cl;
    mov byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shr al, cl;
    mov byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 5], 0x20;
    mov byte ptr [bp - 4], 4;
    mov byte ptr [bp - 3], 0x24;
    $1 = $2;
    push($1);
    $1 = 0;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    and bl, 0xc0;
    shr bl, cl;
    $1 = $2;
    $1 = $2;
    or al, bl;
    $1++;
    $1 = $2;
    and bl, 0xc0;
    shr bl, cl;
    $1 = $2;
    $1 = $2;
    shr bl, 1;
    or al, bl;
    $1++;
    $1 = $2;
    and bl, 0xc0;
    shr bl, cl;
    $1 = $2;
    $1 = $2;
    shr bl, 1;
    shr bl, 1;
    or al, bl;
    $1++;
    $1 = pop();
    stosb byte ptr es:[di], al;
    $1--;
    if (!ZF) goto $1;
    mov byte ptr es:[di], 0;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    shr al, 1;
    shr al, 1;
    mov byte ptr es:[di], al;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xfff7;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x14e41;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    lds si, ptr [bp + 6];
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    shl al, cl;
    mov byte ptr es:[di], al;
    mov byte ptr es:[di + 1], 0;
    mov byte ptr es:[di + 2], 0;
    $1 = $2;
    $1 = $2;
    shl al, cl;
    mov byte ptr es:[di + 3], al;
    mov byte ptr es:[di + 4], 0;
    mov byte ptr es:[di + 5], 0;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    shl al, cl;
    mov byte ptr es:[di], al;
    mov byte ptr es:[di + 1], 0;
    mov byte ptr es:[di + 2], 0;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    shl ah, 1;
    $1 = $2;
    and al, 0x48;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 0;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 0x55;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov byte ptr es:[di], 0xaa;
    goto $1;
    mov byte ptr es:[di], 0xff;
    $1++;
    loop 0x14ed5;
    $1 = pop();
    $1++;
    loop 0x14ecf;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    $1 = $2;
    shl al, 1;
    shl al, 1;
    mov byte ptr es:[di], al;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x14f56;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    goto $1;
    cmp byte ptr [si + 1], 5;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff6;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    cld ;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x14fe0;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    les di, ptr [bp + 0xc];
    cmp byte ptr es:[di + 1], 5;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff6;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    mov byte ptr es:[bx + di - 1], 0xc;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x1507b;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    lea ax, [bp - 0xe];
    push($1);
    push($1);
    lea ax, [bp - 0x10];
    push($1);
    lcall 0x96b, 0x66;
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0xe];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    jae 0x150bd;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    cmp byte ptr [si + 1], 5;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff6;
    goto $1;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x150de;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp - 0xe];
    les di, ptr [bp + 6];
    // Compare $1 with $2
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, 0;
    $1 -= $2;
    sbb dx, 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 += $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    $1 = $2;
    int 0x21;
    $1 = 0;
    // Compare $1 with $2
    jbe 0x15214;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    or al, ah;
    $1 = $2;
    int 0x21;
    $1 = pop();
    jae 0x15231;
    mov word ptr [bp - 2], 0xffff;
    goto $1;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x15246;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    mov word ptr [bp - 6], 0x30;
    goto $1;
    mov word ptr [bp - 6], 0x300;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    cmp byte ptr es:[di + 1], 5;
    if (ZF) goto $1;
    mov byte ptr es:[di + 1], 5;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    mov byte ptr es:[di], 0xc;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff7;
    goto $1;
    mov byte ptr es:[di], 0xc;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x153ec;
    *($1) = $2;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x166;
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x125a, 0;
    *($1) = $2;
    lcall 0x96b, 0x1c0;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x15486;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf448;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    les di, ptr [bp + 6];
    cld ;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x12c5, 0xc0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x15598;
    *($1) = $2;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x166;
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x12ed, 0xc;
    *($1) = $2;
    lcall 0x96b, 0x1c0;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 5;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x66;
    les di, ptr [bp - 6];
    lds si, ptr [bp + 0xc];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mul bx;
    or dx, dx;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jle 0x15680;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x9e7, 0xa;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x9e7, 0xb0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x10];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    mul word ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    shl ax, cl;
    $1--;
    and word ptr [bp + 8], ax;
    and word ptr [bp + 6], ax;
    $1 = $2;
    div byte ptr [bp + 0xa];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    shl ax, cl;
    $1--;
    $1 = $2;
    not ah;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp + 0xc], 1;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    push($1);
    $1 = $2;
    shl ax, cl;
    $1 = pop();
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    or al, ah;
    loop 0x15728;
    stosb byte ptr es:[di], al;
    $1 = pop();
    loop 0x1571f;
    goto $1;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = 0;
    $1 = 0;
    rol byte ptr es:[di], 1;
    rcl al, 1;
    shl al, cl;
    or ah, al;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x15749;
    $1 = pop();
    $1 = pop();
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    shr al, cl;
    and al, dl;
    and byte ptr es:[di], dh;
    or byte ptr es:[di], al;
    $1 += $2;
    $1++;
    // Compare $1 with $2
    jb 0x15768;
    $1 = pop();
    $1 = pop();
    loop 0x15743;
    $1++;
    $1 = pop();
    loop 0x1573f;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    cmp word ptr [si], 0xca00;
    if (!ZF) goto $1;
    cmp word ptr es:[di], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf82d;
    goto $1;
    les di, ptr [bp + 0xe];
    mov word ptr es:[di], 0xca20;
    $1 = $2;
    mov word ptr es:[di + 6], ax;
    mov word ptr es:[di + 4], si;
    lcall 0x1535, 0x2d;
    mov word ptr es:[di + 2], ax;
    mov word ptr es:[di + 0x8c], 0;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    mov word ptr es:[di + 0x8c], 1;
    lds si, ptr [bp + 6];
    $1 += $2;
    $1 = $2;
    cld ;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 4], 0;
    lds si, ptr [bp + 8];
    les di, ptr [bp + 0xc];
    $1 += $2;
    cmp word ptr [si], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    $1 = $2;
    cmp byte ptr [si + 0x12], 4;
    if (ZF) goto $1;
    cmp byte ptr [si + 0x13], 8;
    if (!ZF) goto $1;
    les di, ptr [bp + 8];
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x5e5, 0x1b0;
    or ax, ax;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 1;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x13d3, 2;
    or ax, ax;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    cmp word ptr [bp - 4], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    lcall 0x5e5, 0x2fa;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    les di, ptr [bp + 6];
    cmp word ptr es:[di], 0xca20;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    cmp word ptr es:[di + 0x8c], 1;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    lcall 0x5e5, 0x2fa;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    cld ;
    rep stosb byte ptr es:[di], al;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    cmp word ptr [si], 0xca00;
    if (!ZF) goto $1;
    cmp word ptr es:[di], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf82d;
    goto $1;
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x66;
    shr word ptr [bp - 8], 1;
    $1 = $2;
    mul word ptr [bp - 0xc];
    or dx, dx;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jbe 0x159c4;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    lcall 0x1535, 0x2d;
    $1 = $2;
    $1 = $2;
    mul byte ptr [bp - 0xc];
    $1 = $2;
    $1 = $2;
    shl ax, cl;
    $1--;
    and bx, ax;
    *($1) = $2;
    lds si, ptr [bp - 6];
    les di, ptr [bp - 6];
    $1 += $2;
    mov word ptr [bp - 0x14], 0;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x9e7, 0xa;
    or ax, ax;
    if (!ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x9e7, 0xb0;
    or ax, ax;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x10], 0;
    if (ZF) goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = 0;
    push($1);
    lcall 0x13a3, 0x96;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x9e7, 0xb0;
    or ax, ax;
    if (!ZF) goto $1;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 6];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x12];
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp + 0xa], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 0xa], 4;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 8], 1;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 2;
    if (ZF) goto $1;
    cmp word ptr [bp + 8], 8;
    if (ZF) goto $1;
    goto $1;
    ror dl, 1;
    not dl;
    cwde ;
    $1 = $2;
    shr cx, 1;
    lodsw ax, word ptr [si];
    xor ax, dx;
    stosw word ptr es:[di], ax;
    loop 0x15aff;
    goto $1;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = 0;
    shl ax, 1;
    shl ax, 1;
    xor ah, dl;
    $1 = $2;
    if (ZF) goto $1;
    $1 = 0;
    or al, ah;
    $1--;
    if (!ZF) goto $1;
    stosb byte ptr es:[di], al;
    loop 0x15b09;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    if (!ZF) goto $1;
    not al;
    stosb byte ptr es:[di], al;
    loop 0x15b25;
    goto $1;
    cmp word ptr [bp + 8], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    not dh;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    ror al, 1;
    cwde ;
    xor ah, byte ptr [si];
    and dl, ah;
    $1 += $2;
    loop 0x15b4c;
    $1 = pop();
    $1 = pop();
    mov byte ptr es:[di], dl;
    $1++;
    $1++;
    loop 0x15b43;
    lds si, ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 2], 0xfffa;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0x36], 0;
    mov word ptr [bp - 0x38], 0;
    cmp byte ptr [0x6f51], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    lds si, ptr [bp + 0xe];
    cmp word ptr [si], 0xca20;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xf82c;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    lds si, ptr [si + 4];
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    mov word ptr [bp - 0x3a], 0;
    $1 = $2;
    or ax, ax;
    jge 0x15c18;
    neg ax;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jbe 0x15c26;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    cmp word ptr [bp - 0x3a], ax;
    jbe 0x15c36;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0x15c48;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    mul word ptr [bp - 0xc];
    *($1) = $2;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x3c], 0;
    $1 = $2;
    or ax, ax;
    jge 0x15c80;
    neg ax;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jbe 0x15c8e;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    cmp word ptr [bp - 0x3c], ax;
    jbe 0x15c9e;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1++;
    // Compare $1 with $2
    jbe 0x15cb0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    mul word ptr [bp - 0x24];
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    jae 0x15cd0;
    goto $1;
    lds si, ptr [bp - 0xa];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    *($1) = $2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2;
    mov word ptr [bp - 0x2a], 0xff;
    mov word ptr [bp - 0x2c], 0;
    cmp byte ptr [bp - 0xc], 8;
    if (!ZF) goto $1;
    goto $1;
    push($1);
    lea ax, [bp - 0x48];
    push($1);
    push($1);
    lea ax, [bp - 0x4a];
    push($1);
    lcall 0x96b, 0x66;
    $1 = $2;
    // Compare $1 with $2
    jae 0x15d32;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    mul word ptr [bp - 0xc];
    $1 = $2;
    and cx, 7;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    shr dl, cl;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    and cx, 7;
    $1 = $2;
    shr dh, cl;
    not dh;
    *($1) = $2;
    // Compare $1 with $2
    jl 0x15d73;
    $1 = $2;
    *($1) = $2;
    or dh, dh;
    if (ZF) goto $1;
    and byte ptr [bp - 0x2a], dh;
    mov byte ptr [bp - 0x29], 0;
    $1 = $2;
    $1 -= $2;
    mul word ptr [bp - 0xc];
    and ax, 7;
    *($1) = $2;
    mov word ptr [bp - 0x30], 1;
    $1 = $2;
    mul word ptr [bp - 0xc];
    and ax, 7;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0xc];
    and ax, 7;
    // Compare $1 with $2
    jle 0x15da2;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    div bx;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    mov byte ptr [bp - 0x29], 0;
    mov word ptr [bp - 0x34], 0;
    // Compare $1 with $2
    jbe 0x15dc7;
    $1++;
    $1 = $2;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    cmp byte ptr [bp - 0x29], 0;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    $1 = $2;
    $1 = $2;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    $1 = $2;
    $1 = $2;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    cld ;
    $1 = $2;
    shl bx, 1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = pop();
    goto $1;
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    mov word ptr [bx], 0x34c;
    $1 += $2;
    mov word ptr [bx], 0x34c;
    $1 += $2;
    mov word ptr [bx], 0x38b;
    $1 += $2;
    mov word ptr [bx], 0x55b;
    $1 += $2;
    mov byte ptr [0x6f51], 1;
    retf ;
    lds si, ptr [bp + 0xe];
    lds si, ptr [si + 4];
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    goto $1;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    mov byte ptr [bp - 0x22], 0;
    cmp byte ptr [bp - 0x22], 0;
    if (!ZF) goto $1;
    push($1);
    push($1);
    les di, ptr [bp - 0x48];
    lds si, ptr [bp - 0x44];
    $1 = $2;
    // Compare $1 with $2
    jbe 0x15f5f;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    xchg bx, cx;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x15f5f;
    $1 = pop();
    $1 = pop();
    *($1) = $2;
    goto $1;
    shr cx, 1;
    rep movsw word ptr es:[di], word ptr [si];
    rcl cx, 1;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    lds si, ptr [bp - 0x48];
    $1 = $2;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    and al, bl;
    not bl;
    or al, bl;
    and byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x15fb2;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and byte ptr es:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x15fe0;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    $1 = $2;
    not dx;
    and al, bh;
    or al, dh;
    and byte ptr es:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x16018;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x16028;
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x1603b;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x1603b;
    *($1) = $2;
    goto $1;
    $1++;
    cmp byte ptr [bp - 0x22], 3;
    jbe 0x1608e;
    mov byte ptr [bp - 0x22], 0;
    lds si, ptr [bp - 0x44];
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16063;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x16073;
    cmp word ptr [bp - 0x36], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x16086;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16086;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    nop ;
    nop ;
    goto $1;
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jae 0x16101;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jae 0x1611c;
    goto $1;
    lodsb al, byte ptr [si];
    // Compare $1 with $2
    if (ZF) goto $1;
    mov byte ptr es:[di], al;
    $1++;
    loop 0x160e6;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x16142;
    *($1) = $2;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x1615a;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x1616a;
    cmp word ptr [bp - 0x36], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x1617d;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x1617d;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x1618d;
    cmp word ptr [bp - 0x38], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x161a0;
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    jae 0x161a0;
    *($1) = $2;
    goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0xa];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 0x52], 0;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    cmp byte ptr [0x6f50], 1;
    if (ZF) goto $1;
    push($1);
    $1();
    lcall 0x98e, 0x35e;
    or ax, ax;
    jge 0x16218;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x1622b;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [0x54d4], 1;
    if (!ZF) goto $1;
    cmp byte ptr es:[di], 9;
    if (ZF) goto $1;
    lcall 0x98e, 0x18a;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfff9;
    goto $1;
    lds si, ptr [bp + 0xc];
    cmp word ptr [si], 0xca20;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    lds si, ptr [si + 4];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    mov word ptr [bp - 4], 0;
    $1 = $2;
    or ax, ax;
    jge 0x16295;
    neg ax;
    add word ptr [bp - 4], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jb 0x162a3;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    cmp word ptr [bp - 4], ax;
    jbe 0x162b3;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    jbe 0x162c4;
    $1 = $2;
    *($1) = $2;
    mul word ptr [bp - 0x10];
    *($1) = $2;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 6], 0;
    $1 = $2;
    or ax, ax;
    jge 0x162f3;
    neg ax;
    add word ptr [bp - 6], ax;
    $1 = 0;
    *($1) = $2;
    // Compare $1 with $2
    jb 0x16301;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    cmp word ptr [bp - 6], ax;
    jbe 0x16311;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 -= $2;
    $1++;
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    jbe 0x16322;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    mul bx;
    *($1) = $2;
    les di, ptr [bp + 0xc];
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    mov word ptr [bp - 0x2a], 0xffff;
    mov word ptr [bp - 0x2c], 0;
    cmp byte ptr [bp - 0x10], 8;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2;
    $1 = $2;
    mul word ptr [bp - 0x10];
    $1 = $2;
    and cx, 7;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    shr dl, cl;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    and cx, 7;
    $1 = $2;
    shr dh, cl;
    not dh;
    *($1) = $2;
    // Compare $1 with $2
    jl 0x163df;
    $1 = $2;
    *($1) = $2;
    or dh, dh;
    if (ZF) goto $1;
    and byte ptr [bp - 0x2a], dh;
    mov byte ptr [bp - 0x29], 0;
    $1 = $2;
    $1 -= $2;
    mul word ptr [bp - 0x10];
    and ax, 7;
    *($1) = $2;
    mov word ptr [bp - 0x30], 1;
    $1 = $2;
    mul word ptr [bp - 0x10];
    and ax, 7;
    $1 = $2;
    $1 = $2;
    mul word ptr [bp - 0x10];
    and ax, 7;
    // Compare $1 with $2
    jle 0x1640e;
    $1++;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    div bx;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    mov byte ptr [bp - 0x29], 0;
    mov word ptr [bp - 0x34], 0;
    // Compare $1 with $2
    jbe 0x16433;
    $1++;
    $1 = $2;
    $1 += $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1++;
    cmp byte ptr [bp - 0x29], 0;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    *($1) = $2;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    *($1) = $2;
    *($1) = $2;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 0x38];
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    mov byte ptr [bp - 0xa], 0;
    push($1);
    lcall 0x98e, 0xa6;
    or ax, ax;
    jge 0x164cd;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    cld ;
    $1 = $2;
    shl bx, 1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = pop();
    goto $1;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    $1 = $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x78d;
    $1 += $2;
    mov word ptr [bx], 0x83b;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov byte ptr [0x6f50], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    and al, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    shl word ptr [bp - 0x1a], 1;
    $1 = $2;
    cmp word ptr [bp - 0x5c], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    xor byte ptr [bp - 0xa], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x4c];
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16636;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror al, cl;
    $1 = $2;
    goto $1;
    not bl;
    or al, bl;
    and byte ptr es:[di], al;
    goto $1;
    and al, bl;
    xor byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16672;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x166ad;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    goto $1;
    not bh;
    or al, bh;
    and byte ptr es:[di], al;
    goto $1;
    and al, bh;
    xor byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x166e1;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x166f1;
    cmp word ptr [bp - 0x52], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x16704;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16704;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0xa], 1;
    if (ZF) goto $1;
    xor byte ptr [bp - 9], 1;
    if (ZF) goto $1;
    $1 += $2;
    goto $1;
    $1 -= $2;
    $1 -= $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 0x26], 0x10f;
    cmp byte ptr [bp - 0x12], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 0x26], 0x801;
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    add word ptr [bp - 0x1a], ax;
    mov byte ptr [bp - 0xa], 1;
    $1 = $2;
    cmp word ptr [bp - 0x5c], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0xa], 1;
    if (ZF) goto $1;
    test byte ptr [bp - 0x26], 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    shl al, 1;
    $1--;
    // Compare $1 with $2
    jae 0x167f6;
    $1 = $2;
    $1++;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x4c];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = 0;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16854;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16887;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and byte ptr es:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    or ah, ah;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x168c0;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    and byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x168e6;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x168f6;
    cmp word ptr [bp - 0x52], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x16909;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16909;
    *($1) = $2;
    goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp - 0x5c], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jae 0x1699b;
    goto $1;
    lodsb al, byte ptr [si];
    // Compare $1 with $2
    if (ZF) goto $1;
    mov byte ptr es:[di], al;
    $1++;
    loop 0x16982;
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x169c0;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0x169d8;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x169d8;
    *($1) = $2;
    goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    $1 = $2;
    $1 = $2;
    mul dx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    and al, 3;
    *($1) = $2;
    shl word ptr [bp - 0x1a], 1;
    $1 = $2;
    cmp word ptr [bp - 0x5c], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    xor byte ptr [bp - 0xa], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x48];
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x4c];
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cmp byte ptr [bp - 0x30], 1;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16ac1;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror al, cl;
    $1 = $2;
    goto $1;
    not bl;
    or al, bl;
    and byte ptr es:[di], al;
    goto $1;
    and al, bl;
    xor byte ptr es:[di], al;
    $1++;
    $1 = $2;
    or bx, bx;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16afd;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    or bh, bh;
    if (ZF) goto $1;
    cmp byte ptr [bp - 0x34], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16b38;
    *($1) = $2;
    goto $1;
    lodsb al, byte ptr [si];
    $1 = $2;
    ror ax, cl;
    goto $1;
    not bh;
    or al, bh;
    and byte ptr es:[di], al;
    goto $1;
    and al, bh;
    xor byte ptr es:[di], al;
    $1++;
    $1--;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16b6c;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jb 0x16b7c;
    cmp word ptr [bp - 0x52], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x16b8f;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16b8f;
    *($1) = $2;
    goto $1;
    cmp byte ptr [bp - 0xa], 1;
    if (ZF) goto $1;
    $1 -= $2;
    $1++;
    cmp byte ptr [bp - 9], 4;
    jb 0x16bab;
    $1 -= $2;
    mov byte ptr [bp - 9], 0;
    goto $1;
    $1 += $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = $2;
    cmp word ptr [bp - 0x5c], 0;
    if (ZF) goto $1;
    $1 = $2;
    in al, dx;
    test al, 8;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    goto $1;
    or si, si;
    if (!ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    *($1) = $2;
    $1 = pop();
    jae 0x16c2c;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    push($1);
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1 = pop();
    lodsb al, byte ptr [si];
    // Compare $1 with $2
    if (ZF) goto $1;
    mov byte ptr es:[di], al;
    $1++;
    loop 0x16c13;
    $1--;
    if (ZF) goto $1;
    or si, si;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16c65;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0x16c7d;
    $1 = $2;
    $1 = $2;
    clc ;
    lcall 0xb08, 0x17e;
    jae 0x16c7d;
    *($1) = $2;
    goto $1;
    or di, di;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1 += $2;
    jae 0x16ca2;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    goto $1;
    mov word ptr [bp - 2], 0;
    push($1);
    lcall 0xa36, 0x1a5;
    lds si, ptr [bp - 0x3c];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    les di, ptr [bp - 0x40];
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 3;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x16d29;
    // Compare $1 with $2
    jle 0x16d32;
    mov word ptr [bp - 2], 0xf830;
    cdq ;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    cmp byte ptr es:[di], bl;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc19;
    cdq ;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jl 0x16d83;
    // Compare $1 with $2
    jle 0x16d8c;
    mov word ptr [bp - 2], 0xf824;
    cdq ;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    cmp word ptr es:[di], bx;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc19;
    cdq ;
    stc ;
    goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    clc ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xf830;
    $1 = $2;
    // Compare $1 with $2
    jl 0x16dea;
    // Compare $1 with $2
    jg 0x16dea;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xf82f;
    $1 = $2;
    // Compare $1 with $2
    jl 0x16e64;
    // Compare $1 with $2
    jg 0x16e64;
    $1 = $2;
    // Compare $1 with $2
    jl 0x16e64;
    // Compare $1 with $2
    jg 0x16e64;
    $1 = $2;
    // Compare $1 with $2
    jl 0x16e64;
    // Compare $1 with $2
    jg 0x16e64;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xe];
    $1 = $2;
    stosw word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    stosw word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    stosw word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xf82e;
    $1 = $2;
    $1 = $2;
    or dx, dx;
    if (!ZF) goto $1;
    // Compare $1 with $2
    jg 0x16ed6;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    $1 = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    $1 += $2;
    les di, ptr [bp + 6];
    les di, ptr es:[di + 0xa4];
    $1 = 0;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    and bx, 7;
    if (ZF) goto $1;
    $1++;
    shl ax, 1;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    mov word ptr es:[di + 2], dx;
    $1++;
    $1++;
    $1++;
    $1++;
    loop 0x16fca;
    les di, ptr [bp + 6];
    mov word ptr es:[di + 0xa], dx;
    lds si, ptr [bp + 0xc];
    $1 += $2;
    les di, ptr es:[di + 0xa8];
    $1++;
    $1++;
    $1 = $2;
    lodsw ax, word ptr [si];
    $1 -= $2;
    stosw word ptr es:[di], ax;
    loop 0x17006;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    // Compare $1 with $2
    jl 0x1706d;
    cmp word ptr [si + 0x2a], 0;
    jl 0x1706d;
    // Compare $1 with $2
    jl 0x1706d;
    cmp word ptr [si + 0x2e], 0;
    jl 0x1706d;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jg 0x1706d;
    cmp word ptr [si + 0x34], 0;
    if (ZF) goto $1;
    $1 = $2;
    // Compare $1 with $2
    jl 0x1706d;
    // Compare $1 with $2
    jl 0x17074;
    mov word ptr [bp - 2], 0xfc18;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1--;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0x1542, 0;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr es:[di + 8], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov word ptr es:[di + 0xc], ax;
    $1 = $2;
    mov word ptr es:[di + 0xe], ax;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 0x10], ax;
    mov word ptr es:[di + 0x12], 1;
    mov word ptr es:[di + 0x14], 0;
    mov word ptr es:[di + 0x16], 0;
    mov word ptr es:[di + 0x18], 0;
    mov word ptr es:[di + 0x1a], 0;
    mov word ptr es:[di + 0x1c], 0;
    mov word ptr es:[di + 0x20], 0;
    $1 = $2;
    mov word ptr es:[di + 0x22], ax;
    mov word ptr es:[di + 0x1e], ax;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 4], ax;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 6], ax;
    $1 -= $2;
    $1++;
    *($1) = $2;
    $1 += $2;
    les di, ptr [bp + 6];
    les di, ptr es:[di + 0xa4];
    *($1) = $2;
    *($1) = $2;
    cld ;
    $1 = $2;
    $1++;
    rep movsw word ptr es:[di], word ptr [si];
    lds si, ptr [bp + 0xc];
    $1 += $2;
    push($1);
    lcall 0x96b, 0xa0;
    jae 0x17178;
    mov word ptr [bp - 2], 0xfffd;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    lds si, ptr [bp + 6];
    lds si, ptr [si + 0xa4];
    *($1) = $2;
    *($1) = $2;
    les di, ptr [bp + 6];
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    les di, ptr [bp - 0x16];
    $1 = $2;
    push($1);
    $1 = $2;
    and ax, 7;
    *($1) = $2;
    $1 = $2;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    and dx, 7;
    if (ZF) goto $1;
    $1++;
    $1 = $2;
    xor cl, 7;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    $1 = 0;
    or cx, word ptr [bp - 0x24];
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    *($1) = $2;
    *($1) = $2;
    lds si, ptr [bp - 0x12];
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1++;
    shl ax, cl;
    mov byte ptr es:[di], ah;
    $1++;
    if (!ZF) goto $1;
    stc ;
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    jae 0x1723a;
    *($1) = $2;
    goto $1;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1++;
    shl ax, cl;
    and ah, ch;
    mov byte ptr es:[di], ah;
    $1++;
    if (!ZF) goto $1;
    stc ;
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    jae 0x17260;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 0xe];
    $1++;
    $1++;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x12];
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 0xc], 0;
    jge 0x17300;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    cmp word ptr [bp + 0xa], 0;
    jge 0x1730d;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jge 0x1731c;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jge 0x1732b;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    jl 0x173c0;
    // Compare $1 with $2
    jl 0x173c0;
    // Compare $1 with $2
    jg 0x173c0;
    // Compare $1 with $2
    jg 0x173c0;
    clc ;
    goto $1;
    stc ;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x15a7, 6;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xa;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0xa], 8;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x12], 1;
    mov word ptr [si + 0x14], 0;
    mov word ptr [si + 0x16], 0;
    mov word ptr [si + 0x18], 0;
    mov word ptr [si + 0x1a], 0;
    mov word ptr [si + 0x1c], 0;
    mov word ptr [si + 0x20], 0;
    mov word ptr [si + 0x22], 8;
    mov word ptr [si + 0x1e], 8;
    cmp word ptr [bp + 0xa], 6;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 0x10;
    mov word ptr [bp - 0xe], 0x100;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0xff;
    mov word ptr [si + 0xc], 0xc;
    mov word ptr [si + 0xe], 4;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = $2;
    $1 = pop();
    goto $1;
    cmp word ptr [bp + 0xa], 2;
    if (!ZF) goto $1;
    mov word ptr [bp - 4], 0xe;
    mov word ptr [bp - 0xe], 0x100;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0xff;
    mov word ptr [si + 0xc], 0xa;
    mov word ptr [si + 0xe], 4;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = $2;
    $1 = pop();
    goto $1;
    mov word ptr [bp - 4], 8;
    mov word ptr [bp - 0xe], 0x80;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0x7f;
    mov word ptr [si + 0xc], 6;
    mov word ptr [si + 0xe], 2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    lcall 0xae3, 0;
    cmp byte ptr es:[di], 3;
    if (ZF) goto $1;
    cmp byte ptr es:[di], 5;
    if (ZF) goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    goto $1;
    mov word ptr [bp - 0xe], 0x100;
    mov word ptr [si + 6], 0xff;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x10;
    $1 = $2;
    $1 = pop();
    *($1) = $2;
    *($1) = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    push($1);
    lcall 0x5e5, 0x1b0;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    lcall 0x95a, 6;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    lds si, ptr [bp + 6];
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    les di, ptr [bp + 6];
    $1 += $2;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp - 8];
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    mov byte ptr es:[di], al;
    $1 = $2;
    $1 += $2;
    $1++;
    if (!ZF) goto $1;
    stc ;
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    jae 0x17603;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    $1--;
    if (!ZF) goto $1;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lds si, ptr [bp + 6];
    les di, ptr [si + 0xa8];
    cld ;
    $1 = $2;
    $1 = $2;
    rep stosw word ptr es:[di], ax;
    les di, ptr [si + 0xa4];
    $1 = 0;
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 += $2;
    $1++;
    $1++;
    loop 0x17627;
    $1 = $2;
    goto $1;
    lds si, ptr [bp + 6];
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    lds si, ptr [bp + 6];
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    lds si, ptr [bp + 6];
    $1 += $2;
    push($1);
    push($1);
    lcall 0x5e5, 0x2fa;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x15bd, 0xa;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    push($1);
    lea ax, [bp - 0xa];
    push($1);
    lcall 0x18c7, 8;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 6];
    $1 += $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x5e5, 0x1b0;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    lcall 0x95a, 6;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 6];
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = 0;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x79e, 0xc;
    or dx, dx;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0xffe6;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x15c8, 0xe;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    push($1);
    $1 += $2;
    push($1);
    lcall 0x5e5, 0x2fa;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    push($1);
    push($1);
    lcall 0x79e, 0x5d;
    push($1);
    $1 += $2;
    push($1);
    lcall 0x5e5, 0x2fa;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x17808;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc18;
    goto $1;
    push($1);
    push($1);
    lcall 0x1542, 0;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    les di, ptr [bp + 6];
    cld ;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    *($1) = $2;
    or ax, ax;
    jge 0x178c0;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x166;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    lcall 0x1548, 6;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lcall 0x96b, 0x1c0;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x166;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    lcall 0x1539, 0xe;
    *($1) = $2;
    lcall 0x96b, 0x1c0;
    push($1);
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    $1 -= $2;
    shl bx, 1;
    lds si, ptr [bp - 0x60];
    push($1);
    push($1);
    lds si, ptr [si + 0xa8];
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    push($1);
    push($1);
    lds si, ptr [si + 0xa4];
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    cmp word ptr [bp - 0x24], 0;
    jg 0x179a0;
    mov word ptr [bp - 2], 0xfc16;
    goto $1;
    $1 += $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 4], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    cmp word ptr [bp - 0x48], 2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp - 0x48], 1;
    if (ZF) goto $1;
    cmp word ptr [bp - 0x48], 3;
    if (ZF) goto $1;
    goto $1;
    $1 = 0;
    $1 = $2;
    cmp word ptr [bp - 0x84], 1;
    if (ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], dx;
    goto $1;
    cmp word ptr [bp - 0x84], 1;
    if (ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 8], dx;
    goto $1;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0x9c], 0xff;
    cmp word ptr [bp - 0x92], 1;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jle 0x17a71;
    goto $1;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jge 0x17a7e;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jle 0x17a8a;
    goto $1;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jge 0x17a97;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], ax;
    jge 0x17ab9;
    $1 -= $2;
    $1 = $2;
    and ax, 0xf8;
    and cx, 7;
    ror word ptr [bp - 0x9c], cl;
    add word ptr [bp + 8], ax;
    add word ptr [bp - 0x98], ax;
    sub word ptr [bp - 0x7a], ax;
    $1 = $2;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jle 0x17acd;
    $1 -= $2;
    sub word ptr [bp - 0x7a], ax;
    $1 = $2;
    // Compare $1 with $2
    jge 0x17ae7;
    $1 = $2;
    $1 -= $2;
    add word ptr [bp + 6], ax;
    add word ptr [bp - 0x9a], ax;
    sub word ptr [bp - 0x7c], ax;
    $1 = $2;
    $1 += $2;
    $1--;
    // Compare $1 with $2
    jle 0x17afb;
    $1 -= $2;
    sub word ptr [bp - 0x7c], ax;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    div bx;
    or dx, dx;
    if (ZF) goto $1;
    $1++;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xor cl, al;
    $1++;
    and cl, 7;
    $1 = $2;
    shl ch, cl;
    *($1) = $2;
    les di, ptr [bp - 0x58];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    shl bx, 1;
    ljmp es:[bx + di];
    ljmp 0x189a:8;
    mov word ptr [bp - 2], 0;
    retf ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr [bx], 0;
    mov word ptr [bx + 2], 0x1641;
    $1 += $2;
    mov word ptr [bx], 0x77a;
    mov word ptr [bx + 2], 0x1641;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 6;
    mov word ptr [bx + 2], 0x1805;
    $1 += $2;
    mov word ptr [bx], 6;
    mov word ptr [bx + 2], 0x1705;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x160f;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2;
    mov word ptr [bx], 0xa;
    mov word ptr [bx + 2], 0x181e;
    $1 += $2;
    mov byte ptr [0x712c], 1;
    retf ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 0x1e], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr es:[di + 0x20], 0;
    push($1);
    push($1);
    mov word ptr es:[0x712e], 1;
    mov word ptr es:[0x7130], 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1++;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1--;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1--;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1++;
    mov word ptr [si + 0x18], 0x20;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x17b8, 0x342;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    $1 = $2;
    mov word ptr es:[di + 0x1e], dx;
    $1 = $2;
    mov word ptr es:[di + 0x20], dx;
    retf ;
    $1 = $2;
    // Compare $1 with $2
    jge 0x17d05;
    $1 += $2;
    $1 = $2;
    xor al, 7;
    $1++;
    and al, 7;
    *($1) = $2;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl bx, cl;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    cmp byte ptr [bp - 0xa2], 1;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x2a], 0;
    if (ZF) goto $1;
    mov word ptr [bp - 0x2a], 0xf;
    cmp word ptr [bp - 0x2c], 0;
    if (ZF) goto $1;
    mov word ptr [bp - 0x2c], 0xf;
    $1 = $2;
    cld ;
    cmp word ptr [bp - 0xa], 0xff00;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], 0xff;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    not ah;
    out dx, ax;
    and byte ptr es:[di], bl;
    $1++;
    $1++;
    loop 0x17d92;
    $1 = pop();
    $1 = pop();
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    cwde ;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    and bl, ch;
    $1 = $2;
    and ah, byte ptr [bp - 0x9c];
    $1 = 0;
    push($1);
    shl ax, cl;
    shl bx, cl;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop();
    $1 = $2;
    cmp byte ptr [bp - 0xa0], 0;
    if (!ZF) goto $1;
    $1 = $2;
    rol bx, cl;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lodsw ax, word ptr [si];
    $1--;
    test cl, cl;
    if (!ZF) goto $1;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    rol ax, cl;
    cmp word ptr [bp + 8], 0;
    jl 0x17e3a;
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    and ah, byte ptr [bp - 0xa0];
    out dx, ax;
    and byte ptr es:[di], bh;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    not ah;
    and ah, byte ptr [bp - 0xa0];
    out dx, ax;
    and byte ptr es:[di], bl;
    $1 = pop();
    $1 = pop();
    $1++;
    $1--;
    $1--;
    jg 0x17e47;
    $1 = $2;
    and byte ptr [bp - 0x1e], bl;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    and ah, byte ptr [bp - 0x9f];
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    not ah;
    and ah, byte ptr [bp - 0x9f];
    out dx, ax;
    and byte ptr es:[di], bl;
    goto $1;
    push($1);
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    not ah;
    out dx, ax;
    and byte ptr es:[di], bl;
    $1 = pop();
    $1++;
    lodsw ax, word ptr [si];
    $1--;
    rol ax, cl;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    xchg al, ah;
    and ah, byte ptr [bp - 0x1e];
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    not ah;
    and ah, byte ptr [bp - 0x1e];
    out dx, ax;
    and byte ptr es:[di], bl;
    $1 = pop();
    and ah, byte ptr [bp - 0x20];
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di + 1], bh;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    not ah;
    and ah, byte ptr [bp - 0x20];
    out dx, ax;
    and byte ptr es:[di + 1], bl;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 += $2;
    $1 += $2;
    $1--;
    if (ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    mov word ptr [bp - 2], 0;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0x28], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 0x10], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x17f66;
    // Compare $1 with $2
    jbe 0x17f69;
    goto $1;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    // Compare $1 with $2
    jge 0x17f81;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    cmp word ptr [bp - 0xa], 0xff00;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], 0xff;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    $1++;
    loop 0x17fae;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test bl, bl;
    if (!ZF) goto $1;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    cmp word ptr [bp + 8], 0;
    jl 0x17fe0;
    and ah, byte ptr [bp - 0xa0];
    out dx, ax;
    and byte ptr es:[di], bh;
    $1 = $2;
    $1++;
    $1--;
    $1--;
    jg 0x17fed;
    $1 = $2;
    and byte ptr [bp - 0x1e], ah;
    goto $1;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    $1 = $2;
    out dx, ax;
    goto $1;
    and byte ptr es:[di], bh;
    $1++;
    loop 0x17ffa;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di], bh;
    $1 = $2;
    out dx, ax;
    and byte ptr es:[di + 1], bh;
    retf ;
    $1 = $2;
    shl cx, 1;
    and cl, 7;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    loop 0x18028;
    not dx;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    loop 0x1803e;
    *($1) = $2;
    not dx;
    *($1) = $2;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    $1 = $2;
    and word ptr [bp - 0xa0], ax;
    not ax;
    or word ptr [bp - 0x9e], ax;
    and byte ptr [bp - 9], bl;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xlatb ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    xlatb ;
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    test ax, 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], -1;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    not dx;
    xchg dl, dh;
    and word ptr es:[di], dx;
    and ax, word ptr [bp - 0x2a];
    xchg al, ah;
    or word ptr es:[di], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or ax, dx;
    xchg al, ah;
    mov word ptr es:[di], ax;
    $1++;
    $1++;
    $1++;
    loop 0x180d6;
    $1 = pop();
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    and al, byte ptr [bp - 0x9b];
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di], ax;
    $1 = $2;
    and al, byte ptr [bp - 0x9c];
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di + 1], ax;
    and dx, word ptr [bp - 0x2a];
    and dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = 0;
    $1 = $2;
    not ax;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = 0;
    $1 = $2;
    not ax;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    and dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di + 1], ax;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    and word ptr es:[di + 1], ax;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    $1++;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    and al, ch;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di + 1], ax;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    and dx, word ptr [bp - 0xa0];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    $1++;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    and al, byte ptr [bp - 0x9b];
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 = $2;
    and al, byte ptr [bp - 0x9c];
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    and dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di + 1], ax;
    $1++;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    and al, ch;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    and ax, word ptr [bp - 0xa0];
    not dx;
    and dx, word ptr [bp - 0x2c];
    and dx, word ptr [bp - 0xa0];
    or dx, ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di + 1], ax;
    $1++;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    not word ptr [bp - 0x9c];
    push($1);
    push($1);
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    or dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    or dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    $1++;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    and al, ch;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    or dx, word ptr [bp - 0x9e];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    or dx, word ptr [bp - 0x9e];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    $1++;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    and dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    and dx, word ptr [bp - 0x9c];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    $1++;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    and al, ch;
    $1 = 0;
    $1 = $2;
    shr al, 1;
    rcr dx, 1;
    sar dx, 1;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    not dx;
    and dx, word ptr [bp - 0x2c];
    or dx, ax;
    and dx, word ptr [bp - 0xa0];
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    $1++;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    mov word ptr [bp - 2], 0;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0x28], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 0x10], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x186b1;
    // Compare $1 with $2
    jbe 0x186b4;
    goto $1;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    $1 += $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    cld ;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], -1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    and ax, word ptr [bp - 0x2a];
    mov word ptr es:[di], ax;
    $1++;
    $1++;
    loop 0x186e1;
    goto $1;
    $1 = $2;
    $1--;
    if (ZF) goto $1;
    $1 = $2;
    and dx, word ptr [bp - 0x2a];
    and dx, word ptr [bp - 0x9c];
    $1 = 0;
    $1 = $2;
    not ax;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = 0;
    $1 = $2;
    not ax;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    goto $1;
    $1 = $2;
    and dx, word ptr [bp - 0x2a];
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    and word ptr es:[di + 1], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    and dx, word ptr [bp - 0x2a];
    and dx, word ptr [bp - 0xa0];
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1 = $2;
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di + 1], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di + 1], ax;
    retf ;
    $1 = $2;
    // Compare $1 with $2
    jge 0x18795;
    $1 += $2;
    push($1);
    and cl, 7;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    ror ax, cl;
    xchg al, ah;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    *($1) = $2;
    $1 = pop();
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    $1 = $2;
    or word ptr [bp - 0x9e], ax;
    and byte ptr [bp - 9], bl;
    mov word ptr [bp - 8], 0xffff;
    cmp word ptr [bp - 0x2a], 0;
    if (ZF) goto $1;
    mov word ptr [bp - 8], 0;
    mov word ptr [bp - 0x2a], 0xffff;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    test ax, 1;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp - 0x28], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0xa], 0xff00;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], 0xff00;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    not ah;
    and byte ptr es:[di], ah;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    or byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    mov byte ptr es:[di], al;
    $1++;
    $1++;
    loop 0x18841;
    $1 = pop();
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    ror dx, cl;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (!ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    or ax, word ptr [bp - 0x9c];
    cmp word ptr [bp + 8], 0;
    jge 0x188c4;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x188e1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x188f4;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x1890f;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    goto $1;
    and word ptr es:[di], dx;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    or ax, word ptr [bp - 0x9e];
    cmp word ptr [bp + 8], 0;
    jge 0x1896d;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x1898d;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = 0;
    or word ptr es:[di], ax;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x189a6;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x189c5;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    $1++;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18a00;
    xor byte ptr es:[di], ah;
    goto $1;
    xor word ptr es:[di], ax;
    goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    and al, ch;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18a31;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xor byte ptr es:[di], ah;
    goto $1;
    xor word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = $2;
    ror ax, cl;
    or ax, word ptr [bp - 0x9c];
    cmp word ptr [bp + 8], 0;
    jge 0x18a6a;
    and byte ptr es:[di], ah;
    goto $1;
    and word ptr es:[di], ax;
    goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = $2;
    and al, ch;
    ror ax, cl;
    or ax, word ptr [bp - 0x9e];
    cmp word ptr [bp + 8], 0;
    jge 0x18a9d;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    and byte ptr es:[di], ah;
    goto $1;
    and word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18ad5;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18b04;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    xor word ptr [bp - 4], 0xc050;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    mov word ptr [bp - 2], 0;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0x28], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 0x10], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x18b78;
    // Compare $1 with $2
    jbe 0x18b7b;
    goto $1;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    // Compare $1 with $2
    jge 0x18b93;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp - 0xa], 0xff00;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], 0xff00;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    not ah;
    and byte ptr es:[di], ah;
    xor al, byte ptr [bp - 8];
    or byte ptr es:[di], al;
    $1++;
    loop 0x18bb9;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    ror dx, cl;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x18bec;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18c07;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    and word ptr es:[di], dx;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x18c33;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18c52;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    retf ;
    $1 = $2;
    // Compare $1 with $2
    jge 0x18c61;
    $1 += $2;
    push($1);
    and cl, 7;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    ror ax, cl;
    xchg al, ah;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    *($1) = $2;
    $1 = pop();
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    $1 = $2;
    or word ptr [bp - 0x9e], ax;
    and byte ptr [bp - 9], bl;
    mov word ptr [bp - 8], 0xffff;
    cmp word ptr [bp - 0x2a], 0;
    if (ZF) goto $1;
    mov word ptr [bp - 8], 0;
    mov word ptr [bp - 0x2a], 0xffff;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    and al, 3;
    mov byte ptr [bp - 6], 4;
    sub byte ptr [bp - 6], al;
    $1 = $2;
    cld ;
    cmp word ptr [bp - 0x28], 0;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0xa], 0xff00;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], 0xff00;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    not ah;
    and byte ptr es:[di], ah;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    or byte ptr es:[di], al;
    goto $1;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    mov byte ptr es:[di], al;
    $1++;
    $1++;
    loop 0x18d08;
    $1 = pop();
    $1 = pop();
    $1 += $2;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    ror dx, cl;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (!ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    or ax, word ptr [bp - 0x9c];
    cmp word ptr [bp + 8], 0;
    jge 0x18d94;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18db1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x18dc4;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18ddf;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    goto $1;
    and word ptr es:[di], dx;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1++;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 0x20;
    if (ZF) goto $1;
    $1 = $2;
    $1 = 0;
    ror ax, cl;
    not ax;
    or ax, word ptr [bp - 0x9e];
    cmp word ptr [bp + 8], 0;
    jge 0x18e3d;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    and al, byte ptr [si];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18e5d;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = 0;
    or word ptr es:[di], ax;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x18e76;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18e95;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    $1++;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18ed9;
    xor byte ptr es:[di], ah;
    goto $1;
    xor word ptr es:[di], ax;
    goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    xor word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    and al, ch;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18f0a;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xor byte ptr es:[di], ah;
    goto $1;
    xor word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = $2;
    ror ax, cl;
    or ax, word ptr [bp - 0x9c];
    cmp word ptr [bp + 8], 0;
    jge 0x18f4c;
    and byte ptr es:[di], ah;
    goto $1;
    and word ptr es:[di], ax;
    goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = $2;
    ror ax, cl;
    and word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = $2;
    and al, ch;
    ror ax, cl;
    or ax, word ptr [bp - 0x9e];
    cmp word ptr [bp + 8], 0;
    jge 0x18f7f;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    and byte ptr es:[di], ah;
    goto $1;
    and word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    $1--;
    if (ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x18fc0;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x18fef;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    $1 += $2;
    $1 = pop();
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    $1 -= $2;
    mov byte ptr [bp - 6], 4;
    $1 = pop();
    $1--;
    if (ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    mov word ptr [bp - 2], 0;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0x28], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 0x10], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x1906c;
    // Compare $1 with $2
    jbe 0x1906f;
    goto $1;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    mul bx;
    push($1);
    $1 = $2;
    // Compare $1 with $2
    jge 0x19087;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    lcall es:[di + 0x26];
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp - 0xa], 0xff00;
    if (!ZF) goto $1;
    cmp word ptr [bp - 0x9c], 0xff00;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    not ah;
    and byte ptr es:[di], ah;
    xor al, byte ptr [bp - 8];
    or byte ptr es:[di], al;
    $1++;
    loop 0x190ad;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    ror dx, cl;
    $1--;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x190e0;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    and ax, word ptr [bp - 0xa0];
    cmp word ptr [bp + 8], 0;
    jge 0x190fb;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    goto $1;
    and word ptr es:[di], dx;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    ror ax, cl;
    or word ptr es:[di], ax;
    $1++;
    $1--;
    if (!ZF) goto $1;
    $1 = $2;
    cmp word ptr [bp + 8], 0;
    jge 0x19127;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    xchg al, ah;
    $1 = $2;
    and word ptr es:[di], ax;
    $1 = $2;
    xor al, byte ptr [bp - 8];
    $1 = 0;
    and al, ch;
    ror ax, cl;
    cmp word ptr [bp + 8], 0;
    jge 0x19146;
    cmp word ptr [bp - 0xe], 1;
    if (!ZF) goto $1;
    or byte ptr es:[di], ah;
    goto $1;
    or word ptr es:[di], ax;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    lea ax, [bp - 8];
    push($1);
    lcall 0x96b, 0x66;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 8], ax;
    *($1) = $2;
    $1 = $2;
    mov word ptr es:[di + 0xc], ax;
    $1 = $2;
    mov word ptr es:[di + 0xe], ax;
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x14], ax;
    $1 = $2;
    mov word ptr es:[di + 0x16], ax;
    $1 = $2;
    mov word ptr es:[di + 0x18], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1a], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1c], ax;
    $1 = $2;
    mov word ptr es:[di + 0x20], ax;
    $1 = $2;
    mov word ptr es:[di + 0x1e], ax;
    mov word ptr es:[di + 0xa], ax;
    *($1) = $2;
    test word ptr [si + 0x18], 0x10;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    $1 = $2;
    *($1) = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    goto $1;
    mov word ptr [bp - 0xe], 0;
    cmp word ptr [si + 0x16], 0;
    if (ZF) goto $1;
    cmp word ptr [si + 0x16], 2;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0xe], 1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0xb08, 0x2e7;
    // Compare $1 with $2
    jb 0x1923f;
    mov word ptr [bp - 2], 0xfffe;
    goto $1;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 0xa6], ax;
    mov word ptr es:[di + 0xaa], ax;
    $1 = $2;
    $1 += $2;
    $1++;
    mov word ptr es:[di + 0xa4], ax;
    $1++;
    $1++;
    mov word ptr es:[di + 0xa8], ax;
    lds si, ptr es:[di + 0xa4];
    mov word ptr [si], 0;
    lds si, ptr es:[di + 0xa8];
    $1 = $2;
    cmp word ptr [bp - 0xe], 0;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1++;
    $1++;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x5e5, 6;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x95a, 6;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 0xa], 0;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x27c;
    mov word ptr [bp - 0xe], 0x30c;
    goto $1;
    cmp word ptr [bp + 0xa], 1;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x284;
    mov word ptr [bp - 0xe], 0x311;
    goto $1;
    cmp word ptr [bp + 0xa], 2;
    if (!ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x28c;
    mov word ptr [bp - 0xe], 0x313;
    goto $1;
    cmp word ptr [bp + 0xa], 3;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc15;
    goto $1;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 0xc], 0x294;
    mov word ptr [bp - 0xe], 0x315;
    goto $1;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    lcall 0x185d, 4;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 0x10];
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 0xc];
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp - 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    test word ptr [si + 0x18], 0x10;
    if (ZF) goto $1;
    $1 = $2;
    $1 -= $2;
    les di, ptr es:[di + 0xa8];
    mov word ptr es:[di], bx;
    goto $1;
    $1 = $2;
    *($1) = $2;
    cmp word ptr [bp + 0xa], 0;
    if (ZF) goto $1;
    cmp word ptr [bp + 0xa], 2;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    add word ptr [bp - 0x10], bx;
    goto $1;
    $1 = $2;
    sub word ptr [bp - 0x12], bx;
    goto $1;
    $1 = $2;
    sub word ptr [bp - 0x10], bx;
    goto $1;
    $1 = $2;
    add word ptr [bp - 0x12], bx;
    goto $1;
    cmp word ptr [bp - 8], 0;
    if (ZF) goto $1;
    mov word ptr [bp - 0x18], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x1e], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x20], 0;
    cmp word ptr [0x7132], 1;
    if (!ZF) goto $1;
    mov word ptr [bp - 0x18], 1;
    mov word ptr [0x7132], 0;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x17b8, 0x342;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0x185d, 4;
    $1 = $2;
    $1 = $2;
    goto $1;
    $1 += $2;
    goto $1;
    goto $1;
    goto $1;
    $1 += $2;
    goto $1;
    les di, ptr [bp + 0x10];
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xc];
    mov word ptr es:[di], bx;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xe;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x10], 1;
    if (!ZF) goto $1;
    lcall 0x1568, 0x11d;
    jb 0x194c8;
    $1 = $2;
    cmp word ptr [si + 4], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    mul dx;
    $1 += $2;
    lcall [si + 4];
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    test al, al;
    if (ZF) goto $1;
    or byte ptr es:[di], al;
    goto $1;
    test al, al;
    if (!ZF) goto $1;
    not ah;
    and byte ptr es:[di], ah;
    goto $1;
    test al, al;
    if (ZF) goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    not ah;
    and byte ptr es:[di], ah;
    or byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, ah;
    xor cl, ah;
    shl cl, 1;
    $1 = $2;
    and al, ah;
    shl ax, cl;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[di], al;
    goto $1;
    not ah;
    or al, ah;
    and byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    not ah;
    and byte ptr es:[di], ah;
    or byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    lds si, ptr [si + 6];
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and al, 1;
    shl ax, cl;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    test al, al;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    or byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    jae 0x1965c;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    $1 = pop();
    goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    and byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    jae 0x1968d;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    $1 = pop();
    goto $1;
    goto $1;
    test al, al;
    if (!ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    xor byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    jae 0x196bc;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    $1 = pop();
    goto $1;
    goto $1;
    not ah;
    $1 = $2;
    $1 = $2;
    and byte ptr es:[di], ah;
    or byte ptr es:[di], al;
    $1--;
    if (ZF) goto $1;
    shr bl, 1;
    $1 = $2;
    and al, 1;
    shl al, cl;
    $1 += $2;
    jae 0x196e7;
    push($1);
    $1 = $2;
    $1 = $2;
    stc ;
    lcall 0xb08, 0x17e;
    $1 = pop();
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    or byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    mov byte ptr es:[di], al;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [0x7132], 1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [0x7132], 0;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    lea ax, [bp - 0x82];
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x712c], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x216;
    cmp word ptr [0x7132], 1;
    if (!ZF) goto $1;
    $1 = $2;
    mul word ptr [bp + 8];
    *($1) = $2;
    $1 = $2;
    mul word ptr [bp + 6];
    *($1) = $2;
    lcall 0x98e, 0x35e;
    // Compare $1 with $2
    jge 0x1989d;
    // Compare $1 with $2
    jle 0x1987d;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 4], 1;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfffa;
    goto $1;
    $1 = 0;
    lcall 0x98e, 0x249;
    $1 = 0;
    *($1) = $2;
    push($1);
    lcall 0x98e, 0x12a;
    jae 0x198b0;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0xa6;
    or ax, ax;
    jge 0x198cb;
    mov word ptr [bp - 2], 0xfc19;
    goto $1;
    *($1) = $2;
    les di, ptr [bp - 0x58];
    push($1);
    lea ax, [bp - 0x60];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 0x60];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    $1 += $2;
    *($1) = $2;
    test word ptr [si + 0x18], 0x10;
    if (!ZF) goto $1;
    mov word ptr [bp - 0x32], 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cmp word ptr es:[di + 0x1e], 0;
    if (ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 8], ax;
    cmp word ptr es:[di + 0x20], 0;
    if (ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 6], ax;
    push($1);
    lea ax, [bp - 0x4c];
    push($1);
    push($1);
    lea ax, [bp - 0x4e];
    push($1);
    lcall 0x96b, 0x66;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 0x60];
    lds si, ptr [si + 0xa8];
    push($1);
    les di, ptr [bp - 0x4c];
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    les di, ptr [bp + 0xa];
    cld ;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    $1--;
    // Compare $1 with $2
    ja 0x199e8;
    mov word ptr [bp - 2], 0;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x44], 0;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jb 0x19a28;
    // Compare $1 with $2
    ja 0x19a28;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    $1 -= $2;
    shl bx, 1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    add word ptr [bp - 0x44], ax;
    $1++;
    loop 0x199fa;
    $1 = $2;
    // Compare $1 with $2
    jbe 0x19a47;
    push($1);
    push($1);
    lcall 0x1754, 0xa;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    push($1);
    $1();
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    *($1) = $2;
    push($1);
    lcall 0x1865, 0x1cd;
    // Compare $1 with $2
    jle 0x19aaa;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x15d6, 8;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    cmp word ptr [bp - 0x42], 1;
    jbe 0x19aaa;
    push($1);
    lea ax, [bp - 0x8a];
    push($1);
    push($1);
    lea ax, [bp - 0x8c];
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x1754, 0x18b;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1++;
    $1--;
    if (!ZF) goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    lea ax, [bp - 4];
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 6;
    $1 = $2;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    sub word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    sub word ptr [bp + 6], ax;
    goto $1;
    cmp word ptr [bp - 0x48], 1;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    add word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 6], ax;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1--;
    sub word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    sub word ptr [bp + 8], ax;
    goto $1;
    cmp word ptr [bp - 0x48], 2;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    add word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    add word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    sub word ptr [bp + 6], ax;
    goto $1;
    cmp word ptr [bp - 0x48], 3;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    sub word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 8], ax;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    shr ax, 1;
    sub word ptr [bp + 8], ax;
    goto $1;
    retf ;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x94;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x85;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x8a;
    goto $1;
    mov word ptr [bp - 0x5c], 0x8f;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    // Compare $1 with $2
    jbe 0x19cb5;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    stc ;
    rcl bh, 1;
    jb 0x19cc4;
    shl ah, 1;
    goto $1;
    shl ah, 1;
    jb 0x19cd2;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    mov byte ptr es:[di], al;
    $1++;
    loop 0x19cb8;
    $1 = pop();
    // Compare $1 with $2
    jbe 0x19cf5;
    $1 -= $2;
    goto $1;
    $1 += $2;
    jae 0x19d10;
    push($1);
    push($1);
    clc ;
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    $1 = pop();
    $1 = pop();
    jae 0x19d10;
    *($1) = $2;
    goto $1;
    $1 += $2;
    $1--;
    if (!ZF) goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    mov word ptr [bp - 2], 0;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 0x10], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x19d6c;
    // Compare $1 with $2
    jbe 0x19d6e;
    goto $1;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    $1 += $2;
    lcall es:[di + 0x26];
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x193;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x184;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x189;
    goto $1;
    mov word ptr [bp - 0x5c], 0x18e;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    rcl bh, 1;
    jae 0x19de6;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    mov byte ptr es:[di], al;
    $1++;
    loop 0x19dcc;
    retf ;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x97;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x9c;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0xa1;
    goto $1;
    mov word ptr [bp - 0x5c], 0xa6;
    goto $1;
    $1 = $2;
    $1 = $2;
    push($1);
    // Compare $1 with $2
    jbe 0x19e57;
    $1 = $2;
    lodsb al, byte ptr [si];
    $1 = $2;
    $1 = $2;
    stc ;
    rcl bh, 1;
    jb 0x19e66;
    shl ah, 1;
    goto $1;
    shl ah, 1;
    jb 0x19e74;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    mov byte ptr es:[di], al;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x19e5a;
    $1 = pop();
    // Compare $1 with $2
    jbe 0x19ea9;
    $1 -= $2;
    goto $1;
    $1 += $2;
    jae 0x19ec4;
    push($1);
    push($1);
    clc ;
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    $1 = pop();
    $1 = pop();
    jae 0x19ec4;
    *($1) = $2;
    goto $1;
    $1 += $2;
    jae 0x19ed7;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    $1--;
    if (ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (ZF) goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    goto $1;
    push($1);
    lcall 0xa36, 0x1a5;
    mov word ptr [bp - 2], 0;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0x28], 0;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr es:[di + 0x10], 1;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jb 0x19f46;
    // Compare $1 with $2
    jbe 0x19f49;
    goto $1;
    les di, ptr [bp - 0x58];
    $1 = $2;
    $1 = $2;
    $1 += $2;
    lcall es:[di + 0x26];
    $1 = $2;
    *($1) = $2;
    push($1);
    push($1);
    lcall 0xa36, 0xe;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    cld ;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x1eb;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x1dc;
    goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    mov word ptr [bp - 0x5c], 0x1e1;
    goto $1;
    mov word ptr [bp - 0x5c], 0x1e6;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    stc ;
    rcl bh, 1;
    jae 0x19fce;
    goto $1;
    xor byte ptr es:[di], al;
    goto $1;
    and byte ptr es:[di], al;
    goto $1;
    or byte ptr es:[di], al;
    goto $1;
    mov byte ptr es:[di], al;
    $1++;
    if (!ZF) goto $1;
    $1++;
    push($1);
    push($1);
    lcall 0xa36, 0x63;
    loop 0x19fb4;
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x12], ax;
    $1 = $2;
    mov word ptr es:[di + 0x14], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    $1 = $2;
    xchg al, ah;
    or ax, bx;
    mov word ptr es:[di + 0x10], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x18], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x1e], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x20], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x1c], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    les di, ptr [bp - 6];
    $1 = $2;
    mov word ptr es:[di + 0x1a], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], 2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], 3;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp word ptr [si], 0xca10;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc17;
    goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr es:[di], si;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [si];
    cmp word ptr es:[di], 0xca10;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc17;
    goto $1;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cld ;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 0x16];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 0x16];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 8], 0;
    test word ptr [si + 0x18], 0x10;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    push($1);
    lea ax, [bp - 0x10];
    push($1);
    push($1);
    lea ax, [bp - 0x12];
    push($1);
    lcall 0x96b, 0x66;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 6];
    les di, ptr [bp - 0x10];
    push($1);
    cld ;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1();
    // Compare $1 with $2
    ja 0x1a366;
    mov word ptr [bp - 2], 0;
    goto $1;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    lds si, ptr [si + 0xa8];
    les di, ptr [bp + 6];
    $1 = $2;
    lds si, ptr [bp - 0x16];
    lds si, ptr [si + 0xa8];
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jb 0x1a3b2;
    // Compare $1 with $2
    ja 0x1a3b2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    $1 -= $2;
    shl bx, 1;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    jle 0x1a3b2;
    $1 += $2;
    add word ptr [bp - 2], ax;
    $1++;
    loop 0x1a37f;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    push($1);
    lea ax, [bp - 0x82];
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 6];
    $1 = $2;
    $1 = 0;
    // Compare $1 with $2
    jb 0x1a451;
    // Compare $1 with $2
    jbe 0x1a458;
    mov word ptr [bp - 2], 0xfc16;
    goto $1;
    $1 -= $2;
    shl bx, 1;
    lds si, ptr [si + 0xa8];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp word ptr [si], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    $1 = $2;
    $1 = $2;
    mul bl;
    // Compare $1 with $2
    jbe 0x1a51a;
    shr ax, 1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1++;
    $1--;
    mov word ptr es:[di + 0xa], ax;
    $1 = $2;
    mov word ptr es:[di + 8], ax;
    mov word ptr es:[di + 6], si;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    mov word ptr [si + 4], 0;
    mov word ptr [bp - 2], 0;
    les di, ptr [si + 6];
    cmp word ptr es:[di], 0xca00;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xffe4;
    goto $1;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 2;
    mov word ptr [bp - 0x66], 0;
    mov word ptr [bp - 0x70], 0;
    push($1);
    lea ax, [bp - 0x6e];
    push($1);
    lcall 0x188a, 0xa;
    lds si, ptr [bp - 0x64];
    les di, ptr [bp - 0x6e];
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 2;
    *($1) = $2;
    mov word ptr es:[di + 0x28], 2;
    mov word ptr es:[di + 0x2a], 2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = 0;
    cmp word ptr [bp - 0x48], 0;
    if (ZF) goto $1;
    cmp word ptr [bp - 0x48], 2;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cmp word ptr [bp - 0x48], 1;
    if (ZF) goto $1;
    cmp word ptr [bp - 0x48], 3;
    if (ZF) goto $1;
    goto $1;
    $1 = 0;
    $1 = $2;
    cmp word ptr [bp - 0x84], 1;
    if (ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 6], dx;
    goto $1;
    cmp word ptr [bp - 0x84], 1;
    if (ZF) goto $1;
    $1 = $2;
    sub word ptr [bp + 8], dx;
    goto $1;
    $1 = 0;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb08, 0xa;
    or dx, dx;
    if (!ZF) goto $1;
    *($1) = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp - 0x6e];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    *($1) = $2;
    shl ax, 1;
    shl ax, 1;
    shl ax, 1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1++;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    cld ;
    $1 = $2;
    push($1);
    // Compare $1 with $2
    jbe 0x1a6cc;
    $1 = $2;
    $1 = 0;
    lodsb al, byte ptr [si];
    *($1) = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    shl al, 1;
    *($1) = $2;
    jb 0x1a6eb;
    test word ptr [bp - 0x2e], 0x20;
    if (!ZF) goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x1787, 8;
    $1 = pop();
    $1 = pop();
    $1++;
    loop 0x1a6d2;
    $1 = pop();
    // Compare $1 with $2
    jbe 0x1a70e;
    $1 -= $2;
    goto $1;
    $1 += $2;
    jb 0x1a71d;
    cmp word ptr [bp - 0x66], 0;
    if (ZF) goto $1;
    // Compare $1 with $2
    jb 0x1a732;
    push($1);
    clc ;
    $1 = $2;
    $1 = $2;
    lcall 0xb08, 0x17e;
    $1 = pop();
    jae 0x1a732;
    *($1) = $2;
    goto $1;
    $1++;
    $1 = $2;
    *($1) = $2;
    $1--;
    if (ZF) goto $1;
    goto $1;
    test word ptr [bp - 0x2e], 5;
    if (!ZF) goto $1;
    goto $1;
    lds si, ptr [bp - 0x60];
    test word ptr [bp - 0x2e], 4;
    if (!ZF) goto $1;
    goto $1;
    push($1);
    $1();
    test word ptr [bp - 0x2e], 1;
    if (ZF) goto $1;
    lcall 0x15d6, 0x2f0;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 0x64];
    les di, ptr [bp - 0x6e];
    mov word ptr [si + 0x28], 0;
    mov word ptr [si + 0x2a], 4;
    mov word ptr es:[di + 0x28], 0;
    mov word ptr es:[di + 0x2a], 4;
    retf ;
    cmp word ptr [bp - 0x48], 0;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0x1787, 8;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1++;
    loop 0x1a79c;
    retf ;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x12];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xe];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [bp + 0xc], 0;
    jge 0x1a81b;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    cmp word ptr [bp + 0xa], 0;
    jge 0x1a828;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jge 0x1a837;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    // Compare $1 with $2
    jge 0x1a846;
    mov word ptr [bp - 2], 0xffe5;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = 0;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    jge 0x1a8a8;
    *($1) = $2;
    goto $1;
    *($1) = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lea ax, [bp - 0xe];
    push($1);
    push($1);
    lea ax, [bp - 0x10];
    push($1);
    lcall 0x96b, 0x166;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 0xe];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    mov word ptr es:[di], ax;
    $1 += $2;
    jae 0x1a8f2;
    mov word ptr [bp - 2], 0xfc18;
    goto $1;
    $1 = $2;
    $1 -= $2;
    $1++;
    $1 = 0;
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    and bx, 7;
    if (ZF) goto $1;
    $1++;
    shl ax, 1;
    shl ax, 1;
    shl ax, 1;
    $1 += $2;
    $1++;
    $1++;
    loop 0x1a8fb;
    les di, ptr [bp + 0xa];
    mov word ptr es:[di], dx;
    mov word ptr [bp - 2], 0;
    lcall 0x96b, 0x1c0;
    push($1);
    push($1);
    lcall 0x80c, 0x640;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x10;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    goto $1;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0xb08, 0x2e7;
    test dx, 0x8000;
    if (!ZF) goto $1;
    $1 = $2;
    $1 += $2;
    $1 += $2;
    adc dx, 0;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1();
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 4;
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x16];
    mov word ptr [si], 0xca10;
    mov word ptr [si + 2], 0;
    mov word ptr [si + 4], 0;
    mov word ptr [si + 6], 0;
    mov word ptr [si + 8], 0;
    mov word ptr [si + 0xa], 0;
    mov word ptr [si + 0xc], 0;
    mov word ptr [si + 0xe], 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x12], 1;
    mov word ptr [si + 0x14], 0;
    mov word ptr [si + 0x16], 0;
    mov word ptr [si + 0x18], 0;
    mov word ptr [si + 0x1a], 0;
    mov word ptr [si + 0x1c], 0;
    mov word ptr [si + 0x1e], 0;
    mov word ptr [si + 0x20], 0;
    mov word ptr [si + 0x22], 0;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lcall 0x5e5, 6;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0x16;
    add byte ptr [di - 0x75], dl;
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    cld ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    *($1) = $2;
    movsb byte ptr es:[di], byte ptr [si];
    cmp byte ptr [si - 1], 0;
    if (!ZF) goto $1;
    $1 = pop();
    lds si, ptr [bp + 0xa];
    $1 = $2;
    *($1) = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    *($1) = $2;
    les di, ptr [bp + 0xe];
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    $1--;
    *($1) = $2;
    cmp word ptr [bp - 0xe], 0x80;
    jb 0x1ab28;
    mov word ptr [bp - 2], 0xfc13;
    goto $1;
    cmp word ptr [bp - 0xe], 0;
    ja 0x1ab30;
    goto $1;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp - 6];
    cmp word ptr [si + 0x16], 0;
    if (ZF) goto $1;
    mov word ptr [bp - 2], 0xfc15;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 -= $2;
    $1++;
    *($1) = $2;
    push($1);
    $1();
    or ax, ax;
    if (ZF) goto $1;
    *($1) = $2;
    goto $1;
    lds si, ptr [bp + 0xa];
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    lds si, ptr [bp + 6];
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 2], 0;
    lds si, ptr [bp - 6];
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    cld ;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 0xc;
    lds si, ptr [bp + 0xe];
    les di, ptr [bp + 0xe];
    $1 = $2;
    cld ;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cx, cx;
    if (ZF) goto $1;
    $1 = $2;
    *($1) = $2;
    mov byte ptr es:[di - 1], 0;
    push($1);
    push($1);
    lcall 0x1865, 0x8e;
    *($1) = $2;
    cmp byte ptr es:[di - 1], 0;
    if (!ZF) goto $1;
    $1 = $2;
    mov byte ptr es:[di - 1], al;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jle 0x1ac3b;
    cmp word ptr [bp - 0x1c], 0;
    if (!ZF) goto $1;
    goto $1;
    mov word ptr [bp - 0x1c], 0;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xe];
    $1 += $2;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    $1++;
    std ;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cl, cl;
    if (ZF) goto $1;
    *($1) = $2;
    $1++;
    $1++;
    goto $1;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [bp - 0x22], 0;
    $1 = 0;
    $1 = $2;
    // Compare $1 with $2
    jl 0x1ac78;
    goto $1;
    mov word ptr [bp - 0x24], 0;
    $1 = $2;
    $1 += $2;
    // Compare $1 with $2
    jle 0x1ac8b;
    goto $1;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    mov byte ptr es:[bx + di], 0;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    lcall 0x1865, 0x8e;
    *($1) = $2;
    $1 = pop();
    $1 = $2;
    mov byte ptr es:[bx + di], dl;
    $1 = pop();
    $1 += $2;
    // Compare $1 with $2
    jle 0x1acc4;
    // Compare $1 with $2
    if (!ZF) goto $1;
    goto $1;
    $1++;
    goto $1;
    $1++;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    mov byte ptr es:[bx + di], 0;
    push($1);
    push($1);
    $1 = $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0x17b8, 0xb1;
    $1 = pop();
    $1 = $2;
    mov byte ptr es:[bx + di], dl;
    *($1) = $2;
    $1++;
    $1 = $2;
    // Compare $1 with $2
    jae 0x1ad0b;
    mov word ptr [bp - 0x1c], 0;
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    goto $1;
    $1 = $2;
    retf ;
    cmpsb byte ptr [si], byte ptr es:[di];
    sbb word ptr [di + 0x501a], si;
    $1++;
    push($1);
    $1--;
    // Compare $1 with $2
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    cmp word ptr [0xa0], 0;
    if (!ZF) goto $1;
    goto $1;
    $1();
    jae 0x1ad64;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (!ZF) goto $1;
    mov word ptr [bp + 6], 0x4a8;
    mov word ptr [bp + 8], 0x19b2;
    $1();
    jae 0x1ad64;
    $1();
    jae 0x1ad64;
    $1 = $2;
    goto $1;
    $1 = $2;
    int 0x21;
    $1 = $2;
    goto $1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1();
    $1 = $2;
    jb 0x1ad5a;
    $1 = 0;
    $1 = 0;
    cmp word ptr [bp - 0x14], 0x5a4d;
    if (ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 = $2;
    jcxz 0x1ad8e;
    $1--;
    $1 = $2;
    mul dx;
    $1 += $2;
    $1 += $2;
    adc dx, 0;
    and ax, 0xfff0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = $2;
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    jb 0x1ad5a;
    $1 += $2;
    adc dx, 0;
    cmp word ptr [bp - 0x14], 0x4246;
    $1 = $2;
    if (ZF) goto $1;
    goto $1;
    cmp word ptr [bp - 0x12], 0x564f;
    if (ZF) goto $1;
    $1 += $2;
    adc dx, word ptr [bp - 0xe];
    goto $1;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x722a], ax;
    $1 = $2;
    mov word ptr es:[0x722c], ax;
    $1 = $2;
    int 0x21;
    mov word ptr [0xb8], 0;
    nop ;
    push($1);
    $1();
    $1 = $2;
    $1++;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1();
    $1 = $2;
    $1 -= $2;
    // Compare $1 with $2
    jae 0x1ae28;
    $1 = $2;
    goto $1;
    shr bx, 1;
    shr bx, 1;
    *($1) = $2;
    $1();
    jae 0x1ae3f;
    $1 = $2;
    $1 = $2;
    goto $1;
    nop ;
    $1 = 0;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf 8;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    cmp word ptr [0xb8], 0;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    int 0x21;
    mov word ptr [0xb8], 0;
    goto $1;
    lea dx, [0x1c];
    $1 = $2;
    $1 = $2;
    int 0x21;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    cmp word ptr [0xb8], 0;
    if (ZF) goto $1;
    nop ;
    push($1);
    $1();
    push($1);
    $1();
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    lea di, [0x1c];
    push($1);
    $1 = pop();
    $1();
    $1 = pop();
    ret ;
    $1 = $2;
    int 0x21;
    // Compare $1 with $2
    jb 0x1af0f;
    mov byte ptr [6], 0x20;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    cld ;
    lodsb al, byte ptr [si];
    or al, al;
    if (!ZF) goto $1;
    lodsb al, byte ptr [si];
    or al, al;
    if (!ZF) goto $1;
    lodsw ax, word ptr [si];
    lea di, [0x1c];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lodsb al, byte ptr [si];
    stosb byte ptr es:[di], al;
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = $2;
    $1();
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    push($1);
    $1 = pop();
    $1 = $2;
    cld ;
    repe cmpsb byte ptr [si], byte ptr es:[di];
    if (ZF) goto $1;
    $1--;
    lodsb al, byte ptr [si];
    or al, al;
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = pop();
    stc ;
    ret ;
    cmp byte ptr [si], 0;
    if (ZF) goto $1;
    lea di, [0x1c];
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lodsb al, byte ptr [si];
    or al, al;
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    stosb byte ptr es:[di], al;
    goto $1;
    $1--;
    // Compare $1 with $2
    if (ZF) goto $1;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 = $2;
    stosb byte ptr es:[di], al;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    jb 0x1af36;
    $1 = pop();
    ret ;
    lds si, ptr [bp + 6];
    $1 = $2;
    or ax, si;
    if (ZF) goto $1;
    $1 = $2;
    lodsb al, byte ptr [si];
    stosb byte ptr es:[di], al;
    or al, al;
    if (ZF) goto $1;
    loop 0x1af79;
    $1 -= $2;
    stosb byte ptr es:[di], al;
    lea dx, [0x1c];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x21;
    ret ;
    push($1);
    lea dx, [bp - 0x14];
    push($1);
    $1 = pop();
    $1 = $2;
    int 0x21;
    $1 = pop();
    jb 0x1afa4;
    // Compare $1 with $2
    ret ;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    mov word ptr cs:[0x18], ax;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    lea si, [0xc0];
    test word ptr [si + 4], 2;
    if (ZF) goto $1;
    cmp word ptr [si + 2], 0;
    if (!ZF) goto $1;
    goto $1;
    nop ;
    $1 = $2;
    push($1);
    mov word ptr es:[0x12], ax;
    $1 = $2;
    cmp byte ptr es:[0x1a], 0xff;
    if (!ZF) goto $1;
    $1 = pop();
    mov word ptr es:[0x12], 0;
    goto $1;
    nop ;
    $1 = pop();
    mov word ptr es:[0x18], 0x4d0;
    $1 = $2;
    $1 = $2;
    add word ptr es:[4], ax;
    adc word ptr es:[6], dx;
    $1();
    // Compare $1 with $2
    jae 0x1b010;
    xchg dx, bx;
    $1 += $2;
    // Compare $1 with $2
    jae 0x1b01b;
    goto $1;
    $1 = 0;
    $1 += $2;
    *($1) = $2;
    ret ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    jcxz 0x1b06e;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    sbb dx, word ptr [6];
    $1 = $2;
    div cx;
    $1 += $2;
    // Compare $1 with $2
    ja 0x1b06e;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    goto $1;
    $1 = $2;
    mov word ptr [0x1c], 0;
    $1 = pop();
    *($1) = $2;
    $1 = $2;
    $1 -= $2;
    if (!ZF) goto $1;
    goto $1;
    nop ;
    $1 = $2;
    rol si, cl;
    $1 = $2;
    and di, 0xf;
    and si, 0xfff0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    jb 0x1b0e4;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    jcxz 0x1b0b4;
    $1();
    cmp word ptr es:[0xc], 0;
    if (ZF) goto $1;
    $1();
    $1 = $2;
    $1--;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lcall [0x16];
    $1 = pop();
    $1 = $2;
    or ax, ax;
    if (!ZF) goto $1;
    $1 = pop();
    clc ;
    ret ;
    $1 = $2;
    shr ax, cl;
    ror dx, cl;
    and dx, 0xf000;
    or ax, dx;
    ret ;
    push($1);
    $1 = $2;
    $1 = $2;
    int 0x21;
    $1 = pop();
    push($1);
    $1 = $2;
    goto $1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    or di, di;
    if (!ZF) goto $1;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    int 0x21;
    jb 0x1b129;
    // Compare $1 with $2
    jb 0x1b129;
    $1 -= $2;
    sbb di, 0;
    $1 = $2;
    or ax, di;
    if (!ZF) goto $1;
    $1 = pop();
    ret ;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    and si, 0xf;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shr cx, 1;
    cld ;
    lodsw ax, word ptr [si];
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and di, 0xfff8;
    $1 = $2;
    mov word ptr es:[bx], dx;
    test ax, 1;
    if (ZF) goto $1;
    $1();
    $1 = pop();
    loop 0x1b14c;
    $1 = pop();
    $1 = pop();
    ret ;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and ax, 0xf807;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and ax, 0xf807;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and ax, 0xf807;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    and ax, 0xf807;
    // Compare $1 with $2
    if (!ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (ZF) goto $1;
    $1 += $2;
    loop 0x1b1bc;
    goto $1;
    mov word ptr es:[bx + 4], di;
    $1 = pop();
    ret ;
    $1 = pop();
    ret ;
    $1 = $2;
    $1 = 0;
    $1 += $2;
    adc di, 0;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1();
    jb 0x1b1fd;
    $1 = $2;
    jcxz 0x1b1fc;
    $1();
    clc ;
    ret ;
    push($1);
    $1 = $2;
    test bp, 1;
    if (ZF) goto $1;
    ljmp 0:0xd87;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    sti ;
    les bx, ptr [bp + 2];
    push($1);
    sub word ptr [bp + 2], 2;
    if (!ZF) goto $1;
    $1();
    goto $1;
    $1 += $2;
    $1 = $2;
    xchg word ptr [bp - 6], ax;
    *($1) = $2;
    $1();
    $1 = $2;
    xchg word ptr [bp - 6], ax;
    *($1) = $2;
    $1 = pop();
    $1 = $2;
    and al, 8;
    and byte ptr es:[0x1a], 0xf7;
    cwde ;
    $1 = $2;
    lcall [0x16];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    iret ;
    push($1);
    $1++;
    $1();
    goto $1;
    popf ;
    push($1);
    jae 0x1b275;
    $1();
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    cmp byte ptr es:[0x1b], 0;
    if (!ZF) goto $1;
    $1();
    $1();
    goto $1;
    $1--;
    $1();
    $1();
    $1 = pop();
    $1();
    pushf ;
    // Compare $1 with $2
    ja 0x1b26e;
    popf ;
    $1 = pop();
    $1 = $2;
    mov word ptr es:[0x10], ax;
    ret ;
    $1++;
    cmp word ptr es:[0x10], 0;
    if (ZF) goto $1;
    mov byte ptr es:[0x1b], 1;
    or byte ptr es:[0x1a], 4;
    goto $1;
    nop ;
    or byte ptr es:[0x1a], 8;
    $1();
    push($1);
    $1--;
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    $1();
    jb 0x1b324;
    $1();
    $1();
    $1 = $2;
    and al, 3;
    add byte ptr es:[0x1b], al;
    push($1);
    $1();
    $1 = $2;
    $1 = $2;
    jcxz 0x1b322;
    // Compare $1 with $2
    jae 0x1b322;
    push($1);
    push($1);
    cmp byte ptr es:[0x1b], 0;
    if (ZF) goto $1;
    $1 = 0;
    goto $1;
    $1();
    $1();
    $1 = pop();
    $1 = pop();
    $1 += $2;
    goto $1;
    $1 = pop();
    ret ;
    ljmp 0:0xd87;
    $1();
    cmp word ptr es:[0x18], 0x4d0;
    if (!ZF) goto $1;
    $1();
    mov word ptr es:[0x10], 0;
    ret ;
    $1 = $2;
    $1 = 0;
    $1++;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (!ZF) goto $1;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    push($1);
    $1 = $2;
    mov word ptr es:[0x1c], ax;
    *($1) = $2;
    $1();
    sub word ptr [0xb0], ax;
    $1();
    $1 = pop();
    loop 0x1b35b;
    $1 = $2;
    *($1) = $2;
    ret ;
    cmp word ptr es:[0xc], 0;
    if (!ZF) goto $1;
    ret ;
    cmp byte ptr es:[0x20], 0xea;
    if (ZF) goto $1;
    $1 = $2;
    jcxz 0x1b39d;
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    loop 0x1b3ab;
    ret ;
    cmp byte ptr es:[0x20], 0xcd;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1();
    mov word ptr es:[2], cx;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = 0;
    stosb byte ptr es:[di], al;
    loop 0x1b3dd;
    ret ;
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x10], ax;
    $1 = $2;
    $1++;
    shr cx, 1;
    $1 = 0;
    cld ;
    // Compare $1 with $2
    jb 0x1b40f;
    $1 = $2;
    $1--;
    shl si, 1;
    std ;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    rep movsw word ptr es:[di], word ptr [si];
    cld ;
    $1--;
    $1 = $2;
    $1 = pop();
    *($1) = $2;
    $1++;
    $1 = pop();
    cmp byte ptr es:[0x20], 0xcd;
    if (ZF) goto $1;
    $1();
    $1 = $2;
    $1 = $2;
    cld ;
    stosw word ptr es:[di], ax;
    $1 += $2;
    loop 0x1b438;
    ret ;
    $1();
    add word ptr [0xb0], ax;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (!ZF) goto $1;
    *($1) = $2;
    mov word ptr es:[0x1c], ax;
    $1 = pop();
    ret ;
    $1();
    or bx, bx;
    if (ZF) goto $1;
    xchg word ptr ss:[bx + 2], cx;
    ret ;
    $1 = 0;
    push($1);
    push($1);
    goto $1;
    shl cx, 1;
    $1 = $2;
    $1 = $2;
    shr cx, 1;
    if (ZF) goto $1;
    jb 0x1b46f;
    // Compare $1 with $2
    if (!ZF) goto $1;
    *($1) = $2;
    or bx, bx;
    if (!ZF) goto $1;
    $1 = $2;
    goto $1;
    $1 = pop();
    $1 = pop();
    ret ;
    $1 = $2;
    or ax, ax;
    if (ZF) goto $1;
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    jae 0x1b4aa;
    $1 = $2;
    $1 -= $2;
    stc ;
    ret ;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    shr ax, cl;
    ret ;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    shr ax, cl;
    $1 = $2;
    $1 += $2;
    shr dx, cl;
    $1 += $2;
    ret ;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    jb 0x1b4ff;
    // Compare $1 with $2
    jae 0x1b4ff;
    $1--;
    $1 = $2;
    $1 = $2;
    $1++;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    // Compare $1 with $2
    $1 = $2;
    if (ZF) goto $1;
    $1 = 0;
    stc ;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    $1 -= $2;
    mov byte ptr [bp - 2], 0;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    goto $1;
    shl si, 1;
    $1 = $2;
    // Compare $1 with $2
    jae 0x1b554;
    $1 = $2;
    shr si, 1;
    if (ZF) goto $1;
    jb 0x1b522;
    $1 = $2;
    // Compare $1 with $2
    jae 0x1b522;
    $1 = $2;
    $1 = $2;
    or di, di;
    if (!ZF) goto $1;
    cmp word ptr es:[di], ax;
    if (!ZF) goto $1;
    mov byte ptr [bp - 2], 1;
    mov word ptr es:[di + 2], di;
    goto $1;
    cmp byte ptr [bp - 2], 1;
    if (ZF) goto $1;
    goto $1;
    nop ;
    shl si, 1;
    $1 = $2;
    $1 = $2;
    shr si, 1;
    if (ZF) goto $1;
    jb 0x1b55d;
    $1 = $2;
    // Compare $1 with $2
    jae 0x1b55d;
    $1 = $2;
    $1 = $2;
    or di, di;
    if (ZF) goto $1;
    cmp word ptr es:[0], ax;
    if (!ZF) goto $1;
    cmp word ptr es:[2], 0;
    if (!ZF) goto $1;
    xchg word ptr es:[2], di;
    mov word ptr ss:[bx + 2], di;
    goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    retf ;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (!ZF) goto $1;
    cmp word ptr es:[0x10], 0;
    if (ZF) goto $1;
    cmp byte ptr es:[0x20], 0xcd;
    if (!ZF) goto $1;
    mov word ptr [bp + 8], 0;
    push($1);
    push($1);
    $1();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    push($1);
    $1 = $2;
    and al, 8;
    and byte ptr es:[0x1a], 0xf7;
    cwde ;
    $1 = $2;
    lcall [0x16];
    $1 = pop();
    $1 = $2;
    *($1) = $2;
    $1 = pop();
    $1 = pop();
    retf ;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1();
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    jae 0x1b61c;
    $1 = $2;
    goto $1;
    shl bx, 1;
    $1++;
    push($1);
    $1 = $2;
    mul bx;
    push($1);
    push($1);
    lcall 0, 0x270c;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    or cx, dx;
    jcxz 0x1b64b;
    $1++;
    $1 += $2;
    push($1);
    push($1);
    $1 = 0;
    push($1);
    push($1);
    nop ;
    push($1);
    $1();
    or ax, ax;
    if (!ZF) goto $1;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    retf ;
    ljmp 0:0x27a;
    ret ;
    retf ;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    $1++;
    adc byte ptr [bx + di], bl;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    push($1);
    or word ptr [bx + di + 9], dx;
    push($1);
    or word ptr [si + 0xd], sp;
    add byte ptr [0], cl;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    $1 += $2;
    aas ;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    add byte ptr [bx + si], al;
    push 0x14e;
    add byte ptr [bx + si], al;
    $1 += $2;
    $1 += $2;
    $1 += $2;
    add byte ptr [bx + si], cl;
    add byte ptr [si], ah;
    $1 += $2;
    add word ptr [bx + si], ax;
    str word ptr [bp + si + 5];
    jl 0x1b73e;
    add word ptr [bx + si], ax;
    add byte ptr [bx + si], al;
    jno 0x1b747;
    $1++;
    $1 = pop();
    add word ptr [bx + si], ax;
    or al, 0;
    in ax, 5;
    $1 = $2;
    add word ptr [bx + si], ax;
    push($1);
    add byte ptr [bx + si], ah;
    push($1);
    $1++;
    $1 += $2;
    $1 += $2;
    if (ZF) goto $1;
    cli ;
    $1 += $2;
    push($1);
    $1 += $2;
    push($1);
    jnp 0x1b768;
    add word ptr [bx + si], ax;
    or al, byte ptr [bx + si];
    sbb al, byte ptr [bx];
    $1--;
    or byte ptr [bx + di], al;
    add byte ptr [si], cl;
    add byte ptr [bp + 0x4f07], bl;
    add word ptr [bx + di], ax;
    add byte ptr [si], cl;
    add byte ptr [bp + di + 0x1907], dh;
    $1 += $2;
    add byte ptr [bx + si], al;
    $1 += $2;
    $1 = pop();
    $1 = $2;
    add byte ptr [bp + si], cl;
    $1 += $2;
    $1 = pop();
    fld qword ptr [bx + si];
    add word ptr [bx + si], ax;
    or byte ptr [bx + si], al;
    or al, 8;
    nop ;
    $1 = pop();
    add word ptr [bx + si], ax;
    push($1);
    add byte ptr [di - 0x5cf8], al;
    add word ptr [bx + di], ax;
    add byte ptr [bx + si], al;
    add byte ptr [bx + 0x2508], bl;
    or byte ptr [bx + di], al;
    add byte ptr [si], al;
    add byte ptr [bx + di], ah;
    or word ptr [bp + 0x103], dx;
    add byte ptr [0x5a00], al;
    or word ptr [bx], dx;
    add word ptr [bx + di], ax;
    add byte ptr [0x6b00], al;
    or word ptr [bp + di], di;
    $1 += $2;
    add byte ptr [bx + si], cl;
    add byte ptr [bp - 0x65f7], cl;
    $1 += $2;
    or al, 0;
    out 9, ax;
    jb 0x1b7d0;
    add word ptr [bx + si], ax;
    or al, byte ptr [bx + si];
    or cl, byte ptr cs:[di + 0x100];
    add byte ptr [bp + si], al;
    add byte ptr [0xce0a], dh;
    add word ptr [bx + di], ax;
    add byte ptr [0x5200], cl;
    or dl, byte ptr [bx + si];
    or word ptr [bx + di], ax;
    add byte ptr [0xe300], cl;
    or bl, byte ptr [bp + si + 2];
    add word ptr [bx + si], ax;
    add byte ptr [bx + si], al;
    or byte ptr [bp + di], cl;
    retf ;
    $1 += $2;
    add byte ptr [bp + si], cl;
    add byte ptr [si + 0xb], al;
    adc al, byte ptr [di];
    add word ptr [bx + si], ax;
    or al, 0;
    xchg bp, ax;
    or sp, word ptr [bx];
    $1 += $2;
    add byte ptr [bp + si], al;
    $1 += $2;
    or bx, word ptr [bp + di + 9];
    add word ptr [bx + si], ax;
    or byte ptr [bx + si], al;
    insb byte ptr es:[di], dx;
    or al, 8;
    $1 += $2;
    add byte ptr [si], cl;
    add byte ptr [si - 0x44f4], ch;
    or word ptr [bx + di], ax;
    add byte ptr [bx + si], cl;
    add byte ptr [bx + 0xd], al;
    jg 0x1b829;
    add word ptr [bx + si], ax;
    or al, 0;
    lahf ;
    or ax, 0x14d6;
    add word ptr [bx + si], ax;
    add byte ptr [bx + si], al;
    in al, dx;
    push($1);
    test al, 0xf;
    add word ptr [bx + si], ax;
    push($1);
    $1 += $2;
}

void sub_102B1() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 37 if statements

    // Block 0x102B1
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_102B1();
    sub_102B1();
    sub_102B1();
    sub_102B1();
    sub_102B1();
    sub_102B1();
}

void sub_106BF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 60 if statements

    // Block 0x106BF
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_106BF();
    sub_106BF();
    sub_106BF();
    sub_10E93();
    sub_10ECE();
    sub_114B2();
}

void sub_10BCD() {
    // Variable declarations
    int var_5C6C;
    int var_5C6E;
    int var_5C80;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x10BCD
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    lcall 0x5e5, 6;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bl;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    mul bx;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0x10c91
        // Block 0x10C91
        cld ;
        $1 = $2;
        $1 = $2;
        xchg al, ah;
        stosw word ptr es:[di], ax;
        $1++;
        $1++;
        loop 0x10c95;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        cld ;
        $1 = $2;
        $1 = $2;
        xchg al, ah;
        stosw word ptr es:[di], ax;
        $1++;
        $1++;
        loop 0x10caa;
        jmp 0x10daa;
        // Block 0x10DAA
        $1 = $2;
        *($1) = $2;
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x10C81
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x10cb6
            // Block 0x10CB6
            cld ;
            mov dx, 0x10;
        } else {
            // Block 0x10C86
            // Compare $1 with $2
            if (a != b) {  // jne 0x10c8e
                // Block 0x10C8E
                jmp 0x10d61;
                // Block 0x10D61
                cld ;
                mov dx, 0x10;
            } else {
                // Block 0x10C8B
                jmp 0x10d24;
                // Block 0x10D24
                cld ;
                mov dx, 0x10;
            }
        }
    }
}

void sub_10DC0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x10DC0
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    lcall 0x71a, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0xb44, 0xc;
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    *($1) = $2;
    *($1) = $2;
    return;  // ret 
}

void sub_10E6D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x10E6D
    push($1);
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    $1 += $2;
    $1 += $2;
    push($1);
    push($1);
    push($1);
    lcall 0xa52, 0xe;
    return;  // ret 
}

void sub_10E93() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x10E93
    // Compare $1 with $2
    if (a >= b) {  // jge 0x10e9f
        // Block 0x10E9F
        // Compare $1 with $2
        if (a <= b) {  // jle 0x10ea9
            // Block 0x10EA9
            // Compare $1 with $2
            if (a >= b) {  // jge 0x10eb5
                // Block 0x10EB5
                // Compare $1 with $2
                if (a <= b) {  // jle 0x10ebf
                    // Block 0x10EBF
                    pushf ;
                    cli ;
                    *($1) = $2;
                    *($1) = $2;
                    popf ;
                    call 0x11a48;
                    // Block 0x10ECD
                    return;  // ret 
                } else {
                    // Block 0x10EBB
                    mov di, word ptr [0x5cd0];
                }
            } else {
                // Block 0x10EAF
                $1 = $2;
                jmp 0x10ebf;
                // Block 0x10EBF
                pushf ;
                cli ;
                *($1) = $2;
                *($1) = $2;
                popf ;
                call 0x11a48;
                // Block 0x10ECD
                return;  // ret 
            }
        } else {
            // Block 0x10EA5
            mov si, word ptr [0x5cce];
        }
    } else {
        // Block 0x10E99
        $1 = $2;
        jmp 0x10ea9;
        // Block 0x10EA9
        // Compare $1 with $2
        if (a >= b) {  // jge 0x10eb5
            // Block 0x10EB5
            // Compare $1 with $2
            if (a <= b) {  // jle 0x10ebf
                // Block 0x10EBF
                pushf ;
                cli ;
                *($1) = $2;
                *($1) = $2;
                popf ;
                call 0x11a48;
                // Block 0x10ECD
                return;  // ret 
            } else {
                // Block 0x10EBB
                mov di, word ptr [0x5cd0];
            }
        } else {
            // Block 0x10EAF
            $1 = $2;
            jmp 0x10ebf;
            // Block 0x10EBF
            pushf ;
            cli ;
            *($1) = $2;
            *($1) = $2;
            popf ;
            call 0x11a48;
            // Block 0x10ECD
            return;  // ret 
        }
    }

    // Function calls:
    sub_11A48();
}

void sub_10ECE() {
    // Variable declarations
    char var_65F3;
    int var_5C96;
    int var_5C8E;
    int var_5C92;
    int var_5C9E;
    int var_5C9A;
    int var_5C98;
    int var_5C90;
    int var_5C94;
    int var_5CA0;
    int var_5C9C;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x10ECE
    $1 -= $2;
    $1 -= $2;
    cmp word ptr [0x5c74], 0;
    if (a == b) {  // je 0x10ee3
        // Block 0x10EE3
        push($1);
        $1 = 0;
        push($1);
        lcall 0x98e, 0x53a;
        *($1) = $2;
        test byte ptr [0x5c7a], 0xff;
        if (a == b) {  // je 0x10ef9
            // Block 0x10EF9
            $1 = pop();
            $1 = $2;
            xchg word ptr [0x5cd4], bx;
            or ax, bx;
            if (a == b) {  // je 0x10f07
                // Block 0x10F07
                cmp word ptr [0x5c86], si;
                if (a > b) {  // jg 0x10f33
                    // Block 0x10F33
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f44
                        // Block 0x10F44
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        mov word ptr var_5C9A, si;
                    } else {
                        // Block 0x10F41
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x10F0D
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f1f
                        // Block 0x10F1F
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        jmp 0x10f56;
                        // Block 0x10F56
                        cmp word ptr [0x5c88], di;
                        if (a > b) {  // jg 0x10f82
                            // Block 0x10F82
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f93
                                // Block 0x10F93
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr var_5C9C, di;
                            } else {
                                // Block 0x10F90
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0x10F5C
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f6e
                                // Block 0x10F6E
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x10fa5;
                                // Block 0x10FA5
                                $1 = 0;
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                lcall 0x71a, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                push($1);
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 += $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                lcall 0xa52, 0xe;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x110ad;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x10F6B
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x10F1C
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x10F04
                jmp 0x1109c;
                // Block 0x1109C
                or bx, bx;
                if (a != b) {  // jne 0x110a3
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                } else {
                    // Block 0x110A0
                    call 0x10e6d;
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                }
            }
        } else {
            // Block 0x10EF6
            call 0x1183c;
            // Block 0x10EF9
            $1 = pop();
            $1 = $2;
            xchg word ptr [0x5cd4], bx;
            or ax, bx;
            if (a == b) {  // je 0x10f07
                // Block 0x10F07
                cmp word ptr [0x5c86], si;
                if (a > b) {  // jg 0x10f33
                    // Block 0x10F33
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f44
                        // Block 0x10F44
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        mov word ptr var_5C9A, si;
                    } else {
                        // Block 0x10F41
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x10F0D
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x10f1f
                        // Block 0x10F1F
                        *($1) = $2;
                        $1 = 0;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        jmp 0x10f56;
                        // Block 0x10F56
                        cmp word ptr [0x5c88], di;
                        if (a > b) {  // jg 0x10f82
                            // Block 0x10F82
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f93
                                // Block 0x10F93
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr var_5C9C, di;
                            } else {
                                // Block 0x10F90
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0x10F5C
                            $1 = $2;
                            $1 -= $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0x10f6e
                                // Block 0x10F6E
                                *($1) = $2;
                                $1 = 0;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x10fa5;
                                // Block 0x10FA5
                                $1 = 0;
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                lcall 0x71a, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                push($1);
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 += $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lcall 0xb44, 0xc;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                $1 = $2;
                                $1 += $2;
                                push($1);
                                push($1);
                                lcall 0xa52, 0xe;
                                *($1) = $2;
                                *($1) = $2;
                                jmp 0x110ad;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x10F6B
                                jmp 0x1109c;
                                // Block 0x1109C
                                or bx, bx;
                                if (a != b) {  // jne 0x110a3
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                } else {
                                    // Block 0x110A0
                                    call 0x10e6d;
                                    // Block 0x110A3
                                    test byte ptr [0x5cd4], 0xff;
                                    if (a != b) {  // jne 0x110ad
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    } else {
                                        // Block 0x110AA
                                        call 0x10dc0;
                                        // Block 0x110AD
                                        push($1);
                                        lcall 0x98e, 0x53a;
                                        test byte ptr [0x5c7a], 0xff;
                                        if (a == b) {  // je 0x110c0
                                            // Block 0x110C0
                                            return;  // ret 
                                        } else {
                                            // Block 0x110BD
                                            call 0x1193c;
                                            // Block 0x110C0
                                            return;  // ret 
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x10F1C
                        jmp 0x1109c;
                        // Block 0x1109C
                        or bx, bx;
                        if (a != b) {  // jne 0x110a3
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        } else {
                            // Block 0x110A0
                            call 0x10e6d;
                            // Block 0x110A3
                            test byte ptr [0x5cd4], 0xff;
                            if (a != b) {  // jne 0x110ad
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x110AA
                                call 0x10dc0;
                                // Block 0x110AD
                                push($1);
                                lcall 0x98e, 0x53a;
                                test byte ptr [0x5c7a], 0xff;
                                if (a == b) {  // je 0x110c0
                                    // Block 0x110C0
                                    return;  // ret 
                                } else {
                                    // Block 0x110BD
                                    call 0x1193c;
                                    // Block 0x110C0
                                    return;  // ret 
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x10F04
                jmp 0x1109c;
                // Block 0x1109C
                or bx, bx;
                if (a != b) {  // jne 0x110a3
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                } else {
                    // Block 0x110A0
                    call 0x10e6d;
                    // Block 0x110A3
                    test byte ptr [0x5cd4], 0xff;
                    if (a != b) {  // jne 0x110ad
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    } else {
                        // Block 0x110AA
                        call 0x10dc0;
                        // Block 0x110AD
                        push($1);
                        lcall 0x98e, 0x53a;
                        test byte ptr [0x5c7a], 0xff;
                        if (a == b) {  // je 0x110c0
                            // Block 0x110C0
                            return;  // ret 
                        } else {
                            // Block 0x110BD
                            call 0x1193c;
                            // Block 0x110C0
                            return;  // ret 
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x10EDD
        *($1) = $2;
        jmp 0x110c0;
        // Block 0x110C0
        return;  // ret 
    }

    // Function calls:
    sub_1183C();
    sub_10E6D();
    sub_10DC0();
    sub_1193C();
}

void sub_110C1() {
    // Variable declarations
    int var_5C80;
    int var_5C74;
    int var_5CA2;
    int var_5CA8;
    int var_5CAE;
    int var_5CB4;
    int var_5CBA;
    int var_5CC0;
    int var_5C82;
    int var_5C84;
    int var_5C8A;
    int var_5C8C;
    int var_5CD4;
    int var_5CD2;
    int var_5CCA;
    int var_5CCC;
    int var_5CCE;
    int var_5CD0;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x110C1
    $1 = 0;
    mov word ptr [0x5c70], 0;
    mov word ptr [0x5c80], 0xffff;
    mov word ptr [0x5c74], 0xffff;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    mov word ptr [0x5c8a], 0xf;
    mov word ptr [0x5c8c], 0xf;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1--;
    *($1) = $2;
    cmp word ptr [0x5ce6], 0;
    if (a != b) {  // jne 0x11127
        // Block 0x11127
        $1 = $2;
        shr ax, 1;
        push($1);
        $1 = $2;
        shr ax, 1;
        push ax;
    } else {
        // Block 0x1111D
        $1 = $2;
        push($1);
        $1 = $2;
        push($1);
        jmp 0x11133;
        // Block 0x11133
        push($1);
        call 0x114f8;
        // Block 0x11137
        return;  // ret 
    }

    // Function calls:
    sub_114F8();
    sub_11A23();
    sub_11576();
    sub_110C1();
    sub_11249();
    sub_11249();
}

void sub_11249() {
    // Variable declarations
    int var_5C74;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x11249
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 0;
    if (a != b) {  // jne 0x11273
        // Block 0x11273
        cmp word ptr [bp + 6], 1;
        if (a == b) {  // je 0x1128e
            // Block 0x1128E
            cmp word ptr [0x5c74], 0;
            if (a == b) {  // je 0x112cd
                // Block 0x112CD
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            } else {
                // Block 0x11295
                $1 = $2;
                $1 = $2;
                call 0x11a48;
                // Block 0x112A0
                $1 = $2;
                $1++;
                push($1);
                or bx, ax;
                xchg word ptr [0x5cd4], ax;
                or bx, ax;
                if (a != b) {  // jne 0x112c8
                    // Block 0x112C8
                    $1 = pop();
                    mov word ptr var_5C74, bx;
                } else {
                    // Block 0x112B0
                    $1 = $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0x112bd
                        // Block 0x112BD
                        $1 -= $2;
                        $1 -= $2;
                        call 0x10dc0;
                        // Block 0x112C8
                        $1 = pop();
                        mov word ptr var_5C74, bx;
                    } else {
                        // Block 0x112B9
                        push($1);
                        call 0x10bcd;
                        // Block 0x112BD
                        $1 -= $2;
                        $1 -= $2;
                        call 0x10dc0;
                        // Block 0x112C8
                        $1 = pop();
                        mov word ptr var_5C74, bx;
                    }
                }
            }
        } else {
            // Block 0x11279
            $1 = $2;
            $1 = $2;
            $1--;
            *($1) = $2;
            or ax, word ptr [0x5cd4];
            if (a != b) {  // jne 0x112cd
                // Block 0x112CD
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            } else {
                // Block 0x11289
                call 0x10e6d;
                // Block 0x1128C
                jmp 0x112cd;
                // Block 0x112CD
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            }
        }
    } else {
        // Block 0x1125F
        cmp word ptr [bp + 6], 1;
        if (a != b) {  // jne 0x1126c
            // Block 0x1126C
            $1 = $2;
            int 0x33;
            jmp 0x112cd;
            // Block 0x112CD
            mov word ptr [bp - 2], 0;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        } else {
            // Block 0x11265
            $1 = $2;
            int 0x33;
            jmp 0x112cd;
            // Block 0x112CD
            mov word ptr [bp - 2], 0;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    }

    // Function calls:
    sub_10E6D();
    sub_11A48();
    sub_10BCD();
    sub_10DC0();
    sub_11249();
    sub_11249();
}

void sub_114B2() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x114B2
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 0;
    if (a != b) {  // jne 0x114cf
        // Block 0x114CF
        pushf ;
        cli ;
        $1 = $2;
        $1 = $2;
        popf ;
    } else {
        // Block 0x114C8
        $1 = $2;
        int 0x33;
        jmp 0x114da;
        // Block 0x114DA
        les di, ptr [bp + 0xa];
        mov word ptr es:[di], cx;
        les di, ptr [bp + 6];
        mov word ptr es:[di], dx;
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }
}

void sub_114F8() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x114F8
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x5ce6], 1;
    if (a == b) {  // je 0x1151b
        // Block 0x1151B
        $1 = $2;
        $1 = $2;
        call 0x10e93;
        // Block 0x11524
        pushf ;
        cli ;
        cmp word ptr [0x5c74], 0;
        if (a != b) {  // jne 0x11530
            // Block 0x11530
            popf ;
        } else {
            // Block 0x1152D
            call 0x10ece;
            // Block 0x11530
            popf ;
        }
    } else {
        // Block 0x1150E
        $1 = $2;
        $1 = $2;
        $1 = $2;
        int 0x33;
        jmp 0x11531;
        // Block 0x11531
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_10E93();
    sub_10ECE();
}

void sub_11576() {
    // Variable declarations
    int var_5C7C;
    int var_5C7E;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x11576
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b) {  // jl 0x11592
        // Block 0x11592
        mov word ptr [bp - 2], 0xf05c;
        jmp 0x115c1;
        // Block 0x115C1
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    } else {
        // Block 0x1158D
        // Compare $1 with $2
        if (a <= b) {  // jle 0x11599
            // Block 0x11599
            $1 = $2;
            push($1);
            push($1);
            call 0x11249;
            // Block 0x115A1
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            push($1);
            call 0x10bcd;
            // Block 0x115B1
            call 0x117c2;
            // Block 0x115B4
            $1 = $2;
            push($1);
            push($1);
            call 0x11249;
            // Block 0x115BC
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x11592
            mov word ptr [bp - 2], 0xf05c;
            jmp 0x115c1;
            // Block 0x115C1
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        }
    }

    // Function calls:
    sub_11249();
    sub_10BCD();
    sub_117C2();
    sub_11249();
    sub_110C1();
    sub_117C2();
    sub_11A48();
    sub_10ECE();
    sub_11A48();
    sub_10ECE();
}

void sub_117C2() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x117C2
    push($1);
    lcall 0x98e, 0x12a;
    if (a < b (unsigned)) {  // jb 0x1183b
        // Block 0x1183B
        return;  // ret 
    } else {
        // Block 0x117CD
        $1 = $2;
        $1 = $2;
        push($1);
        $1 = $2;
        $1 = 0;
        $1 = $2;
        $1 -= $2;
        $1--;
        $1 += $2;
        $1++;
        if (a >= b) {  // jge 0x117eb
            // Block 0x117EB
            mul bx;
            and ax, 0xfff8;
            $1 = 0;
            div bx;
            *($1) = $2;
            $1 = $2;
            $1 -= $2;
            $1--;
            $1 += $2;
            $1++;
            if (a >= b) {  // jge 0x11808
                // Block 0x11808
                *($1) = $2;
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x11819
                    // Block 0x11819
                    mul bx;
                    $1 += $2;
                    and ax, 0xfff8;
                    $1 = 0;
                    div bx;
                    $1--;
                    *($1) = $2;
                    $1 = $2;
                    $1 += $2;
                    $1 = pop();
                    // Compare $1 with $2
                    if (a < b (unsigned)) {  // jb 0x11838
                        // Block 0x11838
                        mov word ptr [0x5cdc], ax;
                    } else {
                        // Block 0x11835
                        $1 = $2;
                        dec ax;
                    }
                } else {
                    // Block 0x11816
                    $1 = $2;
                    dec ax;
                }
            } else {
                // Block 0x11806
                xor ax, ax;
            }
        } else {
            // Block 0x117E9
            xor ax, ax;
        }
    }
}

void sub_1183C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x1183C
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x11856
        // Block 0x11856
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        $1--;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1++;
        in al, dx;
        *($1) = $2;
        jmp 0x1193b;
        // Block 0x1193B
        return;  // ret 
    } else {
        // Block 0x11844
        // Compare $1 with $2
        if (a == b) {  // je 0x11856
            // Block 0x11856
            $1 = $2;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            $1--;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            *($1) = $2;
            jmp 0x1193b;
            // Block 0x1193B
            return;  // ret 
        } else {
            // Block 0x11849
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0x118a2
                // Block 0x118A2
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x118b4
                    // Block 0x118B4
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x118c6
                        // Block 0x118C6
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x118e8
                            // Block 0x118E8
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x118fa
                                // Block 0x118FA
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x11908
                                    // Block 0x11908
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x1191c
                                        // Block 0x1191C
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x1193b
                                            // Block 0x1193B
                                            return;  // ret 
                                        } else {
                                            // Block 0x11921
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            INT_10_AH4F();  // int 0x10
                                            *($1) = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            INT_10_AH4F();  // int 0x10
                                            mov byte ptr [0x65f0], dl;
                                        }
                                    } else {
                                        // Block 0x1190D
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, al;
                                        $1++;
                                        in al, dx;
                                        xor al, 2;
                                        *($1) = $2;
                                        jmp 0x1193b;
                                        // Block 0x1193B
                                        return;  // ret 
                                    }
                                } else {
                                    // Block 0x118FF
                                    $1 = $2;
                                    in al, dx;
                                    *($1) = $2;
                                    jmp 0x1193b;
                                    // Block 0x1193B
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x118ED
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                *($1) = $2;
                                jmp 0x1193b;
                                // Block 0x1193B
                                return;  // ret 
                            }
                        } else {
                            // Block 0x118CB
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            *($1) = $2;
                            $1--;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            *($1) = $2;
                            $1 = $2;
                            in al, dx;
                            *($1) = $2;
                            jmp 0x1193b;
                            // Block 0x1193B
                            return;  // ret 
                        }
                    } else {
                        // Block 0x118B9
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        *($1) = $2;
                        jmp 0x1193b;
                        // Block 0x1193B
                        return;  // ret 
                    }
                } else {
                    // Block 0x118AA
                    $1 = $2;
                    in al, dx;
                    *($1) = $2;
                    jmp 0x1193b;
                    // Block 0x1193B
                    return;  // ret 
                }
            } else {
                // Block 0x1184E
                // Compare $1 with $2
                if (a >= b (unsigned)) {  // jae 0x11856
                    // Block 0x11856
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    $1--;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    *($1) = $2;
                    jmp 0x1193b;
                    // Block 0x1193B
                    return;  // ret 
                } else {
                    // Block 0x11853
                    jmp 0x1193b;
                    // Block 0x1193B
                    return;  // ret 
                }
            }
        }
    }
}

void sub_1193C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x1193C
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x11956
        // Block 0x11956
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, ax;
        jmp 0x11a22;
        // Block 0x11A22
        return;  // ret 
    } else {
        // Block 0x11944
        // Compare $1 with $2
        if (a == b) {  // je 0x11956
            // Block 0x11956
            $1 = $2;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            jmp 0x11a22;
            // Block 0x11A22
            return;  // ret 
        } else {
            // Block 0x11949
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0x11990
                // Block 0x11990
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x119a2
                    // Block 0x119A2
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x119b3
                        // Block 0x119B3
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x119d2
                            // Block 0x119D2
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x119e3
                                // Block 0x119E3
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x119f1
                                    // Block 0x119F1
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x11a02
                                        // Block 0x11A02
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x11a22
                                            // Block 0x11A22
                                            return;  // ret 
                                        } else {
                                            // Block 0x11A07
                                            $1 = 0;
                                            $1 = 0;
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            INT_10_AH4F();  // int 0x10
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            $1 = $2;
                                            int 0x10;
                                        }
                                    } else {
                                        // Block 0x119F6
                                        $1 = $2;
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, ax;
                                        jmp 0x11a22;
                                        // Block 0x11A22
                                        return;  // ret 
                                    }
                                } else {
                                    // Block 0x119E8
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    jmp 0x11a22;
                                    // Block 0x11A22
                                    return;  // ret 
                                }
                            } else {
                                // Block 0x119D7
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                out dx, ax;
                                jmp 0x11a22;
                                // Block 0x11A22
                                return;  // ret 
                            }
                        } else {
                            // Block 0x119B8
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            out dx, ax;
                            $1 = $2;
                            $1 = $2;
                            out dx, ax;
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            jmp 0x11a22;
                            // Block 0x11A22
                            return;  // ret 
                        }
                    } else {
                        // Block 0x119A7
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        out dx, ax;
                        jmp 0x11a22;
                        // Block 0x11A22
                        return;  // ret 
                    }
                } else {
                    // Block 0x11998
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    jmp 0x11a22;
                    // Block 0x11A22
                    return;  // ret 
                }
            } else {
                // Block 0x1194E
                // Compare $1 with $2
                if (a >= b (unsigned)) {  // jae 0x11956
                    // Block 0x11956
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    out dx, ax;
                    jmp 0x11a22;
                    // Block 0x11A22
                    return;  // ret 
                } else {
                    // Block 0x11953
                    jmp 0x11a22;
                    // Block 0x11A22
                    return;  // ret 
                }
            }
        }
    }
}

void sub_11A23() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x11A23
    $1 = $2;
    INT_10();  // int 0x10
    // Compare $1 with $2
    if (a != b) {  // jne 0x11a40
        // Block 0x11A40
        $1 = 0;
        jmp 0x11a47;
        // Block 0x11A47
        return;  // ret 
    } else {
        // Block 0x11A2C
        // Compare $1 with $2
        if (a == b) {  // je 0x11a44
            // Block 0x11A44
            mov ax, 1;
        } else {
            // Block 0x11A31
            // Compare $1 with $2
            if (a == b) {  // je 0x11a44
                // Block 0x11A44
                mov ax, 1;
            } else {
                // Block 0x11A36
                // Compare $1 with $2
                if (a == b) {  // je 0x11a44
                    // Block 0x11A44
                    mov ax, 1;
                } else {
                    // Block 0x11A3B
                    // Compare $1 with $2
                    if (a == b) {  // je 0x11a44
                        // Block 0x11A44
                        mov ax, 1;
                    } else {
                        // Block 0x11A40
                        $1 = 0;
                        jmp 0x11a47;
                        // Block 0x11A47
                        return;  // ret 
                    }
                }
            }
        }
    }
}

void sub_11A48() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x11A48
    $1 = 0;
    // Compare $1 with $2
    if (a < b) {  // jl 0x11a63
        // Block 0x11A63
        and ax, word ptr [0x5cd2];
        return;  // ret 
    } else {
        // Block 0x11A50
        // Compare $1 with $2
        if (a < b) {  // jl 0x11a63
            // Block 0x11A63
            and ax, word ptr [0x5cd2];
            return;  // ret 
        } else {
            // Block 0x11A56
            // Compare $1 with $2
            if (a > b) {  // jg 0x11a63
                // Block 0x11A63
                and ax, word ptr [0x5cd2];
                return;  // ret 
            } else {
                // Block 0x11A5C
                // Compare $1 with $2
                if (a > b) {  // jg 0x11a63
                    // Block 0x11A63
                    and ax, word ptr [0x5cd2];
                    return;  // ret 
                } else {
                    // Block 0x11A62
                    inc ax;
                }
            }
        }
    }
}

void sub_11A68() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 16 if statements

    // Block 0x11A68
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    or bx, ax;
    $1 = $2;
    *($1) = $2;
    or bx, ax;
    or bx, bx;
    if (a != b) {  // jne 0x11acf
        // Block 0x11ACF
        $1 = $2;
        shl bx, 1;
        shl bx, 1;
        $1 = $2;
        les di, ptr [0x54c1];
        lds si, ptr [bp + 0x10];
        lds si, ptr [si];
        $1 = $2;
        $1 = $2;
        lds si, ptr [bp + 0x10];
        $1 += $2;
        $1 -= $2;
        *($1) = $2;
        *($1) = $2;
        sub word ptr [bp - 0x22], bx;
        if (a >= b (unsigned)) {  // jae 0x11b00
            // Block 0x11B00
            $1 = $2;
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            lodsw ax, word ptr [si];
            $1 = $2;
            lodsw ax, word ptr [si];
            cmp word ptr [bp - 4], 1;
            if (a != b) {  // jne 0x11b31
                // Block 0x11B31
                $1 += $2;
                $1 += $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x11b3f
                    // Block 0x11B3F
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0x11b47
                        // Block 0x11B47
                        xchg bx, ax;
                        stosw word ptr es:[di], ax;
                        $1 = $2;
                        stosw word ptr es:[di], ax;
                        loop 0x11b13;
                        $1 = $2;
                        $1 -= $2;
                        inc dx;
                    } else {
                        // Block 0x11B44
                        mov word ptr [bp - 0x26], ax;
                    }
                } else {
                    // Block 0x11B3C
                    mov word ptr [bp - 0x24], ax;
                }
            } else {
                // Block 0x11B1D
                push($1);
                push($1);
                push($1);
                lcall 0x1214, 0x21c;
                *($1) = $2;
                lcall 0x1214, 0x26c;
                $1 = $2;
                pop cx;
            }
        } else {
            // Block 0x11AF8
            mov word ptr [bp - 2], 0xfffe;
            jmp 0x11cf3;
            // Block 0x11CF3
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xe
        }
    } else {
        // Block 0x11A9E
        lds si, ptr [bp + 0x10];
        lds si, ptr [si];
        $1 = $2;
        $1++;
        $1++;
        lodsw ax, word ptr [si];
        $1 = $2;
        $1 = $2;
        $1--;
        $1++;
        $1++;
        lodsw ax, word ptr [si];
        // Compare $1 with $2
        if (a >= b) {  // jge 0x11abb
            // Block 0x11ABB
            // Compare $1 with $2
            if (a <= b) {  // jle 0x11ac1
                // Block 0x11AC1
                loop 0x11aae;
            } else {
                // Block 0x11ABF
                mov dx, ax;
            }
        } else {
            // Block 0x11AB5
            $1 = $2;
            loop 0x11aae;
            jmp 0x11ac3;
            // Block 0x11AC3
            *($1) = $2;
            *($1) = $2;
            $1 -= $2;
            $1++;
            jmp 0x11b55;
            // Block 0x11B55
            $1 = $2;
            shl dx, 1;
            *($1) = $2;
            $1 = $2;
            $1 = $2;
            les di, ptr [0x54c1];
            $1 = $2;
            $1 = 0;
            rep stosw word ptr es:[di], ax;
            $1 = $2;
            lds si, ptr [bp + 0x10];
            lds si, ptr [si];
            $1 = $2;
            $1 -= $2;
            shl bx, 1;
            shl bx, 1;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 += $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 += $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = 0;
            mov word ptr [bp - 6], ax;
        }
    }
}

void sub_11D00() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x11D00
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [0x54c1];
    mov word ptr [bp - 6], 0;
    $1 = $2;
    mov word ptr [bp - 4], ax;
}

void sub_11DD9() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x11DD9
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b) {  // jle 0x11df9
        // Block 0x11DF9
        cmp word ptr [si + 0x26], 1;
        if (a == b) {  // je 0x11e21
            // Block 0x11E21
            $1 = $2;
            $1 = $2;
            mul bx;
            $1 = $2;
            $1 += $2;
            $1 = $2;
            and cx, 7;
            $1 = $2;
            and bx, 7;
            $1 = $2;
            $1 = $2;
            rol ax, cl;
            *($1) = $2;
            push($1);
            push($1);
            push($1);
            push($1);
            lcall 0xd9f, 0x178;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 6
        } else {
            // Block 0x11DFF
            mov word ptr [si + 0x28], 0xffff;
            $1 = $2;
            *($1) = $2;
            push($1);
            push($1);
            push($1);
            push($1);
            lcall 0xd9f, 0x178;
            $1 = $2;
            mov word ptr [si + 0xc], ax;
        }
    } else {
        // Block 0x11DF3
        xchg word ptr [bp + 6], ax;
        mov word ptr [bp + 0xa], ax;
    }
}

void sub_11E61() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 23 if statements

    // Block 0x11E61
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x28], 0xffff;
    $1 = $2;
    *($1) = $2;
    mov word ptr [si + 0x2a], 1;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    *($1) = $2;
    les di, ptr [0x54c1];
    lea ax, [bp + 8];
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x14];
    push($1);
    push($1);
    lea ax, [bp - 0x16];
    push($1);
    push($1);
    push($1);
    call 0x11a68;
    // Block 0x11EC1
    // Compare $1 with $2
    if (a == b) {  // je 0x11ecc
        // Block 0x11ECC
        mov word ptr [si + 0x3c], 0;
        $1 = 0;
        *($1) = $2;
        *($1) = $2;
        mov word ptr [bp - 0x1c], 0;
        $1 = $2;
        mov word ptr [bp - 0x1e], bx;
    } else {
        // Block 0x11EC6
        *($1) = $2;
        jmp 0x11ff2;
        // Block 0x11FF2
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 6
    }

    // Function calls:
    sub_11A68();
    sub_11D00();
    sub_11DD9();
    sub_11E61();
    sub_12166();
}

void sub_12166() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x12166
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (a != b) {  // jne 0x121aa
        // Block 0x121AA
        $1 = $2;
        // Compare $1 with $2
        if (a >= b) {  // jge 0x121b8
            // Block 0x121B8
            $1 = $2;
            // Compare $1 with $2
            if (a >= b) {  // jge 0x121c6
                // Block 0x121C6
                $1 = $2;
                *($1) = $2;
                mov word ptr [si + 0x3c], 0;
                cmp word ptr [bp + 6], 2;
                if (a != b) {  // jne 0x121da
                    // Block 0x121DA
                    $1 = $2;
                    $1--;
                    $1 = $2;
                    $1 -= $2;
                    $1--;
                    $1 -= $2;
                    // Compare $1 with $2
                    if (a < b) {  // jl 0x121fa
                        // Block 0x121FA
                        $1 = $2;
                        shr bx, 1;
                        sub word ptr [bp + 0xe], bx;
                        sub word ptr [bp + 0xc], bx;
                        add word ptr [bp + 0xa], bx;
                        add word ptr [bp + 8], bx;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        cmp word ptr [si + 0x28], -1;
                        if (a == b) {  // je 0x1221d
                            // Block 0x1221D
                            cmp word ptr [si + 0x16], 0;
                            if (a != b) {  // jne 0x12226
                                // Block 0x12226
                                jmp 0x122de;
                                // Block 0x122DE
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [si + 0x2a], 1;
                                mov di, word ptr [bp + 0xc];
                            } else {
                                // Block 0x12223
                                jmp 0x122b0;
                                // Block 0x122B0
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                lcall 0xbd7, 8;
                                $1 = $2;
                                *($1) = $2;
                                jmp 0x123a3;
                                // Block 0x123A3
                                $1 = $2;
                                mov word ptr [si + 0x10], 1;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [bp - 2], 0;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x1221A
                            jmp 0x122de;
                            // Block 0x122DE
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            mov word ptr [si + 0x2a], 1;
                            mov di, word ptr [bp + 0xc];
                        }
                    } else {
                        // Block 0x121EC
                        $1 = $2;
                        $1 -= $2;
                        $1--;
                        $1 -= $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x12229
                            // Block 0x12229
                            $1 = $2;
                            shr di, 1;
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            push($1);
                            lcall 0xd9f, 0x178;
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            push($1);
                            lcall 0xd9f, 0x178;
                            $1++;
                            push($1);
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            lcall 0xd9f, 0x178;
                            push($1);
                            $1 = $2;
                            $1 -= $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 += $2;
                            push($1);
                            lcall 0xd9f, 0x178;
                            test word ptr [bp + 6], 2;
                            if (a != b) {  // jne 0x12295
                                // Block 0x12295
                                add word ptr [bp + 0xe], di;
                                add word ptr [bp + 0xc], di;
                                sub word ptr [bp + 0xa], di;
                                sub word ptr [bp + 8], di;
                            } else {
                                // Block 0x12292
                                jmp 0x123a3;
                                // Block 0x123A3
                                $1 = $2;
                                mov word ptr [si + 0x10], 1;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [bp - 2], 0;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x121FA
                            $1 = $2;
                            shr bx, 1;
                            sub word ptr [bp + 0xe], bx;
                            sub word ptr [bp + 0xc], bx;
                            add word ptr [bp + 0xa], bx;
                            add word ptr [bp + 8], bx;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            cmp word ptr [si + 0x28], -1;
                            if (a == b) {  // je 0x1221d
                                // Block 0x1221D
                                cmp word ptr [si + 0x16], 0;
                                if (a != b) {  // jne 0x12226
                                    // Block 0x12226
                                    jmp 0x122de;
                                    // Block 0x122DE
                                    $1 = $2;
                                    *($1) = $2;
                                    *($1) = $2;
                                    $1 = $2;
                                    *($1) = $2;
                                    mov word ptr [si + 0x2a], 1;
                                    mov di, word ptr [bp + 0xc];
                                } else {
                                    // Block 0x12223
                                    jmp 0x122b0;
                                    // Block 0x122B0
                                    $1 = $2;
                                    *($1) = $2;
                                    *($1) = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall 0xbd7, 8;
                                    $1 = $2;
                                    *($1) = $2;
                                    jmp 0x123a3;
                                    // Block 0x123A3
                                    $1 = $2;
                                    mov word ptr [si + 0x10], 1;
                                    $1 = $2;
                                    *($1) = $2;
                                    mov word ptr [bp - 2], 0;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0xa
                                }
                            } else {
                                // Block 0x1221A
                                jmp 0x122de;
                                // Block 0x122DE
                                $1 = $2;
                                *($1) = $2;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                mov word ptr [si + 0x2a], 1;
                                mov di, word ptr [bp + 0xc];
                            }
                        }
                    }
                } else {
                    // Block 0x121D7
                    jmp 0x122a1;
                    // Block 0x122A1
                    $1 = $2;
                    cmp word ptr [si + 0x22], 0;
                    if (a != b) {  // jne 0x1230b
                        // Block 0x1230B
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        mov word ptr [si + 0x2a], 1;
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        $1 = $2;
                        $1 += $2;
                        $1 = $2;
                        and cx, 7;
                        $1 = $2;
                        and bx, 7;
                        mov dx, word ptr [bp + 0xc];
                    } else {
                        // Block 0x122AA
                        cmp word ptr [si + 0x16], 0;
                        if (a != b) {  // jne 0x122d3
                            // Block 0x122D3
                            $1 = $2;
                            *($1) = $2;
                            mov word ptr [si + 0x28], 0xffff;
                        } else {
                            // Block 0x122B0
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            lcall 0xbd7, 8;
                            $1 = $2;
                            *($1) = $2;
                            jmp 0x123a3;
                            // Block 0x123A3
                            $1 = $2;
                            mov word ptr [si + 0x10], 1;
                            $1 = $2;
                            *($1) = $2;
                            mov word ptr [bp - 2], 0;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        }
                    }
                }
            } else {
                // Block 0x121C0
                xchg word ptr [bp + 0xe], ax;
                mov word ptr [bp + 0xa], ax;
            }
        } else {
            // Block 0x121B2
            xchg word ptr [bp + 0xc], ax;
            mov word ptr [bp + 8], ax;
        }
    } else {
        // Block 0x1217E
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x26c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x26c;
        mov word ptr [bp + 8], ax;
    }
}

void sub_12524() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x12524
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test word ptr [0x6ab2], 0xffff;
    if (a != b) {  // jne 0x12542
        // Block 0x12542
        push($1);
        $1 = $2;
        $1 = $2;
        les di, ptr [bp + 6];
        $1 = $2;
        cld ;
        rep movsw word ptr es:[di], word ptr [si];
        $1 = pop();
        $1 = $2;
        $1 += $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x12566
            // Block 0x12566
            *($1) = $2;
            $1--;
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x12562
            mov si, word ptr [0x6aa6];
        }
    } else {
        // Block 0x1253B
        mov word ptr [bp - 2], 0xf04c;
        jmp 0x12573;
        // Block 0x12573
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }
}

void sub_12580() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 166 if statements

    // Block 0x12580
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cli ;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x125a7
        // Block 0x125A7
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 += $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x125c8
            // Block 0x125C8
            *($1) = $2;
            $1++;
            popf ;
            push($1);
            $1 = $2;
            lds si, ptr [bp + 6];
            *($1) = $2;
            *($1) = $2;
            $1 = $2;
            cld ;
            rep movsw word ptr es:[di], word ptr [si];
            $1 = pop();
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x125C4
            mov si, word ptr [0x6aa6];
        }
    } else {
        // Block 0x1259B
        popf ;
        mov word ptr [bp - 2], 0xf04b;
        $1++;
        jmp 0x125eb;
        // Block 0x125EB
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_12524();
    sub_12580();
    sub_14286();
}

void sub_14286() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 62 if statements

    // Block 0x14286
    $1 = $2;
    mov word ptr [bx], 0x166;
    $1 += $2;
    mov word ptr [bx], 0x166;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x402;
    $1 += $2;
    mov word ptr [bx], 0x4b1;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x27b;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov word ptr [bx], 0x5c6;
    $1 += $2;
    mov byte ptr [0x6f01], 1;
    return;  // retf 
}

void sub_1485A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 74 if statements

    // Block 0x1485A
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    cmp byte ptr [si], 0xa;
    if (a == b) {  // je 0x14878
        // Block 0x14878
        mov word ptr [bp - 2], 0;
    } else {
        // Block 0x14871
        mov word ptr [bp - 2], 0xf448;
        jmp 0x1487d;
        // Block 0x1487D
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_1485A();
    sub_1485A();
}

void sub_14D0E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 9 if statements

    // Block 0x14D0E
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x14d30
        // Block 0x14D30
        $1 = $2;
        $1 = $2;
        $1 = $2;
        lds si, ptr [bp + 0xa];
        les di, ptr [bp + 6];
        // Compare $1 with $2
        if (a != b) {  // jne 0x14d4b
            // Block 0x14D4B
            // Compare $1 with $2
            if (a != b) {  // jne 0x14d6c
                // Block 0x14D6C
                // Compare $1 with $2
                if (a != b) {  // jne 0x14d82
                    // Block 0x14D82
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x14de4
                        // Block 0x14DE4
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x14e01
                            // Block 0x14E01
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x14e0d
                                // Block 0x14E0D
                                mov word ptr [bp - 2], 0xfff7;
                            } else {
                                // Block 0x14E06
                                $1 = $2;
                                goto $1;
                                jmp 0x14e12;
                                // Block 0x14E12
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x14DE9
                            mov cx, 0x30;
                        }
                    } else {
                        // Block 0x14D87
                        mov byte ptr [bp - 6], 0;
                        mov byte ptr [bp - 5], 0x20;
                        mov byte ptr [bp - 4], 4;
                        mov byte ptr [bp - 3], 0x24;
                        mov dx, 0x10;
                    }
                } else {
                    // Block 0x14D71
                    $1 = $2;
                    $1 = $2;
                    shr al, cl;
                    mov byte ptr es:[di], al;
                    mov word ptr [bp - 2], 0;
                    jmp 0x14e12;
                    // Block 0x14E12
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                }
            } else {
                // Block 0x14D50
                $1 = $2;
                $1 = $2;
                shr al, cl;
                mov byte ptr es:[di], al;
                $1++;
                $1 = $2;
                $1 = $2;
                shr al, cl;
                mov byte ptr es:[di], al;
                mov word ptr [bp - 2], 0;
                jmp 0x14e12;
                // Block 0x14E12
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xa
            }
        } else {
            // Block 0x14D43
            mov word ptr [bp - 2], 0;
            jmp 0x14e12;
            // Block 0x14E12
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xa
        }
    } else {
        // Block 0x14D28
        mov word ptr [bp - 2], 0xfc19;
        jmp 0x14e12;
        // Block 0x14E12
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_14E1F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 21 if statements

    // Block 0x14E1F
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x14e41
        // Block 0x14E41
        $1 = $2;
        $1 = $2;
        $1 = $2;
        les di, ptr [bp + 0xa];
        lds si, ptr [bp + 6];
        // Compare $1 with $2
        if (a == b) {  // je 0x14e7b
            // Block 0x14E7B
            mov word ptr [bp - 2], 0;
            jmp 0x14f28;
            // Block 0x14F28
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xa
        } else {
            // Block 0x14E54
            // Compare $1 with $2
            if (a == b) {  // je 0x14e83
                // Block 0x14E83
                $1 = $2;
                $1 = $2;
                shl al, cl;
                mov byte ptr es:[di], al;
                mov byte ptr es:[di + 1], 0;
                mov byte ptr es:[di + 2], 0;
                $1 = $2;
                $1 = $2;
                shl al, cl;
                mov byte ptr es:[di + 3], al;
                mov byte ptr es:[di + 4], 0;
                mov byte ptr es:[di + 5], 0;
                mov word ptr [bp - 2], 0;
                jmp 0x14f28;
                // Block 0x14F28
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xa
            } else {
                // Block 0x14E59
                // Compare $1 with $2
                if (a == b) {  // je 0x14eb2
                    // Block 0x14EB2
                    $1 = $2;
                    $1 = $2;
                    shl al, cl;
                    mov byte ptr es:[di], al;
                    mov byte ptr es:[di + 1], 0;
                    mov byte ptr es:[di + 2], 0;
                    mov word ptr [bp - 2], 0;
                    jmp 0x14f28;
                    // Block 0x14F28
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                } else {
                    // Block 0x14E5E
                    // Compare $1 with $2
                    if (a == b) {  // je 0x14ecc
                        // Block 0x14ECC
                        $1 = $2;
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        shl ah, 1;
                        $1 = $2;
                        and al, 0x48;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x14ee5
                            // Block 0x14EE5
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x14eef
                                // Block 0x14EEF
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x14ef9
                                    // Block 0x14EF9
                                    mov byte ptr es:[di], 0xff;
                                } else {
                                    // Block 0x14EF3
                                    mov byte ptr es:[di], 0xaa;
                                    jmp 0x14efd;
                                    // Block 0x14EFD
                                    $1++;
                                    loop 0x14ed5;
                                    $1 = pop();
                                    $1++;
                                    loop 0x14ecf;
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x14f28;
                                    // Block 0x14F28
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0xa
                                }
                            } else {
                                // Block 0x14EE9
                                mov byte ptr es:[di], 0x55;
                                jmp 0x14efd;
                                // Block 0x14EFD
                                $1++;
                                loop 0x14ed5;
                                $1 = pop();
                                $1++;
                                loop 0x14ecf;
                                mov word ptr [bp - 2], 0;
                                jmp 0x14f28;
                                // Block 0x14F28
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x14EDF
                            mov byte ptr es:[di], 0;
                            jmp 0x14efd;
                            // Block 0x14EFD
                            $1++;
                            loop 0x14ed5;
                            $1 = pop();
                            $1++;
                            loop 0x14ecf;
                            mov word ptr [bp - 2], 0;
                            jmp 0x14f28;
                            // Block 0x14F28
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        }
                    } else {
                        // Block 0x14E63
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x14e6b
                            // Block 0x14E6B
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x14e73
                                // Block 0x14E73
                                mov word ptr [bp - 2], 0xfff7;
                                jmp 0x14f28;
                                // Block 0x14F28
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            } else {
                                // Block 0x14E70
                                jmp 0x14f23;
                                // Block 0x14F23
                                $1 = $2;
                                jmp 0x14f0e;
                                // Block 0x14F0E
                                $1 = $2;
                                shl al, 1;
                                shl al, 1;
                                mov byte ptr es:[di], al;
                                $1++;
                                $1++;
                                $1--;
                                if (a != b) {  // jne 0x14f0e
                                    // Jump to block at 0x14F0E
                                } else {
                                    // Block 0x14F1C
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x14f28;
                                    // Block 0x14F28
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0xa
                                }
                            }
                        } else {
                            // Block 0x14E68
                            jmp 0x14f0b;
                            // Block 0x14F0B
                            mov cx, 0x30;
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x14E39
        mov word ptr [bp - 2], 0xfc19;
        jmp 0x14f28;
        // Block 0x14F28
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }

    // Function calls:
    sub_14D0E();
    sub_14E1F();
}

void sub_15048() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0x15048
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x1507b
        // Block 0x1507B
        *($1) = $2;
        push($1);
        lea ax, [bp - 0xe];
        push($1);
        push($1);
        lea ax, [bp - 0x10];
        push($1);
        lcall 0x96b, 0x66;
        // Compare $1 with $2
        if (a == b) {  // je 0x15098
            // Block 0x15098
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            lds si, ptr [bp - 0xe];
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            DOS_ReadFile();  // int 0x21
            if (a >= b (unsigned)) {  // jae 0x150bd
                // Block 0x150BD
                cmp byte ptr [si + 1], 5;
                if (a == b) {  // je 0x150cb
                    // Block 0x150CB
                    $1 = $2;
                    push($1);
                    lcall 0x98e, 0x12a;
                    if (a >= b (unsigned)) {  // jae 0x150de
                        // Block 0x150DE
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        lds si, ptr [bp - 0xe];
                        les di, ptr [bp + 6];
                        // Compare $1 with $2
                        if (a == b) {  // je 0x150f3
                            // Block 0x150F3
                            $1 = $2;
                            $1 = $2;
                            $1 -= $2;
                            sbb dx, 0;
                            $1 -= $2;
                            sbb dx, 0;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_MoveFilePointer();  // int 0x21
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_ReadFile();  // int 0x21
                            $1 = $2;
                            *($1) = $2;
                            // Compare $1 with $2
                            if (a == b) {  // je 0x15134
                                // Block 0x15134
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                DOS_ReadFile();  // int 0x21
                                $1 = pop();
                                // Compare $1 with $2
                                if (a == b) {  // je 0x15152
                                    // Block 0x15152
                                    push($1);
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x1516c
                                        // Block 0x1516C
                                        $1 = $2;
                                        push($1);
                                        push($1);
                                        push($1);
                                        push($1);
                                        push($1);
                                        push($1);
                                        call 0x14d0e;
                                        // Block 0x15178
                                        mov word ptr [bp - 2], ax;
                                    } else {
                                        // Block 0x15162
                                        mov word ptr [bp - 2], 0;
                                        jmp 0x1517b;
                                        // Block 0x1517B
                                        $1 = $2;
                                        push($1);
                                        $1 = $2;
                                        push($1);
                                        lcall 0x80c, 0x640;
                                    }
                                } else {
                                    // Block 0x1514B
                                    mov word ptr [bp - 2], 0xfffd;
                                    jmp 0x1517b;
                                    // Block 0x1517B
                                    $1 = $2;
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    lcall 0x80c, 0x640;
                                }
                            } else {
                                // Block 0x15128
                                // Compare $1 with $2
                                if (a == b) {  // je 0x15134
                                    // Block 0x15134
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    push($1);
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    DOS_ReadFile();  // int 0x21
                                    $1 = pop();
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x15152
                                        // Block 0x15152
                                        push($1);
                                        $1 = $2;
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a == b) {  // je 0x1516c
                                            // Block 0x1516C
                                            $1 = $2;
                                            push($1);
                                            push($1);
                                            push($1);
                                            push($1);
                                            push($1);
                                            push($1);
                                            call 0x14d0e;
                                            // Block 0x15178
                                            mov word ptr [bp - 2], ax;
                                        } else {
                                            // Block 0x15162
                                            mov word ptr [bp - 2], 0;
                                            jmp 0x1517b;
                                            // Block 0x1517B
                                            $1 = $2;
                                            push($1);
                                            $1 = $2;
                                            push($1);
                                            lcall 0x80c, 0x640;
                                        }
                                    } else {
                                        // Block 0x1514B
                                        mov word ptr [bp - 2], 0xfffd;
                                        jmp 0x1517b;
                                        // Block 0x1517B
                                        $1 = $2;
                                        push($1);
                                        $1 = $2;
                                        push($1);
                                        lcall 0x80c, 0x640;
                                    }
                                } else {
                                    // Block 0x1512D
                                    mov word ptr [bp - 2], 0xfff7;
                                    jmp 0x1517b;
                                    // Block 0x1517B
                                    $1 = $2;
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    lcall 0x80c, 0x640;
                                }
                            }
                        } else {
                            // Block 0x150F1
                            jmp 0x15169;
                            // Block 0x15169
                            add si, 0x10;
                        }
                    } else {
                        // Block 0x150D6
                        mov word ptr [bp - 2], 0xfc19;
                        jmp 0x1517b;
                        // Block 0x1517B
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        push($1);
                        lcall 0x80c, 0x640;
                    }
                } else {
                    // Block 0x150C3
                    mov word ptr [bp - 2], 0xfff6;
                    jmp 0x1517b;
                    // Block 0x1517B
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    push($1);
                    lcall 0x80c, 0x640;
                }
            } else {
                // Block 0x150B5
                mov word ptr [bp - 2], 0xfffd;
                jmp 0x1517b;
                // Block 0x1517B
                $1 = $2;
                push($1);
                $1 = $2;
                push($1);
                lcall 0x80c, 0x640;
            }
        } else {
            // Block 0x15092
            *($1) = $2;
            jmp 0x1517b;
            // Block 0x1517B
            $1 = $2;
            push($1);
            $1 = $2;
            push($1);
            lcall 0x80c, 0x640;
        }
    } else {
        // Block 0x15075
        *($1) = $2;
        jmp 0x15188;
        // Block 0x15188
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xe
    }

    // Function calls:
    sub_14D0E();
    sub_15048();
    sub_14E1F();
}

void sub_15454() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x15454
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x15486
        // Block 0x15486
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        // Compare $1 with $2
        if (a == b) {  // je 0x154a4
            // Block 0x154A4
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0x154b1
                // Block 0x154B1
                mov word ptr [bp - 2], 0;
            } else {
                // Block 0x154AA
                mov word ptr [bp - 2], 0xf448;
                jmp 0x154b6;
                // Block 0x154B6
                $1 = $2;
                push($1);
                $1 = $2;
                push($1);
                lcall 0x80c, 0x640;
            }
        } else {
            // Block 0x1549D
            mov word ptr [bp - 2], 0xf448;
            jmp 0x154b6;
            // Block 0x154B6
            $1 = $2;
            push($1);
            $1 = $2;
            push($1);
            lcall 0x80c, 0x640;
        }
    } else {
        // Block 0x15481
        *($1) = $2;
        jmp 0x154c3;
        // Block 0x154C3
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }
}

void sub_154D0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x154D0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    call 0x15454;
    // Block 0x154F3
    // Compare $1 with $2
    if (a == b) {  // je 0x154fd
        // Block 0x154FD
        $1 = $2;
        les di, ptr [bp + 6];
        cld ;
        $1 = $2;
        rep movsb byte ptr es:[di], byte ptr [si];
        mov word ptr [bp - 2], 0;
    } else {
        // Block 0x154F8
        *($1) = $2;
        jmp 0x1550e;
        // Block 0x1550E
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xc
    }

    // Function calls:
    sub_15454();
    sub_154D0();
    sub_156C6();
}

void sub_156C6() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0x156C6
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0x10];
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x156e3
        // Block 0x156E3
        $1 = $2;
        mul word ptr [bp + 0xa];
        $1 = $2;
        $1 = $2;
        shl ax, cl;
        $1--;
        and word ptr [bp + 8], ax;
        and word ptr [bp + 6], ax;
        $1 = $2;
        div byte ptr [bp + 0xa];
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        shl ax, cl;
        $1--;
        $1 = $2;
        not ah;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        cld ;
        cmp word ptr [bp + 0xc], 1;
        if (a != b) {  // jne 0x1573f
            // Block 0x1573F
            push($1);
            $1 = $2;
            push($1);
            push($1);
            $1 = 0;
            xor cx, cx;
        } else {
            // Block 0x1571F
            push($1);
            $1 = $2;
            $1 = 0;
            $1 = $2;
            push($1);
            $1 = $2;
            shl ax, cl;
            $1 = pop();
            // Compare $1 with $2
            if (a != b) {  // jne 0x15735
                // Block 0x15735
                or al, ah;
                loop 0x15728;
                stosb byte ptr es:[di], al;
                $1 = pop();
                loop 0x1571f;
                jmp 0x15786;
                // Block 0x15786
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xe
            } else {
                // Block 0x15733
                mov ah, bl;
            }
        }
    } else {
        // Block 0x156E0
        jmp 0x15786;
        // Block 0x15786
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xe
    }
}

void sub_15798() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 31 if statements

    // Block 0x15798
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    cmp word ptr [si], 0xca00;
    if (a != b) {  // jne 0x157ba
        // Block 0x157BA
        mov word ptr [bp - 2], 0xffe4;
        jmp 0x15832;
        // Block 0x15832
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xc
    } else {
        // Block 0x157B3
        cmp word ptr es:[di], 0xca00;
        if (a == b) {  // je 0x157c1
            // Block 0x157C1
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0x157d1
                // Block 0x157D1
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x157e3
                    // Block 0x157E3
                    mov word ptr [bp - 2], 0xf82d;
                    jmp 0x15832;
                    // Block 0x15832
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xc
                } else {
                    // Block 0x157DA
                    $1 = $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0x157ea
                        // Block 0x157EA
                        les di, ptr [bp + 0xe];
                        mov word ptr es:[di], 0xca20;
                        $1 = $2;
                        mov word ptr es:[di + 6], ax;
                        mov word ptr es:[di + 4], si;
                        lcall 0x1535, 0x2d;
                        mov word ptr es:[di + 2], ax;
                        mov word ptr es:[di + 0x8c], 0;
                        $1 = $2;
                        $1 -= $2;
                        if (a != b) {  // jne 0x15821
                            // Block 0x15821
                            lds si, ptr [bp + 6];
                            $1 += $2;
                            $1 = $2;
                            cld ;
                            rep movsb byte ptr es:[di], byte ptr [si];
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x15813
                            $1 = $2;
                            $1 -= $2;
                            if (a != b) {  // jne 0x15821
                                // Block 0x15821
                                lds si, ptr [bp + 6];
                                $1 += $2;
                                $1 = $2;
                                cld ;
                                rep movsb byte ptr es:[di], byte ptr [si];
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x1581A
                                mov word ptr es:[di + 0x8c], 1;
                            }
                        }
                    } else {
                        // Block 0x157E3
                        mov word ptr [bp - 2], 0xf82d;
                        jmp 0x15832;
                        // Block 0x15832
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 0xc
                    }
                }
            } else {
                // Block 0x157CA
                mov word ptr [bp - 2], 0xfffa;
                jmp 0x15832;
                // Block 0x15832
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xc
            }
        } else {
            // Block 0x157BA
            mov word ptr [bp - 2], 0xffe4;
            jmp 0x15832;
            // Block 0x15832
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xc
        }
    }

    // Function calls:
    sub_15798();
    sub_15AB6();
}

void sub_15AB6() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 36 if statements

    // Block 0x15AB6
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x12];
    les di, ptr [bp + 0xe];
    $1 = $2;
    $1 = $2;
    cld ;
    cmp word ptr [bp + 0xa], 1;
    if (a == b) {  // je 0x15ae1
        // Block 0x15AE1
        cmp word ptr [bp + 8], 1;
        if (a == b) {  // je 0x15af6
            // Block 0x15AF6
            ror dl, 1;
            not dl;
            cwde ;
            $1 = $2;
            shr cx, 1;
            lodsw ax, word ptr [si];
            xor ax, dx;
            stosw word ptr es:[di], ax;
            loop 0x15aff;
            jmp 0x15b6f;
            // Block 0x15B6F
            mov word ptr [bp - 2], 0;
            jmp 0x15b7b;
            // Block 0x15B7B
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0x10
        } else {
            // Block 0x15AE7
            cmp word ptr [bp + 8], 2;
            if (a == b) {  // je 0x15b07
                // Block 0x15B07
                $1 = $2;
                $1 = $2;
                lodsb al, byte ptr [si];
            } else {
                // Block 0x15AED
                cmp word ptr [bp + 8], 8;
                if (a == b) {  // je 0x15b25
                    // Block 0x15B25
                    lodsb al, byte ptr [si];
                    $1 = $2;
                    $1 = 0;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x15b30
                        // Block 0x15B30
                        stosb byte ptr es:[di], al;
                        loop 0x15b25;
                        jmp 0x15b6f;
                        // Block 0x15B6F
                        mov word ptr [bp - 2], 0;
                        jmp 0x15b7b;
                        // Block 0x15B7B
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 0x10
                    } else {
                        // Block 0x15B2E
                        not al;
                    }
                } else {
                    // Block 0x15AF3
                    jmp 0x15b76;
                    // Block 0x15B76
                    mov word ptr [bp - 2], 0xfffa;
                }
            }
        }
    } else {
        // Block 0x15AD8
        cmp word ptr [bp + 0xa], 4;
        if (a == b) {  // je 0x15b35
            // Block 0x15B35
            cmp word ptr [bp + 8], 1;
            if (a == b) {  // je 0x15b3d
                // Block 0x15B3D
                $1 = $2;
                not dh;
                $1 = $2;
                push($1);
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = $2;
                ror al, 1;
                cwde ;
                xor ah, byte ptr [si];
                and dl, ah;
                $1 += $2;
                loop 0x15b4c;
                $1 = pop();
                $1 = pop();
                mov byte ptr es:[di], dl;
                $1++;
                $1++;
                loop 0x15b43;
                lds si, ptr [bp + 0xe];
                mov dx, 3;
            } else {
                // Block 0x15B3B
                jmp 0x15b76;
                // Block 0x15B76
                mov word ptr [bp - 2], 0xfffa;
            }
        } else {
            // Block 0x15ADE
            jmp 0x15b76;
            // Block 0x15B76
            mov word ptr [bp - 2], 0xfffa;
        }
    }

    // Function calls:
    sub_15E6E();
}

void sub_15E6E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 76 if statements

    // Block 0x15E6E
    $1 = $2;
    mov word ptr [bx], 0x34c;
    $1 += $2;
    mov word ptr [bx], 0x34c;
    $1 += $2;
    mov word ptr [bx], 0x38b;
    $1 += $2;
    mov word ptr [bx], 0x55b;
    $1 += $2;
    mov byte ptr [0x6f51], 1;
    return;  // retf 

    // Function calls:
    sub_16504();
}

void sub_16504() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 164 if statements

    // Block 0x16504
    $1 = $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2;
    mov word ptr [bx], 0x3b4;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0x78d;
    $1 += $2;
    mov word ptr [bx], 0x83b;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0x57d;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov word ptr [bx], 0xa10;
    $1 += $2;
    mov byte ptr [0x6f50], 1;
    return;  // retf 
}

void sub_177DA() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 54 if statements

    // Block 0x177DA
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x17808
        // Block 0x17808
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        // Compare $1 with $2
        if (a == b) {  // je 0x17826
            // Block 0x17826
            push($1);
            push($1);
            lcall 0x1542, 0;
            mov word ptr [bp - 2], ax;
        } else {
            // Block 0x1781F
            mov word ptr [bp - 2], 0xfc18;
            jmp 0x17830;
            // Block 0x17830
            push($1);
            push($1);
            lcall 0x80c, 0x640;
        }
    } else {
        // Block 0x17803
        *($1) = $2;
        jmp 0x1783b;
        // Block 0x1783B
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }

    // Function calls:
    sub_177DA();
    sub_17F32();
}

void sub_17F32() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 61 if statements

    // Block 0x17F32
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x17f3b
        // Block 0x17F3B
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x17f44
            // Block 0x17F44
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x17f69
                // Block 0x17F69
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                mul bx;
                push($1);
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x17f81
                    // Block 0x17F81
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = pop();
                    $1 += $2;
                    $1 = $2;
                    cmp word ptr [bp - 0xa], 0xff00;
                    if (a != b) {  // jne 0x17fb6
                        // Block 0x17FB6
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        test bl, bl;
                        if (a != b) {  // jne 0x17fcf
                            // Block 0x17FCF
                            cmp word ptr [bp + 8], 0;
                            if (a < b) {  // jl 0x17fe0
                                // Block 0x17FE0
                                dec cx;
                            } else {
                                // Block 0x17FD5
                                and ah, byte ptr [bp - 0xa0];
                                out dx, ax;
                                and byte ptr es:[di], bh;
                                $1 = $2;
                                inc di;
                            }
                        } else {
                            // Block 0x17FCA
                            $1--;
                            if (a != b) {  // jne 0x17fe1
                                // Block 0x17FE1
                                $1--;
                                if (a > b) {  // jg 0x17fed
                                    // Block 0x17FED
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    out dx, ax;
                                    goto $1;
                                    and byte ptr es:[di], bh;
                                    // Block 0x17FFD
                                    $1++;
                                    loop 0x17ffa;
                                } else {
                                    // Block 0x17FE4
                                    $1 = $2;
                                    and byte ptr [bp - 0x1e], ah;
                                    jmp 0x18000;
                                    // Block 0x18000
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di + 1], bh;
                                }
                            } else {
                                // Block 0x17FCD
                                jmp 0x18000;
                                // Block 0x18000
                                $1 = $2;
                                out dx, ax;
                                and byte ptr es:[di], bh;
                                $1 = $2;
                                out dx, ax;
                                and byte ptr es:[di + 1], bh;
                            }
                        }
                    } else {
                        // Block 0x17F98
                        cmp word ptr [bp - 0x9c], 0xff;
                        if (a != b) {  // jne 0x17fb6
                            // Block 0x17FB6
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            test bl, bl;
                            if (a != b) {  // jne 0x17fcf
                                // Block 0x17FCF
                                cmp word ptr [bp + 8], 0;
                                if (a < b) {  // jl 0x17fe0
                                    // Block 0x17FE0
                                    dec cx;
                                } else {
                                    // Block 0x17FD5
                                    and ah, byte ptr [bp - 0xa0];
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    inc di;
                                }
                            } else {
                                // Block 0x17FCA
                                $1--;
                                if (a != b) {  // jne 0x17fe1
                                    // Block 0x17FE1
                                    $1--;
                                    if (a > b) {  // jg 0x17fed
                                        // Block 0x17FED
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        out dx, ax;
                                        goto $1;
                                        and byte ptr es:[di], bh;
                                        // Block 0x17FFD
                                        $1++;
                                        loop 0x17ffa;
                                    } else {
                                        // Block 0x17FE4
                                        $1 = $2;
                                        and byte ptr [bp - 0x1e], ah;
                                        jmp 0x18000;
                                        // Block 0x18000
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di + 1], bh;
                                    }
                                } else {
                                    // Block 0x17FCD
                                    jmp 0x18000;
                                    // Block 0x18000
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di + 1], bh;
                                }
                            }
                        } else {
                            // Block 0x17FA0
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            out dx, ax;
                            and byte ptr es:[di], bh;
                            $1++;
                            loop 0x17fae;
                            jmp 0x1800f;
                            // Block 0x1800F
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x17F7E
                    add bx, 8;
                }
            } else {
                // Block 0x17F53
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x17f66
                    // Block 0x17F66
                    jmp 0x1800f;
                    // Block 0x1800F
                    return;  // retf 
                } else {
                    // Block 0x17F60
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x17f69
                        // Block 0x17F69
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        push($1);
                        $1 = $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x17f81
                            // Block 0x17F81
                            $1 = $2;
                            $1 += $2;
                            lcall es:[di + 0x26];
                            $1 = pop();
                            $1 += $2;
                            $1 = $2;
                            cmp word ptr [bp - 0xa], 0xff00;
                            if (a != b) {  // jne 0x17fb6
                                // Block 0x17FB6
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                test bl, bl;
                                if (a != b) {  // jne 0x17fcf
                                    // Block 0x17FCF
                                    cmp word ptr [bp + 8], 0;
                                    if (a < b) {  // jl 0x17fe0
                                        // Block 0x17FE0
                                        dec cx;
                                    } else {
                                        // Block 0x17FD5
                                        and ah, byte ptr [bp - 0xa0];
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        inc di;
                                    }
                                } else {
                                    // Block 0x17FCA
                                    $1--;
                                    if (a != b) {  // jne 0x17fe1
                                        // Block 0x17FE1
                                        $1--;
                                        if (a > b) {  // jg 0x17fed
                                            // Block 0x17FED
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            out dx, ax;
                                            goto $1;
                                            and byte ptr es:[di], bh;
                                            // Block 0x17FFD
                                            $1++;
                                            loop 0x17ffa;
                                        } else {
                                            // Block 0x17FE4
                                            $1 = $2;
                                            and byte ptr [bp - 0x1e], ah;
                                            jmp 0x18000;
                                            // Block 0x18000
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di + 1], bh;
                                        }
                                    } else {
                                        // Block 0x17FCD
                                        jmp 0x18000;
                                        // Block 0x18000
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di], bh;
                                        $1 = $2;
                                        out dx, ax;
                                        and byte ptr es:[di + 1], bh;
                                    }
                                }
                            } else {
                                // Block 0x17F98
                                cmp word ptr [bp - 0x9c], 0xff;
                                if (a != b) {  // jne 0x17fb6
                                    // Block 0x17FB6
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    test bl, bl;
                                    if (a != b) {  // jne 0x17fcf
                                        // Block 0x17FCF
                                        cmp word ptr [bp + 8], 0;
                                        if (a < b) {  // jl 0x17fe0
                                            // Block 0x17FE0
                                            dec cx;
                                        } else {
                                            // Block 0x17FD5
                                            and ah, byte ptr [bp - 0xa0];
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            inc di;
                                        }
                                    } else {
                                        // Block 0x17FCA
                                        $1--;
                                        if (a != b) {  // jne 0x17fe1
                                            // Block 0x17FE1
                                            $1--;
                                            if (a > b) {  // jg 0x17fed
                                                // Block 0x17FED
                                                $1 = $2;
                                                out dx, ax;
                                                and byte ptr es:[di], bh;
                                                $1 = $2;
                                                out dx, ax;
                                                goto $1;
                                                and byte ptr es:[di], bh;
                                                // Block 0x17FFD
                                                $1++;
                                                loop 0x17ffa;
                                            } else {
                                                // Block 0x17FE4
                                                $1 = $2;
                                                and byte ptr [bp - 0x1e], ah;
                                                jmp 0x18000;
                                                // Block 0x18000
                                                $1 = $2;
                                                out dx, ax;
                                                and byte ptr es:[di], bh;
                                                $1 = $2;
                                                out dx, ax;
                                                and byte ptr es:[di + 1], bh;
                                            }
                                        } else {
                                            // Block 0x17FCD
                                            jmp 0x18000;
                                            // Block 0x18000
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di], bh;
                                            $1 = $2;
                                            out dx, ax;
                                            and byte ptr es:[di + 1], bh;
                                        }
                                    }
                                } else {
                                    // Block 0x17FA0
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, ax;
                                    and byte ptr es:[di], bh;
                                    $1++;
                                    loop 0x17fae;
                                    jmp 0x1800f;
                                    // Block 0x1800F
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x17F7E
                            add bx, 8;
                        }
                    } else {
                        // Block 0x17F66
                        jmp 0x1800f;
                        // Block 0x1800F
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x17F41
            jmp 0x1800f;
            // Block 0x1800F
            return;  // retf 
        }
    } else {
        // Block 0x17F38
        jmp 0x1800f;
        // Block 0x1800F
        return;  // retf 
    }

    // Function calls:
    sub_1867D();
}

void sub_1867D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 60 if statements

    // Block 0x1867D
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x18686
        // Block 0x18686
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x1868f
            // Block 0x1868F
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x186b4
                // Block 0x186B4
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                $1 += $2;
                lcall es:[di + 0x26];
                $1 = $2;
                $1 = $2;
                cld ;
                // Compare $1 with $2
                if (a != b) {  // jne 0x186eb
                    // Block 0x186EB
                    $1 = $2;
                    $1--;
                    if (a == b) {  // je 0x18755
                        // Block 0x18755
                        $1 = $2;
                        and dx, word ptr [bp - 0x2a];
                        and dx, word ptr [bp - 0xa0];
                        $1 = $2;
                        $1 = $2;
                        ror ax, cl;
                        and word ptr es:[di], ax;
                        $1 = $2;
                        $1 = $2;
                        ror ax, cl;
                        and word ptr es:[di + 1], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di + 1], ax;
                    } else {
                        // Block 0x186F1
                        $1 = $2;
                        and dx, word ptr [bp - 0x2a];
                        and dx, word ptr [bp - 0x9c];
                        $1 = 0;
                        $1 = $2;
                        not ax;
                        ror ax, cl;
                        and word ptr es:[di], ax;
                        $1 = 0;
                        $1 = $2;
                        not ax;
                        ror ax, cl;
                        and word ptr es:[di + 1], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di], ax;
                        $1 = $2;
                        $1 = 0;
                        ror ax, cl;
                        or word ptr es:[di + 1], ax;
                        jmp 0x18750;
                        // Block 0x18750
                        $1++;
                        $1++;
                        $1--;
                        if (a != b) {  // jne 0x1872b
                            // Block 0x1872B
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                        } else {
                            // Block 0x18755
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            and dx, word ptr [bp - 0xa0];
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                        }
                    }
                } else {
                    // Block 0x186D1
                    cmp word ptr [bp - 0x9c], -1;
                    if (a != b) {  // jne 0x186eb
                        // Block 0x186EB
                        $1 = $2;
                        $1--;
                        if (a == b) {  // je 0x18755
                            // Block 0x18755
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            and dx, word ptr [bp - 0xa0];
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            $1 = $2;
                            $1 = $2;
                            ror ax, cl;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                        } else {
                            // Block 0x186F1
                            $1 = $2;
                            and dx, word ptr [bp - 0x2a];
                            and dx, word ptr [bp - 0x9c];
                            $1 = 0;
                            $1 = $2;
                            not ax;
                            ror ax, cl;
                            and word ptr es:[di], ax;
                            $1 = 0;
                            $1 = $2;
                            not ax;
                            ror ax, cl;
                            and word ptr es:[di + 1], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di], ax;
                            $1 = $2;
                            $1 = 0;
                            ror ax, cl;
                            or word ptr es:[di + 1], ax;
                            jmp 0x18750;
                            // Block 0x18750
                            $1++;
                            $1++;
                            $1--;
                            if (a != b) {  // jne 0x1872b
                                // Block 0x1872B
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                            } else {
                                // Block 0x18755
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                and dx, word ptr [bp - 0xa0];
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                            }
                        }
                    } else {
                        // Block 0x186D8
                        $1 = $2;
                        $1 = $2;
                        and ax, word ptr [bp - 0x2a];
                        mov word ptr es:[di], ax;
                        $1++;
                        $1++;
                        loop 0x186e1;
                        jmp 0x18789;
                        // Block 0x18789
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x1869E
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x186b1
                    // Block 0x186B1
                    jmp 0x18789;
                    // Block 0x18789
                    return;  // retf 
                } else {
                    // Block 0x186AB
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x186b4
                        // Block 0x186B4
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        lcall es:[di + 0x26];
                        $1 = $2;
                        $1 = $2;
                        cld ;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x186eb
                            // Block 0x186EB
                            $1 = $2;
                            $1--;
                            if (a == b) {  // je 0x18755
                                // Block 0x18755
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                and dx, word ptr [bp - 0xa0];
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                $1 = $2;
                                $1 = $2;
                                ror ax, cl;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                            } else {
                                // Block 0x186F1
                                $1 = $2;
                                and dx, word ptr [bp - 0x2a];
                                and dx, word ptr [bp - 0x9c];
                                $1 = 0;
                                $1 = $2;
                                not ax;
                                ror ax, cl;
                                and word ptr es:[di], ax;
                                $1 = 0;
                                $1 = $2;
                                not ax;
                                ror ax, cl;
                                and word ptr es:[di + 1], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di], ax;
                                $1 = $2;
                                $1 = 0;
                                ror ax, cl;
                                or word ptr es:[di + 1], ax;
                                jmp 0x18750;
                                // Block 0x18750
                                $1++;
                                $1++;
                                $1--;
                                if (a != b) {  // jne 0x1872b
                                    // Block 0x1872B
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                } else {
                                    // Block 0x18755
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    and dx, word ptr [bp - 0xa0];
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                }
                            }
                        } else {
                            // Block 0x186D1
                            cmp word ptr [bp - 0x9c], -1;
                            if (a != b) {  // jne 0x186eb
                                // Block 0x186EB
                                $1 = $2;
                                $1--;
                                if (a == b) {  // je 0x18755
                                    // Block 0x18755
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    and dx, word ptr [bp - 0xa0];
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = $2;
                                    ror ax, cl;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                } else {
                                    // Block 0x186F1
                                    $1 = $2;
                                    and dx, word ptr [bp - 0x2a];
                                    and dx, word ptr [bp - 0x9c];
                                    $1 = 0;
                                    $1 = $2;
                                    not ax;
                                    ror ax, cl;
                                    and word ptr es:[di], ax;
                                    $1 = 0;
                                    $1 = $2;
                                    not ax;
                                    ror ax, cl;
                                    and word ptr es:[di + 1], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    ror ax, cl;
                                    or word ptr es:[di + 1], ax;
                                    jmp 0x18750;
                                    // Block 0x18750
                                    $1++;
                                    $1++;
                                    $1--;
                                    if (a != b) {  // jne 0x1872b
                                        // Block 0x1872B
                                        $1 = $2;
                                        and dx, word ptr [bp - 0x2a];
                                        $1 = $2;
                                        ror ax, cl;
                                        and word ptr es:[di], ax;
                                        and word ptr es:[di + 1], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di + 1], ax;
                                    } else {
                                        // Block 0x18755
                                        $1 = $2;
                                        and dx, word ptr [bp - 0x2a];
                                        and dx, word ptr [bp - 0xa0];
                                        $1 = $2;
                                        $1 = $2;
                                        ror ax, cl;
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        $1 = $2;
                                        ror ax, cl;
                                        and word ptr es:[di + 1], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di + 1], ax;
                                    }
                                }
                            } else {
                                // Block 0x186D8
                                $1 = $2;
                                $1 = $2;
                                and ax, word ptr [bp - 0x2a];
                                mov word ptr es:[di], ax;
                                $1++;
                                $1++;
                                loop 0x186e1;
                                jmp 0x18789;
                                // Block 0x18789
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0x186B1
                        jmp 0x18789;
                        // Block 0x18789
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x1868C
            jmp 0x18789;
            // Block 0x18789
            return;  // retf 
        }
    } else {
        // Block 0x18683
        jmp 0x18789;
        // Block 0x18789
        return;  // retf 
    }

    // Function calls:
    sub_18B44();
}

void sub_18B44() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 71 if statements

    // Block 0x18B44
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x18b4d
        // Block 0x18B4D
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x18b56
            // Block 0x18B56
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x18b7b
                // Block 0x18B7B
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                mul bx;
                push($1);
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x18b93
                    // Block 0x18B93
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = pop();
                    $1 += $2;
                    $1 = $2;
                    $1 = $2;
                    cld ;
                    cmp word ptr [bp - 0xa], 0xff00;
                    if (a != b) {  // jne 0x18bce
                        // Block 0x18BCE
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        ror dx, cl;
                        $1--;
                        if (a != b) {  // jne 0x18bde
                            // Block 0x18BDE
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x18bec
                                // Block 0x18BEC
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                ror ax, cl;
                                and ax, word ptr [bp - 0xa0];
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18c07
                                    // Block 0x18C07
                                    or word ptr es:[di], ax;
                                    jmp 0x18c1b;
                                    // Block 0x18C1B
                                    inc di;
                                } else {
                                    // Block 0x18C02
                                    or byte ptr es:[di], ah;
                                    jmp 0x18c1c;
                                    // Block 0x18C1C
                                    $1--;
                                    if (a != b) {  // jne 0x18c0c
                                        // Block 0x18C0C
                                        and word ptr es:[di], dx;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C1F
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c33
                                            // Block 0x18C33
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C47
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C4D
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x18c55;
                                                    // Block 0x18C55
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x18C29
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c33
                                                // Block 0x18C33
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C47
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C4D
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x18c55;
                                                        // Block 0x18C55
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x18C2F
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x18BE8
                                xchg al, ah;
                                mov ah, 0xff;
                            }
                        } else {
                            // Block 0x18BDC
                            jmp 0x18c1f;
                            // Block 0x18C1F
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x18c33
                                // Block 0x18C33
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                and al, ch;
                                ror ax, cl;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18c52
                                    // Block 0x18C52
                                    or word ptr es:[di], ax;
                                } else {
                                    // Block 0x18C47
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x18c52
                                        // Block 0x18C52
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C4D
                                        or byte ptr es:[di], ah;
                                        jmp 0x18c55;
                                        // Block 0x18C55
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0x18C29
                                cmp word ptr [bp - 0xe], 1;
                                if (a != b) {  // jne 0x18c33
                                    // Block 0x18C33
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c52
                                        // Block 0x18C52
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C47
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C4D
                                            or byte ptr es:[di], ah;
                                            jmp 0x18c55;
                                            // Block 0x18C55
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x18C2F
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            }
                        }
                    } else {
                        // Block 0x18BAE
                        cmp word ptr [bp - 0x9c], 0xff00;
                        if (a != b) {  // jne 0x18bce
                            // Block 0x18BCE
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            ror dx, cl;
                            $1--;
                            if (a != b) {  // jne 0x18bde
                                // Block 0x18BDE
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18bec
                                    // Block 0x18BEC
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    ror ax, cl;
                                    and ax, word ptr [bp - 0xa0];
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c07
                                        // Block 0x18C07
                                        or word ptr es:[di], ax;
                                        jmp 0x18c1b;
                                        // Block 0x18C1B
                                        inc di;
                                    } else {
                                        // Block 0x18C02
                                        or byte ptr es:[di], ah;
                                        jmp 0x18c1c;
                                        // Block 0x18C1C
                                        $1--;
                                        if (a != b) {  // jne 0x18c0c
                                            // Block 0x18C0C
                                            and word ptr es:[di], dx;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C1F
                                            $1 = $2;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c33
                                                // Block 0x18C33
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C47
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C4D
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x18c55;
                                                        // Block 0x18C55
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x18C29
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c33
                                                    // Block 0x18C33
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C47
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C4D
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x18c55;
                                                            // Block 0x18C55
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x18C2F
                                                    xchg al, ah;
                                                    mov ah, 0xff;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x18BE8
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            } else {
                                // Block 0x18BDC
                                jmp 0x18c1f;
                                // Block 0x18C1F
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x18c33
                                    // Block 0x18C33
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c52
                                        // Block 0x18C52
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x18C47
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C4D
                                            or byte ptr es:[di], ah;
                                            jmp 0x18c55;
                                            // Block 0x18C55
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x18C29
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x18c33
                                        // Block 0x18C33
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C47
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C4D
                                                or byte ptr es:[di], ah;
                                                jmp 0x18c55;
                                                // Block 0x18C55
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x18C2F
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                }
                            }
                        } else {
                            // Block 0x18BB6
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            not ah;
                            and byte ptr es:[di], ah;
                            xor al, byte ptr [bp - 8];
                            or byte ptr es:[di], al;
                            $1++;
                            loop 0x18bb9;
                            jmp 0x18c55;
                            // Block 0x18C55
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x18B90
                    add bx, 8;
                }
            } else {
                // Block 0x18B65
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x18b78
                    // Block 0x18B78
                    jmp 0x18c55;
                    // Block 0x18C55
                    return;  // retf 
                } else {
                    // Block 0x18B72
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x18b7b
                        // Block 0x18B7B
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        push($1);
                        $1 = $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x18b93
                            // Block 0x18B93
                            $1 = $2;
                            $1 += $2;
                            lcall es:[di + 0x26];
                            $1 = pop();
                            $1 += $2;
                            $1 = $2;
                            $1 = $2;
                            cld ;
                            cmp word ptr [bp - 0xa], 0xff00;
                            if (a != b) {  // jne 0x18bce
                                // Block 0x18BCE
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                ror dx, cl;
                                $1--;
                                if (a != b) {  // jne 0x18bde
                                    // Block 0x18BDE
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18bec
                                        // Block 0x18BEC
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        and ax, word ptr [bp - 0xa0];
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c07
                                            // Block 0x18C07
                                            or word ptr es:[di], ax;
                                            jmp 0x18c1b;
                                            // Block 0x18C1B
                                            inc di;
                                        } else {
                                            // Block 0x18C02
                                            or byte ptr es:[di], ah;
                                            jmp 0x18c1c;
                                            // Block 0x18C1C
                                            $1--;
                                            if (a != b) {  // jne 0x18c0c
                                                // Block 0x18C0C
                                                and word ptr es:[di], dx;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                ror ax, cl;
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C1F
                                                $1 = $2;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c33
                                                    // Block 0x18C33
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C47
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C4D
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x18c55;
                                                            // Block 0x18C55
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x18C29
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c33
                                                        // Block 0x18C33
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C47
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x18c52
                                                                // Block 0x18C52
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x18C4D
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x18c55;
                                                                // Block 0x18C55
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x18C2F
                                                        xchg al, ah;
                                                        mov ah, 0xff;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x18BE8
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                } else {
                                    // Block 0x18BDC
                                    jmp 0x18c1f;
                                    // Block 0x18C1F
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x18c33
                                        // Block 0x18C33
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c52
                                            // Block 0x18C52
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x18C47
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C4D
                                                or byte ptr es:[di], ah;
                                                jmp 0x18c55;
                                                // Block 0x18C55
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x18C29
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x18c33
                                            // Block 0x18C33
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C47
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C4D
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x18c55;
                                                    // Block 0x18C55
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x18C2F
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x18BAE
                                cmp word ptr [bp - 0x9c], 0xff00;
                                if (a != b) {  // jne 0x18bce
                                    // Block 0x18BCE
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    ror dx, cl;
                                    $1--;
                                    if (a != b) {  // jne 0x18bde
                                        // Block 0x18BDE
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18bec
                                            // Block 0x18BEC
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            and ax, word ptr [bp - 0xa0];
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c07
                                                // Block 0x18C07
                                                or word ptr es:[di], ax;
                                                jmp 0x18c1b;
                                                // Block 0x18C1B
                                                inc di;
                                            } else {
                                                // Block 0x18C02
                                                or byte ptr es:[di], ah;
                                                jmp 0x18c1c;
                                                // Block 0x18C1C
                                                $1--;
                                                if (a != b) {  // jne 0x18c0c
                                                    // Block 0x18C0C
                                                    and word ptr es:[di], dx;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    ror ax, cl;
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C1F
                                                    $1 = $2;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x18c33
                                                        // Block 0x18C33
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x18c52
                                                            // Block 0x18C52
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x18C47
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x18c52
                                                                // Block 0x18C52
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x18C4D
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x18c55;
                                                                // Block 0x18C55
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x18C29
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x18c33
                                                            // Block 0x18C33
                                                            and word ptr es:[di], ax;
                                                            $1 = $2;
                                                            xor al, byte ptr [bp - 8];
                                                            $1 = 0;
                                                            and al, ch;
                                                            ror ax, cl;
                                                            cmp word ptr [bp + 8], 0;
                                                            if (a >= b) {  // jge 0x18c52
                                                                // Block 0x18C52
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x18C47
                                                                cmp word ptr [bp - 0xe], 1;
                                                                if (a != b) {  // jne 0x18c52
                                                                    // Block 0x18C52
                                                                    or word ptr es:[di], ax;
                                                                } else {
                                                                    // Block 0x18C4D
                                                                    or byte ptr es:[di], ah;
                                                                    jmp 0x18c55;
                                                                    // Block 0x18C55
                                                                    return;  // retf 
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x18C2F
                                                            xchg al, ah;
                                                            mov ah, 0xff;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x18BE8
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    } else {
                                        // Block 0x18BDC
                                        jmp 0x18c1f;
                                        // Block 0x18C1F
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x18c33
                                            // Block 0x18C33
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x18c52
                                                // Block 0x18C52
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x18C47
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C4D
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x18c55;
                                                    // Block 0x18C55
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x18C29
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x18c33
                                                // Block 0x18C33
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x18c52
                                                    // Block 0x18C52
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x18C47
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x18c52
                                                        // Block 0x18C52
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x18C4D
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x18c55;
                                                        // Block 0x18C55
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x18C2F
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x18BB6
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    not ah;
                                    and byte ptr es:[di], ah;
                                    xor al, byte ptr [bp - 8];
                                    or byte ptr es:[di], al;
                                    $1++;
                                    loop 0x18bb9;
                                    jmp 0x18c55;
                                    // Block 0x18C55
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x18B90
                            add bx, 8;
                        }
                    } else {
                        // Block 0x18B78
                        jmp 0x18c55;
                        // Block 0x18C55
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x18B53
            jmp 0x18c55;
            // Block 0x18C55
            return;  // retf 
        }
    } else {
        // Block 0x18B4A
        jmp 0x18c55;
        // Block 0x18C55
        return;  // retf 
    }

    // Function calls:
    sub_19038();
}

void sub_19038() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 74 if statements

    // Block 0x19038
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19041
        // Block 0x19041
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x1904a
            // Block 0x1904A
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x1906f
                // Block 0x1906F
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                mul bx;
                push($1);
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0x19087
                    // Block 0x19087
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = pop();
                    $1 += $2;
                    $1 = $2;
                    $1 = $2;
                    cld ;
                    cmp word ptr [bp - 0xa], 0xff00;
                    if (a != b) {  // jne 0x190c2
                        // Block 0x190C2
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        ror dx, cl;
                        $1--;
                        if (a != b) {  // jne 0x190d2
                            // Block 0x190D2
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x190e0
                                // Block 0x190E0
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                ror ax, cl;
                                and ax, word ptr [bp - 0xa0];
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x190fb
                                    // Block 0x190FB
                                    or word ptr es:[di], ax;
                                    jmp 0x1910f;
                                    // Block 0x1910F
                                    inc di;
                                } else {
                                    // Block 0x190F6
                                    or byte ptr es:[di], ah;
                                    jmp 0x19110;
                                    // Block 0x19110
                                    $1--;
                                    if (a != b) {  // jne 0x19100
                                        // Block 0x19100
                                        and word ptr es:[di], dx;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x19113
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19127
                                            // Block 0x19127
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x1913B
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19141
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x19149;
                                                    // Block 0x19149
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x1911D
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19127
                                                // Block 0x19127
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x1913B
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x19141
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x19149;
                                                        // Block 0x19149
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x19123
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x190DC
                                xchg al, ah;
                                mov ah, 0xff;
                            }
                        } else {
                            // Block 0x190D0
                            jmp 0x19113;
                            // Block 0x19113
                            $1 = $2;
                            cmp word ptr [bp + 8], 0;
                            if (a >= b) {  // jge 0x19127
                                // Block 0x19127
                                and word ptr es:[di], ax;
                                $1 = $2;
                                xor al, byte ptr [bp - 8];
                                $1 = 0;
                                and al, ch;
                                ror ax, cl;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x19146
                                    // Block 0x19146
                                    or word ptr es:[di], ax;
                                } else {
                                    // Block 0x1913B
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x19146
                                        // Block 0x19146
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x19141
                                        or byte ptr es:[di], ah;
                                        jmp 0x19149;
                                        // Block 0x19149
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0x1911D
                                cmp word ptr [bp - 0xe], 1;
                                if (a != b) {  // jne 0x19127
                                    // Block 0x19127
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x19146
                                        // Block 0x19146
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x1913B
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x19141
                                            or byte ptr es:[di], ah;
                                            jmp 0x19149;
                                            // Block 0x19149
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x19123
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            }
                        }
                    } else {
                        // Block 0x190A2
                        cmp word ptr [bp - 0x9c], 0xff00;
                        if (a != b) {  // jne 0x190c2
                            // Block 0x190C2
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            ror dx, cl;
                            $1--;
                            if (a != b) {  // jne 0x190d2
                                // Block 0x190D2
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x190e0
                                    // Block 0x190E0
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    ror ax, cl;
                                    and ax, word ptr [bp - 0xa0];
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x190fb
                                        // Block 0x190FB
                                        or word ptr es:[di], ax;
                                        jmp 0x1910f;
                                        // Block 0x1910F
                                        inc di;
                                    } else {
                                        // Block 0x190F6
                                        or byte ptr es:[di], ah;
                                        jmp 0x19110;
                                        // Block 0x19110
                                        $1--;
                                        if (a != b) {  // jne 0x19100
                                            // Block 0x19100
                                            and word ptr es:[di], dx;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x19113
                                            $1 = $2;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19127
                                                // Block 0x19127
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x1913B
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x19141
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x19149;
                                                        // Block 0x19149
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x1911D
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19127
                                                    // Block 0x19127
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x1913B
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x19141
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x19149;
                                                            // Block 0x19149
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x19123
                                                    xchg al, ah;
                                                    mov ah, 0xff;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x190DC
                                    xchg al, ah;
                                    mov ah, 0xff;
                                }
                            } else {
                                // Block 0x190D0
                                jmp 0x19113;
                                // Block 0x19113
                                $1 = $2;
                                cmp word ptr [bp + 8], 0;
                                if (a >= b) {  // jge 0x19127
                                    // Block 0x19127
                                    and word ptr es:[di], ax;
                                    $1 = $2;
                                    xor al, byte ptr [bp - 8];
                                    $1 = 0;
                                    and al, ch;
                                    ror ax, cl;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x19146
                                        // Block 0x19146
                                        or word ptr es:[di], ax;
                                    } else {
                                        // Block 0x1913B
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x19141
                                            or byte ptr es:[di], ah;
                                            jmp 0x19149;
                                            // Block 0x19149
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0x1911D
                                    cmp word ptr [bp - 0xe], 1;
                                    if (a != b) {  // jne 0x19127
                                        // Block 0x19127
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x1913B
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x19141
                                                or byte ptr es:[di], ah;
                                                jmp 0x19149;
                                                // Block 0x19149
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x19123
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                }
                            }
                        } else {
                            // Block 0x190AA
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            not ah;
                            and byte ptr es:[di], ah;
                            xor al, byte ptr [bp - 8];
                            or byte ptr es:[di], al;
                            $1++;
                            loop 0x190ad;
                            jmp 0x19149;
                            // Block 0x19149
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x19084
                    add bx, 8;
                }
            } else {
                // Block 0x19059
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x1906c
                    // Block 0x1906C
                    jmp 0x19149;
                    // Block 0x19149
                    return;  // retf 
                } else {
                    // Block 0x19066
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x1906f
                        // Block 0x1906F
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        mul bx;
                        push($1);
                        $1 = $2;
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0x19087
                            // Block 0x19087
                            $1 = $2;
                            $1 += $2;
                            lcall es:[di + 0x26];
                            $1 = pop();
                            $1 += $2;
                            $1 = $2;
                            $1 = $2;
                            cld ;
                            cmp word ptr [bp - 0xa], 0xff00;
                            if (a != b) {  // jne 0x190c2
                                // Block 0x190C2
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                ror dx, cl;
                                $1--;
                                if (a != b) {  // jne 0x190d2
                                    // Block 0x190D2
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x190e0
                                        // Block 0x190E0
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        ror ax, cl;
                                        and ax, word ptr [bp - 0xa0];
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x190fb
                                            // Block 0x190FB
                                            or word ptr es:[di], ax;
                                            jmp 0x1910f;
                                            // Block 0x1910F
                                            inc di;
                                        } else {
                                            // Block 0x190F6
                                            or byte ptr es:[di], ah;
                                            jmp 0x19110;
                                            // Block 0x19110
                                            $1--;
                                            if (a != b) {  // jne 0x19100
                                                // Block 0x19100
                                                and word ptr es:[di], dx;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                ror ax, cl;
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x19113
                                                $1 = $2;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19127
                                                    // Block 0x19127
                                                    and word ptr es:[di], ax;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    and al, ch;
                                                    ror ax, cl;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x1913B
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x19141
                                                            or byte ptr es:[di], ah;
                                                            jmp 0x19149;
                                                            // Block 0x19149
                                                            return;  // retf 
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x1911D
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19127
                                                        // Block 0x19127
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x1913B
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x19146
                                                                // Block 0x19146
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x19141
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x19149;
                                                                // Block 0x19149
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x19123
                                                        xchg al, ah;
                                                        mov ah, 0xff;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x190DC
                                        xchg al, ah;
                                        mov ah, 0xff;
                                    }
                                } else {
                                    // Block 0x190D0
                                    jmp 0x19113;
                                    // Block 0x19113
                                    $1 = $2;
                                    cmp word ptr [bp + 8], 0;
                                    if (a >= b) {  // jge 0x19127
                                        // Block 0x19127
                                        and word ptr es:[di], ax;
                                        $1 = $2;
                                        xor al, byte ptr [bp - 8];
                                        $1 = 0;
                                        and al, ch;
                                        ror ax, cl;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19146
                                            // Block 0x19146
                                            or word ptr es:[di], ax;
                                        } else {
                                            // Block 0x1913B
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x19141
                                                or byte ptr es:[di], ah;
                                                jmp 0x19149;
                                                // Block 0x19149
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0x1911D
                                        cmp word ptr [bp - 0xe], 1;
                                        if (a != b) {  // jne 0x19127
                                            // Block 0x19127
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x1913B
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19141
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x19149;
                                                    // Block 0x19149
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x19123
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x190A2
                                cmp word ptr [bp - 0x9c], 0xff00;
                                if (a != b) {  // jne 0x190c2
                                    // Block 0x190C2
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    ror dx, cl;
                                    $1--;
                                    if (a != b) {  // jne 0x190d2
                                        // Block 0x190D2
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x190e0
                                            // Block 0x190E0
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            ror ax, cl;
                                            and ax, word ptr [bp - 0xa0];
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x190fb
                                                // Block 0x190FB
                                                or word ptr es:[di], ax;
                                                jmp 0x1910f;
                                                // Block 0x1910F
                                                inc di;
                                            } else {
                                                // Block 0x190F6
                                                or byte ptr es:[di], ah;
                                                jmp 0x19110;
                                                // Block 0x19110
                                                $1--;
                                                if (a != b) {  // jne 0x19100
                                                    // Block 0x19100
                                                    and word ptr es:[di], dx;
                                                    $1 = $2;
                                                    xor al, byte ptr [bp - 8];
                                                    $1 = 0;
                                                    ror ax, cl;
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19113
                                                    $1 = $2;
                                                    cmp word ptr [bp + 8], 0;
                                                    if (a >= b) {  // jge 0x19127
                                                        // Block 0x19127
                                                        and word ptr es:[di], ax;
                                                        $1 = $2;
                                                        xor al, byte ptr [bp - 8];
                                                        $1 = 0;
                                                        and al, ch;
                                                        ror ax, cl;
                                                        cmp word ptr [bp + 8], 0;
                                                        if (a >= b) {  // jge 0x19146
                                                            // Block 0x19146
                                                            or word ptr es:[di], ax;
                                                        } else {
                                                            // Block 0x1913B
                                                            cmp word ptr [bp - 0xe], 1;
                                                            if (a != b) {  // jne 0x19146
                                                                // Block 0x19146
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x19141
                                                                or byte ptr es:[di], ah;
                                                                jmp 0x19149;
                                                                // Block 0x19149
                                                                return;  // retf 
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x1911D
                                                        cmp word ptr [bp - 0xe], 1;
                                                        if (a != b) {  // jne 0x19127
                                                            // Block 0x19127
                                                            and word ptr es:[di], ax;
                                                            $1 = $2;
                                                            xor al, byte ptr [bp - 8];
                                                            $1 = 0;
                                                            and al, ch;
                                                            ror ax, cl;
                                                            cmp word ptr [bp + 8], 0;
                                                            if (a >= b) {  // jge 0x19146
                                                                // Block 0x19146
                                                                or word ptr es:[di], ax;
                                                            } else {
                                                                // Block 0x1913B
                                                                cmp word ptr [bp - 0xe], 1;
                                                                if (a != b) {  // jne 0x19146
                                                                    // Block 0x19146
                                                                    or word ptr es:[di], ax;
                                                                } else {
                                                                    // Block 0x19141
                                                                    or byte ptr es:[di], ah;
                                                                    jmp 0x19149;
                                                                    // Block 0x19149
                                                                    return;  // retf 
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x19123
                                                            xchg al, ah;
                                                            mov ah, 0xff;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x190DC
                                            xchg al, ah;
                                            mov ah, 0xff;
                                        }
                                    } else {
                                        // Block 0x190D0
                                        jmp 0x19113;
                                        // Block 0x19113
                                        $1 = $2;
                                        cmp word ptr [bp + 8], 0;
                                        if (a >= b) {  // jge 0x19127
                                            // Block 0x19127
                                            and word ptr es:[di], ax;
                                            $1 = $2;
                                            xor al, byte ptr [bp - 8];
                                            $1 = 0;
                                            and al, ch;
                                            ror ax, cl;
                                            cmp word ptr [bp + 8], 0;
                                            if (a >= b) {  // jge 0x19146
                                                // Block 0x19146
                                                or word ptr es:[di], ax;
                                            } else {
                                                // Block 0x1913B
                                                cmp word ptr [bp - 0xe], 1;
                                                if (a != b) {  // jne 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x19141
                                                    or byte ptr es:[di], ah;
                                                    jmp 0x19149;
                                                    // Block 0x19149
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0x1911D
                                            cmp word ptr [bp - 0xe], 1;
                                            if (a != b) {  // jne 0x19127
                                                // Block 0x19127
                                                and word ptr es:[di], ax;
                                                $1 = $2;
                                                xor al, byte ptr [bp - 8];
                                                $1 = 0;
                                                and al, ch;
                                                ror ax, cl;
                                                cmp word ptr [bp + 8], 0;
                                                if (a >= b) {  // jge 0x19146
                                                    // Block 0x19146
                                                    or word ptr es:[di], ax;
                                                } else {
                                                    // Block 0x1913B
                                                    cmp word ptr [bp - 0xe], 1;
                                                    if (a != b) {  // jne 0x19146
                                                        // Block 0x19146
                                                        or word ptr es:[di], ax;
                                                    } else {
                                                        // Block 0x19141
                                                        or byte ptr es:[di], ah;
                                                        jmp 0x19149;
                                                        // Block 0x19149
                                                        return;  // retf 
                                                    }
                                                }
                                            } else {
                                                // Block 0x19123
                                                xchg al, ah;
                                                mov ah, 0xff;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x190AA
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    not ah;
                                    and byte ptr es:[di], ah;
                                    xor al, byte ptr [bp - 8];
                                    or byte ptr es:[di], al;
                                    $1++;
                                    loop 0x190ad;
                                    jmp 0x19149;
                                    // Block 0x19149
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x19084
                            add bx, 8;
                        }
                    } else {
                        // Block 0x1906C
                        jmp 0x19149;
                        // Block 0x19149
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x19047
            jmp 0x19149;
            // Block 0x19149
            return;  // retf 
        }
    } else {
        // Block 0x1903E
        jmp 0x19149;
        // Block 0x19149
        return;  // retf 
    }

    // Function calls:
    sub_19831();
}

void sub_19831() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 25 if statements

    // Block 0x19831
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp byte ptr [0x712c], 1;
    if (a == b) {  // je 0x1984d
        // Block 0x1984D
        cmp word ptr [0x7132], 1;
        if (a != b) {  // jne 0x19866
            // Block 0x19866
            lcall 0x98e, 0x35e;
            // Compare $1 with $2
            if (a >= b) {  // jge 0x1989d
                // Block 0x1989D
                *($1) = $2;
                push($1);
                lcall 0x98e, 0x12a;
                if (a >= b (unsigned)) {  // jae 0x198b0
                    // Block 0x198B0
                    *($1) = $2;
                    *($1) = $2;
                    $1 = $2;
                    push($1);
                    lcall 0x98e, 0xa6;
                    or ax, ax;
                    if (a >= b) {  // jge 0x198cb
                        // Block 0x198CB
                        *($1) = $2;
                        les di, ptr [bp - 0x58];
                        push($1);
                        lea ax, [bp - 0x60];
                        push($1);
                        lcall 0x185d, 0x46;
                        or ax, ax;
                        if (a == b) {  // je 0x198e5
                            // Block 0x198E5
                            lds si, ptr [bp - 0x60];
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = 0;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 = $2;
                            *($1) = $2;
                            $1 -= $2;
                            $1 += $2;
                            *($1) = $2;
                            test word ptr [si + 0x18], 0x10;
                            if (a != b) {  // jne 0x1996f
                                // Block 0x1996F
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                *($1) = $2;
                                $1 = $2;
                                *($1) = $2;
                                cmp word ptr es:[di + 0x1e], 0;
                                if (a == b) {  // je 0x19994
                                    // Block 0x19994
                                    cmp word ptr es:[di + 0x20], 0;
                                    if (a == b) {  // je 0x199a2
                                        // Block 0x199A2
                                        push($1);
                                        lea ax, [bp - 0x4c];
                                        push($1);
                                        push($1);
                                        lea ax, [bp - 0x4e];
                                        push($1);
                                        lcall 0x96b, 0x66;
                                        or ax, ax;
                                        if (a == b) {  // je 0x199bb
                                            // Block 0x199BB
                                            lds si, ptr [bp - 0x60];
                                            lds si, ptr [si + 0xa8];
                                            push($1);
                                            les di, ptr [bp - 0x4c];
                                            $1 = $2;
                                            rep movsb byte ptr es:[di], byte ptr [si];
                                            $1 = pop();
                                            les di, ptr [bp + 0xa];
                                            cld ;
                                            $1 = $2;
                                            $1 = $2;
                                            repne scasb al, byte ptr es:[di];
                                            $1 -= $2;
                                            $1--;
                                            // Compare $1 with $2
                                            if (a > b (unsigned)) {  // ja 0x199e8
                                                // Block 0x199E8
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [bp - 0x44], 0;
                                                les di, ptr [bp + 0xa];
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = 0;
                                                // Compare $1 with $2
                                                if (a < b (unsigned)) {  // jb 0x19a28
                                                    // Block 0x19A28
                                                    $1++;
                                                    loop 0x199fa;
                                                    $1 = $2;
                                                    // Compare $1 with $2
                                                    if (a <= b (unsigned)) {  // jbe 0x19a47
                                                        // Block 0x19A47
                                                        push($1);
                                                        call 0x19b03;
                                                        // Block 0x19A4B
                                                        les di, ptr [bp + 0xa];
                                                    } else {
                                                        // Block 0x19A33
                                                        push($1);
                                                        push($1);
                                                        lcall 0x1754, 0xa;
                                                        or ax, ax;
                                                        if (a == b) {  // je 0x19a47
                                                            // Block 0x19A47
                                                            push($1);
                                                            call 0x19b03;
                                                            // Block 0x19A4B
                                                            les di, ptr [bp + 0xa];
                                                        } else {
                                                            // Block 0x19A42
                                                            *($1) = $2;
                                                            jmp 0x19ab5;
                                                            // Block 0x19AB5
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 8
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x19A04
                                                    // Compare $1 with $2
                                                    if (a > b (unsigned)) {  // ja 0x19a28
                                                        // Block 0x19A28
                                                        $1++;
                                                        loop 0x199fa;
                                                        $1 = $2;
                                                        // Compare $1 with $2
                                                        if (a <= b (unsigned)) {  // jbe 0x19a47
                                                            // Block 0x19A47
                                                            push($1);
                                                            call 0x19b03;
                                                            // Block 0x19A4B
                                                            les di, ptr [bp + 0xa];
                                                        } else {
                                                            // Block 0x19A33
                                                            push($1);
                                                            push($1);
                                                            lcall 0x1754, 0xa;
                                                            or ax, ax;
                                                            if (a == b) {  // je 0x19a47
                                                                // Block 0x19A47
                                                                push($1);
                                                                call 0x19b03;
                                                                // Block 0x19A4B
                                                                les di, ptr [bp + 0xa];
                                                            } else {
                                                                // Block 0x19A42
                                                                *($1) = $2;
                                                                jmp 0x19ab5;
                                                                // Block 0x19AB5
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 8
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x19A09
                                                        $1 = $2;
                                                        // Compare $1 with $2
                                                        if (a != b) {  // jne 0x19a25
                                                            // Block 0x19A25
                                                            add word ptr [bp - 0x44], ax;
                                                        } else {
                                                            // Block 0x19A11
                                                            $1 = $2;
                                                            $1 = 0;
                                                            $1 -= $2;
                                                            shl bx, 1;
                                                            $1 = $2;
                                                            // Compare $1 with $2
                                                            if (a == b) {  // je 0x19a25
                                                                // Block 0x19A25
                                                                add word ptr [bp - 0x44], ax;
                                                            } else {
                                                                // Block 0x19A22
                                                                add ax, word ptr [bp - 0x34];
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x199E0
                                                mov word ptr [bp - 2], 0;
                                                jmp 0x19ab5;
                                                // Block 0x19AB5
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 8
                                            }
                                        } else {
                                            // Block 0x199B5
                                            *($1) = $2;
                                            jmp 0x19ab5;
                                            // Block 0x19AB5
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 8
                                        }
                                    } else {
                                        // Block 0x1999B
                                        $1 = $2;
                                        add word ptr [bp + 6], ax;
                                    }
                                } else {
                                    // Block 0x1998D
                                    $1 = $2;
                                    add word ptr [bp + 8], ax;
                                }
                            } else {
                                // Block 0x1996A
                                mov word ptr [bp - 0x32], 0;
                            }
                        } else {
                            // Block 0x198DF
                            *($1) = $2;
                            jmp 0x19ab5;
                            // Block 0x19AB5
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    } else {
                        // Block 0x198C3
                        mov word ptr [bp - 2], 0xfc19;
                        jmp 0x19ab5;
                        // Block 0x19AB5
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    }
                } else {
                    // Block 0x198A8
                    mov word ptr [bp - 2], 0xfc19;
                    jmp 0x19ab5;
                    // Block 0x19AB5
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 8
                }
            } else {
                // Block 0x19870
                // Compare $1 with $2
                if (a <= b) {  // jle 0x1987d
                    // Block 0x1987D
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    cmp word ptr es:[di + 4], 1;
                    if (a == b) {  // je 0x19894
                        // Block 0x19894
                        $1 = 0;
                        lcall 0x98e, 0x249;
                        xor ax, ax;
                    } else {
                        // Block 0x1988C
                        mov word ptr [bp - 2], 0xfffa;
                        jmp 0x19ab5;
                        // Block 0x19AB5
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    }
                } else {
                    // Block 0x19875
                    mov word ptr [bp - 2], 0xfffa;
                    jmp 0x19ab5;
                    // Block 0x19AB5
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 8
                }
            }
        } else {
            // Block 0x19854
            $1 = $2;
            mul word ptr [bp + 8];
            *($1) = $2;
            $1 = $2;
            mul word ptr [bp + 6];
            mov word ptr [bp + 6], ax;
        }
    } else {
        // Block 0x19848
        lcall 0x15d6, 0x216;
    }

    // Function calls:
    sub_19B03();
    sub_19831();
}

void sub_19B03() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 42 if statements

    // Block 0x19B03
    $1 = $2;
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19b0e
        // Block 0x19B0E
        // Compare $1 with $2
        if (a != b) {  // jne 0x19b16
            // Block 0x19B16
            // Compare $1 with $2
            if (a != b) {  // jne 0x19b25
                // Block 0x19B25
                // Compare $1 with $2
                if (a != b) {  // jne 0x19b32
                    // Block 0x19B32
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b3f
                        // Block 0x19B3F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b4c
                            // Block 0x19B4C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19b59
                                // Block 0x19B59
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            } else {
                                // Block 0x19B51
                                $1 = $2;
                                shr ax, 1;
                                sub word ptr [bp + 6], ax;
                            }
                        } else {
                            // Block 0x19B44
                            $1 = $2;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19b59;
                            // Block 0x19B59
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B37
                        $1 = $2;
                        sub word ptr [bp + 6], ax;
                        jmp 0x19b59;
                        // Block 0x19B59
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                } else {
                    // Block 0x19B2A
                    $1 = $2;
                    sub word ptr [bp + 8], ax;
                    jmp 0x19b32;
                    // Block 0x19B32
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b3f
                        // Block 0x19B3F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b4c
                            // Block 0x19B4C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19b59
                                // Block 0x19B59
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            } else {
                                // Block 0x19B51
                                $1 = $2;
                                shr ax, 1;
                                sub word ptr [bp + 6], ax;
                            }
                        } else {
                            // Block 0x19B44
                            $1 = $2;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19b59;
                            // Block 0x19B59
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B37
                        $1 = $2;
                        sub word ptr [bp + 6], ax;
                        jmp 0x19b59;
                        // Block 0x19B59
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x19B1B
                $1 = $2;
                shr ax, 1;
                sub word ptr [bp + 8], ax;
                jmp 0x19b32;
                // Block 0x19B32
                // Compare $1 with $2
                if (a != b) {  // jne 0x19b3f
                    // Block 0x19B3F
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b4c
                        // Block 0x19B4C
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b59
                            // Block 0x19B59
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        } else {
                            // Block 0x19B51
                            $1 = $2;
                            shr ax, 1;
                            sub word ptr [bp + 6], ax;
                        }
                    } else {
                        // Block 0x19B44
                        $1 = $2;
                        sub word ptr [bp + 6], ax;
                        jmp 0x19b59;
                        // Block 0x19B59
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                } else {
                    // Block 0x19B37
                    $1 = $2;
                    sub word ptr [bp + 6], ax;
                    jmp 0x19b59;
                    // Block 0x19B59
                    jmp 0x19c55;
                    // Block 0x19C55
                    return;  // retf 
                }
            }
        } else {
            // Block 0x19B14
            jmp 0x19b59;
            // Block 0x19B59
            jmp 0x19c55;
            // Block 0x19C55
            return;  // retf 
        }
    } else {
        // Block 0x19B0C
        jmp 0x19b5c;
        // Block 0x19B5C
        cmp word ptr [bp - 0x48], 1;
        if (a != b) {  // jne 0x19baf
            // Block 0x19BAF
            cmp word ptr [bp - 0x48], 2;
            if (a != b) {  // jne 0x19c02
                // Block 0x19C02
                cmp word ptr [bp - 0x48], 3;
                if (a != b) {  // jne 0x19c55
                    // Block 0x19C55
                    return;  // retf 
                } else {
                    // Block 0x19C08
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19c10
                        // Block 0x19C10
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19c1f
                            // Block 0x19C1F
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19c2c
                                // Block 0x19C2C
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c39
                                    // Block 0x19C39
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c46
                                        // Block 0x19C46
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x19c55
                                            // Block 0x19C55
                                            return;  // retf 
                                        } else {
                                            // Block 0x19C4B
                                            $1 = $2;
                                            shr ax, 1;
                                            sub word ptr [bp + 8], ax;
                                        }
                                    } else {
                                        // Block 0x19C3E
                                        $1 = $2;
                                        sub word ptr [bp + 8], ax;
                                        jmp 0x19c53;
                                        // Block 0x19C53
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    }
                                } else {
                                    // Block 0x19C31
                                    $1 = $2;
                                    sub word ptr [bp + 8], ax;
                                    jmp 0x19c53;
                                    // Block 0x19C53
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19C24
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c2c;
                                // Block 0x19C2C
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c39
                                    // Block 0x19C39
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c46
                                        // Block 0x19C46
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x19c55
                                            // Block 0x19C55
                                            return;  // retf 
                                        } else {
                                            // Block 0x19C4B
                                            $1 = $2;
                                            shr ax, 1;
                                            sub word ptr [bp + 8], ax;
                                        }
                                    } else {
                                        // Block 0x19C3E
                                        $1 = $2;
                                        sub word ptr [bp + 8], ax;
                                        jmp 0x19c53;
                                        // Block 0x19C53
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    }
                                } else {
                                    // Block 0x19C31
                                    $1 = $2;
                                    sub word ptr [bp + 8], ax;
                                    jmp 0x19c53;
                                    // Block 0x19C53
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            }
                        } else {
                            // Block 0x19C15
                            $1 = $2;
                            shr ax, 1;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19c2c;
                            // Block 0x19C2C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19c39
                                // Block 0x19C39
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c46
                                    // Block 0x19C46
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c55
                                        // Block 0x19C55
                                        return;  // retf 
                                    } else {
                                        // Block 0x19C4B
                                        $1 = $2;
                                        shr ax, 1;
                                        sub word ptr [bp + 8], ax;
                                    }
                                } else {
                                    // Block 0x19C3E
                                    $1 = $2;
                                    sub word ptr [bp + 8], ax;
                                    jmp 0x19c53;
                                    // Block 0x19C53
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19C31
                                $1 = $2;
                                sub word ptr [bp + 8], ax;
                                jmp 0x19c53;
                                // Block 0x19C53
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0x19C0E
                        jmp 0x19c53;
                        // Block 0x19C53
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x19BB5
                // Compare $1 with $2
                if (a != b) {  // jne 0x19bbd
                    // Block 0x19BBD
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19bcc
                        // Block 0x19BCC
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19bd9
                            // Block 0x19BD9
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19be6
                                // Block 0x19BE6
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19bf3
                                    // Block 0x19BF3
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c00
                                        // Block 0x19C00
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    } else {
                                        // Block 0x19BF8
                                        $1 = $2;
                                        shr ax, 1;
                                        sub word ptr [bp + 6], ax;
                                    }
                                } else {
                                    // Block 0x19BEB
                                    $1 = $2;
                                    sub word ptr [bp + 6], ax;
                                    jmp 0x19c00;
                                    // Block 0x19C00
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19BDE
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c00;
                                // Block 0x19C00
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        } else {
                            // Block 0x19BD1
                            $1 = $2;
                            add word ptr [bp + 8], ax;
                            jmp 0x19bd9;
                            // Block 0x19BD9
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19be6
                                // Block 0x19BE6
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19bf3
                                    // Block 0x19BF3
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x19c00
                                        // Block 0x19C00
                                        jmp 0x19c55;
                                        // Block 0x19C55
                                        return;  // retf 
                                    } else {
                                        // Block 0x19BF8
                                        $1 = $2;
                                        shr ax, 1;
                                        sub word ptr [bp + 6], ax;
                                    }
                                } else {
                                    // Block 0x19BEB
                                    $1 = $2;
                                    sub word ptr [bp + 6], ax;
                                    jmp 0x19c00;
                                    // Block 0x19C00
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                }
                            } else {
                                // Block 0x19BDE
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c00;
                                // Block 0x19C00
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0x19BC2
                        $1 = $2;
                        shr ax, 1;
                        add word ptr [bp + 8], ax;
                        jmp 0x19bd9;
                        // Block 0x19BD9
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19be6
                            // Block 0x19BE6
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19bf3
                                // Block 0x19BF3
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19c00
                                    // Block 0x19C00
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                } else {
                                    // Block 0x19BF8
                                    $1 = $2;
                                    shr ax, 1;
                                    sub word ptr [bp + 6], ax;
                                }
                            } else {
                                // Block 0x19BEB
                                $1 = $2;
                                sub word ptr [bp + 6], ax;
                                jmp 0x19c00;
                                // Block 0x19C00
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        } else {
                            // Block 0x19BDE
                            $1 = $2;
                            sub word ptr [bp + 6], ax;
                            jmp 0x19c00;
                            // Block 0x19C00
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0x19BBB
                    jmp 0x19c00;
                    // Block 0x19C00
                    jmp 0x19c55;
                    // Block 0x19C55
                    return;  // retf 
                }
            }
        } else {
            // Block 0x19B62
            // Compare $1 with $2
            if (a != b) {  // jne 0x19b6a
                // Block 0x19B6A
                // Compare $1 with $2
                if (a != b) {  // jne 0x19b79
                    // Block 0x19B79
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b84
                        // Block 0x19B84
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b92
                            // Block 0x19B92
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19b9f
                                // Block 0x19B9F
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19bac
                                    // Block 0x19BAC
                                    jmp 0x19c55;
                                    // Block 0x19C55
                                    return;  // retf 
                                } else {
                                    // Block 0x19BA4
                                    $1 = $2;
                                    shr ax, 1;
                                    sub word ptr [bp + 8], ax;
                                }
                            } else {
                                // Block 0x19B97
                                $1 = $2;
                                sub word ptr [bp + 8], ax;
                                jmp 0x19bac;
                                // Block 0x19BAC
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            }
                        } else {
                            // Block 0x19B89
                            $1 = $2;
                            $1--;
                            sub word ptr [bp + 8], ax;
                            jmp 0x19bac;
                            // Block 0x19BAC
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B7E
                        $1 = $2;
                        add word ptr [bp + 6], ax;
                    }
                } else {
                    // Block 0x19B6F
                    $1 = $2;
                    shr ax, 1;
                    add word ptr [bp + 6], ax;
                    jmp 0x19b84;
                    // Block 0x19B84
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19b92
                        // Block 0x19B92
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19b9f
                            // Block 0x19B9F
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19bac
                                // Block 0x19BAC
                                jmp 0x19c55;
                                // Block 0x19C55
                                return;  // retf 
                            } else {
                                // Block 0x19BA4
                                $1 = $2;
                                shr ax, 1;
                                sub word ptr [bp + 8], ax;
                            }
                        } else {
                            // Block 0x19B97
                            $1 = $2;
                            sub word ptr [bp + 8], ax;
                            jmp 0x19bac;
                            // Block 0x19BAC
                            jmp 0x19c55;
                            // Block 0x19C55
                            return;  // retf 
                        }
                    } else {
                        // Block 0x19B89
                        $1 = $2;
                        $1--;
                        sub word ptr [bp + 8], ax;
                        jmp 0x19bac;
                        // Block 0x19BAC
                        jmp 0x19c55;
                        // Block 0x19C55
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x19B68
                jmp 0x19bac;
                // Block 0x19BAC
                jmp 0x19c55;
                // Block 0x19C55
                return;  // retf 
            }
        }
    }

    // Function calls:
    sub_19D41();
}

void sub_19D41() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 24 if statements

    // Block 0x19D41
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19d4a
        // Block 0x19D4A
        $1 = $2;
        $1 = $2;
        $1 = $2;
        cmp word ptr es:[di + 0x10], 1;
        if (a != b) {  // jne 0x19d6e
            // Block 0x19D6E
            les di, ptr [bp - 0x58];
            $1 = $2;
            $1 = $2;
            $1 += $2;
            lcall es:[di + 0x26];
            $1 = $2;
            $1 = $2;
            $1 -= $2;
            *($1) = $2;
            $1 = $2;
            $1 -= $2;
            $1 = $2;
            cld ;
            $1 = $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x19da4
                // Block 0x19DA4
                // Compare $1 with $2
                if (a != b) {  // jne 0x19db0
                    // Block 0x19DB0
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19dbc
                        // Block 0x19DBC
                        mov word ptr [bp - 0x5c], 0x18e;
                    } else {
                        // Block 0x19DB5
                        mov word ptr [bp - 0x5c], 0x189;
                        jmp 0x19dc1;
                        // Block 0x19DC1
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        stc ;
                        rcl bh, 1;
                        if (a >= b (unsigned)) {  // jae 0x19de6
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        } else {
                            // Block 0x19DD1
                            goto $1;
                            xor byte ptr es:[di], al;
                            goto $1;
                            and byte ptr es:[di], al;
                            goto $1;
                            or byte ptr es:[di], al;
                            goto $1;
                            mov byte ptr es:[di], al;
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        }
                    }
                } else {
                    // Block 0x19DA9
                    mov word ptr [bp - 0x5c], 0x184;
                    jmp 0x19dc1;
                    // Block 0x19DC1
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    stc ;
                    rcl bh, 1;
                    if (a >= b (unsigned)) {  // jae 0x19de6
                        // Block 0x19DE6
                        $1++;
                        loop 0x19dcc;
                    } else {
                        // Block 0x19DD1
                        goto $1;
                        xor byte ptr es:[di], al;
                        goto $1;
                        and byte ptr es:[di], al;
                        goto $1;
                        or byte ptr es:[di], al;
                        goto $1;
                        mov byte ptr es:[di], al;
                        // Block 0x19DE6
                        $1++;
                        loop 0x19dcc;
                    }
                }
            } else {
                // Block 0x19D9D
                mov word ptr [bp - 0x5c], 0x193;
                jmp 0x19dc1;
                // Block 0x19DC1
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                stc ;
                rcl bh, 1;
                if (a >= b (unsigned)) {  // jae 0x19de6
                    // Block 0x19DE6
                    $1++;
                    loop 0x19dcc;
                } else {
                    // Block 0x19DD1
                    goto $1;
                    xor byte ptr es:[di], al;
                    goto $1;
                    and byte ptr es:[di], al;
                    goto $1;
                    or byte ptr es:[di], al;
                    goto $1;
                    mov byte ptr es:[di], al;
                    // Block 0x19DE6
                    $1++;
                    loop 0x19dcc;
                }
            }
        } else {
            // Block 0x19D59
            $1 = $2;
            $1 += $2;
            // Compare $1 with $2
            if (a < b (unsigned)) {  // jb 0x19d6c
                // Block 0x19D6C
                jmp 0x19de9;
                // Block 0x19DE9
                return;  // retf 
            } else {
                // Block 0x19D66
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0x19d6e
                    // Block 0x19D6E
                    les di, ptr [bp - 0x58];
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    lcall es:[di + 0x26];
                    $1 = $2;
                    $1 = $2;
                    $1 -= $2;
                    *($1) = $2;
                    $1 = $2;
                    $1 -= $2;
                    $1 = $2;
                    cld ;
                    $1 = $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19da4
                        // Block 0x19DA4
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19db0
                            // Block 0x19DB0
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19dbc
                                // Block 0x19DBC
                                mov word ptr [bp - 0x5c], 0x18e;
                            } else {
                                // Block 0x19DB5
                                mov word ptr [bp - 0x5c], 0x189;
                                jmp 0x19dc1;
                                // Block 0x19DC1
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                stc ;
                                rcl bh, 1;
                                if (a >= b (unsigned)) {  // jae 0x19de6
                                    // Block 0x19DE6
                                    $1++;
                                    loop 0x19dcc;
                                } else {
                                    // Block 0x19DD1
                                    goto $1;
                                    xor byte ptr es:[di], al;
                                    goto $1;
                                    and byte ptr es:[di], al;
                                    goto $1;
                                    or byte ptr es:[di], al;
                                    goto $1;
                                    mov byte ptr es:[di], al;
                                    // Block 0x19DE6
                                    $1++;
                                    loop 0x19dcc;
                                }
                            }
                        } else {
                            // Block 0x19DA9
                            mov word ptr [bp - 0x5c], 0x184;
                            jmp 0x19dc1;
                            // Block 0x19DC1
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            stc ;
                            rcl bh, 1;
                            if (a >= b (unsigned)) {  // jae 0x19de6
                                // Block 0x19DE6
                                $1++;
                                loop 0x19dcc;
                            } else {
                                // Block 0x19DD1
                                goto $1;
                                xor byte ptr es:[di], al;
                                goto $1;
                                and byte ptr es:[di], al;
                                goto $1;
                                or byte ptr es:[di], al;
                                goto $1;
                                mov byte ptr es:[di], al;
                                // Block 0x19DE6
                                $1++;
                                loop 0x19dcc;
                            }
                        }
                    } else {
                        // Block 0x19D9D
                        mov word ptr [bp - 0x5c], 0x193;
                        jmp 0x19dc1;
                        // Block 0x19DC1
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        stc ;
                        rcl bh, 1;
                        if (a >= b (unsigned)) {  // jae 0x19de6
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        } else {
                            // Block 0x19DD1
                            goto $1;
                            xor byte ptr es:[di], al;
                            goto $1;
                            and byte ptr es:[di], al;
                            goto $1;
                            or byte ptr es:[di], al;
                            goto $1;
                            mov byte ptr es:[di], al;
                            // Block 0x19DE6
                            $1++;
                            loop 0x19dcc;
                        }
                    }
                } else {
                    // Block 0x19D6C
                    jmp 0x19de9;
                    // Block 0x19DE9
                    return;  // retf 
                }
            }
        }
    } else {
        // Block 0x19D47
        jmp 0x19de9;
        // Block 0x19DE9
        return;  // retf 
    }

    // Function calls:
    sub_19F12();
}

void sub_19F12() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 19 if statements

    // Block 0x19F12
    cmp word ptr [bp - 0x48], 0;
    if (a == b) {  // je 0x19f49
        // Block 0x19F49
        les di, ptr [bp - 0x58];
        $1 = $2;
        $1 = $2;
        $1 += $2;
        lcall es:[di + 0x26];
        $1 = $2;
        *($1) = $2;
        push($1);
        push($1);
        lcall 0xa36, 0xe;
        $1 = $2;
        $1 -= $2;
        *($1) = $2;
        $1 = $2;
        $1 -= $2;
        $1 = $2;
        cld ;
        $1 = $2;
        // Compare $1 with $2
        if (a != b) {  // jne 0x19f8c
            // Block 0x19F8C
            // Compare $1 with $2
            if (a != b) {  // jne 0x19f98
                // Block 0x19F98
                // Compare $1 with $2
                if (a != b) {  // jne 0x19fa4
                    // Block 0x19FA4
                    mov word ptr [bp - 0x5c], 0x1e6;
                } else {
                    // Block 0x19F9D
                    mov word ptr [bp - 0x5c], 0x1e1;
                    jmp 0x19fa9;
                    // Block 0x19FA9
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    stc ;
                    rcl bh, 1;
                    if (a >= b (unsigned)) {  // jae 0x19fce
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    } else {
                        // Block 0x19FB9
                        goto $1;
                        xor byte ptr es:[di], al;
                        goto $1;
                        and byte ptr es:[di], al;
                        goto $1;
                        or byte ptr es:[di], al;
                        goto $1;
                        mov byte ptr es:[di], al;
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    }
                }
            } else {
                // Block 0x19F91
                mov word ptr [bp - 0x5c], 0x1dc;
                jmp 0x19fa9;
                // Block 0x19FA9
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                stc ;
                rcl bh, 1;
                if (a >= b (unsigned)) {  // jae 0x19fce
                    // Block 0x19FCE
                    $1++;
                    if (a != b) {  // jne 0x19fdf
                        // Block 0x19FDF
                        loop 0x19fb4;
                    } else {
                        // Block 0x19FD1
                        $1++;
                        push($1);
                        push($1);
                        lcall 0xa36, 0x63;
                    }
                } else {
                    // Block 0x19FB9
                    goto $1;
                    xor byte ptr es:[di], al;
                    goto $1;
                    and byte ptr es:[di], al;
                    goto $1;
                    or byte ptr es:[di], al;
                    goto $1;
                    mov byte ptr es:[di], al;
                    // Block 0x19FCE
                    $1++;
                    if (a != b) {  // jne 0x19fdf
                        // Block 0x19FDF
                        loop 0x19fb4;
                    } else {
                        // Block 0x19FD1
                        $1++;
                        push($1);
                        push($1);
                        lcall 0xa36, 0x63;
                    }
                }
            }
        } else {
            // Block 0x19F85
            mov word ptr [bp - 0x5c], 0x1eb;
            jmp 0x19fa9;
            // Block 0x19FA9
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            stc ;
            rcl bh, 1;
            if (a >= b (unsigned)) {  // jae 0x19fce
                // Block 0x19FCE
                $1++;
                if (a != b) {  // jne 0x19fdf
                    // Block 0x19FDF
                    loop 0x19fb4;
                } else {
                    // Block 0x19FD1
                    $1++;
                    push($1);
                    push($1);
                    lcall 0xa36, 0x63;
                }
            } else {
                // Block 0x19FB9
                goto $1;
                xor byte ptr es:[di], al;
                goto $1;
                and byte ptr es:[di], al;
                goto $1;
                or byte ptr es:[di], al;
                goto $1;
                mov byte ptr es:[di], al;
                // Block 0x19FCE
                $1++;
                if (a != b) {  // jne 0x19fdf
                    // Block 0x19FDF
                    loop 0x19fb4;
                } else {
                    // Block 0x19FD1
                    $1++;
                    push($1);
                    push($1);
                    lcall 0xa36, 0x63;
                }
            }
        }
    } else {
        // Block 0x19F18
        goto $1;
        cmp word ptr [bp - 0x28], 0;
        if (a == b) {  // je 0x19f24
            // Block 0x19F24
            $1 = $2;
            $1 = $2;
            $1 = $2;
            cmp word ptr es:[di + 0x10], 1;
            if (a != b) {  // jne 0x19f49
                // Block 0x19F49
                les di, ptr [bp - 0x58];
                $1 = $2;
                $1 = $2;
                $1 += $2;
                lcall es:[di + 0x26];
                $1 = $2;
                *($1) = $2;
                push($1);
                push($1);
                lcall 0xa36, 0xe;
                $1 = $2;
                $1 -= $2;
                *($1) = $2;
                $1 = $2;
                $1 -= $2;
                $1 = $2;
                cld ;
                $1 = $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x19f8c
                    // Block 0x19F8C
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x19f98
                        // Block 0x19F98
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19fa4
                            // Block 0x19FA4
                            mov word ptr [bp - 0x5c], 0x1e6;
                        } else {
                            // Block 0x19F9D
                            mov word ptr [bp - 0x5c], 0x1e1;
                            jmp 0x19fa9;
                            // Block 0x19FA9
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            stc ;
                            rcl bh, 1;
                            if (a >= b (unsigned)) {  // jae 0x19fce
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            } else {
                                // Block 0x19FB9
                                goto $1;
                                xor byte ptr es:[di], al;
                                goto $1;
                                and byte ptr es:[di], al;
                                goto $1;
                                or byte ptr es:[di], al;
                                goto $1;
                                mov byte ptr es:[di], al;
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            }
                        }
                    } else {
                        // Block 0x19F91
                        mov word ptr [bp - 0x5c], 0x1dc;
                        jmp 0x19fa9;
                        // Block 0x19FA9
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        stc ;
                        rcl bh, 1;
                        if (a >= b (unsigned)) {  // jae 0x19fce
                            // Block 0x19FCE
                            $1++;
                            if (a != b) {  // jne 0x19fdf
                                // Block 0x19FDF
                                loop 0x19fb4;
                            } else {
                                // Block 0x19FD1
                                $1++;
                                push($1);
                                push($1);
                                lcall 0xa36, 0x63;
                            }
                        } else {
                            // Block 0x19FB9
                            goto $1;
                            xor byte ptr es:[di], al;
                            goto $1;
                            and byte ptr es:[di], al;
                            goto $1;
                            or byte ptr es:[di], al;
                            goto $1;
                            mov byte ptr es:[di], al;
                            // Block 0x19FCE
                            $1++;
                            if (a != b) {  // jne 0x19fdf
                                // Block 0x19FDF
                                loop 0x19fb4;
                            } else {
                                // Block 0x19FD1
                                $1++;
                                push($1);
                                push($1);
                                lcall 0xa36, 0x63;
                            }
                        }
                    }
                } else {
                    // Block 0x19F85
                    mov word ptr [bp - 0x5c], 0x1eb;
                    jmp 0x19fa9;
                    // Block 0x19FA9
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    stc ;
                    rcl bh, 1;
                    if (a >= b (unsigned)) {  // jae 0x19fce
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    } else {
                        // Block 0x19FB9
                        goto $1;
                        xor byte ptr es:[di], al;
                        goto $1;
                        and byte ptr es:[di], al;
                        goto $1;
                        or byte ptr es:[di], al;
                        goto $1;
                        mov byte ptr es:[di], al;
                        // Block 0x19FCE
                        $1++;
                        if (a != b) {  // jne 0x19fdf
                            // Block 0x19FDF
                            loop 0x19fb4;
                        } else {
                            // Block 0x19FD1
                            $1++;
                            push($1);
                            push($1);
                            lcall 0xa36, 0x63;
                        }
                    }
                }
            } else {
                // Block 0x19F33
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x19f46
                    // Block 0x19F46
                    jmp 0x19fe1;
                    // Block 0x19FE1
                    return;  // retf 
                } else {
                    // Block 0x19F40
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x19f49
                        // Block 0x19F49
                        les di, ptr [bp - 0x58];
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        lcall es:[di + 0x26];
                        $1 = $2;
                        *($1) = $2;
                        push($1);
                        push($1);
                        lcall 0xa36, 0xe;
                        $1 = $2;
                        $1 -= $2;
                        *($1) = $2;
                        $1 = $2;
                        $1 -= $2;
                        $1 = $2;
                        cld ;
                        $1 = $2;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x19f8c
                            // Block 0x19F8C
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x19f98
                                // Block 0x19F98
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x19fa4
                                    // Block 0x19FA4
                                    mov word ptr [bp - 0x5c], 0x1e6;
                                } else {
                                    // Block 0x19F9D
                                    mov word ptr [bp - 0x5c], 0x1e1;
                                    jmp 0x19fa9;
                                    // Block 0x19FA9
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    stc ;
                                    rcl bh, 1;
                                    if (a >= b (unsigned)) {  // jae 0x19fce
                                        // Block 0x19FCE
                                        $1++;
                                        if (a != b) {  // jne 0x19fdf
                                            // Block 0x19FDF
                                            loop 0x19fb4;
                                        } else {
                                            // Block 0x19FD1
                                            $1++;
                                            push($1);
                                            push($1);
                                            lcall 0xa36, 0x63;
                                        }
                                    } else {
                                        // Block 0x19FB9
                                        goto $1;
                                        xor byte ptr es:[di], al;
                                        goto $1;
                                        and byte ptr es:[di], al;
                                        goto $1;
                                        or byte ptr es:[di], al;
                                        goto $1;
                                        mov byte ptr es:[di], al;
                                        // Block 0x19FCE
                                        $1++;
                                        if (a != b) {  // jne 0x19fdf
                                            // Block 0x19FDF
                                            loop 0x19fb4;
                                        } else {
                                            // Block 0x19FD1
                                            $1++;
                                            push($1);
                                            push($1);
                                            lcall 0xa36, 0x63;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x19F91
                                mov word ptr [bp - 0x5c], 0x1dc;
                                jmp 0x19fa9;
                                // Block 0x19FA9
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                stc ;
                                rcl bh, 1;
                                if (a >= b (unsigned)) {  // jae 0x19fce
                                    // Block 0x19FCE
                                    $1++;
                                    if (a != b) {  // jne 0x19fdf
                                        // Block 0x19FDF
                                        loop 0x19fb4;
                                    } else {
                                        // Block 0x19FD1
                                        $1++;
                                        push($1);
                                        push($1);
                                        lcall 0xa36, 0x63;
                                    }
                                } else {
                                    // Block 0x19FB9
                                    goto $1;
                                    xor byte ptr es:[di], al;
                                    goto $1;
                                    and byte ptr es:[di], al;
                                    goto $1;
                                    or byte ptr es:[di], al;
                                    goto $1;
                                    mov byte ptr es:[di], al;
                                    // Block 0x19FCE
                                    $1++;
                                    if (a != b) {  // jne 0x19fdf
                                        // Block 0x19FDF
                                        loop 0x19fb4;
                                    } else {
                                        // Block 0x19FD1
                                        $1++;
                                        push($1);
                                        push($1);
                                        lcall 0xa36, 0x63;
                                    }
                                }
                            }
                        } else {
                            // Block 0x19F85
                            mov word ptr [bp - 0x5c], 0x1eb;
                            jmp 0x19fa9;
                            // Block 0x19FA9
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            stc ;
                            rcl bh, 1;
                            if (a >= b (unsigned)) {  // jae 0x19fce
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            } else {
                                // Block 0x19FB9
                                goto $1;
                                xor byte ptr es:[di], al;
                                goto $1;
                                and byte ptr es:[di], al;
                                goto $1;
                                or byte ptr es:[di], al;
                                goto $1;
                                mov byte ptr es:[di], al;
                                // Block 0x19FCE
                                $1++;
                                if (a != b) {  // jne 0x19fdf
                                    // Block 0x19FDF
                                    loop 0x19fb4;
                                } else {
                                    // Block 0x19FD1
                                    $1++;
                                    push($1);
                                    push($1);
                                    lcall 0xa36, 0x63;
                                }
                            }
                        }
                    } else {
                        // Block 0x19F46
                        jmp 0x19fe1;
                        // Block 0x19FE1
                        return;  // retf 
                    }
                }
            }
        } else {
            // Block 0x19F21
            jmp 0x19fe1;
            // Block 0x19FE1
            return;  // retf 
        }
    }
}

void sub_1A25E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1A25E
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cld ;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    $1--;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 4

    // Function calls:
    sub_1A25E();
}

void sub_1A2DE() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 42 if statements

    // Block 0x1A2DE
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 0x16];
    push($1);
    lcall 0x185d, 0x46;
    or ax, ax;
    if (a == b) {  // je 0x1a301
        // Block 0x1A301
        lds si, ptr [bp - 0x16];
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        *($1) = $2;
        mov word ptr [bp - 8], 0;
        test word ptr [si + 0x18], 0x10;
        if (a == b) {  // je 0x1a328
            // Block 0x1A328
            push($1);
            lea ax, [bp - 0x10];
            push($1);
            push($1);
            lea ax, [bp - 0x12];
            push($1);
            lcall 0x96b, 0x66;
            or ax, ax;
            if (a == b) {  // je 0x1a340
                // Block 0x1A340
                lds si, ptr [bp + 6];
                les di, ptr [bp - 0x10];
                push($1);
                cld ;
                $1 = $2;
                rep movsb byte ptr es:[di], byte ptr [si];
                $1 = pop();
                $1 = $2;
                push($1);
                $1 = $2;
                push($1);
                push($1);
                call 0x1a25e;
                // Block 0x1A35A
                // Compare $1 with $2
                if (a > b (unsigned)) {  // ja 0x1a366
                    // Block 0x1A366
                    *($1) = $2;
                    mov word ptr [bp - 2], 0;
                    lds si, ptr [si + 0xa8];
                    les di, ptr [bp + 6];
                    $1 = $2;
                    lds si, ptr [bp - 0x16];
                    lds si, ptr [si + 0xa8];
                    $1 = $2;
                    $1 = 0;
                    // Compare $1 with $2
                    if (a < b (unsigned)) {  // jb 0x1a3b2
                        // Block 0x1A3B2
                        $1++;
                        loop 0x1a37f;
                    } else {
                        // Block 0x1A389
                        // Compare $1 with $2
                        if (a > b (unsigned)) {  // ja 0x1a3b2
                            // Block 0x1A3B2
                            $1++;
                            loop 0x1a37f;
                        } else {
                            // Block 0x1A38E
                            $1 = $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x1a3af
                                // Block 0x1A3AF
                                add word ptr [bp - 2], ax;
                            } else {
                                // Block 0x1A396
                                $1 = $2;
                                $1 = 0;
                                $1 -= $2;
                                shl bx, 1;
                                $1 = $2;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x1a3af
                                    // Block 0x1A3AF
                                    add word ptr [bp - 2], ax;
                                } else {
                                    // Block 0x1A3A7
                                    // Compare $1 with $2
                                    if (a <= b) {  // jle 0x1a3b2
                                        // Block 0x1A3B2
                                        $1++;
                                        loop 0x1a37f;
                                    } else {
                                        // Block 0x1A3AC
                                        add ax, word ptr [bp - 0xa];
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x1A35F
                    mov word ptr [bp - 2], 0;
                    jmp 0x1a3b5;
                    // Block 0x1A3B5
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                }
            } else {
                // Block 0x1A33B
                *($1) = $2;
                jmp 0x1a3b5;
                // Block 0x1A3B5
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            }
        } else {
            // Block 0x1A322
            $1 = $2;
            mov word ptr [bp - 8], ax;
        }
    } else {
        // Block 0x1A2FB
        *($1) = $2;
        jmp 0x1a3b5;
        // Block 0x1A3B5
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_1A25E();
    sub_1A2DE();
    sub_1A78A();
}

void sub_1A78A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1A78A
    cmp word ptr [bp - 0x48], 0;
    if (a != b) {  // jne 0x1a7b2
        // Block 0x1A7B2
        return;  // retf 
    } else {
        // Block 0x1A790
        $1 = $2;
        $1 = $2;
        $1 += $2;
        $1 = $2;
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        lcall 0x1787, 8;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1++;
        loop 0x1a79c;
    }
}

void sub_1A878() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x1A878
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    lcall 0x80c, 0x56c;
    or ax, ax;
    if (a >= b) {  // jge 0x1a8a8
        // Block 0x1A8A8
        *($1) = $2;
        push($1);
        push($1);
        push($1);
        $1 = $2;
        push($1);
        push($1);
        lea ax, [bp - 0xe];
        push($1);
        push($1);
        lea ax, [bp - 0x10];
        push($1);
        lcall 0x96b, 0x166;
        or ax, ax;
        if (a == b) {  // je 0x1a8ce
            // Block 0x1A8CE
            lds si, ptr [bp - 0xe];
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            les di, ptr [bp + 6];
            mov word ptr es:[di], ax;
            $1 += $2;
            if (a >= b (unsigned)) {  // jae 0x1a8f2
                // Block 0x1A8F2
                $1 = $2;
                $1 -= $2;
                $1++;
                $1 = 0;
                $1 = $2;
                $1 -= $2;
                $1 = $2;
                shr ax, 1;
                shr ax, 1;
                shr ax, 1;
                and bx, 7;
                if (a == b) {  // je 0x1a90e
                    // Block 0x1A90E
                    shl ax, 1;
                    shl ax, 1;
                    shl ax, 1;
                    $1 += $2;
                    $1++;
                    $1++;
                    loop 0x1a8fb;
                    les di, ptr [bp + 0xa];
                    mov word ptr es:[di], dx;
                    mov word ptr [bp - 2], 0;
                    lcall 0x96b, 0x1c0;
                } else {
                    // Block 0x1A90D
                    inc ax;
                }
            } else {
                // Block 0x1A8EB
                mov word ptr [bp - 2], 0xfc18;
                jmp 0x1a92a;
                // Block 0x1A92A
                push($1);
                push($1);
                lcall 0x80c, 0x640;
            }
        } else {
            // Block 0x1A8C9
            *($1) = $2;
            jmp 0x1a935;
            // Block 0x1A935
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0x10
        }
    } else {
        // Block 0x1A8A2
        *($1) = $2;
        jmp 0x1a935;
        // Block 0x1A935
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0x10
    }

    // Function calls:
    sub_1A878();
}

void sub_1A97C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x1A97C
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    push($1);
    lea ax, [bp - 6];
    push($1);
    push($1);
    call 0x1a878;
    // Block 0x1A9A5
    or ax, ax;
    if (a == b) {  // je 0x1a9ab
        // Block 0x1A9AB
        $1 = $2;
        push($1);
        push($1);
        push($1);
        lcall 0xb08, 0x2e7;
        test dx, 0x8000;
        if (a != b) {  // jne 0x1a9cc
            // Block 0x1A9CC
            *($1) = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 8
        } else {
            // Block 0x1A9C0
            $1 = $2;
            $1 += $2;
            $1 += $2;
            adc dx, 0;
        }
    } else {
        // Block 0x1A9A9
        jmp 0x1a9cc;
        // Block 0x1A9CC
        *($1) = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    }

    // Function calls:
    sub_1A878();
    sub_1A97C();
    sub_1ABE3();
}

void sub_1ABE3() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x1ABE3
    lds si, ptr [bp + 0xe];
    les di, ptr [bp + 0xe];
    $1 = $2;
    cld ;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    or cx, cx;
    if (a == b) {  // je 0x1ac01
        // Block 0x1AC01
        push($1);
        push($1);
        lcall 0x1865, 0x8e;
        *($1) = $2;
        cmp byte ptr es:[di - 1], 0;
        if (a != b) {  // jne 0x1ac19
            // Block 0x1AC19
            $1 = $2;
            $1 += $2;
            // Compare $1 with $2
            if (a <= b) {  // jle 0x1ac3b
                // Block 0x1AC3B
                $1 = $2;
                $1 = $2;
                $1 = $2;
                les di, ptr [bp + 0xe];
                $1 += $2;
                $1 = 0;
                $1 = $2;
                *($1) = $2;
                inc bx;
            } else {
                // Block 0x1AC24
                cmp word ptr [bp - 0x1c], 0;
                if (a != b) {  // jne 0x1ac2d
                    // Block 0x1AC2D
                    mov word ptr [bp - 0x1c], 0;
                    $1 = $2;
                    $1 += $2;
                    mov word ptr [bp - 0x1e], ax;
                } else {
                    // Block 0x1AC2A
                    jmp 0x1ad0b;
                    // Block 0x1AD0B
                    $1 = $2;
                    return;  // retf 
                }
            }
        } else {
            // Block 0x1AC12
            $1 = $2;
            mov byte ptr es:[di - 1], al;
        }
    } else {
        // Block 0x1ABF5
        $1 = $2;
        *($1) = $2;
        mov byte ptr es:[di - 1], 0;
    }
}

void sub_1AD1A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 13 if statements

    // Block 0x1AD1A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    cmp word ptr [0xa0], 0;
    if (a != b) {  // jne 0x1ad33
        // Block 0x1AD33
        call 0x1aecb;
        // Block 0x1AD36
        if (a >= b (unsigned)) {  // jae 0x1ad64
            // Block 0x1AD64
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            call 0x1af95;
            // Block 0x1AD70
            $1 = $2;
            if (a < b (unsigned)) {  // jb 0x1ad5a
                // Block 0x1AD5A
                $1 = $2;
                INT_21();  // int 0x21
                $1 = $2;
                jmp 0x1ae41;
                // Block 0x1AE41
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 8
            } else {
                // Block 0x1AD75
                $1 = 0;
                $1 = 0;
                cmp word ptr [bp - 0x14], 0x5a4d;
                if (a == b) {  // je 0x1ad85
                    // Block 0x1AD85
                    $1 = $2;
                    $1 = $2;
                    if (condition_jcxz) {  // jcxz 0x1ad8e
                        // Block 0x1AD8E
                        $1 = $2;
                        mul dx;
                        $1 += $2;
                        $1 += $2;
                        adc dx, 0;
                        and ax, 0xfff0;
                    } else {
                        // Block 0x1AD8D
                        dec ax;
                    }
                } else {
                    // Block 0x1AD80
                    $1 = $2;
                    jmp 0x1ad5a;
                    // Block 0x1AD5A
                    $1 = $2;
                    INT_21();  // int 0x21
                    $1 = $2;
                    jmp 0x1ae41;
                    // Block 0x1AE41
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 8
                }
            }
        } else {
            // Block 0x1AD38
            $1 = $2;
            or ax, word ptr [bp + 8];
            if (a != b) {  // jne 0x1ad4a
                // Block 0x1AD4A
                call 0x1aebf;
                // Block 0x1AD4D
                if (a >= b (unsigned)) {  // jae 0x1ad64
                    // Block 0x1AD64
                    $1 = $2;
                    *($1) = $2;
                    $1 = $2;
                    call 0x1af95;
                    // Block 0x1AD70
                    $1 = $2;
                    if (a < b (unsigned)) {  // jb 0x1ad5a
                        // Block 0x1AD5A
                        $1 = $2;
                        INT_21();  // int 0x21
                        $1 = $2;
                        jmp 0x1ae41;
                        // Block 0x1AE41
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    } else {
                        // Block 0x1AD75
                        $1 = 0;
                        $1 = 0;
                        cmp word ptr [bp - 0x14], 0x5a4d;
                        if (a == b) {  // je 0x1ad85
                            // Block 0x1AD85
                            $1 = $2;
                            $1 = $2;
                            if (condition_jcxz) {  // jcxz 0x1ad8e
                                // Block 0x1AD8E
                                $1 = $2;
                                mul dx;
                                $1 += $2;
                                $1 += $2;
                                adc dx, 0;
                                and ax, 0xfff0;
                            } else {
                                // Block 0x1AD8D
                                dec ax;
                            }
                        } else {
                            // Block 0x1AD80
                            $1 = $2;
                            jmp 0x1ad5a;
                            // Block 0x1AD5A
                            $1 = $2;
                            INT_21();  // int 0x21
                            $1 = $2;
                            jmp 0x1ae41;
                            // Block 0x1AE41
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    }
                } else {
                    // Block 0x1AD4F
                    call 0x1af10;
                    // Block 0x1AD52
                    if (a >= b (unsigned)) {  // jae 0x1ad64
                        // Block 0x1AD64
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        call 0x1af95;
                        // Block 0x1AD70
                        $1 = $2;
                        if (a < b (unsigned)) {  // jb 0x1ad5a
                            // Block 0x1AD5A
                            $1 = $2;
                            INT_21();  // int 0x21
                            $1 = $2;
                            jmp 0x1ae41;
                            // Block 0x1AE41
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        } else {
                            // Block 0x1AD75
                            $1 = 0;
                            $1 = 0;
                            cmp word ptr [bp - 0x14], 0x5a4d;
                            if (a == b) {  // je 0x1ad85
                                // Block 0x1AD85
                                $1 = $2;
                                $1 = $2;
                                if (condition_jcxz) {  // jcxz 0x1ad8e
                                    // Block 0x1AD8E
                                    $1 = $2;
                                    mul dx;
                                    $1 += $2;
                                    $1 += $2;
                                    adc dx, 0;
                                    and ax, 0xfff0;
                                } else {
                                    // Block 0x1AD8D
                                    dec ax;
                                }
                            } else {
                                // Block 0x1AD80
                                $1 = $2;
                                jmp 0x1ad5a;
                                // Block 0x1AD5A
                                $1 = $2;
                                INT_21();  // int 0x21
                                $1 = $2;
                                jmp 0x1ae41;
                                // Block 0x1AE41
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 8
                            }
                        }
                    } else {
                        // Block 0x1AD54
                        $1 = $2;
                        jmp 0x1ae41;
                        // Block 0x1AE41
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 8
                    }
                }
            } else {
                // Block 0x1AD40
                mov word ptr [bp + 6], 0x4a8;
                mov word ptr [bp + 8], 0x19b2;
            }
        }
    } else {
        // Block 0x1AD30
        jmp 0x1ae3f;
        // Block 0x1AE3F
        xor ax, ax;
    }

    // Function calls:
    sub_1AECB();
    sub_1AEBF();
    sub_1AF10();
    sub_1AF95();
    sub_1AF95();
    sub_1AE4A();
    sub_1AFA5();
    sub_1B025();
}

void sub_1AE4A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1AE4A
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21_AH35();  // int 0x21
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21_AH25();  // int 0x21
    $1 = pop();
    $1 = pop();
    $1 = pop();
    cmp word ptr [0xb8], 0;
    if (a == b) {  // je 0x1ae8c
        // Block 0x1AE8C
        lea dx, [0x1c];
        $1 = $2;
        $1 = $2;
        DOS_OpenFile();  // int 0x21
        mov word ptr [0xb8], ax;
    } else {
        // Block 0x1AE7C
        $1 = $2;
        $1 = $2;
        DOS_CloseFile();  // int 0x21
        mov word ptr [0xb8], 0;
        jmp 0x1ae9a;
        // Block 0x1AE9A
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_1AE4A();
}

void sub_1AEBF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1AEBF
    push($1);
    lea di, [0x1c];
    push($1);
    $1 = pop();
    call 0x1af6d;
    // Block 0x1AEC9
    $1 = pop();
    return;  // ret 

    // Function calls:
    sub_1AF6D();
}

void sub_1AECB() {
    // Variable declarations
    int var_6;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1AECB
    $1 = $2;
    INT_21();  // int 0x21
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x1af0f
        // Block 0x1AF0F
        return;  // ret 
    } else {
        // Block 0x1AED3
        mov byte ptr [6], 0x20;
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = 0;
        cld ;
    }

    // Function calls:
    sub_1AF6D();
}

void sub_1AF10() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x1AF10
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    xor si, si;

    // Function calls:
    sub_1AF6D();
}

void sub_1AF6D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1AF6D
    lds si, ptr [bp + 6];
    $1 = $2;
    or ax, si;
    if (a == b) {  // je 0x1af84
        // Block 0x1AF84
        lea dx, [0x1c];
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_OpenFile();  // int 0x21
        return;  // ret 
    } else {
        // Block 0x1AF76
        $1 = $2;
        lodsb al, byte ptr [si];
        stosb byte ptr es:[di], al;
        or al, al;
        if (a == b) {  // je 0x1af84
            // Block 0x1AF84
            lea dx, [0x1c];
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            DOS_OpenFile();  // int 0x21
            return;  // ret 
        } else {
            // Block 0x1AF7F
            loop 0x1af79;
            $1 -= $2;
            stosb byte ptr es:[di], al;
        }
    }
}

void sub_1AF95() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1AF95
    push($1);
    lea dx, [bp - 0x14];
    push($1);
    $1 = pop();
    $1 = $2;
    DOS_ReadFile();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x1afa4
        // Block 0x1AFA4
        return;  // ret 
    } else {
        // Block 0x1AFA2
        cmp ax, cx;
    }
}

void sub_1AFA5() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1AFA5
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    mov word ptr cs:[0x18], ax;
    $1 = $2;
    $1 = $2;
    $1 = 0;
    $1 = 0;
    lea si, [0xc0];

    // Function calls:
    sub_1B4B7();
}

void sub_1B025() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x1B025
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push ds;

    // Function calls:
    sub_1B0F2();
    sub_1B12B();
    sub_1B39D();
}

void sub_1B0F2() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x1B0F2
    push($1);
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    jmp 0x1b109;
    // Block 0x1B109
    $1 = $2;
    or di, di;
    if (a != b) {  // jne 0x1b112
        // Block 0x1B112
        $1 = 0;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        if (a < b (unsigned)) {  // jb 0x1b129
            // Block 0x1B129
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x1B11A
            // Compare $1 with $2
            if (a < b (unsigned)) {  // jb 0x1b129
                // Block 0x1B129
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x1B11E
                $1 -= $2;
                sbb di, 0;
                $1 = $2;
                or ax, di;
                if (a != b) {  // jne 0x1b102
                    // Block 0x1B102
                    $1 = $2;
                    $1 += $2;
                    mov ds, ax;
                } else {
                    // Block 0x1B129
                    $1 = pop();
                    return;  // ret 
                }
            }
        }
    } else {
        // Block 0x1B110
        mov cx, si;
    }
}

void sub_1B12B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B12B
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    and si, 0xf;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    shr ax, 1;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shr cx, 1;
    cld ;
    lodsw ax, word ptr [si];
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and di, 0xfff8;
    $1 = $2;
    mov word ptr es:[bx], dx;
    test ax, 1;
    if (a == b) {  // je 0x1b16a
        // Block 0x1B16A
        $1 = pop();
        loop 0x1b14c;
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1B167
        call 0x1b170;
        // Block 0x1B16A
        $1 = pop();
        loop 0x1b14c;
        $1 = pop();
        $1 = pop();
        return;  // ret 
    }

    // Function calls:
    sub_1B170();
}

void sub_1B170() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x1B170
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and ax, 0xf807;
    // Compare $1 with $2
    if (a != b) {  // jne 0x1b1cc
        // Block 0x1B1CC
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1B181
        $1 = $2;
        $1 = $2;
        $1 = $2;
        and ax, 0xf807;
        // Compare $1 with $2
        if (a != b) {  // jne 0x1b1cc
            // Block 0x1B1CC
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x1B191
            // Compare $1 with $2
            if (a != b) {  // jne 0x1b1cc
                // Block 0x1B1CC
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x1B195
                $1 = $2;
                $1 = $2;
                $1 = $2;
                and ax, 0xf807;
                // Compare $1 with $2
                if (a != b) {  // jne 0x1b1cc
                    // Block 0x1B1CC
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x1B1A4
                    $1 = $2;
                    $1 = $2;
                    and ax, 0xf807;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x1b1cc
                        // Block 0x1B1CC
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x1B1B1
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        // Compare $1 with $2
                        if (a == b) {  // je 0x1b1c8
                            // Block 0x1B1C8
                            mov word ptr es:[bx + 4], di;
                        } else {
                            // Block 0x1B1C1
                            $1 += $2;
                            loop 0x1b1bc;
                            jmp 0x1b1ce;
                            // Block 0x1B1CE
                            $1 = pop();
                            return;  // ret 
                        }
                    }
                }
            }
        }
    }

    // Function calls:
    sub_1B0F2();
    sub_1B12B();
    sub_1B2AE();
    sub_1B2AE();
}

void sub_1B264() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x1B264
    push($1);
    $1++;
    call 0x1b4b7;
    // Block 0x1B26C
    jmp 0x1b29c;
    // Block 0x1B29C
    call 0x1b48f;
    // Block 0x1B29F
    pushf ;
    // Compare $1 with $2
    if (a > b (unsigned)) {  // ja 0x1b26e
        // Block 0x1B26E
        popf ;
        push($1);
        if (a >= b (unsigned)) {  // jae 0x1b275
            // Block 0x1B275
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            cmp byte ptr es:[0x1b], 0;
            if (a != b) {  // jne 0x1b290
                // Block 0x1B290
                $1--;
                call 0x1b3ee;
                // Block 0x1B298
                call 0x1b43f;
                // Block 0x1B29B
                pop dx;
            } else {
                // Block 0x1B288
                call 0x1b329;
                // Block 0x1B28B
                call 0x1b4ab;
                // Block 0x1B28E
                jmp 0x1b29b;
                // Block 0x1B29B
                pop dx;
            }
        } else {
            // Block 0x1B272
            call 0x1b341;
            // Block 0x1B275
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            cmp byte ptr es:[0x1b], 0;
            if (a != b) {  // jne 0x1b290
                // Block 0x1B290
                $1--;
                call 0x1b3ee;
                // Block 0x1B298
                call 0x1b43f;
                // Block 0x1B29B
                pop dx;
            } else {
                // Block 0x1B288
                call 0x1b329;
                // Block 0x1B28B
                call 0x1b4ab;
                // Block 0x1B28E
                jmp 0x1b29b;
                // Block 0x1B29B
                pop dx;
            }
        }
    } else {
        // Block 0x1B2A4
        popf ;
        $1 = pop();
        $1 = $2;
        mov word ptr es:[0x10], ax;
        return;  // ret 
    }

    // Function calls:
    sub_1B4B7();
    sub_1B341();
    sub_1B329();
    sub_1B4AB();
    sub_1B3EE();
    sub_1B43F();
    sub_1B48F();
}

void sub_1B2AE() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1B2AE
    $1++;
    cmp word ptr es:[0x10], 0;
    if (a == b) {  // je 0x1b2c9
        // Block 0x1B2C9
        or byte ptr es:[0x1a], 8;
        call 0x1b264;
        // Block 0x1B2D2
        push($1);
        $1--;
        $1 = $2;
        *($1) = $2;
        $1 = pop();
        call word ptr es:[0x18];
        // Block 0x1B2E0
        if (a < b (unsigned)) {  // jb 0x1b324
            // Block 0x1B324
            ljmp 0:0xd87;
        } else {
            // Block 0x1B2E2
            call 0x1b43f;
            // Block 0x1B2E5
            call 0x1b37c;
            // Block 0x1B2E8
            $1 = $2;
            and al, 3;
            add byte ptr es:[0x1b], al;
            push($1);
            call 0x1b48f;
            // Block 0x1B2F7
            mov es, word ptr [0xbc];
        }
    } else {
        // Block 0x1B2BA
        mov byte ptr es:[0x1b], 1;
        or byte ptr es:[0x1a], 4;
        goto $1;
        nop ;
        // Block 0x1B2E5
        call 0x1b37c;
        // Block 0x1B2E8
        $1 = $2;
        and al, 3;
        add byte ptr es:[0x1b], al;
        push($1);
        call 0x1b48f;
        // Block 0x1B2F7
        mov es, word ptr [0xbc];
    }

    // Function calls:
    sub_1B264();
    sub_1B43F();
    sub_1B37C();
    sub_1B48F();
    sub_1B3BB();
    sub_1B4AB();
}

void sub_1B329() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B329
    call 0x1b3bb;
    // Block 0x1B32C
    cmp word ptr es:[0x18], 0x4d0;
    if (a != b) {  // jne 0x1b339
        // Block 0x1B339
        mov word ptr es:[0x10], 0;
        return;  // ret 
    } else {
        // Block 0x1B335
        call word ptr [0x10];
        // Block 0x1B339
        mov word ptr es:[0x10], 0;
        return;  // ret 
    }

    // Function calls:
    sub_1B3BB();
}

void sub_1B341() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B341
    $1 = $2;
    xor cx, cx;

    // Function calls:
    sub_1B4AB();
    sub_1B3EE();
}

void sub_1B37C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x1B37C
    cmp word ptr es:[0xc], 0;
    if (a != b) {  // jne 0x1b385
        // Block 0x1B385
        cmp byte ptr es:[0x20], 0xea;
        if (a == b) {  // je 0x1b3ba
            // Block 0x1B3BA
        } else {
            // Block 0x1B38D
            $1 = $2;
            if (condition_jcxz) {  // jcxz 0x1b39d
                // Block 0x1B39D
            } else {
                // Block 0x1B394
                $1 = $2;
                $1 = $2;
                call 0x1b45d;
                // Block 0x1B39D
            }
        }
    } else {
        // Block 0x1B384
        return;  // ret 
    }

    // Function calls:
    sub_1B45D();
}

void sub_1B39D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1B39D
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosw word ptr es:[di], ax;
    $1 = $2;
    stosw word ptr es:[di], ax;
    loop 0x1b3ab;
    return;  // ret 
}

void sub_1B3BB() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B3BB
    cmp byte ptr es:[0x20], 0xcd;
    if (a == b) {  // je 0x1b3ed
        // Block 0x1B3ED
        return;  // ret 
    } else {
        // Block 0x1B3C3
        $1 = $2;
        $1 = $2;
        $1 = 0;
        call 0x1b45d;
        // Block 0x1B3CF
        mov word ptr es:[2], cx;
        $1 = $2;
        $1 = $2;
        cld ;
        $1 = $2;
        $1 = $2;
        stosw word ptr es:[di], ax;
        $1 = $2;
        stosw word ptr es:[di], ax;
        $1 = 0;
        stosb byte ptr es:[di], al;
        loop 0x1b3dd;
    }

    // Function calls:
    sub_1B45D();
}

void sub_1B3EE() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1B3EE
    $1 = $2;
    $1 = $2;
    mov word ptr es:[0x10], ax;
    $1 = $2;
    $1++;
    shr cx, 1;
    $1 = 0;
    cld ;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x1b40f
        // Block 0x1B40F
        $1 = $2;
        push($1);
        push($1);
        $1 = $2;
        $1 = $2;
        rep movsw word ptr es:[di], word ptr [si];
        cld ;
        $1--;
        $1 = $2;
        $1 = pop();
        *($1) = $2;
        $1++;
        $1 = pop();
        cmp byte ptr es:[0x20], 0xcd;
        if (a == b) {  // je 0x1b43e
            // Block 0x1B43E
            return;  // ret 
        } else {
            // Block 0x1B42C
            call 0x1b469;
            // Block 0x1B42F
            $1 = $2;
            $1 = $2;
            cld ;
            stosw word ptr es:[di], ax;
            $1 += $2;
            loop 0x1b438;
        }
    } else {
        // Block 0x1B409
        $1 = $2;
        $1--;
        shl si, 1;
        std ;
    }

    // Function calls:
    sub_1B469();
}

void sub_1B43F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B43F
    call 0x1b4ab;
    // Block 0x1B442
    add word ptr [0xb0], ax;
    push($1);
    mov ax, 0x19b0;

    // Function calls:
    sub_1B4AB();
}

void sub_1B45D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x1B45D
    call 0x1b469;
    // Block 0x1B460
    or bx, bx;
    if (a == b) {  // je 0x1b468
        // Block 0x1B468
        return;  // ret 
    } else {
        // Block 0x1B464
        xchg word ptr ss:[bx + 2], cx;
    }

    // Function calls:
    sub_1B469();
}

void sub_1B469() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x1B469
    $1 = 0;
    push($1);
    push($1);
    jmp 0x1b473;
    // Block 0x1B473
    $1 = $2;
    shr cx, 1;
    if (a == b) {  // je 0x1b48c
        // Block 0x1B48C
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1B47A
        if (a < b (unsigned)) {  // jb 0x1b46f
            // Block 0x1B46F
            shl cx, 1;
            mov bp, cx;
        } else {
            // Block 0x1B47C
            // Compare $1 with $2
            if (a != b) {  // jne 0x1b46f
                // Block 0x1B46F
                shl cx, 1;
                mov bp, cx;
            } else {
                // Block 0x1B481
                *($1) = $2;
                or bx, bx;
                if (a != b) {  // jne 0x1b46f
                    // Block 0x1B46F
                    shl cx, 1;
                    mov bp, cx;
                } else {
                    // Block 0x1B488
                    $1 = $2;
                    jmp 0x1b46f;
                    // Block 0x1B46F
                    shl cx, 1;
                    mov bp, cx;
                }
            }
        }
    }
}

void sub_1B48F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x1B48F
    $1 = $2;
    or ax, ax;
    if (a == b) {  // je 0x1b4a2
        // Block 0x1B4A2
        $1 = $2;
        $1 -= $2;
        stc ;
    } else {
        // Block 0x1B496
        $1 = $2;
        $1 = $2;
        $1 -= $2;
        if (a >= b (unsigned)) {  // jae 0x1b4aa
            // Block 0x1B4AA
            return;  // ret 
        } else {
            // Block 0x1B4A2
            $1 = $2;
            $1 -= $2;
            stc ;
        }
    }
}

void sub_1B4AB() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1B4AB
    $1 = $2;
    $1 += $2;
    $1 = $2;
    shr ax, cl;
    return;  // ret 
}

void sub_1B4B7() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 29 if statements

    // Block 0x1B4B7
    $1 = $2;
    $1 = $2;
    $1 += $2;
    shr ax, cl;
    $1 = $2;
    $1 += $2;
    shr dx, cl;
    $1 += $2;
    return;  // ret 

    // Function calls:
    sub_1B2AE();
    sub_1AFA5();
    sub_1AD1A();
}

void sub_1D57() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1D57
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    call 0x1e31;
    // Block 0x1D67
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_1E31();
}

void sub_1D6A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1D6A
    return;  // retf 
}

void sub_1D6B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1D6B
    $1 = $2;
    $1 = $2;
    $1 = $2;
    DOS_TerminateWithReturnCode();  // int 0x21
    $1 = $2;
    $1 = $2;
    jmp 0x1e80;
    // Block 0x1E80
}

void sub_1D7D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1D7D
    push($1);
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    INT_21();  // int 0x21
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    $1 = pop();
    return;  // ret 
}

void sub_1DC0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x1DC0
    push($1);
    $1 = $2;
    lds dx, ptr [0x5b];
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x5f];
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x63];
    INT_21();  // int 0x21
    $1 = pop();
    push($1);
    $1 = $2;
    lds dx, ptr [0x67];
    INT_21();  // int 0x21
    $1 = pop();
    return;  // retf 
}

void sub_1DED() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1DED
    $1 = $2;
    $1 = $2;
    mov bx, si;
}

void sub_1E31() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x1E31
    $1 = $2;
    $1 = $2;
    mov bx, si;
}

void sub_1E72() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x1E72
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    return;  // ret 

    // Function calls:
    sub_1E72();
    sub_2ACF();
    sub_1F91();
    sub_1F91();
}

void sub_1F91() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 16 if statements

    // Block 0x1F91
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lds si, ptr [si];
    or si, si;
    if (a == b) {  // je 0x1fe3
        // Block 0x1FE3
        $1 = 0;
        goto $1;
        add byte ptr [bx + si], al;
        add byte ptr [bx + si], al;
        add byte ptr [bx + si], al;
        add byte ptr [bp + si], al;
        add byte ptr [bx + si], al;
        $1 += $2;
        add byte ptr [bx + si], al;
        push($1);
        $1 = $2;
        push($1);
        push($1);
        push($1);
        push($1);
        cld ;
        push($1);
        $1 = $2;
        push($1);
        $1 = 0;
        push($1);
        push($1);
        les dx, ptr [bp + 6];
        push($1);
        push($1);
        nop ;
        push($1);
        call 0x2495;
        // Block 0x1FE0
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x1FA0
        nop ;
        nop ;
        nop ;
        $1 -= $2;
        cmp word ptr [si], 0x494d;
        if (a != b) {  // jne 0x1fca
            // Block 0x1FCA
            cmp word ptr [si], 0x454b;
            if (a != b) {  // jne 0x1fe3
                // Block 0x1FE3
                $1 = 0;
                goto $1;
                add byte ptr [bx + si], al;
                add byte ptr [bx + si], al;
                add byte ptr [bx + si], al;
                add byte ptr [bp + si], al;
                add byte ptr [bx + si], al;
                $1 += $2;
                add byte ptr [bx + si], al;
                push($1);
                $1 = $2;
                push($1);
                push($1);
                push($1);
                push($1);
                cld ;
                push($1);
                $1 = $2;
                push($1);
                $1 = 0;
                push($1);
                push($1);
                les dx, ptr [bp + 6];
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x2495;
                // Block 0x1FE0
                $1 = pop();
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x1FD0
                nop ;
                nop ;
                nop ;
                cmp word ptr [si + 2], 0x4e52;
                if (a != b) {  // jne 0x1fe3
                    // Block 0x1FE3
                    $1 = 0;
                    goto $1;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bp + si], al;
                    add byte ptr [bx + si], al;
                    $1 += $2;
                    add byte ptr [bx + si], al;
                    push($1);
                    $1 = $2;
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    cld ;
                    push($1);
                    $1 = $2;
                    push($1);
                    $1 = 0;
                    push($1);
                    push($1);
                    les dx, ptr [bp + 6];
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x2495;
                    // Block 0x1FE0
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x1FDA
                    nop ;
                    nop ;
                    nop ;
                }
            }
        } else {
            // Block 0x1FAC
            nop ;
            nop ;
            nop ;
            cmp word ptr [si + 2], 0x4944;
            if (a != b) {  // jne 0x1fca
                // Block 0x1FCA
                cmp word ptr [si], 0x454b;
                if (a != b) {  // jne 0x1fe3
                    // Block 0x1FE3
                    $1 = 0;
                    goto $1;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bx + si], al;
                    add byte ptr [bp + si], al;
                    add byte ptr [bx + si], al;
                    $1 += $2;
                    add byte ptr [bx + si], al;
                    push($1);
                    $1 = $2;
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    cld ;
                    push($1);
                    $1 = $2;
                    push($1);
                    $1 = 0;
                    push($1);
                    push($1);
                    les dx, ptr [bp + 6];
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x2495;
                    // Block 0x1FE0
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x1FD0
                    nop ;
                    nop ;
                    nop ;
                    cmp word ptr [si + 2], 0x4e52;
                    if (a != b) {  // jne 0x1fe3
                        // Block 0x1FE3
                        $1 = 0;
                        goto $1;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bp + si], al;
                        add byte ptr [bx + si], al;
                        $1 += $2;
                        add byte ptr [bx + si], al;
                        push($1);
                        $1 = $2;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        cld ;
                        push($1);
                        $1 = $2;
                        push($1);
                        $1 = 0;
                        push($1);
                        push($1);
                        les dx, ptr [bp + 6];
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x2495;
                        // Block 0x1FE0
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x1FDA
                        nop ;
                        nop ;
                        nop ;
                    }
                }
            } else {
                // Block 0x1FB6
                nop ;
                nop ;
                nop ;
                $1 = $2;
                int 0x66;
                or ax, ax;
                if (a != b) {  // jne 0x1fdd
                    // Block 0x1FDD
                    mov ax, 1;
                } else {
                    // Block 0x1FC2
                    nop ;
                    nop ;
                    nop ;
                    if (a == b) {  // je 0x1fe3
                        // Block 0x1FE3
                        $1 = 0;
                        goto $1;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bx + si], al;
                        add byte ptr [bp + si], al;
                        add byte ptr [bx + si], al;
                        $1 += $2;
                        add byte ptr [bx + si], al;
                        push($1);
                        $1 = $2;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        cld ;
                        push($1);
                        $1 = $2;
                        push($1);
                        $1 = 0;
                        push($1);
                        push($1);
                        les dx, ptr [bp + 6];
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x2495;
                        // Block 0x1FE0
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x1FC7
                        nop ;
                        nop ;
                        nop ;
                    }
                }
            }
        }
    }

    // Function calls:
    sub_2495();
    sub_2128();
}

void sub_2128() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 40 if statements

    // Block 0x2128
    push($1);
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    lds si, ptr [si];
    or si, si;
    if (a == b) {  // je 0x2156
        // Block 0x2156
        $1 = 0;
        goto $1;
        $1 = $2;
        int 0x66;
        return;  // retf 
    } else {
        // Block 0x2137
        nop ;
        nop ;
        nop ;
        $1 -= $2;
        cmp word ptr [si], 0x494d;
        if (a != b) {  // jne 0x2156
            // Block 0x2156
            $1 = 0;
            goto $1;
            $1 = $2;
            int 0x66;
            return;  // retf 
        } else {
            // Block 0x2143
            nop ;
            nop ;
            nop ;
            cmp word ptr [si + 2], 0x4944;
            if (a != b) {  // jne 0x2156
                // Block 0x2156
                $1 = 0;
                goto $1;
                $1 = $2;
                int 0x66;
                return;  // retf 
            } else {
                // Block 0x214D
                nop ;
                nop ;
                nop ;
                mov ax, 1;
            }
        }
    }

    // Function calls:
    sub_2495();
}

void sub_2495() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 32 if statements

    // Block 0x2495
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    $1 = 0;
    $1 = $2;
    DOS_OpenFile();  // int 0x21
    if (a >= b (unsigned)) {  // jae 0x24ab
        // Block 0x24AB
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = 0;
        $1 = 0;
        DOS_MoveFilePointer();  // int 0x21
        if (a < b (unsigned)) {  // jb 0x2532
            // Block 0x2532
            $1 = $2;
            int 0x21;
        } else {
            // Block 0x24B9
            lds di, ptr [bp + 0xa];
            or di, di;
            if (a == b) {  // je 0x24c5
                // Block 0x24C5
                $1 = $2;
                $1 = $2;
                $1 += $2;
                adc dx, 0;
                push($1);
                push($1);
                lcall 0x1a10, 0x2f;
                $1 += $2;
                $1 = $2;
                or ax, ax;
                if (a != b) {  // jne 0x24e3
                    // Block 0x24E3
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    // Swap cx and cx
                    int 0x21;
                    $1 = $2;
                    DOS_MoveFilePointer();  // int 0x21
                    $1 = $2;
                    $1 += $2;
                    mov dx, di;
                    add dx, 0xf;
                    and dx, 0xfff0;
                } else {
                    // Block 0x24DF
                    or dx, dx;
                    if (a == b) {  // je 0x2532
                        // Block 0x2532
                        $1 = $2;
                        int 0x21;
                    } else {
                        // Block 0x24E3
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        // Swap cx and cx
                        int 0x21;
                        $1 = $2;
                        DOS_MoveFilePointer();  // int 0x21
                        $1 = $2;
                        $1 += $2;
                        mov dx, di;
                        add dx, 0xf;
                        and dx, 0xfff0;
                    }
                }
            } else {
                // Block 0x24C0
                *($1) = $2;
                mov word ptr [di + 2], dx;
            }
        }
    } else {
        // Block 0x24A8
        jmp 0x2536;
        // Block 0x2536
        $1 = 0;
        $1 = 0;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }
}

void sub_2827() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 24 if statements

    // Block 0x2827
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 6];
    push($1);
    push($1);
    $1 = pop();
    $1 = $2;
    INT_21_AH19();  // int 0x21
    $1 += $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = $2;
    stosb byte ptr es:[di], al;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    DOS_GetCurrentDirectory();  // int 0x21
    $1 = pop();
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2827();
    sub_2ACF();
    sub_2D44();
}

void sub_2A03() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x2A03
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    lds dx, ptr [bp + 6];
    INT_21_AH43();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x2a1d
        // Block 0x2A1D
        push($1);
        call 0x2d7d;
        // Block 0x2A21
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x2A13
        les bx, ptr [bp + 0xa];
        mov word ptr es:[bx], cx;
        $1 = 0;
        jmp 0x2a21;
        // Block 0x2A21
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D7D();
    sub_2D7D();
}

void sub_2A40() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x2A40
    push($1);
    $1 = $2;
    $1 = $2;
    INT_21_AH19();  // int 0x21
    $1 = $2;
    $1++;
    les bx, ptr [bp + 6];
    mov word ptr es:[bx], ax;
    $1 = pop();
    return;  // retf 
}

void sub_2A52() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x2A52
    push($1);
    $1 = $2;
    $1 = $2;
    $1--;
    $1 = $2;
    INT_21_AH0E();  // int 0x21
    $1 = $2;
    les bx, ptr [bp + 8];
    mov word ptr es:[bx], ax;
    $1 = pop();
    return;  // retf 
}

void sub_2A69() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x2A69
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or si, si;
    if (a != b) {  // jne 0x2a96
        // Block 0x2A96
        nop ;
        push($1);
        call 0x1dc0;
        // Block 0x2A9B
        nop ;
        push($1);
        call 0x1d6a;
        // Block 0x2AA0
        cmp word ptr [bp + 6], 0;
        if (a != b) {  // jne 0x2abb
            // Block 0x2ABB
            $1 = pop();
            $1 = pop();
            return;  // ret 6
        } else {
            // Block 0x2AA6
            or si, si;
            if (a != b) {  // jne 0x2ab2
                // Block 0x2AB2
                push($1);
                nop ;
                push($1);
                call 0x1d6b;
                // Block 0x2ABA
                pop cx;
            } else {
                // Block 0x2AAA
                lcall [0x7338];
                lcall [0x733c];
            }
        }
    } else {
        // Block 0x2A74
        jmp 0x2a86;
        // Block 0x2A86
        cmp word ptr [0x7230], 0;
        if (a != b) {  // jne 0x2a76
            // Block 0x2A76
            $1--;
            $1 = $2;
            $1 = $2;
            shl bx, cl;
            lcall [bx - 0x78fe];
        } else {
            // Block 0x2A8D
            nop ;
            push($1);
            call 0x1d57;
            // Block 0x2A92
            lcall [0x7334];
        }
    }

    // Function calls:
    sub_1D57();
    sub_1DC0();
    sub_1D6A();
    sub_1D6B();
}

void sub_2AC0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x2AC0
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    call 0x2a69;
    // Block 0x2ACD
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2A69();
}

void sub_2ACF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x2ACF
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = 0;
    push($1);
    push($1);
    call 0x2a69;
    // Block 0x2ADF
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2A69();
    sub_2A69();
    sub_2A69();
}

void sub_2B2E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x2B2E
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 8];
    DOS_GetCurrentDirectory();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x2b44
        // Block 0x2B44
        push($1);
        call 0x2d44;
        // Block 0x2B48
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x2B40
        $1 = 0;
        jmp 0x2b48;
        // Block 0x2B48
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_2B71() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 13 if statements

    // Block 0x2B71
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    lea ax, [bp - 2];
    push($1);
    nop ;
    push($1);
    call 0x2a40;
    // Block 0x2B81
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1--;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2A40();
    sub_2A52();
    sub_2D44();
}

void sub_2C9B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x2C9B
    $1 = pop();
    push($1);
    push($1);
    // Compare $1 with $2
    if (a >= b (unsigned)) {  // jae 0x2cb3
        // Block 0x2CB3
        $1 -= $2;
        xchg dx, ax;
        $1 = 0;
        shl dx, cl;
        return;  // retf 
    } else {
        // Block 0x2CA3
        $1 = $2;
        shl ax, cl;
        shl dx, cl;
        neg cl;
        $1 += $2;
        shr bx, cl;
        or dx, bx;
        return;  // retf 
    }
}

void sub_2CBC() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x2CBC
    $1 = pop();
    push($1);
    push($1);
    or cx, cx;
    if (a >= b) {  // jge 0x2ccf
        // Block 0x2CCF
        $1 += $2;
        if (a >= b (unsigned)) {  // jae 0x2cd7
            // Block 0x2CD7
            $1 = $2;
            $1 = $2;
            shl ch, cl;
            $1 += $2;
            $1 = $2;
            shr ax, cl;
            $1 += $2;
            $1 = $2;
            and ax, 0xf;
            return;  // retf 
        } else {
            // Block 0x2CD3
            add dx, 0x1000;
        }
    } else {
        // Block 0x2CC3
        not bx;
        not cx;
        $1 += $2;
        adc cx, 0;
        jmp 0x2cfe;
        // Block 0x2CFE
        $1 -= $2;
        if (a >= b (unsigned)) {  // jae 0x2d06
            // Block 0x2D06
            $1 = $2;
            $1 = $2;
            shl bh, cl;
            $1 = 0;
            $1 -= $2;
            $1 = $2;
            shr ax, cl;
            $1 += $2;
            $1 = $2;
            and ax, 0xf;
            return;  // retf 
        } else {
            // Block 0x2D02
            sub dx, 0x1000;
        }
    }
}

void sub_2D1C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x2D1C
    $1 = pop();
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    shl dx, cl;
    shr ch, cl;
    $1 += $2;
    adc ch, 0;
    $1 = $2;
    shl di, cl;
    shr ah, cl;
    $1 += $2;
    adc ah, 0;
    $1 -= $2;
    sbb ch, ah;
    $1 = $2;
    cwde ;
    xchg dx, ax;
    $1 = pop();
    return;  // retf 
}

void sub_2D44() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x2D44
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or si, si;
    if (a < b) {  // jl 0x2d64
        // Block 0x2D64
        neg si;
        // Compare $1 with $2
        if (a > b) {  // jg 0x2d54
            // Block 0x2D54
            mov si, 0x57;
        } else {
            // Block 0x2D6B
            mov word ptr [0x74fe], 0xffff;
        }
    } else {
        // Block 0x2D4F
        // Compare $1 with $2
        if (a <= b) {  // jle 0x2d57
            // Block 0x2D57
            *($1) = $2;
            $1 = $2;
            cwde ;
            $1 = $2;
            jmp 0x2d71;
            // Block 0x2D71
            *($1) = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            return;  // ret 2
        } else {
            // Block 0x2D54
            mov si, 0x57;
        }
    }
}

void sub_2D7D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x2D7D
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    call 0x2d44;
    // Block 0x2D88
    $1 = $2;
    $1 = pop();
    $1 = pop();
    return;  // ret 2

    // Function calls:
    sub_2D44();
    sub_57EF();
    sub_57EF();
    sub_5C29();
    sub_5C29();
}

void sub_2F4E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x2F4E
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    xchg dx, ax;
    and ax, 0x80;
    $1 = pop();
    return;  // retf 
}

void sub_2F5F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 8 if statements

    // Block 0x2F5F
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    les di, ptr [bp + 0xa];
    $1 = $2;
    // Compare $1 with $2
    if (a > b (unsigned)) {  // ja 0x2fcf
        // Block 0x2FCF
        $1 = $2;
        stosb byte ptr es:[di], al;
        $1 = pop();
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // ret 0xe
    } else {
        // Block 0x2F73
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x2fcf
            // Block 0x2FCF
            $1 = $2;
            stosb byte ptr es:[di], al;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // ret 0xe
        } else {
            // Block 0x2F78
            $1 = $2;
            $1 = $2;
            or cx, cx;
            if (a >= b) {  // jge 0x2f94
                // Block 0x2F94
                lea si, [bp - 0x22];
                if (condition_jcxz) {  // jcxz 0x2fa9
                    // Block 0x2FA9
                    $1 -= $2;
                    div bx;
                    mov byte ptr ss:[si], dl;
                    inc si;
                } else {
                    // Block 0x2F99
                    xchg cx, ax;
                    $1 -= $2;
                    div bx;
                    xchg cx, ax;
                    div bx;
                    mov byte ptr ss:[si], dl;
                    $1++;
                    if (condition_jcxz) {  // jcxz 0x2fb1
                        // Block 0x2FB1
                        or ax, ax;
                        if (a != b) {  // jne 0x2fa9
                            // Block 0x2FA9
                            $1 -= $2;
                            div bx;
                            mov byte ptr ss:[si], dl;
                            inc si;
                        } else {
                            // Block 0x2FB5
                            lea cx, [bp - 0x22];
                            neg cx;
                            $1 += $2;
                            cld ;
                            $1--;
                            $1 = $2;
                            $1 -= $2;
                            if (a >= b (unsigned)) {  // jae 0x2fc9
                                // Block 0x2FC9
                                add al, byte ptr [bp + 4];
                            } else {
                                // Block 0x2FC5
                                $1 += $2;
                                jmp 0x2fcc;
                                // Block 0x2FCC
                                stosb byte ptr es:[di], al;
                                loop 0x2fbd;
                            }
                        }
                    } else {
                        // Block 0x2FA7
                        jmp 0x2f99;
                    }
                }
            } else {
                // Block 0x2F82
                cmp byte ptr [bp + 6], 0;
                if (a == b) {  // je 0x2f94
                    // Block 0x2F94
                    lea si, [bp - 0x22];
                    if (condition_jcxz) {  // jcxz 0x2fa9
                        // Block 0x2FA9
                        $1 -= $2;
                        div bx;
                        mov byte ptr ss:[si], dl;
                        inc si;
                    } else {
                        // Block 0x2F99
                        xchg cx, ax;
                        $1 -= $2;
                        div bx;
                        xchg cx, ax;
                        div bx;
                        mov byte ptr ss:[si], dl;
                        $1++;
                        if (condition_jcxz) {  // jcxz 0x2fb1
                            // Block 0x2FB1
                            or ax, ax;
                            if (a != b) {  // jne 0x2fa9
                                // Block 0x2FA9
                                $1 -= $2;
                                div bx;
                                mov byte ptr ss:[si], dl;
                                inc si;
                            } else {
                                // Block 0x2FB5
                                lea cx, [bp - 0x22];
                                neg cx;
                                $1 += $2;
                                cld ;
                                $1--;
                                $1 = $2;
                                $1 -= $2;
                                if (a >= b (unsigned)) {  // jae 0x2fc9
                                    // Block 0x2FC9
                                    add al, byte ptr [bp + 4];
                                } else {
                                    // Block 0x2FC5
                                    $1 += $2;
                                    jmp 0x2fcc;
                                    // Block 0x2FCC
                                    stosb byte ptr es:[di], al;
                                    loop 0x2fbd;
                                }
                            }
                        } else {
                            // Block 0x2FA7
                            jmp 0x2f99;
                        }
                    }
                } else {
                    // Block 0x2F88
                    mov byte ptr es:[di], 0x2d;
                    $1++;
                    neg cx;
                    neg ax;
                    sbb cx, 0;
                }
            }
        }
    }
}

void sub_2FE1() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x2FE1
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    call 0x2f5f;
    // Block 0x2FFD
    $1 = pop();
    return;  // ret 6

    // Function calls:
    sub_2F5F();
}

void sub_3001() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x3001
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    and word ptr [bx + 0x74d2], 0xfdff;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21();  // int 0x21
    if (a < b (unsigned)) {  // jb 0x3023
        // Block 0x3023
        push($1);
        call 0x2d44;
        // Block 0x3027
        cdq ;
    } else {
        // Block 0x3021
        jmp 0x3028;
        // Block 0x3028
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_302A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x302A
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (a != b) {  // jne 0x303d
        // Block 0x303D
        push($1);
        $1 = $2;
        or ax, word ptr [bp + 8];
        if (a != b) {  // jne 0x304f
            // Block 0x304F
            $1 = $2;
            mov ax, word ptr [bp + 6];
        } else {
            // Block 0x3048
            $1 = $2;
            $1 = $2;
            jmp 0x3055;
            // Block 0x3055
            push($1);
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x3e97;
            // Block 0x3062
            $1 += $2;
            push($1);
            push($1);
            call 0x2fe1;
            // Block 0x306A
            push($1);
            $1 = $2;
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x65b8;
            // Block 0x307A
            $1 += $2;
            $1 = $2;
            $1 = $2;
            $1 = pop();
            return;  // ret 0xa
        }
    } else {
        // Block 0x3035
        *($1) = $2;
        mov word ptr [bp + 0xa], 0x8782;
    }

    // Function calls:
    sub_3E97();
    sub_2FE1();
    sub_65B8();
    sub_302A();
    sub_2A03();
}

void sub_30E0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x30E0
    push($1);
    xchg si, ax;
    xchg dx, ax;
    test ax, ax;
    if (a == b) {  // je 0x30e9
        // Block 0x30E9
        if (condition_jcxz) {  // jcxz 0x30f0
            // Block 0x30F0
            xchg si, ax;
            mul bx;
            $1 += $2;
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x30EB
            xchg cx, ax;
            mul si;
            add ax, cx;
        }
    } else {
        // Block 0x30E7
        mul bx;
    }
}

void sub_30F7() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x30F7
    push($1);
    $1 = $2;
    $1 = $2;
    shr ax, cl;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    and ax, 0xf;
    and bx, 0xf;
    // Compare $1 with $2
    if (a != b) {  // jne 0x3117
        // Block 0x3117
        return;  // ret 
    } else {
        // Block 0x3115
        cmp ax, bx;
    }
}

void sub_3118() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x3118
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 2;
    if (a == b) {  // je 0x312e
        // Block 0x312E
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        lds dx, ptr [bp + 8];
        DOS_ReadFile();  // int 0x21
        $1 = pop();
        if (a < b (unsigned)) {  // jb 0x3141
            // Block 0x3141
            push ax;
        } else {
            // Block 0x313F
            jmp 0x3145;
            // Block 0x3145
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x3128
        $1 = $2;
        push($1);
        jmp 0x3142;
        // Block 0x3142
        call 0x2d44;
        // Block 0x3145
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_3147() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x3147
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 0;
    jmp 0x3176;
    // Block 0x3176
}

void sub_315B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x315B
    les di, ptr [bp + 0x10];
    test byte ptr [bp - 1], 0x20;
    if (a == b) {  // je 0x316c
        // Block 0x316C
        $1 = $2;
        push($1);
        $1 = pop();
        add word ptr [bp + 0x10], 2;
        return;  // ret 
    } else {
        // Block 0x3164
        les di, ptr es:[di];
        add word ptr [bp + 0x10], 4;
        return;  // ret 
    }

    // Function calls:
    sub_3666();
    sub_315B();
    sub_32DA();
}

void sub_32DA() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x32DA
    goto $1;
    push($1);
    push($1);
    push($1);
    call word ptr [bp + 6];
    // Block 0x357B

    // Function calls:
    sub_32F5();
}

void sub_32F5() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x32F5
    goto $1;
    push($1);
    // Compare $1 with $2
    if (a == b) {  // je 0x3316
        // Block 0x3316
        call 0x3319;
        // Block 0x3319
    } else {
        // Block 0x32FD
        or ax, ax;
        if (a <= b) {  // jle 0x3311
            // Block 0x3311
            $1 = pop();
            $1 = $2;
            jmp 0x3335;
            // Block 0x3335
        } else {
            // Block 0x3301
            push($1);
            push($1);
            push($1);
            call word ptr [bp + 6];
            // Block 0x330B
            $1 += $2;
            dec word ptr [bp - 6];
        }
    }

    // Function calls:
    sub_3319();
}

void sub_3319() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x3319
    goto $1;
    $1 = pop();
    or ax, ax;
    if (a <= b) {  // jle 0x3335
        // Block 0x3335
        test byte ptr [bp - 1], 1;
        if (a != b) {  // jne 0x334b
            // Block 0x334B
            jmp 0x3178;
            // Block 0x3178
        } else {
            // Block 0x333B
            call 0x315b;
            // Block 0x333E
            $1++;
            xchg dx, ax;
            stosw word ptr es:[di], ax;
            test byte ptr [bp - 1], 0x20;
            if (a == b) {  // je 0x334b
                // Block 0x334B
                jmp 0x3178;
                // Block 0x3178
            } else {
                // Block 0x3349
                xchg bx, ax;
                stosw word ptr es:[di], ax;
            }
        }
    } else {
        // Block 0x3321
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        call word ptr [bp + 6];
        // Block 0x332D
        $1 += $2;
        $1--;
        $1 = pop();
        pop dx;
    }

    // Function calls:
    sub_315B();
    sub_4890();
    sub_315B();
    sub_4894();
    sub_4898();
    sub_4898();
    sub_33BE();
}

void sub_33BE() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 loops
    // - 55 if statements

    // Block 0x33BE
    goto $1;
    test byte ptr [bp - 1], 1;
    if (a != b) {  // jne 0x33cd
        // Block 0x33CD
        and word ptr [bp - 0xa], 0x7fff;
        if (a == b) {  // je 0x3401
            // Block 0x3401
            push($1);
            push($1);
            push($1);
            push($1);
            call word ptr [bp + 6];
            // Block 0x340C
            $1 += $2;
            $1 = pop();
            $1--;
            test byte ptr [bp - 1], 1;
            if (a != b) {  // jne 0x341c
                // Block 0x341C
                goto $1;
                test byte ptr [bp - 1], 1;
                if (a != b) {  // jne 0x3428
                    // Block 0x3428
                    $1 = $2;
                    or si, si;
                    if (a >= b) {  // jge 0x3432
                        // Block 0x3432
                        if (a == b) {  // je 0x3452
                            // Block 0x3452
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x345b
                                // Block 0x345B
                                jmp 0x3178;
                                // Block 0x3178
                            } else {
                                // Block 0x3458
                                inc word ptr [bp - 4];
                            }
                        } else {
                            // Block 0x3434
                            $1++;
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 4];
                            // Block 0x3441
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            or ax, ax;
                            if (a < b) {  // jl 0x345e
                                // Block 0x345E
                                goto $1;
                                push($1);
                                $1 -= $2;
                                cld ;
                                push($1);
                                $1 = pop();
                                lea di, [bp - 0x2a];
                                $1 = $2;
                                rep stosw word ptr es:[di], ax;
                                $1 = pop();
                                lodsb al, byte ptr es:[si];
                                and byte ptr [bp - 1], 0xef;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x3480
                                    // Block 0x3480
                                    mov ah, 0;
                                } else {
                                    // Block 0x347A
                                    or byte ptr [bp - 1], 0x10;
                                    lodsb al, byte ptr es:[si];
                                }
                            } else {
                                // Block 0x3448
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x344f
                                    // Block 0x344F
                                    $1--;
                                    if (a > b) {  // jg 0x3434
                                        // Jump to block at 0x3434
                                    } else {
                                        // Block 0x3452
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x345b
                                            // Block 0x345B
                                            jmp 0x3178;
                                            // Block 0x3178
                                        } else {
                                            // Block 0x3458
                                            inc word ptr [bp - 4];
                                        }
                                    }
                                } else {
                                    // Block 0x344E
                                    stosb byte ptr es:[di], al;
                                }
                            }
                        }
                    } else {
                        // Block 0x342F
                        mov si, 1;
                    }
                } else {
                    // Block 0x3425
                    call 0x315b;
                    // Block 0x3428
                    $1 = $2;
                    or si, si;
                    if (a >= b) {  // jge 0x3432
                        // Block 0x3432
                        if (a == b) {  // je 0x3452
                            // Block 0x3452
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x345b
                                // Block 0x345B
                                jmp 0x3178;
                                // Block 0x3178
                            } else {
                                // Block 0x3458
                                inc word ptr [bp - 4];
                            }
                        } else {
                            // Block 0x3434
                            $1++;
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 4];
                            // Block 0x3441
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            or ax, ax;
                            if (a < b) {  // jl 0x345e
                                // Block 0x345E
                                goto $1;
                                push($1);
                                $1 -= $2;
                                cld ;
                                push($1);
                                $1 = pop();
                                lea di, [bp - 0x2a];
                                $1 = $2;
                                rep stosw word ptr es:[di], ax;
                                $1 = pop();
                                lodsb al, byte ptr es:[si];
                                and byte ptr [bp - 1], 0xef;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x3480
                                    // Block 0x3480
                                    mov ah, 0;
                                } else {
                                    // Block 0x347A
                                    or byte ptr [bp - 1], 0x10;
                                    lodsb al, byte ptr es:[si];
                                }
                            } else {
                                // Block 0x3448
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x344f
                                    // Block 0x344F
                                    $1--;
                                    if (a > b) {  // jg 0x3434
                                        // Jump to block at 0x3434
                                    } else {
                                        // Block 0x3452
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x345b
                                            // Block 0x345B
                                            jmp 0x3178;
                                            // Block 0x3178
                                        } else {
                                            // Block 0x3458
                                            inc word ptr [bp - 4];
                                        }
                                    }
                                } else {
                                    // Block 0x344E
                                    stosb byte ptr es:[di], al;
                                }
                            }
                        }
                    } else {
                        // Block 0x342F
                        mov si, 1;
                    }
                }
            } else {
                // Block 0x3419
                $1 = $2;
                stosb byte ptr es:[di], al;
            }
        } else {
            // Block 0x33D4
            test byte ptr [bp - 1], 1;
            if (a != b) {  // jne 0x33db
                // Block 0x33DB
                $1++;
                push($1);
                push($1);
                push($1);
                call word ptr [bp + 4];
                // Block 0x33E8
                $1 = pop();
                $1 = pop();
                $1 = pop();
                or ax, ax;
                if (a <= b) {  // jle 0x3401
                    // Block 0x3401
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    call word ptr [bp + 6];
                    // Block 0x340C
                    $1 += $2;
                    $1 = pop();
                    $1--;
                    test byte ptr [bp - 1], 1;
                    if (a != b) {  // jne 0x341c
                        // Block 0x341C
                        goto $1;
                        test byte ptr [bp - 1], 1;
                        if (a != b) {  // jne 0x3428
                            // Block 0x3428
                            $1 = $2;
                            or si, si;
                            if (a >= b) {  // jge 0x3432
                                // Block 0x3432
                                if (a == b) {  // je 0x3452
                                    // Block 0x3452
                                    test byte ptr [bp - 1], 1;
                                    if (a != b) {  // jne 0x345b
                                        // Block 0x345B
                                        jmp 0x3178;
                                        // Block 0x3178
                                    } else {
                                        // Block 0x3458
                                        inc word ptr [bp - 4];
                                    }
                                } else {
                                    // Block 0x3434
                                    $1++;
                                    push($1);
                                    push($1);
                                    push($1);
                                    call word ptr [bp + 4];
                                    // Block 0x3441
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a < b) {  // jl 0x345e
                                        // Block 0x345E
                                        goto $1;
                                        push($1);
                                        $1 -= $2;
                                        cld ;
                                        push($1);
                                        $1 = pop();
                                        lea di, [bp - 0x2a];
                                        $1 = $2;
                                        rep stosw word ptr es:[di], ax;
                                        $1 = pop();
                                        lodsb al, byte ptr es:[si];
                                        and byte ptr [bp - 1], 0xef;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x3480
                                            // Block 0x3480
                                            mov ah, 0;
                                        } else {
                                            // Block 0x347A
                                            or byte ptr [bp - 1], 0x10;
                                            lodsb al, byte ptr es:[si];
                                        }
                                    } else {
                                        // Block 0x3448
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x344f
                                            // Block 0x344F
                                            $1--;
                                            if (a > b) {  // jg 0x3434
                                                // Jump to block at 0x3434
                                            } else {
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            }
                                        } else {
                                            // Block 0x344E
                                            stosb byte ptr es:[di], al;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x342F
                                mov si, 1;
                            }
                        } else {
                            // Block 0x3425
                            call 0x315b;
                            // Block 0x3428
                            $1 = $2;
                            or si, si;
                            if (a >= b) {  // jge 0x3432
                                // Block 0x3432
                                if (a == b) {  // je 0x3452
                                    // Block 0x3452
                                    test byte ptr [bp - 1], 1;
                                    if (a != b) {  // jne 0x345b
                                        // Block 0x345B
                                        jmp 0x3178;
                                        // Block 0x3178
                                    } else {
                                        // Block 0x3458
                                        inc word ptr [bp - 4];
                                    }
                                } else {
                                    // Block 0x3434
                                    $1++;
                                    push($1);
                                    push($1);
                                    push($1);
                                    call word ptr [bp + 4];
                                    // Block 0x3441
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a < b) {  // jl 0x345e
                                        // Block 0x345E
                                        goto $1;
                                        push($1);
                                        $1 -= $2;
                                        cld ;
                                        push($1);
                                        $1 = pop();
                                        lea di, [bp - 0x2a];
                                        $1 = $2;
                                        rep stosw word ptr es:[di], ax;
                                        $1 = pop();
                                        lodsb al, byte ptr es:[si];
                                        and byte ptr [bp - 1], 0xef;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x3480
                                            // Block 0x3480
                                            mov ah, 0;
                                        } else {
                                            // Block 0x347A
                                            or byte ptr [bp - 1], 0x10;
                                            lodsb al, byte ptr es:[si];
                                        }
                                    } else {
                                        // Block 0x3448
                                        test byte ptr [bp - 1], 1;
                                        if (a != b) {  // jne 0x344f
                                            // Block 0x344F
                                            $1--;
                                            if (a > b) {  // jg 0x3434
                                                // Jump to block at 0x3434
                                            } else {
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            }
                                        } else {
                                            // Block 0x344E
                                            stosb byte ptr es:[di], al;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x342F
                                mov si, 1;
                            }
                        }
                    } else {
                        // Block 0x3419
                        $1 = $2;
                        stosb byte ptr es:[di], al;
                    }
                } else {
                    // Block 0x33EF
                    or al, al;
                    if (condition_js) {  // js 0x33fc
                        // Block 0x33FC
                        $1--;
                        if (a > b) {  // jg 0x33d4
                            // Jump to block at 0x33D4
                        } else {
                            // Block 0x3401
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 6];
                            // Block 0x340C
                            $1 += $2;
                            $1 = pop();
                            $1--;
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x341c
                                // Block 0x341C
                                goto $1;
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x3428
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                } else {
                                    // Block 0x3425
                                    call 0x315b;
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                }
                            } else {
                                // Block 0x3419
                                $1 = $2;
                                stosb byte ptr es:[di], al;
                            }
                        }
                    } else {
                        // Block 0x33F3
                        xchg bx, ax;
                        cmp byte ptr [bx + 0x7564], 1;
                        xchg bx, ax;
                        if (a <= b) {  // jle 0x3401
                            // Block 0x3401
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            call word ptr [bp + 6];
                            // Block 0x340C
                            $1 += $2;
                            $1 = pop();
                            $1--;
                            test byte ptr [bp - 1], 1;
                            if (a != b) {  // jne 0x341c
                                // Block 0x341C
                                goto $1;
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x3428
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                } else {
                                    // Block 0x3425
                                    call 0x315b;
                                    // Block 0x3428
                                    $1 = $2;
                                    or si, si;
                                    if (a >= b) {  // jge 0x3432
                                        // Block 0x3432
                                        if (a == b) {  // je 0x3452
                                            // Block 0x3452
                                            test byte ptr [bp - 1], 1;
                                            if (a != b) {  // jne 0x345b
                                                // Block 0x345B
                                                jmp 0x3178;
                                                // Block 0x3178
                                            } else {
                                                // Block 0x3458
                                                inc word ptr [bp - 4];
                                            }
                                        } else {
                                            // Block 0x3434
                                            $1++;
                                            push($1);
                                            push($1);
                                            push($1);
                                            call word ptr [bp + 4];
                                            // Block 0x3441
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            or ax, ax;
                                            if (a < b) {  // jl 0x345e
                                                // Block 0x345E
                                                goto $1;
                                                push($1);
                                                $1 -= $2;
                                                cld ;
                                                push($1);
                                                $1 = pop();
                                                lea di, [bp - 0x2a];
                                                $1 = $2;
                                                rep stosw word ptr es:[di], ax;
                                                $1 = pop();
                                                lodsb al, byte ptr es:[si];
                                                and byte ptr [bp - 1], 0xef;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x3480
                                                    // Block 0x3480
                                                    mov ah, 0;
                                                } else {
                                                    // Block 0x347A
                                                    or byte ptr [bp - 1], 0x10;
                                                    lodsb al, byte ptr es:[si];
                                                }
                                            } else {
                                                // Block 0x3448
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x344f
                                                    // Block 0x344F
                                                    $1--;
                                                    if (a > b) {  // jg 0x3434
                                                        // Jump to block at 0x3434
                                                    } else {
                                                        // Block 0x3452
                                                        test byte ptr [bp - 1], 1;
                                                        if (a != b) {  // jne 0x345b
                                                            // Block 0x345B
                                                            jmp 0x3178;
                                                            // Block 0x3178
                                                        } else {
                                                            // Block 0x3458
                                                            inc word ptr [bp - 4];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x344E
                                                    stosb byte ptr es:[di], al;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x342F
                                        mov si, 1;
                                    }
                                }
                            } else {
                                // Block 0x3419
                                $1 = $2;
                                stosb byte ptr es:[di], al;
                            }
                        } else {
                            // Block 0x33FC
                            $1--;
                            if (a > b) {  // jg 0x33d4
                                // Jump to block at 0x33D4
                            } else {
                                // Block 0x3401
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                call word ptr [bp + 6];
                                // Block 0x340C
                                $1 += $2;
                                $1 = pop();
                                $1--;
                                test byte ptr [bp - 1], 1;
                                if (a != b) {  // jne 0x341c
                                    // Block 0x341C
                                    goto $1;
                                    test byte ptr [bp - 1], 1;
                                    if (a != b) {  // jne 0x3428
                                        // Block 0x3428
                                        $1 = $2;
                                        or si, si;
                                        if (a >= b) {  // jge 0x3432
                                            // Block 0x3432
                                            if (a == b) {  // je 0x3452
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            } else {
                                                // Block 0x3434
                                                $1++;
                                                push($1);
                                                push($1);
                                                push($1);
                                                call word ptr [bp + 4];
                                                // Block 0x3441
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                or ax, ax;
                                                if (a < b) {  // jl 0x345e
                                                    // Block 0x345E
                                                    goto $1;
                                                    push($1);
                                                    $1 -= $2;
                                                    cld ;
                                                    push($1);
                                                    $1 = pop();
                                                    lea di, [bp - 0x2a];
                                                    $1 = $2;
                                                    rep stosw word ptr es:[di], ax;
                                                    $1 = pop();
                                                    lodsb al, byte ptr es:[si];
                                                    and byte ptr [bp - 1], 0xef;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0x3480
                                                        // Block 0x3480
                                                        mov ah, 0;
                                                    } else {
                                                        // Block 0x347A
                                                        or byte ptr [bp - 1], 0x10;
                                                        lodsb al, byte ptr es:[si];
                                                    }
                                                } else {
                                                    // Block 0x3448
                                                    test byte ptr [bp - 1], 1;
                                                    if (a != b) {  // jne 0x344f
                                                        // Block 0x344F
                                                        $1--;
                                                        if (a > b) {  // jg 0x3434
                                                            // Jump to block at 0x3434
                                                        } else {
                                                            // Block 0x3452
                                                            test byte ptr [bp - 1], 1;
                                                            if (a != b) {  // jne 0x345b
                                                                // Block 0x345B
                                                                jmp 0x3178;
                                                                // Block 0x3178
                                                            } else {
                                                                // Block 0x3458
                                                                inc word ptr [bp - 4];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x344E
                                                        stosb byte ptr es:[di], al;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x342F
                                            mov si, 1;
                                        }
                                    } else {
                                        // Block 0x3425
                                        call 0x315b;
                                        // Block 0x3428
                                        $1 = $2;
                                        or si, si;
                                        if (a >= b) {  // jge 0x3432
                                            // Block 0x3432
                                            if (a == b) {  // je 0x3452
                                                // Block 0x3452
                                                test byte ptr [bp - 1], 1;
                                                if (a != b) {  // jne 0x345b
                                                    // Block 0x345B
                                                    jmp 0x3178;
                                                    // Block 0x3178
                                                } else {
                                                    // Block 0x3458
                                                    inc word ptr [bp - 4];
                                                }
                                            } else {
                                                // Block 0x3434
                                                $1++;
                                                push($1);
                                                push($1);
                                                push($1);
                                                call word ptr [bp + 4];
                                                // Block 0x3441
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                or ax, ax;
                                                if (a < b) {  // jl 0x345e
                                                    // Block 0x345E
                                                    goto $1;
                                                    push($1);
                                                    $1 -= $2;
                                                    cld ;
                                                    push($1);
                                                    $1 = pop();
                                                    lea di, [bp - 0x2a];
                                                    $1 = $2;
                                                    rep stosw word ptr es:[di], ax;
                                                    $1 = pop();
                                                    lodsb al, byte ptr es:[si];
                                                    and byte ptr [bp - 1], 0xef;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0x3480
                                                        // Block 0x3480
                                                        mov ah, 0;
                                                    } else {
                                                        // Block 0x347A
                                                        or byte ptr [bp - 1], 0x10;
                                                        lodsb al, byte ptr es:[si];
                                                    }
                                                } else {
                                                    // Block 0x3448
                                                    test byte ptr [bp - 1], 1;
                                                    if (a != b) {  // jne 0x344f
                                                        // Block 0x344F
                                                        $1--;
                                                        if (a > b) {  // jg 0x3434
                                                            // Jump to block at 0x3434
                                                        } else {
                                                            // Block 0x3452
                                                            test byte ptr [bp - 1], 1;
                                                            if (a != b) {  // jne 0x345b
                                                                // Block 0x345B
                                                                jmp 0x3178;
                                                                // Block 0x3178
                                                            } else {
                                                                // Block 0x3458
                                                                inc word ptr [bp - 4];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x344E
                                                        stosb byte ptr es:[di], al;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x342F
                                            mov si, 1;
                                        }
                                    }
                                } else {
                                    // Block 0x3419
                                    $1 = $2;
                                    stosb byte ptr es:[di], al;
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x33DA
                stosb byte ptr es:[di], al;
            }
        }
    } else {
        // Block 0x33C7
        call 0x315b;
        // Block 0x33CA
        inc word ptr [bp - 4];
    }

    // Function calls:
    sub_315B();
    sub_315B();
    sub_315B();
}

void sub_363B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x363B
    push($1);
    $1 -= $2;
    if (a < b (unsigned)) {  // jb 0x3663
        // Block 0x3663
        $1 = pop();
        stc ;
    } else {
        // Block 0x3641
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x3658
            // Block 0x3658
            // Compare $1 with $2
            if (a >= b (unsigned)) {  // jae 0x3663
                // Block 0x3663
                $1 = pop();
                stc ;
            } else {
                // Block 0x365C
                $1++;
                $1++;
                clc ;
                $1 = $2;
                jmp 0x3665;
                // Block 0x3665
                return;  // ret 
            }
        } else {
            // Block 0x3646
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0x3650
                // Block 0x3650
                sub bl, 0x27;
            } else {
                // Block 0x364B
                $1 -= $2;
                jmp 0x3653;
                // Block 0x3653
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0x3663
                    // Block 0x3663
                    $1 = pop();
                    stc ;
                } else {
                    // Block 0x3658
                    // Compare $1 with $2
                    if (a >= b (unsigned)) {  // jae 0x3663
                        // Block 0x3663
                        $1 = pop();
                        stc ;
                    } else {
                        // Block 0x365C
                        $1++;
                        $1++;
                        clc ;
                        $1 = $2;
                        jmp 0x3665;
                        // Block 0x3665
                        return;  // ret 
                    }
                }
            }
        }
    }
}

void sub_3666() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 28 if statements

    // Block 0x3666
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov byte ptr [bp - 1], 0;
    mov word ptr [bp - 4], 0;
    mov word ptr [bp - 6], 1;

    // Function calls:
    sub_363B();
    sub_363B();
    sub_363B();
}

void sub_3808() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x3808
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    les si, ptr [bp + 6];
    mov word ptr es:[si], bx;
    $1 = $2;
    mov word ptr es:[si + 2], ax;
    mov word ptr es:[si + 4], ss;
    mov word ptr es:[si + 6], ds;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_2D44();
    sub_2F4E();
    sub_60C5();
    sub_2F4E();
    sub_60C5();
}

void sub_3905() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x3905
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    lds dx, ptr [bp + 6];
    DOS_DeleteFile();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x3917
        // Block 0x3917
        push($1);
        call 0x2d44;
        // Block 0x391B
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x3913
        $1 = 0;
        jmp 0x391b;
        // Block 0x391B
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_391D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x391D
    $1 = $2;
    call 0x3924;
    // Block 0x3922
    mov al, dl;

    // Function calls:
    sub_3924();
}

void sub_3924() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x3924
    aam 0x10;
    xchg al, ah;
    call 0x392d;
    // Block 0x392B
    xchg al, ah;

    // Function calls:
    sub_392D();
}

void sub_392D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x392D
    $1 += $2;
    daa ;
    adc al, 0x40;
    daa ;
    stosb byte ptr es:[di], al;
    return;  // ret 
}

void sub_3935() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x3935
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    mov word ptr [bp - 0x12], 0;
    mov word ptr [bp - 0x14], 0x50;
    mov word ptr [bp - 0x16], 0;
    jmp 0x3999;
    // Block 0x3999
}

void sub_394F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x394F
    push($1);
    $1 = $2;
    $1 = 0;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1--;
    $1 = pop();
    return;  // ret 
}

void sub_395C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x395C
    mov byte ptr ss:[di], al;
    $1++;
    $1--;
    if (a != b) {  // jne 0x3998
        // Block 0x3998
    } else {
        // Block 0x3965
    }
}

void sub_3965() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 63 if statements

    // Block 0x3965
    push($1);
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 0x96];
    $1 -= $2;
    push($1);
    lea ax, [bp - 0x96];
    push($1);
    push($1);
    push($1);
    push($1);
    call word ptr [bp + 0xe];
    // Block 0x397F
    or ax, ax;
    if (a != b) {  // jne 0x3988
        // Block 0x3988
        mov word ptr [bp - 0x14], 0x50;
        add word ptr [bp - 0x12], di;
        lea di, [bp - 0x96];
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x3983
        mov word ptr [bp - 0x16], 1;
    }

    // Function calls:
    sub_3965();
    sub_2F5F();
    sub_391D();
    sub_391D();
    sub_394F();
    sub_488C();
    sub_394F();
    sub_394F();
    sub_395C();
    sub_395C();
    sub_395C();
    sub_395C();
    sub_395C();
    sub_3965();
    sub_395C();
    sub_395C();
    sub_3965();
}

void sub_3DF8() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x3DF8
    in al, dx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1--;
    imul dx;
    push($1);
    $1 = $2;
    $1 = pop();
    $1 += $2;
    $1 = $2;
    $1--;
    $1 += $2;
    shl ax, 1;
    $1 = $2;
    $1 = pop();
    return;  // ret 4
}

void sub_3E1D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x3E1D
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    push($1);
    $1 = $2;
    if (condition_jcxz) {  // jcxz 0x3e8d
        // Block 0x3E8D
        cld ;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x3E33
        les di, ptr [bp + 0xa];
        lds si, ptr [bp + 6];
        cld ;
        // Compare $1 with $2
        if (a >= b (unsigned)) {  // jae 0x3e48
            // Block 0x3E48
            cmp word ptr [bp - 2], 0;
            if (a != b) {  // jne 0x3e52
                // Block 0x3E52
                $1 = $2;
                $1 = $2;
                $1 = $2;
                // Compare $1 with $2
                if (a == b) {  // je 0x3e6e
                    // Block 0x3E6E
                    cli ;
                } else {
                    // Block 0x3E5D
                    cli ;
                }
            } else {
                // Block 0x3E4E
                rep movsw word ptr es:[di], word ptr [si];
                jmp 0x3e8d;
                // Block 0x3E8D
                cld ;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // ret 0xa
            }
        } else {
            // Block 0x3E3E
            $1 = $2;
            $1--;
            shl ax, 1;
            $1 += $2;
            $1 += $2;
            std ;
        }
    }
}

void sub_3E97() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x3E97
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    call 0x6661;
    // Block 0x3EA6
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1++;
    push($1);
    push($1);
    push($1);
    push($1);
    push($1);
    nop ;
    push($1);
    call 0x59ff;
    // Block 0x3EBD
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_6661();
    sub_59FF();
    sub_4A85();
    sub_3F2F();
}

void sub_3EF4() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 2 if statements

    // Block 0x3EF4
    push($1);
    $1 = $2;
    jmp 0x3f11;
    // Block 0x3F11
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx], 0;
    if (a != b) {  // jne 0x3ef9
        // Block 0x3EF9
        les bx, ptr [bp + 4];
        $1++;
        $1 = $2;
        les bx, ptr [bp + 8];
        $1++;
        // Compare $1 with $2
        if (a == b) {  // je 0x3f11
            // Jump to block at 0x3F11
        } else {
            // Block 0x3F0D
            $1 = 0;
            jmp 0x3f1d;
            // Block 0x3F1D
            $1 = pop();
            return;  // ret 8
        }
    } else {
        // Block 0x3F1A
        mov ax, 1;
    }
}

void sub_3F21() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x3F21
    $1 = $2;
    $1 = $2;
    call 0x3f2f;
    // Block 0x3F28
    $1 = $2;
    $1 += $2;
    $1 = $2;
    return;  // ret 

    // Function calls:
    sub_3F2F();
}

void sub_3F2F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x3F2F
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0x3f46
        // Block 0x3F46
        // Compare $1 with $2
        if (a == b) {  // je 0x3f4e
            // Block 0x3F4E
            push($1);
            $1 = $2;
            INT_10();  // int 0x10
            // Compare $1 with $2
            if (a == b) {  // je 0x3f5d
                // Block 0x3F5D
                $1 = $2;
                $1 = $2;
                INT_10();  // int 0x10
                $1 = pop();
                jmp 0x3f42;
                // Block 0x3F42
                INT_10();  // int 0x10
                jmp 0x3fb7;
                // Block 0x3FB7
                $1 = pop();
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x3F58
                and byte ptr [0x87], 0xfe;
            }
        } else {
            // Block 0x3F4A
            // Compare $1 with $2
            if (a != b) {  // jne 0x3f67
                // Block 0x3F67
                // Compare $1 with $2
                if (a != b) {  // jne 0x3f42
                    // Block 0x3F42
                    INT_10();  // int 0x10
                    jmp 0x3fb7;
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3F6B
                    $1 = $2;
                    $1 = $2;
                    INT_10_AH12();  // int 0x10
                    // Compare $1 with $2
                    if (a == b) {  // je 0x3fb7
                        // Block 0x3FB7
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x3F76
                        $1 = $2;
                        $1 = 0;
                        INT_10();  // int 0x10
                        $1 = $2;
                        $1 = $2;
                        INT_10();  // int 0x10
                        $1 = $2;
                        INT_10();  // int 0x10
                        // Compare $1 with $2
                        if (a == b) {  // je 0x3fb7
                            // Block 0x3FB7
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 
                        } else {
                            // Block 0x3F8D
                            or byte ptr [0x87], 1;
                            $1 = $2;
                            $1 = $2;
                            INT_10_AH01();  // int 0x10
                            jmp 0x3fb7;
                            // Block 0x3FB7
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 
                        }
                    }
                }
            } else {
                // Block 0x3F4E
                push($1);
                $1 = $2;
                INT_10();  // int 0x10
                // Compare $1 with $2
                if (a == b) {  // je 0x3f5d
                    // Block 0x3F5D
                    $1 = $2;
                    $1 = $2;
                    INT_10();  // int 0x10
                    $1 = pop();
                    jmp 0x3f42;
                    // Block 0x3F42
                    INT_10();  // int 0x10
                    jmp 0x3fb7;
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3F58
                    and byte ptr [0x87], 0xfe;
                }
            }
        }
    } else {
        // Block 0x3F3D
        // Compare $1 with $2
        if (a == b) {  // je 0x3f9b
            // Block 0x3F9B
            INT_10();  // int 0x10
            // Compare $1 with $2
            if (a == b) {  // je 0x3fa5
                // Block 0x3FA5
                push($1);
                call 0x3f21;
                // Block 0x3FA9
                or al, al;
                $1 = pop();
                if (a == b) {  // je 0x3fb7
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3FAE
                    cmp byte ptr [0x84], 0x18;
                    if (a == b) {  // je 0x3fb7
                        // Block 0x3FB7
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x3FB5
                        mov al, 0x40;
                    }
                }
            } else {
                // Block 0x3FA1
                // Compare $1 with $2
                if (a != b) {  // jne 0x3fb7
                    // Block 0x3FB7
                    $1 = pop();
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x3FA5
                    push($1);
                    call 0x3f21;
                    // Block 0x3FA9
                    or al, al;
                    $1 = pop();
                    if (a == b) {  // je 0x3fb7
                        // Block 0x3FB7
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x3FAE
                        cmp byte ptr [0x84], 0x18;
                        if (a == b) {  // je 0x3fb7
                            // Block 0x3FB7
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 
                        } else {
                            // Block 0x3FB5
                            mov al, 0x40;
                        }
                    }
                }
            }
        } else {
            // Block 0x3F42
            INT_10();  // int 0x10
            jmp 0x3fb7;
            // Block 0x3FB7
            $1 = pop();
            $1 = pop();
            return;  // ret 
        }
    }

    // Function calls:
    sub_3F21();
    sub_3F2F();
    sub_3FD7();
    sub_3F2F();
}

void sub_3FD7() {
    // Variable declarations
    int var_7659;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x3FD7
    push($1);
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    call 0x3f2f;
    // Block 0x3FE5
    *($1) = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x4003
        // Block 0x4003
        cmp byte ptr [0x7652], 3;
        if (a <= b (unsigned)) {  // jbe 0x401d
            // Block 0x401D
            xor ax, ax;
        } else {
            // Block 0x400A
            cmp byte ptr [0x7652], 0x40;
            if (a >= b (unsigned)) {  // jae 0x401d
                // Block 0x401D
                xor ax, ax;
            } else {
                // Block 0x4011
                cmp byte ptr [0x7652], 7;
                if (a == b) {  // je 0x401d
                    // Block 0x401D
                    xor ax, ax;
                } else {
                    // Block 0x4018
                    $1 = $2;
                    jmp 0x401f;
                    // Block 0x401F
                    *($1) = $2;
                    cmp byte ptr [0x7652], 0x40;
                    if (a == b) {  // je 0x402d
                        // Block 0x402D
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        inc al;
                    } else {
                        // Block 0x4029
                        $1 = $2;
                        jmp 0x4038;
                        // Block 0x4038
                        *($1) = $2;
                        cmp byte ptr [0x7652], 7;
                        if (a == b) {  // je 0x4062
                            // Block 0x4062
                            xor ax, ax;
                        } else {
                            // Block 0x4042
                            $1 = $2;
                            $1 = $2;
                            push($1);
                            push($1);
                            push($1);
                            $1 = $2;
                            push($1);
                            call 0x3ef4;
                            // Block 0x4052
                            or ax, ax;
                            if (a != b) {  // jne 0x4062
                                // Block 0x4062
                                xor ax, ax;
                            } else {
                                // Block 0x4056
                                call 0x3f21;
                                // Block 0x4059
                                or ax, ax;
                                if (a != b) {  // jne 0x4062
                                    // Block 0x4062
                                    xor ax, ax;
                                } else {
                                    // Block 0x405D
                                    $1 = $2;
                                    jmp 0x4064;
                                    // Block 0x4064
                                    *($1) = $2;
                                    cmp byte ptr [0x7652], 7;
                                    if (a != b) {  // jne 0x4073
                                        // Block 0x4073
                                        mov ax, 0xb800;
                                    } else {
                                        // Block 0x406E
                                        $1 = $2;
                                        jmp 0x4076;
                                        // Block 0x4076
                                        *($1) = $2;
                                        mov word ptr [0x7657], 0;
                                        $1 = $2;
                                        *($1) = $2;
                                        *($1) = $2;
                                        $1 = $2;
                                        $1 += $2;
                                        *($1) = $2;
                                        $1 = $2;
                                        $1 += $2;
                                        *($1) = $2;
                                        $1 = pop();
                                        return;  // ret 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x3FEF
        $1 = $2;
        $1 = $2;
        call 0x3f2f;
        // Block 0x3FF7
        $1 = $2;
        call 0x3f2f;
        // Block 0x3FFC
        *($1) = $2;
        mov byte ptr [0x7654], ah;
    }

    // Function calls:
    sub_3F2F();
    sub_3F2F();
    sub_3F2F();
    sub_3EF4();
    sub_3F21();
}

void sub_40C4() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x40C4
    // Compare $1 with $2
    if (a == b) {  // je 0x4102
        // Block 0x4102
        mov word ptr cs:[0x24b8], 0;
        mov word ptr cs:[0x24ba], 0;
        mov word ptr cs:[0x24bc], 0;
    } else {
        // Block 0x40CB
        $1 = $2;
        $1 = $2;
        cmp word ptr [2], 0;
        if (a == b) {  // je 0x40df
            // Block 0x40DF
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0x40fd
                // Block 0x40FD
                mov dx, word ptr cs:[0x24b8];
            } else {
                // Block 0x40E8
                $1 = $2;
                mov word ptr cs:[0x24ba], ax;
                push($1);
                $1 = 0;
                push($1);
                call 0x4198;
                // Block 0x40F6
                $1 = $2;
                jmp 0x4120;
                // Block 0x4120
                call 0x4560;
                // Block 0x4123
                $1 += $2;
                return;  // ret 
            }
        } else {
            // Block 0x40D8
            mov word ptr cs:[0x24ba], ds;
            jmp 0x4117;
            // Block 0x4117
            $1 = $2;
            push($1);
            $1 = 0;
            push ax;
        }
    }

    // Function calls:
    sub_4198();
    sub_4560();
}

void sub_4127() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x4127
    $1 = $2;
    push($1);
    $1 = $2;
    mov word ptr [2], 0;
    *($1) = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x416d
        // Block 0x416D
        call 0x41c1;
        // Block 0x4170
        $1 = pop();
        $1 = $2;
        $1 += $2;
        $1 = $2;
        cmp word ptr [2], 0;
        if (a == b) {  // je 0x4182
            // Block 0x4182
            $1 = $2;
            add word ptr es:[0], ax;
            $1 = $2;
            $1 = $2;
            $1 += $2;
            $1 = $2;
            mov word ptr es:[2], ax;
        } else {
            // Block 0x4181
            return;  // ret 
        }
    } else {
        // Block 0x413F
        cmp word ptr es:[2], 0;
        if (a != b) {  // jne 0x416d
            // Block 0x416D
            call 0x41c1;
            // Block 0x4170
            $1 = pop();
            $1 = $2;
            $1 += $2;
            $1 = $2;
            cmp word ptr [2], 0;
            if (a == b) {  // je 0x4182
                // Block 0x4182
                $1 = $2;
                add word ptr es:[0], ax;
                $1 = $2;
                $1 = $2;
                $1 += $2;
                $1 = $2;
                mov word ptr es:[2], ax;
            } else {
                // Block 0x4181
                return;  // ret 
            }
        } else {
            // Block 0x4147
            $1 = $2;
            $1 = pop();
            push($1);
            add word ptr es:[0], ax;
            $1 = $2;
            $1 += $2;
            $1 = $2;
            cmp word ptr es:[2], 0;
            if (a != b) {  // jne 0x4166
                // Block 0x4166
                mov word ptr es:[2], cx;
                jmp 0x4170;
                // Block 0x4170
                $1 = pop();
                $1 = $2;
                $1 += $2;
                $1 = $2;
                cmp word ptr [2], 0;
                if (a == b) {  // je 0x4182
                    // Block 0x4182
                    $1 = $2;
                    add word ptr es:[0], ax;
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    mov word ptr es:[2], ax;
                } else {
                    // Block 0x4181
                    return;  // ret 
                }
            } else {
                // Block 0x415F
                mov word ptr es:[8], cx;
                jmp 0x4170;
                // Block 0x4170
                $1 = pop();
                $1 = $2;
                $1 += $2;
                $1 = $2;
                cmp word ptr [2], 0;
                if (a == b) {  // je 0x4182
                    // Block 0x4182
                    $1 = $2;
                    add word ptr es:[0], ax;
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    mov word ptr es:[2], ax;
                } else {
                    // Block 0x4181
                    return;  // ret 
                }
            }
        }
    }

    // Function calls:
    sub_41C1();
}

void sub_4198() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4198
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x41b9
        // Block 0x41B9
        mov word ptr cs:[0x24bc], 0;
        return;  // ret 
    } else {
        // Block 0x41A0
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        mov word ptr es:[4], ds;
        mov word ptr cs:[0x24bc], ds;
        $1 = $2;
        return;  // ret 
    }
}

void sub_41C1() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x41C1
    $1 = $2;
    or ax, ax;
    if (a == b) {  // je 0x41ea
        // Block 0x41EA
        mov word ptr cs:[0x24bc], ds;
        *($1) = $2;
        *($1) = $2;
        return;  // ret 
    } else {
        // Block 0x41C9
        $1 = $2;
        pushf ;
        cli ;
        $1 = $2;
        $1 = $2;
        mov word ptr ss:[6], ds;
        *($1) = $2;
        $1 = $2;
        popf ;
        mov word ptr es:[4], ds;
        *($1) = $2;
        return;  // ret 
    }
}

void sub_41F8() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x41F8
    push($1);
    $1 = $2;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    $1 = $2;
    or dx, dx;
    if (a == b) {  // je 0x4218
        // Block 0x4218
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4209
        // Compare $1 with $2
        if (a != b) {  // jne 0x4215
            // Block 0x4215
            call 0x4127;
            // Block 0x4218
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x4210
            call 0x40c4;
            // Block 0x4213
            jmp 0x4218;
            // Block 0x4218
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        }
    }

    // Function calls:
    sub_40C4();
    sub_4127();
}

void sub_4221() {
    // Variable declarations
    int var_0;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x4221
    push($1);
    $1 = $2;
    $1 = 0;
    push($1);
    push($1);
    call 0x459f;
    // Block 0x422E
    $1 += $2;
    and ax, 0xf;
    if (a == b) {  // je 0x424a
        // Block 0x424A
        $1 = pop();
        push($1);
        $1 = 0;
        $1 = $2;
        $1 = $2;
        shr bx, cl;
        shl ax, cl;
        $1 = $2;
        push($1);
        push($1);
        call 0x459f;
        // Block 0x4260
        $1 += $2;
        $1 = pop();
        // Compare $1 with $2
        if (a == b) {  // je 0x4281
            // Block 0x4281
            $1 = 0;
            cdq ;
            return;  // ret 
        } else {
            // Block 0x4269
            mov word ptr cs:[0x24b8], dx;
            mov word ptr cs:[0x24ba], dx;
            $1 = $2;
            *($1) = $2;
            *($1) = $2;
            $1 = $2;
            return;  // ret 
        }
    } else {
        // Block 0x4236
        $1 = $2;
        $1 -= $2;
        $1 = 0;
        $1 = $2;
        push($1);
        push($1);
        call 0x459f;
        // Block 0x4247
        add sp, 4;
    }

    // Function calls:
    sub_459F();
    sub_459F();
    sub_459F();
}

void sub_4285() {
    // Variable declarations
    int var_0;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x4285
    push($1);
    $1 = 0;
    $1 = $2;
    $1 = $2;
    shr bx, cl;
    shl ax, cl;
    $1 = $2;
    push($1);
    push($1);
    call 0x459f;
    // Block 0x429A
    $1 += $2;
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0x42db
        // Block 0x42DB
        $1 = 0;
        cdq ;
        return;  // ret 
    } else {
        // Block 0x42A3
        and ax, 0xf;
        if (a != b) {  // jne 0x42c0
            // Block 0x42C0
            push($1);
            push($1);
            neg ax;
            $1 += $2;
            $1 = 0;
            push($1);
            push($1);
            call 0x459f;
            // Block 0x42CE
            $1 += $2;
            $1 = pop();
            $1 = pop();
            // Compare $1 with $2
            if (a == b) {  // je 0x42db
                // Block 0x42DB
                $1 = 0;
                cdq ;
                return;  // ret 
            } else {
                // Block 0x42D8
                $1++;
                jmp 0x42a8;
                // Block 0x42A8
                $1 = $2;
                mov word ptr cs:[0x24ba], dx;
                $1 = $2;
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                return;  // ret 
            }
        } else {
            // Block 0x42A8
            $1 = $2;
            mov word ptr cs:[0x24ba], dx;
            $1 = $2;
            *($1) = $2;
            *($1) = $2;
            $1 = $2;
            return;  // ret 
        }
    }

    // Function calls:
    sub_459F();
    sub_459F();
}

void sub_42DF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x42DF
    $1 = $2;
    sub word ptr [0], ax;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    return;  // ret 
}

void sub_4302() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x4302
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = $2;
    jmp 0x4315;
    // Block 0x4315
}

void sub_430C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x430C
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or cx, dx;
    push($1);
    push($1);
    mov word ptr cs:[0x24be], ds;
    if (a == b) {  // je 0x4380
        // Block 0x4380
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4322
        $1 += $2;
        adc dx, 0;
        if (a < b (unsigned)) {  // jb 0x436b
            // Block 0x436B
            $1 = 0;
            cdq ;
            jmp 0x4380;
            // Block 0x4380
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x432A
            test dx, 0xfff0;
            if (a != b) {  // jne 0x436b
                // Block 0x436B
                $1 = 0;
                cdq ;
                jmp 0x4380;
                // Block 0x4380
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0x4330
                $1 = $2;
                shr ax, cl;
                shl dx, cl;
                or ah, dl;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0x4361
                    // Block 0x4361
                    call 0x4221;
                    // Block 0x4364
                    jmp 0x4380;
                    // Block 0x4380
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x4341
                    $1 = $2;
                    or dx, dx;
                    if (a == b) {  // je 0x435c
                        // Block 0x435C
                        call 0x4285;
                        // Block 0x435F
                        jmp 0x4380;
                        // Block 0x4380
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x434A
                        mov bx, dx;
                    }
                }
            }
        }
    }

    // Function calls:
    sub_4285();
    sub_4221();
    sub_42DF();
    sub_4198();
}

void sub_4389() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x4389
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    call 0x430c;
    // Block 0x439A
    $1 += $2;
    or dx, dx;
    if (a != b) {  // jne 0x43a3
        // Block 0x43A3
        $1 = pop();
        $1 = $2;
        push($1);
        push($1);
        push($1);
        $1 = $2;
        cld ;
        $1--;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        rep movsw word ptr es:[di], word ptr [si];
        or dx, dx;
        if (a == b) {  // je 0x43f4
            // Block 0x43F4
            $1 = $2;
            push($1);
            call 0x41f8;
            // Block 0x43FD
            $1 += $2;
            $1 = pop();
            $1 = $2;
            return;  // ret 
        } else {
            // Block 0x43BD
            $1 = $2;
            $1++;
            $1 = $2;
            $1 = $2;
            $1++;
            mov ds, ax;
        }
    } else {
        // Block 0x43A1
        $1 = pop();
        return;  // ret 
    }

    // Function calls:
    sub_430C();
    sub_41F8();
}

void sub_4405() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x4405
    // Compare $1 with $2
    if (a == b) {  // je 0x4451
        // Block 0x4451
        push($1);
        $1 = $2;
        mov word ptr es:[0], ax;
        $1 += $2;
        push($1);
        $1 = 0;
        push($1);
        call 0x4560;
        // Block 0x4461
        $1 += $2;
        $1 = pop();
        $1 = $2;
        return;  // ret 
    } else {
        // Block 0x440C
        $1 = $2;
        $1 += $2;
        $1 = $2;
        $1 = $2;
        $1 -= $2;
        mov word ptr es:[0], si;
        mov word ptr es:[2], bx;
        push($1);
        push($1);
        $1 = $2;
        mov word ptr es:[0], ax;
        $1 = $2;
        $1 += $2;
        $1 = $2;
        cmp word ptr es:[2], 0;
        if (a == b) {  // je 0x443d
            // Block 0x443D
            mov word ptr es:[8], di;
        } else {
            // Block 0x4436
            mov word ptr es:[2], di;
            jmp 0x4442;
            // Block 0x4442
            $1 = $2;
            push($1);
            call 0x41f8;
            // Block 0x4448
            $1 += $2;
            $1 = $2;
            $1 = $2;
            return;  // ret 
        }
    }

    // Function calls:
    sub_41F8();
    sub_4560();
    sub_4405();
    sub_4389();
    sub_430C();
    sub_41F8();
}

void sub_44EA() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x44EA
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1++;
    $1 -= $2;
    $1 += $2;
    $1 = $2;
    shr si, cl;
    // Compare $1 with $2
    if (a != b) {  // jne 0x4515
        // Block 0x4515
        $1 = $2;
        shl si, cl;
        $1 = $2;
        $1 = $2;
        $1 += $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x452d
            // Block 0x452D
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x4d1c;
            // Block 0x4537
            $1 = pop();
            $1 = pop();
            $1 = $2;
            cmp dx, -1;
            if (a != b) {  // jne 0x454b
                // Block 0x454B
                $1 = $2;
                $1 += $2;
                *($1) = $2;
                mov word ptr [0x8f], 0;
                xor ax, ax;
            } else {
                // Block 0x4540
                $1 = $2;
                $1 = $2;
                shr ax, cl;
                *($1) = $2;
                jmp 0x4503;
                // Block 0x4503
                $1 = $2;
                $1 = $2;
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                jmp 0x455b;
                // Block 0x455B
                $1 = pop();
                $1 = pop();
                return;  // ret 4
            }
        } else {
            // Block 0x4527
            $1 = $2;
            sub si, word ptr [0x7b];
        }
    } else {
        // Block 0x4503
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        *($1) = $2;
        $1 = $2;
        jmp 0x455b;
        // Block 0x455B
        $1 = pop();
        $1 = pop();
        return;  // ret 4
    }

    // Function calls:
    sub_4D1C();
}

void sub_4560() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x4560
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    call 0x30f7;
    // Block 0x4574
    if (a < b (unsigned)) {  // jb 0x4596
        // Block 0x4596
        $1 = $2;
        jmp 0x459d;
        // Block 0x459D
        $1 = pop();
        return;  // ret 
    } else {
        // Block 0x4576
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        call 0x30f7;
        // Block 0x4587
        if (a > b (unsigned)) {  // ja 0x4596
            // Block 0x4596
            $1 = $2;
            jmp 0x459d;
            // Block 0x459D
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x4589
            push($1);
            push($1);
            call 0x44ea;
            // Block 0x4592
            or ax, ax;
            if (a != b) {  // jne 0x459b
                // Block 0x459B
                xor ax, ax;
            } else {
                // Block 0x4596
                $1 = $2;
                jmp 0x459d;
                // Block 0x459D
                $1 = pop();
                return;  // ret 
            }
        }
    }

    // Function calls:
    sub_30F7();
    sub_30F7();
    sub_44EA();
}

void sub_459F() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x459F
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = 0;
    $1 = $2;
    call 0x2c9b;
    // Block 0x45AF
    $1 += $2;
    adc dx, 0;
    $1 += $2;
    adc dx, word ptr [bp + 6];
    // Compare $1 with $2
    if (a < b) {  // jl 0x45d0
        // Block 0x45D0
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        call 0x2cbc;
        // Block 0x45E0
        *($1) = $2;
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        call 0x30f7;
        // Block 0x45F1
        if (a < b (unsigned)) {  // jb 0x45c8
            // Block 0x45C8
            $1 = $2;
            $1 = $2;
            jmp 0x4626;
            // Block 0x4626
            $1 = $2;
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x45F3
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            call 0x30f7;
            // Block 0x4604
            if (a > b (unsigned)) {  // ja 0x45c8
                // Block 0x45C8
                $1 = $2;
                $1 = $2;
                jmp 0x4626;
                // Block 0x4626
                $1 = $2;
                $1 = pop();
                return;  // ret 
            } else {
                // Block 0x4606
                $1 = $2;
                $1 = $2;
                *($1) = $2;
                *($1) = $2;
                push($1);
                push($1);
                call 0x44ea;
                // Block 0x461C
                or ax, ax;
                if (a == b) {  // je 0x45c8
                    // Block 0x45C8
                    $1 = $2;
                    $1 = $2;
                    jmp 0x4626;
                    // Block 0x4626
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x4620
                    $1 = $2;
                    mov ax, word ptr [bp - 8];
                }
            }
        }
    } else {
        // Block 0x45C1
        if (a > b) {  // jg 0x45c8
            // Block 0x45C8
            $1 = $2;
            $1 = $2;
            jmp 0x4626;
            // Block 0x4626
            $1 = $2;
            $1 = pop();
            return;  // ret 
        } else {
            // Block 0x45C3
            // Compare $1 with $2
            if (a <= b (unsigned)) {  // jbe 0x45d0
                // Block 0x45D0
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                call 0x2cbc;
                // Block 0x45E0
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                $1 = $2;
                call 0x30f7;
                // Block 0x45F1
                if (a < b (unsigned)) {  // jb 0x45c8
                    // Block 0x45C8
                    $1 = $2;
                    $1 = $2;
                    jmp 0x4626;
                    // Block 0x4626
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 
                } else {
                    // Block 0x45F3
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    call 0x30f7;
                    // Block 0x4604
                    if (a > b (unsigned)) {  // ja 0x45c8
                        // Block 0x45C8
                        $1 = $2;
                        $1 = $2;
                        jmp 0x4626;
                        // Block 0x4626
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 
                    } else {
                        // Block 0x4606
                        $1 = $2;
                        $1 = $2;
                        *($1) = $2;
                        *($1) = $2;
                        push($1);
                        push($1);
                        call 0x44ea;
                        // Block 0x461C
                        or ax, ax;
                        if (a == b) {  // je 0x45c8
                            // Block 0x45C8
                            $1 = $2;
                            $1 = $2;
                            jmp 0x4626;
                            // Block 0x4626
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 
                        } else {
                            // Block 0x4620
                            $1 = $2;
                            mov ax, word ptr [bp - 8];
                        }
                    }
                }
            } else {
                // Block 0x45C8
                $1 = $2;
                $1 = $2;
                jmp 0x4626;
                // Block 0x4626
                $1 = $2;
                $1 = pop();
                return;  // ret 
            }
        }
    }

    // Function calls:
    sub_2C9B();
    sub_2CBC();
    sub_30F7();
    sub_30F7();
    sub_44EA();
    sub_2D1C();
}

void sub_467A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x467A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    call 0x4a0e;
    // Block 0x4693
    or ax, ax;
    if (a != b) {  // jne 0x469b
        // Block 0x469B
        $1 = $2;
        $1 -= $2;
        $1++;
        *($1) = $2;
        jmp 0x46c2;
        // Block 0x46C2
        // Compare $1 with $2
        if (a <= b) {  // jle 0x46a6
            // Block 0x46A6
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x3df8;
            // Block 0x46B1
            push($1);
            push($1);
            push($1);
            call 0x49d2;
            // Block 0x46B9
            $1 = $2;
            shl ax, 1;
            add word ptr [bp + 0xe], ax;
            inc si;
        } else {
            // Block 0x46C7
            mov ax, 1;
        }
    } else {
        // Block 0x4697
        $1 = 0;
        jmp 0x46ca;
        // Block 0x46CA
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4A0E();
    sub_3DF8();
    sub_49D2();
}

void sub_46D0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x46D0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    call 0x4a0e;
    // Block 0x46E9
    or ax, ax;
    if (a != b) {  // jne 0x46f1
        // Block 0x46F1
        $1 = $2;
        $1 -= $2;
        $1++;
        *($1) = $2;
        jmp 0x4718;
        // Block 0x4718
        // Compare $1 with $2
        if (a <= b) {  // jle 0x46fc
            // Block 0x46FC
            push($1);
            push($1);
            call 0x3df8;
            // Block 0x4701
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x49d2;
            // Block 0x470F
            $1 = $2;
            shl ax, 1;
            add word ptr [bp + 0xe], ax;
            inc si;
        } else {
            // Block 0x471D
            mov ax, 1;
        }
    } else {
        // Block 0x46ED
        $1 = 0;
        jmp 0x4720;
        // Block 0x4720
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4A0E();
    sub_3DF8();
    sub_49D2();
    sub_3808();
    sub_4754();
}

void sub_4754() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4754
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 0xe];
    push($1);
    push($1);
    lds si, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    push($1);
    INT_21();  // int 0x21
    $1 = pop();
    pushf ;
    pushf ;
    push($1);
    push($1);
    push($1);
    lds si, ptr [bp + 0xe];
    $1 = pop();
    $1 = pop();
    lds si, ptr [bp + 0xa];
    $1 = pop();
    $1 = pop();
    $1 = pop();
    and word ptr [si + 0xc], 1;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    *($1) = $2;
    $1 = pop();
    if (a == b) {  // je 0x47b0
        // Block 0x47B0
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x47AA
        push($1);
        push($1);
        call 0x2d44;
        // Block 0x47AF
        pop ax;
    }

    // Function calls:
    sub_2D44();
}

void sub_47B4() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x47B4
    push($1);
    $1 = $2;
    push($1);
    lds dx, ptr [bp + 0xa];
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    INT_21_AH44();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x47d7
        // Block 0x47D7
        push($1);
        call 0x2d44;
        // Block 0x47DB
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x47CB
        cmp word ptr [bp + 8], 0;
        if (a != b) {  // jne 0x47d5
            // Block 0x47D5
            jmp 0x47db;
            // Block 0x47DB
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x47D1
            $1 = $2;
            jmp 0x47db;
            // Block 0x47DB
            $1 = pop();
            return;  // retf 
        }
    }

    // Function calls:
    sub_2D44();
}

void sub_47EF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x47EF
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    call 0x4a0e;
    // Block 0x4808
    or ax, ax;
    if (a == b) {  // je 0x482f
        // Block 0x482F
        $1 = 0;
        jmp 0x4886;
        // Block 0x4886
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x480C
        push($1);
        push($1);
        $1 = $2;
        $1 -= $2;
        $1 = $2;
        $1 += $2;
        push($1);
        $1 = $2;
        $1 -= $2;
        $1 = $2;
        $1 += $2;
        push($1);
        call 0x4a0e;
        // Block 0x482B
        or ax, ax;
        if (a != b) {  // jne 0x4833
            // Block 0x4833
            $1 = $2;
            *($1) = $2;
            mov word ptr [bp - 4], 1;
            // Compare $1 with $2
            if (a >= b) {  // jge 0x484c
                // Block 0x484C
                $1 = $2;
                jmp 0x4879;
                // Block 0x4879
                $1 = $2;
                $1 += $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x4850
                    // Block 0x4850
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    call 0x3df8;
                    // Block 0x4860
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    call 0x3df8;
                    // Block 0x4869
                    push($1);
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    $1++;
                    push($1);
                    call 0x49d2;
                    // Block 0x4876
                    add di, word ptr [bp - 4];
                } else {
                    // Block 0x4883
                    mov ax, 1;
                }
            } else {
                // Block 0x4842
                $1 = $2;
                *($1) = $2;
                mov word ptr [bp - 4], 0xffff;
            }
        } else {
            // Block 0x482F
            $1 = 0;
            jmp 0x4886;
            // Block 0x4886
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    }

    // Function calls:
    sub_4A0E();
    sub_4A0E();
    sub_3DF8();
    sub_3DF8();
    sub_49D2();
}

void sub_488C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x488C
    jmp word ptr [0x76b0];
}

void sub_4890() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x4890
    jmp word ptr [0x76b2];
}

void sub_4894() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x4894
    jmp word ptr [0x76b4];
}

void sub_4898() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x4898
    jmp word ptr [0x76b6];
}

void sub_489C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x489C
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    shr ax, 1;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = 0;
    $1 = pop();
    div bx;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    imul dx;
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    return;  // ret 4
}

void sub_48D4() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x48D4
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1 = $2;
    les bx, ptr [bp + 4];
    // Compare $1 with $2
    if (a == b) {  // je 0x48f2
        // Block 0x48F2
        $1++;
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x48fe
            // Block 0x48FE
            les bx, ptr [bp + 8];
            mov word ptr es:[bx], dx;
            $1 = pop();
            return;  // ret 8
        } else {
            // Block 0x48FA
            $1++;
            mov dl, 0;
        }
    } else {
        // Block 0x48E5
        $1 = $2;
        $1 = $2;
        call 0x3f2f;
        // Block 0x48EC
        les bx, ptr [bp + 4];
        mov word ptr es:[bx], dx;
    }

    // Function calls:
    sub_3F2F();
}

void sub_4908() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 7 if statements

    // Block 0x4908
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    call 0x4d38;
    // Block 0x4916
    *($1) = $2;
    *($1) = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x492a
        // Block 0x492A
        xor ax, ax;
    } else {
        // Block 0x4925
        $1 = $2;
        jmp 0x492c;
        // Block 0x492C
        *($1) = $2;
        or ax, ax;
        if (a == b) {  // je 0x493f
            // Block 0x493F
            $1 = $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x494d
                // Block 0x494D
                xor ax, ax;
            } else {
                // Block 0x4948
                $1 = $2;
                jmp 0x494f;
                // Block 0x494F
                *($1) = $2;
                or ax, ax;
                if (a == b) {  // je 0x49b9
                    // Block 0x49B9
                    $1 = $2;
                    $1--;
                    or ax, ax;
                    if (a != b) {  // jne 0x4964
                        // Block 0x4964
                        cmp word ptr [bp - 0xc], 0;
                        if (a == b) {  // je 0x4982
                            // Block 0x4982
                            les bx, ptr [bp + 6];
                            $1 = $2;
                            add word ptr [bp + 6], 2;
                        } else {
                            // Block 0x496A
                            push($1);
                            lea ax, [bp - 4];
                            push($1);
                            push($1);
                            lea ax, [bp - 6];
                            push($1);
                            call 0x48d4;
                            // Block 0x4977
                            $1 = $2;
                            $1 = $2;
                            call 0x3f2f;
                            // Block 0x497E
                            $1 = $2;
                            jmp 0x498c;
                            // Block 0x498C
                            cmp word ptr [bp - 0xa], 0;
                            if (a == b) {  // je 0x49af
                                // Block 0x49AF
                                les bx, ptr [bp + 0xa];
                                mov word ptr es:[bx], si;
                                add word ptr [bp + 0xa], 2;
                            } else {
                                // Block 0x4992
                                push($1);
                                lea ax, [bp - 2];
                                push($1);
                                push($1);
                                lea ax, [bp - 6];
                                push($1);
                                call 0x48d4;
                                // Block 0x499F
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                call 0x3f2f;
                                // Block 0x49AD
                                jmp 0x49b9;
                            }
                        }
                    } else {
                        // Block 0x49C0
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        call 0x3f2f;
                        // Block 0x49CA
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 0xa
                    }
                } else {
                    // Block 0x4956
                    push($1);
                    push($1);
                    call 0x489c;
                    // Block 0x495F
                    *($1) = $2;
                    jmp 0x49b9;
                    // Block 0x49B9
                    $1 = $2;
                    $1--;
                    or ax, ax;
                    if (a != b) {  // jne 0x4964
                        // Block 0x4964
                        cmp word ptr [bp - 0xc], 0;
                        if (a == b) {  // je 0x4982
                            // Block 0x4982
                            les bx, ptr [bp + 6];
                            $1 = $2;
                            add word ptr [bp + 6], 2;
                        } else {
                            // Block 0x496A
                            push($1);
                            lea ax, [bp - 4];
                            push($1);
                            push($1);
                            lea ax, [bp - 6];
                            push($1);
                            call 0x48d4;
                            // Block 0x4977
                            $1 = $2;
                            $1 = $2;
                            call 0x3f2f;
                            // Block 0x497E
                            $1 = $2;
                            jmp 0x498c;
                            // Block 0x498C
                            cmp word ptr [bp - 0xa], 0;
                            if (a == b) {  // je 0x49af
                                // Block 0x49AF
                                les bx, ptr [bp + 0xa];
                                mov word ptr es:[bx], si;
                                add word ptr [bp + 0xa], 2;
                            } else {
                                // Block 0x4992
                                push($1);
                                lea ax, [bp - 2];
                                push($1);
                                push($1);
                                lea ax, [bp - 6];
                                push($1);
                                call 0x48d4;
                                // Block 0x499F
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                call 0x3f2f;
                                // Block 0x49AD
                                jmp 0x49b9;
                            }
                        }
                    } else {
                        // Block 0x49C0
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        call 0x3f2f;
                        // Block 0x49CA
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 0xa
                    }
                }
            }
        } else {
            // Block 0x4933
            push($1);
            push($1);
            call 0x489c;
            // Block 0x493C
            mov word ptr [bp - 2], ax;
        }
    }

    // Function calls:
    sub_4D38();
    sub_489C();
    sub_489C();
    sub_48D4();
    sub_3F2F();
    sub_48D4();
    sub_3F2F();
    sub_3F2F();
}

void sub_49D2() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x49D2
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (a != b) {  // jne 0x49fa
        // Block 0x49FA
        push($1);
        push($1);
        push($1);
        push($1);
        push($1);
        call 0x4908;
        // Block 0x4A0A
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x49E1
        cmp word ptr [0x765b], 0;
        if (a == b) {  // je 0x49fa
            // Block 0x49FA
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x4908;
            // Block 0x4A0A
            $1 = pop();
            return;  // ret 0xa
        } else {
            // Block 0x49E8
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            call 0x3e1d;
            // Block 0x49F8
            jmp 0x4a0a;
            // Block 0x4A0A
            $1 = pop();
            return;  // ret 0xa
        }
    }

    // Function calls:
    sub_3E1D();
    sub_4908();
}

void sub_4A0E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x4A0E
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a > b (unsigned)) {  // ja 0x4a5b
        // Block 0x4A5B
        xor ax, ax;
    } else {
        // Block 0x4A2E
        // Compare $1 with $2
        if (a > b (unsigned)) {  // ja 0x4a5b
            // Block 0x4A5B
            xor ax, ax;
        } else {
            // Block 0x4A32
            // Compare $1 with $2
            if (a > b) {  // jg 0x4a5b
                // Block 0x4A5B
                xor ax, ax;
            } else {
                // Block 0x4A36
                // Compare $1 with $2
                if (a > b (unsigned)) {  // ja 0x4a5b
                    // Block 0x4A5B
                    xor ax, ax;
                } else {
                    // Block 0x4A3A
                    cmp word ptr [bp + 4], dx;
                    if (a > b (unsigned)) {  // ja 0x4a5b
                        // Block 0x4A5B
                        xor ax, ax;
                    } else {
                        // Block 0x4A3F
                        // Compare $1 with $2
                        if (a > b) {  // jg 0x4a5b
                            // Block 0x4A5B
                            xor ax, ax;
                        } else {
                            // Block 0x4A44
                            or bx, bx;
                            if (a <= b) {  // jle 0x4a5b
                                // Block 0x4A5B
                                xor ax, ax;
                            } else {
                                // Block 0x4A48
                                or di, di;
                                if (a <= b) {  // jle 0x4a5b
                                    // Block 0x4A5B
                                    xor ax, ax;
                                } else {
                                    // Block 0x4A4C
                                    or si, si;
                                    if (a <= b) {  // jle 0x4a5b
                                        // Block 0x4A5B
                                        xor ax, ax;
                                    } else {
                                        // Block 0x4A50
                                        cmp word ptr [bp + 4], 0;
                                        if (a <= b) {  // jle 0x4a5b
                                            // Block 0x4A5B
                                            xor ax, ax;
                                        } else {
                                            // Block 0x4A56
                                            $1 = $2;
                                            jmp 0x4a5d;
                                            // Block 0x4A5D
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // ret 8
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void sub_4A63() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4A63
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    jmp 0x4a7c;
    // Block 0x4A7C
    // Compare $1 with $2
    if (a <= b) {  // jle 0x4a71
        // Block 0x4A71
        les bx, ptr [bp + 8];
        mov word ptr es:[bx], cx;
        add word ptr [bp + 8], 2;
        inc dx;
    } else {
        // Block 0x4A81
        $1 = pop();
        return;  // ret 8
    }
}

void sub_4A85() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x4A85
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    or ax, ax;
    if (a == b) {  // je 0x4a98
        // Block 0x4A98
        cmp word ptr [0x765b], 0;
        if (a != b) {  // jne 0x4aa2
            // Block 0x4AA2
            cmp byte ptr [bp + 4], 1;
            if (a == b) {  // je 0x4aab
                // Block 0x4AAB
                $1++;
                $1++;
                $1++;
                $1++;
                cmp byte ptr [bp + 0xe], 6;
                if (a == b) {  // je 0x4ac0
                    // Block 0x4AC0
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    $1++;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x47ef;
                    // Block 0x4AEA
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x467a;
                    // Block 0x4B10
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    call 0x4a63;
                    // Block 0x4B28
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    mov al, byte ptr [bp + 6];
                } else {
                    // Block 0x4ABD
                    jmp 0x4b51;
                    // Block 0x4B51
                    $1 = $2;
                    $1 = $2;
                    $1++;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    $1--;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x47ef;
                    // Block 0x4B7C
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x467a;
                    // Block 0x4BA2
                    $1 += $2;
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    call 0x4a63;
                    // Block 0x4BBA
                    push($1);
                    lea ax, [bp - 0xa0];
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    jmp 0x4b3d;
                    // Block 0x4B3D
                    $1 = $2;
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    push($1);
                    nop ;
                    push($1);
                    call 0x46d0;
                    // Block 0x4B4B
                    $1 += $2;
                    jmp 0x4beb;
                    // Block 0x4BEB
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 0xc
                }
            } else {
                // Block 0x4AA8
                jmp 0x4bd2;
                // Block 0x4BD2
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                call 0x3f2f;
                // Block 0x4BEB
                $1 = $2;
                $1 = pop();
                return;  // ret 0xc
            }
        } else {
            // Block 0x4A9F
            jmp 0x4bd2;
            // Block 0x4BD2
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            call 0x3f2f;
            // Block 0x4BEB
            $1 = $2;
            $1 = pop();
            return;  // ret 0xc
        }
    } else {
        // Block 0x4A95
        jmp 0x4bd2;
        // Block 0x4BD2
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        call 0x3f2f;
        // Block 0x4BEB
        $1 = $2;
        $1 = pop();
        return;  // ret 0xc
    }

    // Function calls:
    sub_47EF();
    sub_467A();
    sub_4A63();
    sub_46D0();
    sub_47EF();
    sub_467A();
    sub_4A63();
    sub_3F2F();
    sub_4C86();
    sub_4C86();
}

void sub_4C86() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x4C86
    or ax, ax;
    if (a == b) {  // je 0x4c91
        // Block 0x4C91
        xchg al, ah;
        $1 = 0;
        stc ;
        if (condition_jcxz) {  // jcxz 0x4cad
            // Block 0x4CAD
            return;  // ret 
        } else {
            // Block 0x4C98
            lodsb al, byte ptr [si];
            $1--;
            $1 -= $2;
            if (a == b) {  // je 0x4cad
                // Block 0x4CAD
                return;  // ret 
            } else {
                // Block 0x4C9E
                $1 += $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0x4cab
                    // Block 0x4CAB
                    or si, si;
                } else {
                    // Block 0x4CA4
                    cmp byte ptr [si], 0x22;
                    if (a != b) {  // jne 0x4cab
                        // Block 0x4CAB
                        or si, si;
                    } else {
                        // Block 0x4CA9
                        lodsb al, byte ptr [si];
                        dec cx;
                    }
                }
            }
        }
    } else {
        // Block 0x4C8A
        $1++;
        stosb byte ptr es:[di], al;
        or al, al;
        if (a != b) {  // jne 0x4c91
            // Block 0x4C91
            xchg al, ah;
            $1 = 0;
            stc ;
            if (condition_jcxz) {  // jcxz 0x4cad
                // Block 0x4CAD
                return;  // ret 
            } else {
                // Block 0x4C98
                lodsb al, byte ptr [si];
                $1--;
                $1 -= $2;
                if (a == b) {  // je 0x4cad
                    // Block 0x4CAD
                    return;  // ret 
                } else {
                    // Block 0x4C9E
                    $1 += $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x4cab
                        // Block 0x4CAB
                        or si, si;
                    } else {
                        // Block 0x4CA4
                        cmp byte ptr [si], 0x22;
                        if (a != b) {  // jne 0x4cab
                            // Block 0x4CAB
                            or si, si;
                        } else {
                            // Block 0x4CA9
                            lodsb al, byte ptr [si];
                            dec cx;
                        }
                    }
                }
            }
        } else {
            // Block 0x4C90
            inc bx;
        }
    }
}

void sub_4D1C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4D1C
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    DOS_ModifyMemoryAllocation();  // int 0x21
    if (a < b (unsigned)) {  // jb 0x4d30
        // Block 0x4D30
        push($1);
        push($1);
        call 0x2d44;
        // Block 0x4D35
        pop ax;
    } else {
        // Block 0x4D2B
        $1 = $2;
        jmp 0x4d36;
        // Block 0x4D36
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_4D38() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x4D38
    $1 = $2;
    $1 = $2;
    call 0x3f2f;
    // Block 0x4D3F
    $1 = $2;
    return;  // ret 

    // Function calls:
    sub_3F2F();
    sub_4D38();
    sub_4D38();
    sub_4E21();
}

void sub_4D9B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0x4D9B
    push($1);
    $1 = $2;
    push($1);
    push($1);
    push($1);
    push($1);
    les si, ptr [bp + 6];
    cld ;
    $1 -= $2;
    cdq ;
    $1 = $2;
    $1 = $2;
    mov di, 0x7233;

    // Function calls:
    sub_4D9B();
}

void sub_4E21() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4E21
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    INT_21_AH43();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x4e38
        // Block 0x4E38
        push($1);
        call 0x2d44;
        // Block 0x4E3C
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4E35
        xchg cx, ax;
        jmp 0x4e3c;
        // Block 0x4E3C
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_4E3E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4E3E
    push($1);
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x4e53
        // Block 0x4E53
        $1 = $2;
        shl bx, 1;
        mov word ptr [bx + 0x74d2], 0;
        push($1);
        nop ;
        push($1);
        call 0x4e66;
        // Block 0x4E63
        pop cx;
    } else {
        // Block 0x4E4A
        $1 = $2;
        push($1);
        call 0x2d44;
        // Block 0x4E51
        jmp 0x4e64;
        // Block 0x4E64
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
    sub_4E66();
}

void sub_4E66() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x4E66
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    DOS_CloseFile();  // int 0x21
    if (a < b (unsigned)) {  // jb 0x4e7e
        // Block 0x4E7E
        push($1);
        call 0x2d44;
        // Block 0x4E82
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x4E72
        shl bx, 1;
        mov word ptr [bx + 0x74d2], 0;
        $1 = 0;
        jmp 0x4e82;
        // Block 0x4E82
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_4E84() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x4E84
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x4e99
        // Block 0x4E99
        $1 = $2;
        shl bx, 1;
        test word ptr [bx + 0x74d2], 0x200;
        if (a == b) {  // je 0x4eab
            // Block 0x4EAB
            $1 = $2;
            $1 = $2;
            INT_21();  // int 0x21
            if (a < b (unsigned)) {  // jb 0x4ef3
                // Block 0x4EF3
                push ax;
            } else {
                // Block 0x4EB5
                test dl, 0x80;
                if (a != b) {  // jne 0x4eef
                    // Block 0x4EEF
                    $1 = 0;
                    jmp 0x4ef7;
                    // Block 0x4EF7
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x4EBA
                    $1 = $2;
                    $1 = 0;
                    $1 = $2;
                    INT_21();  // int 0x21
                    if (a < b (unsigned)) {  // jb 0x4ef3
                        // Block 0x4EF3
                        push ax;
                    } else {
                        // Block 0x4EC5
                        push($1);
                        push($1);
                        $1 = $2;
                        $1 = 0;
                        $1 = $2;
                        INT_21();  // int 0x21
                        *($1) = $2;
                        *($1) = $2;
                        $1 = pop();
                        $1 = pop();
                        if (a < b (unsigned)) {  // jb 0x4ef3
                            // Block 0x4EF3
                            push ax;
                        } else {
                            // Block 0x4EDA
                            $1 = $2;
                            INT_21();  // int 0x21
                            if (a < b (unsigned)) {  // jb 0x4ef3
                                // Block 0x4EF3
                                push ax;
                            } else {
                                // Block 0x4EE1
                                // Compare $1 with $2
                                if (a < b (unsigned)) {  // jb 0x4eef
                                    // Block 0x4EEF
                                    $1 = 0;
                                    jmp 0x4ef7;
                                    // Block 0x4EF7
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0x4EE6
                                    if (a > b (unsigned)) {  // ja 0x4eed
                                        // Block 0x4EED
                                        jmp 0x4ea6;
                                        // Block 0x4EA6
                                        $1 = $2;
                                        jmp 0x4ef7;
                                        // Block 0x4EF7
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0x4EE8
                                        // Compare $1 with $2
                                        if (a < b (unsigned)) {  // jb 0x4eef
                                            // Block 0x4EEF
                                            $1 = 0;
                                            jmp 0x4ef7;
                                            // Block 0x4EF7
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0x4EED
                                            jmp 0x4ea6;
                                            // Block 0x4EA6
                                            $1 = $2;
                                            jmp 0x4ef7;
                                            // Block 0x4EF7
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            // Block 0x4EA6
            $1 = $2;
            jmp 0x4ef7;
            // Block 0x4EF7
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x4E93
        $1 = $2;
        push($1);
        jmp 0x4ef4;
        // Block 0x4EF4
        call 0x2d44;
        // Block 0x4EF7
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
}

void sub_4EFB() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x4EFB
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (a != b) {  // jne 0x4f0d
        // Block 0x4F0D
        les bx, ptr [bp + 6];
        $1 = $2;
        // Compare $1 with $2
        if (a == b) {  // je 0x4f1c
            // Block 0x4F1C
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx + 6], 0;
            if (a == b) {  // je 0x4f55
                // Block 0x4F55
                les bx, ptr [bp + 6];
                cmp byte ptr es:[bx + 4], 0;
                if (a < b) {  // jl 0x4f6d
                    // Block 0x4F6D
                    les bx, ptr [bp + 6];
                    mov word ptr es:[bx + 2], 0;
                    mov word ptr es:[bx + 6], 0;
                    mov word ptr es:[bx], 0;
                    mov byte ptr es:[bx + 4], 0xff;
                    cmp word ptr es:[bx + 0x10], 0;
                    if (a == b) {  // je 0x4fae
                        // Block 0x4FAE
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x4F8D
                        $1 = 0;
                        $1 = 0;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        call 0x302a;
                        // Block 0x4F9C
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x3905;
                        // Block 0x4FA3
                        $1 = pop();
                        $1 = pop();
                        les bx, ptr [bp + 6];
                        mov word ptr es:[bx + 0x10], 0;
                    }
                } else {
                    // Block 0x4F5F
                    $1 = $2;
                    cwde ;
                    push($1);
                    nop ;
                    push($1);
                    call 0x4e3e;
                    // Block 0x4F6A
                    $1 = pop();
                    mov si, ax;
                }
            } else {
                // Block 0x4F26
                cmp word ptr es:[bx], 0;
                if (a >= b) {  // jge 0x4f3b
                    // Block 0x4F3B
                    les bx, ptr [bp + 6];
                    test word ptr es:[bx + 2], 4;
                    if (a == b) {  // je 0x4f55
                        // Block 0x4F55
                        les bx, ptr [bp + 6];
                        cmp byte ptr es:[bx + 4], 0;
                        if (a < b) {  // jl 0x4f6d
                            // Block 0x4F6D
                            les bx, ptr [bp + 6];
                            mov word ptr es:[bx + 2], 0;
                            mov word ptr es:[bx + 6], 0;
                            mov word ptr es:[bx], 0;
                            mov byte ptr es:[bx + 4], 0xff;
                            cmp word ptr es:[bx + 0x10], 0;
                            if (a == b) {  // je 0x4fae
                                // Block 0x4FAE
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0x4F8D
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                call 0x302a;
                                // Block 0x4F9C
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x3905;
                                // Block 0x4FA3
                                $1 = pop();
                                $1 = pop();
                                les bx, ptr [bp + 6];
                                mov word ptr es:[bx + 0x10], 0;
                            }
                        } else {
                            // Block 0x4F5F
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x4e3e;
                            // Block 0x4F6A
                            $1 = pop();
                            mov si, ax;
                        }
                    } else {
                        // Block 0x4F46
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x41f8;
                        // Block 0x4F53
                        $1 = pop();
                        pop cx;
                    }
                } else {
                    // Block 0x4F2C
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x4fb3;
                    // Block 0x4F35
                    $1 = pop();
                    $1 = pop();
                    or ax, ax;
                    if (a != b) {  // jne 0x4fae
                        // Block 0x4FAE
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x4F3B
                        les bx, ptr [bp + 6];
                        test word ptr es:[bx + 2], 4;
                        if (a == b) {  // je 0x4f55
                            // Block 0x4F55
                            les bx, ptr [bp + 6];
                            cmp byte ptr es:[bx + 4], 0;
                            if (a < b) {  // jl 0x4f6d
                                // Block 0x4F6D
                                les bx, ptr [bp + 6];
                                mov word ptr es:[bx + 2], 0;
                                mov word ptr es:[bx + 6], 0;
                                mov word ptr es:[bx], 0;
                                mov byte ptr es:[bx + 4], 0xff;
                                cmp word ptr es:[bx + 0x10], 0;
                                if (a == b) {  // je 0x4fae
                                    // Block 0x4FAE
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0x4F8D
                                    $1 = 0;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    call 0x302a;
                                    // Block 0x4F9C
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x3905;
                                    // Block 0x4FA3
                                    $1 = pop();
                                    $1 = pop();
                                    les bx, ptr [bp + 6];
                                    mov word ptr es:[bx + 0x10], 0;
                                }
                            } else {
                                // Block 0x4F5F
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x4e3e;
                                // Block 0x4F6A
                                $1 = pop();
                                mov si, ax;
                            }
                        } else {
                            // Block 0x4F46
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x41f8;
                            // Block 0x4F53
                            $1 = pop();
                            pop cx;
                        }
                    }
                }
            }
        } else {
            // Block 0x4F19
            jmp 0x4fae;
            // Block 0x4FAE
            $1 = $2;
            $1 = pop();
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x4F0A
        jmp 0x4fae;
        // Block 0x4FAE
        $1 = $2;
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4FB3();
    sub_41F8();
    sub_4E3E();
    sub_302A();
    sub_3905();
}

void sub_4FB3() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x4FB3
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (a != b) {  // jne 0x4fc7
        // Block 0x4FC7
        les bx, ptr [bp + 6];
        $1 = $2;
        // Compare $1 with $2
        if (a == b) {  // je 0x4fd9
            // Block 0x4FD9
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx], 0;
            if (a < b) {  // jl 0x5033
                // Block 0x5033
                les bx, ptr [bp + 6];
                $1 = $2;
                $1 += $2;
                $1++;
                $1 = $2;
                sub word ptr es:[bx], si;
                push($1);
                $1 = $2;
                $1 = $2;
                mov word ptr es:[bx + 0xe], ax;
                mov word ptr es:[bx + 0xc], dx;
                push($1);
                push($1);
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x679c;
                // Block 0x5061
                $1 += $2;
                // Compare $1 with $2
                if (a == b) {  // je 0x507b
                    // Block 0x507B
                    xor ax, ax;
                } else {
                    // Block 0x5068
                    les bx, ptr [bp + 6];
                    test word ptr es:[bx + 2], 0x200;
                    if (a != b) {  // jne 0x507b
                        // Block 0x507B
                        xor ax, ax;
                    } else {
                        // Block 0x5073
                        or word ptr es:[bx + 2], 0x10;
                        jmp 0x4fd3;
                        // Block 0x4FD3
                        $1 = $2;
                        jmp 0x507d;
                        // Block 0x507D
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x4FE2
                test word ptr es:[bx + 2], 8;
                if (a != b) {  // jne 0x5002
                    // Block 0x5002
                    les bx, ptr [bp + 6];
                    mov word ptr es:[bx], 0;
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x507b
                        // Block 0x507B
                        xor ax, ax;
                    } else {
                        // Block 0x5019
                        cmp word ptr es:[bx + 0xc], dx;
                        if (a != b) {  // jne 0x507b
                            // Block 0x507B
                            xor ax, ax;
                        } else {
                            // Block 0x501F
                            $1 = $2;
                            $1 = $2;
                            mov word ptr es:[bx + 0xe], ax;
                            mov word ptr es:[bx + 0xc], dx;
                            goto $1;
                            jmp 0x507b;
                            // Block 0x507B
                            xor ax, ax;
                        }
                    }
                } else {
                    // Block 0x4FEA
                    $1 = $2;
                    $1 = $2;
                    $1 += $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0x4ffc
                        // Block 0x4FFC
                        cmp word ptr es:[bx + 0xc], dx;
                        if (a != b) {  // jne 0x507b
                            // Block 0x507B
                            xor ax, ax;
                        } else {
                            // Block 0x5002
                            les bx, ptr [bp + 6];
                            mov word ptr es:[bx], 0;
                            $1 = $2;
                            $1 = $2;
                            $1 += $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x507b
                                // Block 0x507B
                                xor ax, ax;
                            } else {
                                // Block 0x5019
                                cmp word ptr es:[bx + 0xc], dx;
                                if (a != b) {  // jne 0x507b
                                    // Block 0x507B
                                    xor ax, ax;
                                } else {
                                    // Block 0x501F
                                    $1 = $2;
                                    $1 = $2;
                                    mov word ptr es:[bx + 0xe], ax;
                                    mov word ptr es:[bx + 0xc], dx;
                                    goto $1;
                                    jmp 0x507b;
                                    // Block 0x507B
                                    xor ax, ax;
                                }
                            }
                        }
                    } else {
                        // Block 0x4FF9
                        jmp 0x507b;
                        // Block 0x507B
                        xor ax, ax;
                    }
                }
            }
        } else {
            // Block 0x4FD3
            $1 = $2;
            jmp 0x507d;
            // Block 0x507D
            $1 = pop();
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x4FBF
        nop ;
        push($1);
        call 0x50e0;
        // Block 0x4FC4
        jmp 0x507b;
        // Block 0x507B
        xor ax, ax;
    }

    // Function calls:
    sub_50E0();
    sub_679C();
    sub_2D44();
    sub_2D44();
}

void sub_50E0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x50E0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    jmp 0x5113;
    // Block 0x5113
    $1 = $2;
    $1--;
    or ax, ax;
    if (a != b) {  // jne 0x50f8
        // Block 0x50F8
        les bx, ptr [bp - 4];
        test word ptr es:[bx + 2], 3;
        if (a == b) {  // je 0x510f
            // Block 0x510F
            add word ptr [bp - 4], 0x14;
        } else {
            // Block 0x5103
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x4fb3;
            // Block 0x510C
            $1 = pop();
            $1 = pop();
            inc di;
        }
    } else {
        // Block 0x511A
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4FB3();
}

void sub_5122() {
    // Variable declarations
    int var_7338;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x5122
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = 0;
    les bx, ptr [bp + 0xc];
    $1++;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x5140
        // Block 0x5140
        // Compare $1 with $2
        if (a != b) {  // jne 0x514a
            // Block 0x514A
            // Compare $1 with $2
            if (a != b) {  // jne 0x515a
                // Block 0x515A
                $1 = 0;
                jmp 0x51d8;
                // Block 0x51D8
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // ret 0xc
            } else {
                // Block 0x514F
                mov dx, 0x902;
            }
        } else {
            // Block 0x5145
            $1 = $2;
            jmp 0x5152;
            // Block 0x5152
            $1 = $2;
            $1 = $2;
            jmp 0x515e;
            // Block 0x515E
            les bx, ptr [bp + 0xc];
            $1 = $2;
            $1++;
            // Compare $1 with $2
            if (a == b) {  // je 0x517f
                // Block 0x517F
                // Compare $1 with $2
                if (a != b) {  // jne 0x518a
                    // Block 0x518A
                    and dx, 0xfffc;
                    or dx, 4;
                    $1 = $2;
                    mov si, 3;
                } else {
                    // Block 0x5184
                    les bx, ptr [bp + 0xc];
                    mov cl, byte ptr es:[bx];
                }
            } else {
                // Block 0x516C
                les bx, ptr [bp + 0xc];
                cmp byte ptr es:[bx], 0x2b;
                if (a != b) {  // jne 0x5196
                    // Block 0x5196
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x51a1
                        // Block 0x51A1
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x51ac
                            // Block 0x51AC
                            $1 = $2;
                            and ax, 0xc000;
                            or dx, ax;
                            $1 = $2;
                            test ax, 0x8000;
                            if (a == b) {  // je 0x51be
                                // Block 0x51BE
                                mov word ptr [0x733a], 0;
                                mov word ptr [0x7338], 0x4d2c;
                                les bx, ptr [bp + 8];
                                mov word ptr es:[bx], dx;
                                les bx, ptr [bp + 4];
                                mov word ptr es:[bx], di;
                                mov ax, si;
                            } else {
                                // Block 0x51BB
                                or si, 0x40;
                            }
                        } else {
                            // Block 0x51A6
                            or dx, 0x8000;
                            jmp 0x51bb;
                            // Block 0x51BB
                            or si, 0x40;
                        }
                    } else {
                        // Block 0x519B
                        or dx, 0x4000;
                        jmp 0x51be;
                        // Block 0x51BE
                        mov word ptr [0x733a], 0;
                        mov word ptr [0x7338], 0x4d2c;
                        les bx, ptr [bp + 8];
                        mov word ptr es:[bx], dx;
                        les bx, ptr [bp + 4];
                        mov word ptr es:[bx], di;
                        mov ax, si;
                    }
                } else {
                    // Block 0x5175
                    // Compare $1 with $2
                    if (a == b) {  // je 0x517f
                        // Block 0x517F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x518a
                            // Block 0x518A
                            and dx, 0xfffc;
                            or dx, 4;
                            $1 = $2;
                            mov si, 3;
                        } else {
                            // Block 0x5184
                            les bx, ptr [bp + 0xc];
                            mov cl, byte ptr es:[bx];
                        }
                    } else {
                        // Block 0x517A
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x5196
                            // Block 0x5196
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x51a1
                                // Block 0x51A1
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x51ac
                                    // Block 0x51AC
                                    $1 = $2;
                                    and ax, 0xc000;
                                    or dx, ax;
                                    $1 = $2;
                                    test ax, 0x8000;
                                    if (a == b) {  // je 0x51be
                                        // Block 0x51BE
                                        mov word ptr [0x733a], 0;
                                        mov word ptr [0x7338], 0x4d2c;
                                        les bx, ptr [bp + 8];
                                        mov word ptr es:[bx], dx;
                                        les bx, ptr [bp + 4];
                                        mov word ptr es:[bx], di;
                                        mov ax, si;
                                    } else {
                                        // Block 0x51BB
                                        or si, 0x40;
                                    }
                                } else {
                                    // Block 0x51A6
                                    or dx, 0x8000;
                                    jmp 0x51bb;
                                    // Block 0x51BB
                                    or si, 0x40;
                                }
                            } else {
                                // Block 0x519B
                                or dx, 0x4000;
                                jmp 0x51be;
                                // Block 0x51BE
                                mov word ptr [0x733a], 0;
                                mov word ptr [0x7338], 0x4d2c;
                                les bx, ptr [bp + 8];
                                mov word ptr es:[bx], dx;
                                les bx, ptr [bp + 4];
                                mov word ptr es:[bx], di;
                                mov ax, si;
                            }
                        } else {
                            // Block 0x517F
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x518a
                                // Block 0x518A
                                and dx, 0xfffc;
                                or dx, 4;
                                $1 = $2;
                                mov si, 3;
                            } else {
                                // Block 0x5184
                                les bx, ptr [bp + 0xc];
                                mov cl, byte ptr es:[bx];
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x5138
        $1 = $2;
        $1 = $2;
        jmp 0x515e;
        // Block 0x515E
        les bx, ptr [bp + 0xc];
        $1 = $2;
        $1++;
        // Compare $1 with $2
        if (a == b) {  // je 0x517f
            // Block 0x517F
            // Compare $1 with $2
            if (a != b) {  // jne 0x518a
                // Block 0x518A
                and dx, 0xfffc;
                or dx, 4;
                $1 = $2;
                mov si, 3;
            } else {
                // Block 0x5184
                les bx, ptr [bp + 0xc];
                mov cl, byte ptr es:[bx];
            }
        } else {
            // Block 0x516C
            les bx, ptr [bp + 0xc];
            cmp byte ptr es:[bx], 0x2b;
            if (a != b) {  // jne 0x5196
                // Block 0x5196
                // Compare $1 with $2
                if (a != b) {  // jne 0x51a1
                    // Block 0x51A1
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x51ac
                        // Block 0x51AC
                        $1 = $2;
                        and ax, 0xc000;
                        or dx, ax;
                        $1 = $2;
                        test ax, 0x8000;
                        if (a == b) {  // je 0x51be
                            // Block 0x51BE
                            mov word ptr [0x733a], 0;
                            mov word ptr [0x7338], 0x4d2c;
                            les bx, ptr [bp + 8];
                            mov word ptr es:[bx], dx;
                            les bx, ptr [bp + 4];
                            mov word ptr es:[bx], di;
                            mov ax, si;
                        } else {
                            // Block 0x51BB
                            or si, 0x40;
                        }
                    } else {
                        // Block 0x51A6
                        or dx, 0x8000;
                        jmp 0x51bb;
                        // Block 0x51BB
                        or si, 0x40;
                    }
                } else {
                    // Block 0x519B
                    or dx, 0x4000;
                    jmp 0x51be;
                    // Block 0x51BE
                    mov word ptr [0x733a], 0;
                    mov word ptr [0x7338], 0x4d2c;
                    les bx, ptr [bp + 8];
                    mov word ptr es:[bx], dx;
                    les bx, ptr [bp + 4];
                    mov word ptr es:[bx], di;
                    mov ax, si;
                }
            } else {
                // Block 0x5175
                // Compare $1 with $2
                if (a == b) {  // je 0x517f
                    // Block 0x517F
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x518a
                        // Block 0x518A
                        and dx, 0xfffc;
                        or dx, 4;
                        $1 = $2;
                        mov si, 3;
                    } else {
                        // Block 0x5184
                        les bx, ptr [bp + 0xc];
                        mov cl, byte ptr es:[bx];
                    }
                } else {
                    // Block 0x517A
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x5196
                        // Block 0x5196
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x51a1
                            // Block 0x51A1
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x51ac
                                // Block 0x51AC
                                $1 = $2;
                                and ax, 0xc000;
                                or dx, ax;
                                $1 = $2;
                                test ax, 0x8000;
                                if (a == b) {  // je 0x51be
                                    // Block 0x51BE
                                    mov word ptr [0x733a], 0;
                                    mov word ptr [0x7338], 0x4d2c;
                                    les bx, ptr [bp + 8];
                                    mov word ptr es:[bx], dx;
                                    les bx, ptr [bp + 4];
                                    mov word ptr es:[bx], di;
                                    mov ax, si;
                                } else {
                                    // Block 0x51BB
                                    or si, 0x40;
                                }
                            } else {
                                // Block 0x51A6
                                or dx, 0x8000;
                                jmp 0x51bb;
                                // Block 0x51BB
                                or si, 0x40;
                            }
                        } else {
                            // Block 0x519B
                            or dx, 0x4000;
                            jmp 0x51be;
                            // Block 0x51BE
                            mov word ptr [0x733a], 0;
                            mov word ptr [0x7338], 0x4d2c;
                            les bx, ptr [bp + 8];
                            mov word ptr es:[bx], dx;
                            les bx, ptr [bp + 4];
                            mov word ptr es:[bx], di;
                            mov ax, si;
                        }
                    } else {
                        // Block 0x517F
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x518a
                            // Block 0x518A
                            and dx, 0xfffc;
                            or dx, 4;
                            $1 = $2;
                            mov si, 3;
                        } else {
                            // Block 0x5184
                            les bx, ptr [bp + 0xc];
                            mov cl, byte ptr es:[bx];
                        }
                    }
                }
            }
        }
    }
}

void sub_51DE() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0x51DE
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    lea ax, [bp - 2];
    push($1);
    push($1);
    lea ax, [bp - 4];
    push($1);
    call 0x5122;
    // Block 0x51F7
    les bx, ptr [bp + 0xe];
    mov word ptr es:[bx + 2], ax;
    or ax, ax;
    if (a == b) {  // je 0x522c
        // Block 0x522C
        les bx, ptr [bp + 0xe];
        mov byte ptr es:[bx + 4], 0xff;
        mov word ptr es:[bx + 2], 0;
    } else {
        // Block 0x5202
        cmp byte ptr es:[bx + 4], 0;
        if (a >= b) {  // jge 0x5240
            // Block 0x5240
            les bx, ptr [bp + 0xe];
            $1 = $2;
            cwde ;
            push($1);
            nop ;
            push($1);
            call 0x2f4e;
            // Block 0x524E
            $1 = pop();
            or ax, ax;
            if (a == b) {  // je 0x525c
                // Block 0x525C
                $1 = $2;
                push($1);
                les bx, ptr [bp + 0xe];
                test word ptr es:[bx + 2], 0x200;
                if (a == b) {  // je 0x5270
                    // Block 0x5270
                    xor ax, ax;
                } else {
                    // Block 0x526B
                    $1 = $2;
                    jmp 0x5272;
                    // Block 0x5272
                    push($1);
                    $1 = 0;
                    $1 = 0;
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x60c5;
                    // Block 0x5284
                    $1 += $2;
                    or ax, ax;
                    if (a == b) {  // je 0x529a
                        // Block 0x529A
                        les bx, ptr [bp + 0xe];
                        mov word ptr es:[bx + 0x10], 0;
                        $1 = $2;
                        mov ax, word ptr [bp + 0xe];
                    } else {
                        // Block 0x528B
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x4efb;
                        // Block 0x5296
                        $1 = pop();
                        $1 = pop();
                        jmp 0x523a;
                        // Block 0x523A
                        $1 = 0;
                        $1 = 0;
                        jmp 0x52a9;
                        // Block 0x52A9
                        $1 = $2;
                        $1 = pop();
                        return;  // ret 0xe
                    }
                }
            } else {
                // Block 0x5253
                les bx, ptr [bp + 0xe];
                or word ptr es:[bx + 2], 0x200;
            }
        } else {
            // Block 0x5209
            push($1);
            $1 = $2;
            or ax, word ptr [bp + 4];
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x5a50;
            // Block 0x521E
            $1 += $2;
            les bx, ptr [bp + 0xe];
            mov byte ptr es:[bx + 4], al;
            or al, al;
            if (a >= b) {  // jge 0x5240
                // Block 0x5240
                les bx, ptr [bp + 0xe];
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x2f4e;
                // Block 0x524E
                $1 = pop();
                or ax, ax;
                if (a == b) {  // je 0x525c
                    // Block 0x525C
                    $1 = $2;
                    push($1);
                    les bx, ptr [bp + 0xe];
                    test word ptr es:[bx + 2], 0x200;
                    if (a == b) {  // je 0x5270
                        // Block 0x5270
                        xor ax, ax;
                    } else {
                        // Block 0x526B
                        $1 = $2;
                        jmp 0x5272;
                        // Block 0x5272
                        push($1);
                        $1 = 0;
                        $1 = 0;
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x60c5;
                        // Block 0x5284
                        $1 += $2;
                        or ax, ax;
                        if (a == b) {  // je 0x529a
                            // Block 0x529A
                            les bx, ptr [bp + 0xe];
                            mov word ptr es:[bx + 0x10], 0;
                            $1 = $2;
                            mov ax, word ptr [bp + 0xe];
                        } else {
                            // Block 0x528B
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x4efb;
                            // Block 0x5296
                            $1 = pop();
                            $1 = pop();
                            jmp 0x523a;
                            // Block 0x523A
                            $1 = 0;
                            $1 = 0;
                            jmp 0x52a9;
                            // Block 0x52A9
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 0xe
                        }
                    }
                } else {
                    // Block 0x5253
                    les bx, ptr [bp + 0xe];
                    or word ptr es:[bx + 2], 0x200;
                }
            } else {
                // Block 0x522C
                les bx, ptr [bp + 0xe];
                mov byte ptr es:[bx + 4], 0xff;
                mov word ptr es:[bx + 2], 0;
            }
        }
    }

    // Function calls:
    sub_5122();
    sub_5A50();
    sub_2F4E();
    sub_60C5();
    sub_4EFB();
}

void sub_52AF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0x52AF
    push($1);
    $1 = $2;
    $1 -= $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;

    // Function calls:
    sub_52AF();
    sub_51DE();
    sub_3935();
}

void sub_534A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 19 if statements

    // Block 0x534A
    push($1);
    $1 = $2;
    push($1);
    push($1);
    jmp 0x542c;
    // Block 0x542C
    cmp word ptr [bp + 8], 0;
    if (a == b) {  // je 0x5435
        // Block 0x5435
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x5432
        jmp 0x5352;
        // Block 0x5352
        $1++;
        les bx, ptr [bp + 4];
        $1 = $2;
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x5366
            // Block 0x5366
            les bx, ptr [bp + 4];
            mov ax, word ptr es:[bx + 6];
        } else {
            // Block 0x5361
            $1 = $2;
            jmp 0x536d;
            // Block 0x536D
            $1 = $2;
            les bx, ptr [bp + 4];
            test word ptr es:[bx + 2], 0x40;
            if (a == b) {  // je 0x53e9
                // Block 0x53E9
                $1--;
                $1 = $2;
                or ax, ax;
                if (a == b) {  // je 0x5427
                    // Block 0x5427
                    cmp dx, -1;
                    if (a == b) {  // je 0x53d6
                        // Block 0x53D6
                        les bx, ptr [bp + 4];
                        or word ptr es:[bx + 2], 0x20;
                        jmp 0x5435;
                        // Block 0x5435
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        return;  // ret 0xa
                    } else {
                        // Jump to block at 0x542C
                    }
                } else {
                    // Block 0x53F3
                    $1--;
                    if (a == b) {  // je 0x5427
                        // Block 0x5427
                        cmp dx, -1;
                        if (a == b) {  // je 0x53d6
                            // Block 0x53D6
                            les bx, ptr [bp + 4];
                            or word ptr es:[bx + 2], 0x20;
                            jmp 0x5435;
                            // Block 0x5435
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 0xa
                        } else {
                            // Jump to block at 0x542C
                        }
                    } else {
                        // Block 0x53F6
                        les bx, ptr [bp + 4];
                        $1--;
                        if (a < b) {  // jl 0x5413
                            // Block 0x5413
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x57ef;
                            // Block 0x541E
                            $1 = pop();
                            pop cx;
                        } else {
                            // Block 0x53FE
                            $1 = $2;
                            $1 = $2;
                            $1++;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            jmp 0x5420;
                            // Block 0x5420
                            $1 = $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x53e0
                                // Block 0x53E0
                                les bx, ptr [bp + 0xa];
                                mov byte ptr es:[bx], dl;
                                inc word ptr [bp + 0xa];
                            } else {
                                // Block 0x5427
                                cmp dx, -1;
                                if (a == b) {  // je 0x53d6
                                    // Block 0x53D6
                                    les bx, ptr [bp + 4];
                                    or word ptr es:[bx + 2], 0x20;
                                    jmp 0x5435;
                                    // Block 0x5435
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // ret 0xa
                                } else {
                                    // Jump to block at 0x542C
                                }
                            }
                        }
                    }
                }
            } else {
                // Block 0x537A
                cmp word ptr es:[bx + 6], 0;
                if (a == b) {  // je 0x53e9
                    // Block 0x53E9
                    $1--;
                    $1 = $2;
                    or ax, ax;
                    if (a == b) {  // je 0x5427
                        // Block 0x5427
                        cmp dx, -1;
                        if (a == b) {  // je 0x53d6
                            // Block 0x53D6
                            les bx, ptr [bp + 4];
                            or word ptr es:[bx + 2], 0x20;
                            jmp 0x5435;
                            // Block 0x5435
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            return;  // ret 0xa
                        } else {
                            // Jump to block at 0x542C
                        }
                    } else {
                        // Block 0x53F3
                        $1--;
                        if (a == b) {  // je 0x5427
                            // Block 0x5427
                            cmp dx, -1;
                            if (a == b) {  // je 0x53d6
                                // Block 0x53D6
                                les bx, ptr [bp + 4];
                                or word ptr es:[bx + 2], 0x20;
                                jmp 0x5435;
                                // Block 0x5435
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                return;  // ret 0xa
                            } else {
                                // Jump to block at 0x542C
                            }
                        } else {
                            // Block 0x53F6
                            les bx, ptr [bp + 4];
                            $1--;
                            if (a < b) {  // jl 0x5413
                                // Block 0x5413
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x57ef;
                                // Block 0x541E
                                $1 = pop();
                                pop cx;
                            } else {
                                // Block 0x53FE
                                $1 = $2;
                                $1 = $2;
                                $1++;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                jmp 0x5420;
                                // Block 0x5420
                                $1 = $2;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x53e0
                                    // Block 0x53E0
                                    les bx, ptr [bp + 0xa];
                                    mov byte ptr es:[bx], dl;
                                    inc word ptr [bp + 0xa];
                                } else {
                                    // Block 0x5427
                                    cmp dx, -1;
                                    if (a == b) {  // je 0x53d6
                                        // Block 0x53D6
                                        les bx, ptr [bp + 4];
                                        or word ptr es:[bx + 2], 0x20;
                                        jmp 0x5435;
                                        // Block 0x5435
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // ret 0xa
                                    } else {
                                        // Jump to block at 0x542C
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x5381
                    $1 = $2;
                    // Compare $1 with $2
                    if (a >= b (unsigned)) {  // jae 0x53e9
                        // Block 0x53E9
                        $1--;
                        $1 = $2;
                        or ax, ax;
                        if (a == b) {  // je 0x5427
                            // Block 0x5427
                            cmp dx, -1;
                            if (a == b) {  // je 0x53d6
                                // Block 0x53D6
                                les bx, ptr [bp + 4];
                                or word ptr es:[bx + 2], 0x20;
                                jmp 0x5435;
                                // Block 0x5435
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                return;  // ret 0xa
                            } else {
                                // Jump to block at 0x542C
                            }
                        } else {
                            // Block 0x53F3
                            $1--;
                            if (a == b) {  // je 0x5427
                                // Block 0x5427
                                cmp dx, -1;
                                if (a == b) {  // je 0x53d6
                                    // Block 0x53D6
                                    les bx, ptr [bp + 4];
                                    or word ptr es:[bx + 2], 0x20;
                                    jmp 0x5435;
                                    // Block 0x5435
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // ret 0xa
                                } else {
                                    // Jump to block at 0x542C
                                }
                            } else {
                                // Block 0x53F6
                                les bx, ptr [bp + 4];
                                $1--;
                                if (a < b) {  // jl 0x5413
                                    // Block 0x5413
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x57ef;
                                    // Block 0x541E
                                    $1 = pop();
                                    pop cx;
                                } else {
                                    // Block 0x53FE
                                    $1 = $2;
                                    $1 = $2;
                                    $1++;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = $2;
                                    jmp 0x5420;
                                    // Block 0x5420
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x53e0
                                        // Block 0x53E0
                                        les bx, ptr [bp + 0xa];
                                        mov byte ptr es:[bx], dl;
                                        inc word ptr [bp + 0xa];
                                    } else {
                                        // Block 0x5427
                                        cmp dx, -1;
                                        if (a == b) {  // je 0x53d6
                                            // Block 0x53D6
                                            les bx, ptr [bp + 4];
                                            or word ptr es:[bx + 2], 0x20;
                                            jmp 0x5435;
                                            // Block 0x5435
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // ret 0xa
                                        } else {
                                            // Jump to block at 0x542C
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x538A
                        cmp word ptr es:[bx], 0;
                        if (a != b) {  // jne 0x53e9
                            // Block 0x53E9
                            $1--;
                            $1 = $2;
                            or ax, ax;
                            if (a == b) {  // je 0x5427
                                // Block 0x5427
                                cmp dx, -1;
                                if (a == b) {  // je 0x53d6
                                    // Block 0x53D6
                                    les bx, ptr [bp + 4];
                                    or word ptr es:[bx + 2], 0x20;
                                    jmp 0x5435;
                                    // Block 0x5435
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // ret 0xa
                                } else {
                                    // Jump to block at 0x542C
                                }
                            } else {
                                // Block 0x53F3
                                $1--;
                                if (a == b) {  // je 0x5427
                                    // Block 0x5427
                                    cmp dx, -1;
                                    if (a == b) {  // je 0x53d6
                                        // Block 0x53D6
                                        les bx, ptr [bp + 4];
                                        or word ptr es:[bx + 2], 0x20;
                                        jmp 0x5435;
                                        // Block 0x5435
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // ret 0xa
                                    } else {
                                        // Jump to block at 0x542C
                                    }
                                } else {
                                    // Block 0x53F6
                                    les bx, ptr [bp + 4];
                                    $1--;
                                    if (a < b) {  // jl 0x5413
                                        // Block 0x5413
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x57ef;
                                        // Block 0x541E
                                        $1 = pop();
                                        pop cx;
                                    } else {
                                        // Block 0x53FE
                                        $1 = $2;
                                        $1 = $2;
                                        $1++;
                                        $1 = $2;
                                        $1 = $2;
                                        $1 = $2;
                                        jmp 0x5420;
                                        // Block 0x5420
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x53e0
                                            // Block 0x53E0
                                            les bx, ptr [bp + 0xa];
                                            mov byte ptr es:[bx], dl;
                                            inc word ptr [bp + 0xa];
                                        } else {
                                            // Block 0x5427
                                            cmp dx, -1;
                                            if (a == b) {  // je 0x53d6
                                                // Block 0x53D6
                                                les bx, ptr [bp + 4];
                                                or word ptr es:[bx + 2], 0x20;
                                                jmp 0x5435;
                                                // Block 0x5435
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // ret 0xa
                                            } else {
                                                // Jump to block at 0x542C
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0x5390
                            $1--;
                            $1 = 0;
                            jmp 0x53a5;
                            // Block 0x53A5
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            // Compare $1 with $2
                            if (a <= b (unsigned)) {  // jbe 0x5397
                                // Block 0x5397
                                les bx, ptr [bp + 4];
                                $1 += $2;
                                $1 = $2;
                                sub word ptr [bp + 8], ax;
                            } else {
                                // Block 0x53B1
                                push($1);
                                push($1);
                                push($1);
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x3118;
                                // Block 0x53C3
                                $1 += $2;
                                $1 = $2;
                                add word ptr [bp + 0xa], dx;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x542c
                                    // Jump to block at 0x542C
                                } else {
                                    // Block 0x53CF
                                    $1 = $2;
                                    $1 -= $2;
                                    add word ptr [bp + 8], ax;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Function calls:
    sub_3118();
    sub_57EF();
    sub_30E0();
    sub_534A();
    sub_2CBC();
    sub_534A();
}

void sub_54CC() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 loops
    // - 7 if statements

    // Block 0x54CC
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    les bx, ptr [bp + 4];
    cmp word ptr es:[bx], 0;
    if (a >= b) {  // jge 0x54e8
        // Block 0x54E8
        les bx, ptr [bp + 4];
        $1 = $2;
        cdq ;
        xor ax, dx;
        $1 -= $2;
        $1 = $2;
        mov si, ax;
    } else {
        // Block 0x54DC
        $1 = $2;
        $1 += $2;
        $1++;
        $1 = $2;
        jmp 0x54f7;
        // Block 0x54F7
        les bx, ptr [bp + 4];
        test word ptr es:[bx + 2], 0x40;
        if (a != b) {  // jne 0x5545
            // Block 0x5545
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // ret 4
        } else {
            // Block 0x5502
            les bx, ptr [bp + 4];
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            *($1) = $2;
            cmp word ptr es:[bx], 0;
            if (a >= b) {  // jge 0x553e
                // Block 0x553E
                $1 = $2;
                $1--;
                or ax, ax;
                if (a != b) {  // jne 0x5531
                    // Block 0x5531
                    les bx, ptr [bp - 4];
                    $1++;
                    cmp byte ptr es:[bx], 0xa;
                    if (a != b) {  // jne 0x553e
                        // Jump to block at 0x553E
                    } else {
                        // Block 0x553D
                        inc si;
                    }
                } else {
                    // Block 0x5545
                    $1 = $2;
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 4
                }
            } else {
                // Block 0x5519
                jmp 0x5528;
                // Block 0x5528
                $1 = $2;
                $1--;
                or ax, ax;
                if (a != b) {  // jne 0x551b
                    // Block 0x551B
                    $1--;
                    les bx, ptr [bp - 4];
                    cmp byte ptr es:[bx], 0xa;
                    if (a != b) {  // jne 0x5528
                        // Jump to block at 0x5528
                    } else {
                        // Block 0x5527
                        inc si;
                    }
                } else {
                    // Block 0x552F
                    jmp 0x5545;
                    // Block 0x5545
                    $1 = $2;
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 4
                }
            }
        }
    }
}

void sub_554E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0x554E
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    push($1);
    push($1);
    nop ;
    push($1);
    call 0x4fb3;
    // Block 0x5560
    $1 = pop();
    $1 = pop();
    or ax, ax;
    if (a == b) {  // je 0x556b
        // Block 0x556B
        // Compare $1 with $2
        if (a != b) {  // jne 0x5587
            // Block 0x5587
            les bx, ptr [bp + 6];
            and word ptr es:[bx + 2], 0xfe5f;
            mov word ptr es:[bx], 0;
            $1 = $2;
            $1 = $2;
            mov word ptr es:[bx + 0xe], ax;
            mov word ptr es:[bx + 0xc], dx;
            push($1);
            push($1);
            push($1);
            $1 = $2;
            cwde ;
            push($1);
            nop ;
            push($1);
            call 0x3001;
            // Block 0x55B7
            $1 += $2;
            cmp dx, -1;
            if (a != b) {  // jne 0x55c9
                // Block 0x55C9
                xor ax, ax;
            } else {
                // Block 0x55BF
                // Compare $1 with $2
                if (a != b) {  // jne 0x55c9
                    // Block 0x55C9
                    xor ax, ax;
                } else {
                    // Block 0x55C4
                    $1 = $2;
                    jmp 0x55cb;
                    // Block 0x55CB
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            }
        } else {
            // Block 0x5570
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx], 0;
            if (a <= b) {  // jle 0x5587
                // Block 0x5587
                les bx, ptr [bp + 6];
                and word ptr es:[bx + 2], 0xfe5f;
                mov word ptr es:[bx], 0;
                $1 = $2;
                $1 = $2;
                mov word ptr es:[bx + 0xe], ax;
                mov word ptr es:[bx + 0xc], dx;
                push($1);
                push($1);
                push($1);
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x3001;
                // Block 0x55B7
                $1 += $2;
                cmp dx, -1;
                if (a != b) {  // jne 0x55c9
                    // Block 0x55C9
                    xor ax, ax;
                } else {
                    // Block 0x55BF
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x55c9
                        // Block 0x55C9
                        xor ax, ax;
                    } else {
                        // Block 0x55C4
                        $1 = $2;
                        jmp 0x55cb;
                        // Block 0x55CB
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x5579
                push($1);
                push($1);
                call 0x54cc;
                // Block 0x5580
                cdq ;
                sub word ptr [bp + 0xa], ax;
                sbb word ptr [bp + 0xc], dx;
            }
        }
    } else {
        // Block 0x5566
        $1 = $2;
        jmp 0x55cb;
        // Block 0x55CB
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_4FB3();
    sub_54CC();
    sub_3001();
    sub_3001();
    sub_3001();
    sub_3001();
    sub_54CC();
    sub_54CC();
    sub_30E0();
    sub_5DEE();
    sub_5DEE();
    sub_2CBC();
}

void sub_5739() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x5739
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    mov word ptr [bp - 4], 0x7340;
    jmp 0x576b;
    // Block 0x576B
    $1 = $2;
    $1--;
    or ax, ax;
    if (a != b) {  // jne 0x574d
        // Block 0x574D
        les bx, ptr [bp - 4];
        $1 = $2;
        and ax, 0x300;
        // Compare $1 with $2
        if (a != b) {  // jne 0x5767
            // Block 0x5767
            add word ptr [bp - 4], 0x14;
        } else {
            // Block 0x575C
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x4fb3;
            // Block 0x5765
            $1 = pop();
            pop cx;
        }
    } else {
        // Block 0x5772
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // ret 
    }

    // Function calls:
    sub_4FB3();
}

void sub_5777() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x5777
    push($1);
    $1 = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 0x200;
    if (a == b) {  // je 0x5788
        // Block 0x5788
        les bx, ptr [bp + 4];
        push($1);
        $1 = $2;
        $1 = $2;
        mov word ptr es:[bx + 0xe], ax;
        mov word ptr es:[bx + 0xc], dx;
        push($1);
        push($1);
        $1 = $2;
        cwde ;
        push($1);
        nop ;
        push($1);
        call 0x5ff1;
        // Block 0x57AC
        $1 += $2;
        les bx, ptr [bp + 4];
        mov word ptr es:[bx], ax;
        or ax, ax;
        if (a <= b) {  // jle 0x57c2
            // Block 0x57C2
            les bx, ptr [bp + 4];
            cmp word ptr es:[bx], 0;
            if (a != b) {  // jne 0x57db
                // Block 0x57DB
                les bx, ptr [bp + 4];
                mov word ptr es:[bx], 0;
                or word ptr es:[bx + 2], 0x10;
            } else {
                // Block 0x57CB
                $1 = $2;
                and ax, 0xfe7f;
                or ax, 0x20;
                mov word ptr es:[bx + 2], ax;
                jmp 0x57e8;
                // Block 0x57E8
                mov ax, 0xffff;
            }
        } else {
            // Block 0x57B9
            and word ptr es:[bx + 2], 0xffdf;
            $1 = 0;
            jmp 0x57eb;
            // Block 0x57EB
            $1 = pop();
            return;  // ret 4
        }
    } else {
        // Block 0x5785
        call 0x5739;
        // Block 0x5788
        les bx, ptr [bp + 4];
        push($1);
        $1 = $2;
        $1 = $2;
        mov word ptr es:[bx + 0xe], ax;
        mov word ptr es:[bx + 0xc], dx;
        push($1);
        push($1);
        $1 = $2;
        cwde ;
        push($1);
        nop ;
        push($1);
        call 0x5ff1;
        // Block 0x57AC
        $1 += $2;
        les bx, ptr [bp + 4];
        mov word ptr es:[bx], ax;
        or ax, ax;
        if (a <= b) {  // jle 0x57c2
            // Block 0x57C2
            les bx, ptr [bp + 4];
            cmp word ptr es:[bx], 0;
            if (a != b) {  // jne 0x57db
                // Block 0x57DB
                les bx, ptr [bp + 4];
                mov word ptr es:[bx], 0;
                or word ptr es:[bx + 2], 0x10;
            } else {
                // Block 0x57CB
                $1 = $2;
                and ax, 0xfe7f;
                or ax, 0x20;
                mov word ptr es:[bx + 2], ax;
                jmp 0x57e8;
                // Block 0x57E8
                mov ax, 0xffff;
            }
        } else {
            // Block 0x57B9
            and word ptr es:[bx + 2], 0xffdf;
            $1 = 0;
            jmp 0x57eb;
            // Block 0x57EB
            $1 = pop();
            return;  // ret 4
        }
    }

    // Function calls:
    sub_5739();
    sub_5FF1();
}

void sub_57EF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x57EF
    push($1);
    $1 = $2;
    les bx, ptr [bp + 6];
    $1++;
    push($1);
    push($1);
    push($1);
    call 0x5807;
    // Block 0x5800
    $1 = pop();
    $1 = pop();
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_5807();
}

void sub_5807() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 18 if statements

    // Block 0x5807
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    or ax, word ptr [bp + 8];
    if (a != b) {  // jne 0x5819
        // Block 0x5819
        les bx, ptr [bp + 6];
        cmp word ptr es:[bx], 0;
        if (a <= b) {  // jle 0x583c
            // Block 0x583C
            les bx, ptr [bp + 6];
            cmp word ptr es:[bx], 0;
            if (a < b) {  // jl 0x58b4
                // Block 0x58B4
                les bx, ptr [bp + 6];
                or word ptr es:[bx + 2], 0x10;
                jmp 0x5813;
                // Block 0x5813
                $1 = $2;
                jmp 0x58f2;
                // Block 0x58F2
                $1 = pop();
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0x5845
                test word ptr es:[bx + 2], 0x110;
                if (a != b) {  // jne 0x58b4
                    // Block 0x58B4
                    les bx, ptr [bp + 6];
                    or word ptr es:[bx + 2], 0x10;
                    jmp 0x5813;
                    // Block 0x5813
                    $1 = $2;
                    jmp 0x58f2;
                    // Block 0x58F2
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x584D
                    test word ptr es:[bx + 2], 1;
                    if (a == b) {  // je 0x58b4
                        // Block 0x58B4
                        les bx, ptr [bp + 6];
                        or word ptr es:[bx + 2], 0x10;
                        jmp 0x5813;
                        // Block 0x5813
                        $1 = $2;
                        jmp 0x58f2;
                        // Block 0x58F2
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x5855
                        les bx, ptr [bp + 6];
                        or word ptr es:[bx + 2], 0x80;
                        cmp word ptr es:[bx + 6], 0;
                        if (a == b) {  // je 0x5874
                            // Block 0x5874
                            les bx, ptr [bp + 6];
                            test word ptr es:[bx + 2], 0x200;
                            if (a == b) {  // je 0x5882
                                // Block 0x5882
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                les bx, ptr [bp + 6];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x5ff1;
                                // Block 0x5899
                                $1 += $2;
                                or ax, ax;
                                if (a != b) {  // jne 0x58d3
                                    // Block 0x58D3
                                    cmp byte ptr [0x8790], 0xd;
                                    if (a != b) {  // jne 0x58e5
                                        // Block 0x58E5
                                        les bx, ptr [bp + 6];
                                        and word ptr es:[bx + 2], 0xffdf;
                                        mov al, byte ptr [0x8790];
                                    } else {
                                        // Block 0x58DA
                                        les bx, ptr [bp + 6];
                                        test word ptr es:[bx + 2], 0x40;
                                        if (a == b) {  // je 0x5874
                                            // Jump to block at 0x5874
                                        } else {
                                            // Block 0x58E5
                                            les bx, ptr [bp + 6];
                                            and word ptr es:[bx + 2], 0xffdf;
                                            mov al, byte ptr [0x8790];
                                        }
                                    }
                                } else {
                                    // Block 0x58A0
                                    les bx, ptr [bp + 6];
                                    $1 = $2;
                                    cwde ;
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e84;
                                    // Block 0x58AE
                                    $1 = pop();
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x58bf
                                        // Block 0x58BF
                                        les bx, ptr [bp + 6];
                                        $1 = $2;
                                        and ax, 0xfe7f;
                                        or ax, 0x20;
                                        mov word ptr es:[bx + 2], ax;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0x58B4
                                        les bx, ptr [bp + 6];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0x587F
                                call 0x5739;
                                // Block 0x5882
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                les bx, ptr [bp + 6];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x5ff1;
                                // Block 0x5899
                                $1 += $2;
                                or ax, ax;
                                if (a != b) {  // jne 0x58d3
                                    // Block 0x58D3
                                    cmp byte ptr [0x8790], 0xd;
                                    if (a != b) {  // jne 0x58e5
                                        // Block 0x58E5
                                        les bx, ptr [bp + 6];
                                        and word ptr es:[bx + 2], 0xffdf;
                                        mov al, byte ptr [0x8790];
                                    } else {
                                        // Block 0x58DA
                                        les bx, ptr [bp + 6];
                                        test word ptr es:[bx + 2], 0x40;
                                        if (a == b) {  // je 0x5874
                                            // Jump to block at 0x5874
                                        } else {
                                            // Block 0x58E5
                                            les bx, ptr [bp + 6];
                                            and word ptr es:[bx + 2], 0xffdf;
                                            mov al, byte ptr [0x8790];
                                        }
                                    }
                                } else {
                                    // Block 0x58A0
                                    les bx, ptr [bp + 6];
                                    $1 = $2;
                                    cwde ;
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e84;
                                    // Block 0x58AE
                                    $1 = pop();
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x58bf
                                        // Block 0x58BF
                                        les bx, ptr [bp + 6];
                                        $1 = $2;
                                        and ax, 0xfe7f;
                                        or ax, 0x20;
                                        mov word ptr es:[bx + 2], ax;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0x58B4
                                        les bx, ptr [bp + 6];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5813;
                                        // Block 0x5813
                                        $1 = $2;
                                        jmp 0x58f2;
                                        // Block 0x58F2
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            }
                        } else {
                            // Block 0x5865
                            push($1);
                            push($1);
                            call 0x5777;
                            // Block 0x586C
                            or ax, ax;
                            if (a == b) {  // je 0x5822
                                // Block 0x5822
                                les bx, ptr [bp + 6];
                                $1--;
                                $1 = $2;
                                $1 = $2;
                                $1++;
                                $1 = $2;
                                $1 = $2;
                                jmp 0x58f0;
                                // Block 0x58F0
                                mov ah, 0;
                            } else {
                                // Block 0x5870
                                goto $1;
                                jmp 0x5822;
                                // Block 0x5822
                                les bx, ptr [bp + 6];
                                $1--;
                                $1 = $2;
                                $1 = $2;
                                $1++;
                                $1 = $2;
                                $1 = $2;
                                jmp 0x58f0;
                                // Block 0x58F0
                                mov ah, 0;
                            }
                        }
                    }
                }
            }
        } else {
            // Block 0x5822
            les bx, ptr [bp + 6];
            $1--;
            $1 = $2;
            $1 = $2;
            $1++;
            $1 = $2;
            $1 = $2;
            jmp 0x58f0;
            // Block 0x58F0
            mov ah, 0;
        }
    } else {
        // Block 0x5813
        $1 = $2;
        jmp 0x58f2;
        // Block 0x58F2
        $1 = pop();
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_5777();
    sub_5739();
    sub_5FF1();
    sub_4E84();
    sub_5807();
    sub_2B71();
    sub_2B2E();
    sub_6661();
    sub_4302();
    sub_65F7();
    sub_2F5F();
    sub_2F5F();
    sub_2F5F();
}

void sub_59FF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x59FF
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    les di, ptr [bp + 6];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    shr cx, 1;
    cld ;
    rep movsw word ptr es:[di], word ptr [si];
    if (a >= b (unsigned)) {  // jae 0x5a17
        // Block 0x5A17
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x5A16
        movsb byte ptr es:[di], byte ptr [si];
    }
}

void sub_5A23() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0x5A23
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    lds dx, ptr [bp + 6];
    INT_21_AH3C();  // int 0x21
    $1 = pop();
    if (a < b (unsigned)) {  // jb 0x5a36
        // Block 0x5A36
        push($1);
        call 0x2d44;
        // Block 0x5A3A
        $1 = pop();
        return;  // ret 6
    } else {
        // Block 0x5A34
        jmp 0x5a3a;
        // Block 0x5A3A
        $1 = pop();
        return;  // ret 6
    }

    // Function calls:
    sub_2D44();
}

void sub_5A3E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x5A3E
    push($1);
    $1 = $2;
    $1 = $2;
    $1 -= $2;
    $1 -= $2;
    $1 = $2;
    DOS_WriteFile();  // int 0x21
    $1 = pop();
    return;  // ret 2
}

void sub_5A50() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x5A50
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    test si, 0xc000;
    if (a != b) {  // jne 0x5a6c
        // Block 0x5A6C
        $1 = 0;
        push($1);
        push($1);
        push($1);
        nop ;
        push($1);
        call 0x4e21;
        // Block 0x5A7A
        $1 += $2;
        *($1) = $2;
        test si, 0x100;
        if (a != b) {  // jne 0x5a89
            // Block 0x5A89
            and di, word ptr [0x74fc];
            $1 = $2;
            test ax, 0x180;
            if (a != b) {  // jne 0x5a9b
                // Block 0x5A9B
                cmp word ptr [bp - 2], -1;
                if (a != b) {  // jne 0x5ac4
                    // Block 0x5AC4
                    test si, 0x400;
                    if (a == b) {  // je 0x5b09
                        // Block 0x5B09
                        push($1);
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x5bbf;
                        // Block 0x5B15
                        $1 += $2;
                        $1 = $2;
                        or ax, ax;
                        if (a < b) {  // jl 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B1E
                            $1 = 0;
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x47b4;
                            // Block 0x5B27
                            $1 = pop();
                            $1 = pop();
                            *($1) = $2;
                            test ax, 0x80;
                            if (a == b) {  // je 0x5b54
                                // Block 0x5B54
                                test si, 0x200;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B5A
                                    push($1);
                                    call 0x5a3e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B31
                                or si, 0x2000;
                                test si, 0x8000;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B3B
                                    and ax, 0xff;
                                    or ax, 0x20;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x47b4;
                                    // Block 0x5B4F
                                    $1 += $2;
                                    jmp 0x5b5e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x5ACA
                        $1 = $2;
                        push($1);
                        jmp 0x5aac;
                        // Block 0x5AAC
                        call 0x2d44;
                        // Block 0x5AAF
                        jmp 0x5bb9;
                        // Block 0x5BB9
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0x5AA1
                    cmp word ptr [0x74fe], 2;
                    if (a == b) {  // je 0x5ab2
                        // Block 0x5AB2
                        test di, 0x80;
                        if (a == b) {  // je 0x5abc
                            // Block 0x5ABC
                            mov ax, 1;
                        } else {
                            // Block 0x5AB8
                            $1 = 0;
                            jmp 0x5abf;
                            // Block 0x5ABF
                            *($1) = $2;
                            jmp 0x5ad0;
                            // Block 0x5AD0
                            test si, 0xf0;
                            if (a == b) {  // je 0x5af4
                                // Block 0x5AF4
                                push($1);
                                push($1);
                                push($1);
                                call 0x5a23;
                                // Block 0x5B00
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B06
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            } else {
                                // Block 0x5AD6
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                call 0x5a23;
                                // Block 0x5AE2
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5aeb
                                    // Block 0x5AEB
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e66;
                                    // Block 0x5AF1
                                    $1 = pop();
                                    jmp 0x5b09;
                                    // Block 0x5B09
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x5bbf;
                                    // Block 0x5B15
                                    $1 += $2;
                                    $1 = $2;
                                    or ax, ax;
                                    if (a < b) {  // jl 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B1E
                                        $1 = 0;
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x47b4;
                                        // Block 0x5B27
                                        $1 = pop();
                                        $1 = pop();
                                        *($1) = $2;
                                        test ax, 0x80;
                                        if (a == b) {  // je 0x5b54
                                            // Block 0x5B54
                                            test si, 0x200;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B5A
                                                push($1);
                                                call 0x5a3e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B31
                                            or si, 0x2000;
                                            test si, 0x8000;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B3B
                                                and ax, 0xff;
                                                or ax, 0x20;
                                                $1 = 0;
                                                push($1);
                                                push($1);
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x47b4;
                                                // Block 0x5B4F
                                                $1 += $2;
                                                jmp 0x5b5e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5AE8
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            }
                        }
                    } else {
                        // Block 0x5AA8
                        push word ptr [0x74fe];
                    }
                }
            } else {
                // Block 0x5A94
                $1 = $2;
                push($1);
                call 0x2d44;
                // Block 0x5A9B
                cmp word ptr [bp - 2], -1;
                if (a != b) {  // jne 0x5ac4
                    // Block 0x5AC4
                    test si, 0x400;
                    if (a == b) {  // je 0x5b09
                        // Block 0x5B09
                        push($1);
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x5bbf;
                        // Block 0x5B15
                        $1 += $2;
                        $1 = $2;
                        or ax, ax;
                        if (a < b) {  // jl 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B1E
                            $1 = 0;
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x47b4;
                            // Block 0x5B27
                            $1 = pop();
                            $1 = pop();
                            *($1) = $2;
                            test ax, 0x80;
                            if (a == b) {  // je 0x5b54
                                // Block 0x5B54
                                test si, 0x200;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B5A
                                    push($1);
                                    call 0x5a3e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B31
                                or si, 0x2000;
                                test si, 0x8000;
                                if (a == b) {  // je 0x5b5e
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B3B
                                    and ax, 0xff;
                                    or ax, 0x20;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x47b4;
                                    // Block 0x5B4F
                                    $1 += $2;
                                    jmp 0x5b5e;
                                    // Block 0x5B5E
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B65
                                        test si, 0x100;
                                        if (a == b) {  // je 0x5b84
                                            // Block 0x5B84
                                            or di, di;
                                            if (a < b) {  // jl 0x5bb7
                                                // Block 0x5BB7
                                                mov ax, di;
                                            } else {
                                                // Block 0x5B88
                                                test si, 0x300;
                                                if (a == b) {  // je 0x5b93
                                                    // Block 0x5B93
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x5B8E
                                                    $1 = $2;
                                                    jmp 0x5b95;
                                                    // Block 0x5B95
                                                    $1 = $2;
                                                    and dx, 0xf8ff;
                                                    or dx, ax;
                                                    push($1);
                                                    test word ptr [bp - 2], 1;
                                                    if (a == b) {  // je 0x5ba9
                                                        // Block 0x5BA9
                                                        mov ax, 0x100;
                                                    } else {
                                                        // Block 0x5BA5
                                                        $1 = 0;
                                                        jmp 0x5bac;
                                                        // Block 0x5BAC
                                                        $1 = pop();
                                                        or dx, ax;
                                                        $1 = $2;
                                                        shl bx, 1;
                                                        mov word ptr [bx + 0x74d2], dx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B6B
                                            test si, 0xf0;
                                            if (a == b) {  // je 0x5b84
                                                // Block 0x5B84
                                                or di, di;
                                                if (a < b) {  // jl 0x5bb7
                                                    // Block 0x5BB7
                                                    mov ax, di;
                                                } else {
                                                    // Block 0x5B88
                                                    test si, 0x300;
                                                    if (a == b) {  // je 0x5b93
                                                        // Block 0x5B93
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x5B8E
                                                        $1 = $2;
                                                        jmp 0x5b95;
                                                        // Block 0x5B95
                                                        $1 = $2;
                                                        and dx, 0xf8ff;
                                                        or dx, ax;
                                                        push($1);
                                                        test word ptr [bp - 2], 1;
                                                        if (a == b) {  // je 0x5ba9
                                                            // Block 0x5BA9
                                                            mov ax, 0x100;
                                                        } else {
                                                            // Block 0x5BA5
                                                            $1 = 0;
                                                            jmp 0x5bac;
                                                            // Block 0x5BAC
                                                            $1 = pop();
                                                            or dx, ax;
                                                            $1 = $2;
                                                            shl bx, 1;
                                                            mov word ptr [bx + 0x74d2], dx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B71
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4e21;
                                                // Block 0x5B81
                                                add sp, 8;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x5ACA
                        $1 = $2;
                        push($1);
                        jmp 0x5aac;
                        // Block 0x5AAC
                        call 0x2d44;
                        // Block 0x5AAF
                        jmp 0x5bb9;
                        // Block 0x5BB9
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0x5AA1
                    cmp word ptr [0x74fe], 2;
                    if (a == b) {  // je 0x5ab2
                        // Block 0x5AB2
                        test di, 0x80;
                        if (a == b) {  // je 0x5abc
                            // Block 0x5ABC
                            mov ax, 1;
                        } else {
                            // Block 0x5AB8
                            $1 = 0;
                            jmp 0x5abf;
                            // Block 0x5ABF
                            *($1) = $2;
                            jmp 0x5ad0;
                            // Block 0x5AD0
                            test si, 0xf0;
                            if (a == b) {  // je 0x5af4
                                // Block 0x5AF4
                                push($1);
                                push($1);
                                push($1);
                                call 0x5a23;
                                // Block 0x5B00
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B06
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            } else {
                                // Block 0x5AD6
                                push($1);
                                push($1);
                                $1 = 0;
                                push($1);
                                call 0x5a23;
                                // Block 0x5AE2
                                $1 = $2;
                                or ax, ax;
                                if (a >= b) {  // jge 0x5aeb
                                    // Block 0x5AEB
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e66;
                                    // Block 0x5AF1
                                    $1 = pop();
                                    jmp 0x5b09;
                                    // Block 0x5B09
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x5bbf;
                                    // Block 0x5B15
                                    $1 += $2;
                                    $1 = $2;
                                    or ax, ax;
                                    if (a < b) {  // jl 0x5b84
                                        // Block 0x5B84
                                        or di, di;
                                        if (a < b) {  // jl 0x5bb7
                                            // Block 0x5BB7
                                            mov ax, di;
                                        } else {
                                            // Block 0x5B88
                                            test si, 0x300;
                                            if (a == b) {  // je 0x5b93
                                                // Block 0x5B93
                                                xor ax, ax;
                                            } else {
                                                // Block 0x5B8E
                                                $1 = $2;
                                                jmp 0x5b95;
                                                // Block 0x5B95
                                                $1 = $2;
                                                and dx, 0xf8ff;
                                                or dx, ax;
                                                push($1);
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5ba9
                                                    // Block 0x5BA9
                                                    mov ax, 0x100;
                                                } else {
                                                    // Block 0x5BA5
                                                    $1 = 0;
                                                    jmp 0x5bac;
                                                    // Block 0x5BAC
                                                    $1 = pop();
                                                    or dx, ax;
                                                    $1 = $2;
                                                    shl bx, 1;
                                                    mov word ptr [bx + 0x74d2], dx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x5B1E
                                        $1 = 0;
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x47b4;
                                        // Block 0x5B27
                                        $1 = pop();
                                        $1 = pop();
                                        *($1) = $2;
                                        test ax, 0x80;
                                        if (a == b) {  // je 0x5b54
                                            // Block 0x5B54
                                            test si, 0x200;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B5A
                                                push($1);
                                                call 0x5a3e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0x5B31
                                            or si, 0x2000;
                                            test si, 0x8000;
                                            if (a == b) {  // je 0x5b5e
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0x5B3B
                                                and ax, 0xff;
                                                or ax, 0x20;
                                                $1 = 0;
                                                push($1);
                                                push($1);
                                                $1 = $2;
                                                push($1);
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x47b4;
                                                // Block 0x5B4F
                                                $1 += $2;
                                                jmp 0x5b5e;
                                                // Block 0x5B5E
                                                test word ptr [bp - 2], 1;
                                                if (a == b) {  // je 0x5b84
                                                    // Block 0x5B84
                                                    or di, di;
                                                    if (a < b) {  // jl 0x5bb7
                                                        // Block 0x5BB7
                                                        mov ax, di;
                                                    } else {
                                                        // Block 0x5B88
                                                        test si, 0x300;
                                                        if (a == b) {  // je 0x5b93
                                                            // Block 0x5B93
                                                            xor ax, ax;
                                                        } else {
                                                            // Block 0x5B8E
                                                            $1 = $2;
                                                            jmp 0x5b95;
                                                            // Block 0x5B95
                                                            $1 = $2;
                                                            and dx, 0xf8ff;
                                                            or dx, ax;
                                                            push($1);
                                                            test word ptr [bp - 2], 1;
                                                            if (a == b) {  // je 0x5ba9
                                                                // Block 0x5BA9
                                                                mov ax, 0x100;
                                                            } else {
                                                                // Block 0x5BA5
                                                                $1 = 0;
                                                                jmp 0x5bac;
                                                                // Block 0x5BAC
                                                                $1 = pop();
                                                                or dx, ax;
                                                                $1 = $2;
                                                                shl bx, 1;
                                                                mov word ptr [bx + 0x74d2], dx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x5B65
                                                    test si, 0x100;
                                                    if (a == b) {  // je 0x5b84
                                                        // Block 0x5B84
                                                        or di, di;
                                                        if (a < b) {  // jl 0x5bb7
                                                            // Block 0x5BB7
                                                            mov ax, di;
                                                        } else {
                                                            // Block 0x5B88
                                                            test si, 0x300;
                                                            if (a == b) {  // je 0x5b93
                                                                // Block 0x5B93
                                                                xor ax, ax;
                                                            } else {
                                                                // Block 0x5B8E
                                                                $1 = $2;
                                                                jmp 0x5b95;
                                                                // Block 0x5B95
                                                                $1 = $2;
                                                                and dx, 0xf8ff;
                                                                or dx, ax;
                                                                push($1);
                                                                test word ptr [bp - 2], 1;
                                                                if (a == b) {  // je 0x5ba9
                                                                    // Block 0x5BA9
                                                                    mov ax, 0x100;
                                                                } else {
                                                                    // Block 0x5BA5
                                                                    $1 = 0;
                                                                    jmp 0x5bac;
                                                                    // Block 0x5BAC
                                                                    $1 = pop();
                                                                    or dx, ax;
                                                                    $1 = $2;
                                                                    shl bx, 1;
                                                                    mov word ptr [bx + 0x74d2], dx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x5B6B
                                                        test si, 0xf0;
                                                        if (a == b) {  // je 0x5b84
                                                            // Block 0x5B84
                                                            or di, di;
                                                            if (a < b) {  // jl 0x5bb7
                                                                // Block 0x5BB7
                                                                mov ax, di;
                                                            } else {
                                                                // Block 0x5B88
                                                                test si, 0x300;
                                                                if (a == b) {  // je 0x5b93
                                                                    // Block 0x5B93
                                                                    xor ax, ax;
                                                                } else {
                                                                    // Block 0x5B8E
                                                                    $1 = $2;
                                                                    jmp 0x5b95;
                                                                    // Block 0x5B95
                                                                    $1 = $2;
                                                                    and dx, 0xf8ff;
                                                                    or dx, ax;
                                                                    push($1);
                                                                    test word ptr [bp - 2], 1;
                                                                    if (a == b) {  // je 0x5ba9
                                                                        // Block 0x5BA9
                                                                        mov ax, 0x100;
                                                                    } else {
                                                                        // Block 0x5BA5
                                                                        $1 = 0;
                                                                        jmp 0x5bac;
                                                                        // Block 0x5BAC
                                                                        $1 = pop();
                                                                        or dx, ax;
                                                                        $1 = $2;
                                                                        shl bx, 1;
                                                                        mov word ptr [bx + 0x74d2], dx;
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x5B71
                                                            $1 = $2;
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            nop ;
                                                            push($1);
                                                            call 0x4e21;
                                                            // Block 0x5B81
                                                            add sp, 8;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5AE8
                                    jmp 0x5bb7;
                                    // Block 0x5BB7
                                    mov ax, di;
                                }
                            }
                        }
                    } else {
                        // Block 0x5AA8
                        push word ptr [0x74fe];
                    }
                }
            }
        } else {
            // Block 0x5A86
            jmp 0x5b09;
            // Block 0x5B09
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x5bbf;
            // Block 0x5B15
            $1 += $2;
            $1 = $2;
            or ax, ax;
            if (a < b) {  // jl 0x5b84
                // Block 0x5B84
                or di, di;
                if (a < b) {  // jl 0x5bb7
                    // Block 0x5BB7
                    mov ax, di;
                } else {
                    // Block 0x5B88
                    test si, 0x300;
                    if (a == b) {  // je 0x5b93
                        // Block 0x5B93
                        xor ax, ax;
                    } else {
                        // Block 0x5B8E
                        $1 = $2;
                        jmp 0x5b95;
                        // Block 0x5B95
                        $1 = $2;
                        and dx, 0xf8ff;
                        or dx, ax;
                        push($1);
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5ba9
                            // Block 0x5BA9
                            mov ax, 0x100;
                        } else {
                            // Block 0x5BA5
                            $1 = 0;
                            jmp 0x5bac;
                            // Block 0x5BAC
                            $1 = pop();
                            or dx, ax;
                            $1 = $2;
                            shl bx, 1;
                            mov word ptr [bx + 0x74d2], dx;
                        }
                    }
                }
            } else {
                // Block 0x5B1E
                $1 = 0;
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x47b4;
                // Block 0x5B27
                $1 = pop();
                $1 = pop();
                *($1) = $2;
                test ax, 0x80;
                if (a == b) {  // je 0x5b54
                    // Block 0x5B54
                    test si, 0x200;
                    if (a == b) {  // je 0x5b5e
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    } else {
                        // Block 0x5B5A
                        push($1);
                        call 0x5a3e;
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    }
                } else {
                    // Block 0x5B31
                    or si, 0x2000;
                    test si, 0x8000;
                    if (a == b) {  // je 0x5b5e
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    } else {
                        // Block 0x5B3B
                        and ax, 0xff;
                        or ax, 0x20;
                        $1 = 0;
                        push($1);
                        push($1);
                        $1 = $2;
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x47b4;
                        // Block 0x5B4F
                        $1 += $2;
                        jmp 0x5b5e;
                        // Block 0x5B5E
                        test word ptr [bp - 2], 1;
                        if (a == b) {  // je 0x5b84
                            // Block 0x5B84
                            or di, di;
                            if (a < b) {  // jl 0x5bb7
                                // Block 0x5BB7
                                mov ax, di;
                            } else {
                                // Block 0x5B88
                                test si, 0x300;
                                if (a == b) {  // je 0x5b93
                                    // Block 0x5B93
                                    xor ax, ax;
                                } else {
                                    // Block 0x5B8E
                                    $1 = $2;
                                    jmp 0x5b95;
                                    // Block 0x5B95
                                    $1 = $2;
                                    and dx, 0xf8ff;
                                    or dx, ax;
                                    push($1);
                                    test word ptr [bp - 2], 1;
                                    if (a == b) {  // je 0x5ba9
                                        // Block 0x5BA9
                                        mov ax, 0x100;
                                    } else {
                                        // Block 0x5BA5
                                        $1 = 0;
                                        jmp 0x5bac;
                                        // Block 0x5BAC
                                        $1 = pop();
                                        or dx, ax;
                                        $1 = $2;
                                        shl bx, 1;
                                        mov word ptr [bx + 0x74d2], dx;
                                    }
                                }
                            }
                        } else {
                            // Block 0x5B65
                            test si, 0x100;
                            if (a == b) {  // je 0x5b84
                                // Block 0x5B84
                                or di, di;
                                if (a < b) {  // jl 0x5bb7
                                    // Block 0x5BB7
                                    mov ax, di;
                                } else {
                                    // Block 0x5B88
                                    test si, 0x300;
                                    if (a == b) {  // je 0x5b93
                                        // Block 0x5B93
                                        xor ax, ax;
                                    } else {
                                        // Block 0x5B8E
                                        $1 = $2;
                                        jmp 0x5b95;
                                        // Block 0x5B95
                                        $1 = $2;
                                        and dx, 0xf8ff;
                                        or dx, ax;
                                        push($1);
                                        test word ptr [bp - 2], 1;
                                        if (a == b) {  // je 0x5ba9
                                            // Block 0x5BA9
                                            mov ax, 0x100;
                                        } else {
                                            // Block 0x5BA5
                                            $1 = 0;
                                            jmp 0x5bac;
                                            // Block 0x5BAC
                                            $1 = pop();
                                            or dx, ax;
                                            $1 = $2;
                                            shl bx, 1;
                                            mov word ptr [bx + 0x74d2], dx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x5B6B
                                test si, 0xf0;
                                if (a == b) {  // je 0x5b84
                                    // Block 0x5B84
                                    or di, di;
                                    if (a < b) {  // jl 0x5bb7
                                        // Block 0x5BB7
                                        mov ax, di;
                                    } else {
                                        // Block 0x5B88
                                        test si, 0x300;
                                        if (a == b) {  // je 0x5b93
                                            // Block 0x5B93
                                            xor ax, ax;
                                        } else {
                                            // Block 0x5B8E
                                            $1 = $2;
                                            jmp 0x5b95;
                                            // Block 0x5B95
                                            $1 = $2;
                                            and dx, 0xf8ff;
                                            or dx, ax;
                                            push($1);
                                            test word ptr [bp - 2], 1;
                                            if (a == b) {  // je 0x5ba9
                                                // Block 0x5BA9
                                                mov ax, 0x100;
                                            } else {
                                                // Block 0x5BA5
                                                $1 = 0;
                                                jmp 0x5bac;
                                                // Block 0x5BAC
                                                $1 = pop();
                                                or dx, ax;
                                                $1 = $2;
                                                shl bx, 1;
                                                mov word ptr [bx + 0x74d2], dx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x5B71
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4e21;
                                    // Block 0x5B81
                                    add sp, 8;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Block 0x5A64
        $1 = $2;
        and ax, 0xc000;
        or si, ax;
    }

    // Function calls:
    sub_4E21();
    sub_2D44();
    sub_2D44();
    sub_5A23();
    sub_4E66();
    sub_5A23();
    sub_5BBF();
    sub_47B4();
    sub_47B4();
    sub_5A3E();
    sub_4E21();
}

void sub_5BBF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x5BBF
    push($1);
    $1 = $2;
    $1 -= $2;
    $1 = $2;
    $1 = $2;
    test cx, 2;
    if (a != b) {  // jne 0x5bda
        // Block 0x5BDA
        push($1);
        lds dx, ptr [bp + 6];
        $1 = $2;
        and cl, byte ptr [bp + 0xa];
        or al, cl;
        $1 = $2;
        DOS_OpenFile();  // int 0x21
        $1 = pop();
        if (a < b (unsigned)) {  // jb 0x5c06
            // Block 0x5C06
            push($1);
            call 0x2d44;
            // Block 0x5C0A
            $1 = $2;
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x5BEC
            *($1) = $2;
            $1 = $2;
            and ax, 0xb8ff;
            or ax, 0x8000;
            $1 = $2;
            shl bx, 1;
            *($1) = $2;
            $1 = $2;
            jmp 0x5c0a;
            // Block 0x5C0A
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x5BD0
        $1 = $2;
        test cx, 4;
        if (a != b) {  // jne 0x5bda
            // Block 0x5BDA
            push($1);
            lds dx, ptr [bp + 6];
            $1 = $2;
            and cl, byte ptr [bp + 0xa];
            or al, cl;
            $1 = $2;
            DOS_OpenFile();  // int 0x21
            $1 = pop();
            if (a < b (unsigned)) {  // jb 0x5c06
                // Block 0x5C06
                push($1);
                call 0x2d44;
                // Block 0x5C0A
                $1 = $2;
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0x5BEC
                *($1) = $2;
                $1 = $2;
                and ax, 0xb8ff;
                or ax, 0x8000;
                $1 = $2;
                shl bx, 1;
                *($1) = $2;
                $1 = $2;
                jmp 0x5c0a;
                // Block 0x5C0A
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        } else {
            // Block 0x5BD8
            mov al, 0;
        }
    }

    // Function calls:
    sub_2D44();
    sub_3935();
}

void sub_5C29() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0x5C29
    push($1);
    $1 = $2;
    les bx, ptr [bp + 8];
    $1--;
    push($1);
    push($1);
    $1 = $2;
    cwde ;
    push($1);
    nop ;
    push($1);
    call 0x5c45;
    // Block 0x5C40
    $1 += $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_5C45();
}

void sub_5C45() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 20 if statements

    // Block 0x5C45
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 8];
    cmp word ptr es:[bx], -1;
    if (a >= b) {  // jge 0x5cac
        // Block 0x5CAC
        les bx, ptr [bp + 8];
        test word ptr es:[bx + 2], 0x90;
        if (a != b) {  // jne 0x5cbf
            // Block 0x5CBF
            les bx, ptr [bp + 8];
            or word ptr es:[bx + 2], 0x10;
            jmp 0x5ca3;
            // Block 0x5CA3
            $1 = $2;
            goto $1;
            jmp 0x5dd2;
            // Block 0x5DD2
            $1 = $2;
            mov ah, 0;
        } else {
            // Block 0x5CB7
            test word ptr es:[bx + 2], 2;
            if (a != b) {  // jne 0x5cc9
                // Block 0x5CC9
                les bx, ptr [bp + 8];
                or word ptr es:[bx + 2], 0x100;
                cmp word ptr es:[bx + 6], 0;
                if (a == b) {  // je 0x5d48
                    // Block 0x5D48
                    les bx, ptr [bp + 8];
                    $1 = $2;
                    cwde ;
                    shl ax, 1;
                    $1 = $2;
                    test word ptr [bx + 0x74d2], 0x800;
                    if (a == b) {  // je 0x5d77
                        // Block 0x5D77
                        cmp byte ptr [0x8792], 0xa;
                        if (a != b) {  // jne 0x5da5
                            // Block 0x5DA5
                            $1 = $2;
                            push($1);
                            push($1);
                            $1 = $2;
                            push($1);
                            les bx, ptr [bp + 8];
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x68ed;
                            // Block 0x5DBC
                            $1 += $2;
                            // Compare $1 with $2
                            if (a == b) {  // je 0x5dd2
                                // Block 0x5DD2
                                $1 = $2;
                                mov ah, 0;
                            } else {
                                // Block 0x5DC4
                                les bx, ptr [bp + 8];
                                test word ptr es:[bx + 2], 0x200;
                                if (a != b) {  // jne 0x5dd2
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                } else {
                                    // Block 0x5DCF
                                    jmp 0x5cbf;
                                    // Block 0x5CBF
                                    les bx, ptr [bp + 8];
                                    or word ptr es:[bx + 2], 0x10;
                                    jmp 0x5ca3;
                                    // Block 0x5CA3
                                    $1 = $2;
                                    goto $1;
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                }
                            }
                        } else {
                            // Block 0x5D7E
                            les bx, ptr [bp + 8];
                            test word ptr es:[bx + 2], 0x40;
                            if (a != b) {  // jne 0x5da5
                                // Block 0x5DA5
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                les bx, ptr [bp + 8];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x68ed;
                                // Block 0x5DBC
                                $1 += $2;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x5dd2
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                } else {
                                    // Block 0x5DC4
                                    les bx, ptr [bp + 8];
                                    test word ptr es:[bx + 2], 0x200;
                                    if (a != b) {  // jne 0x5dd2
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5DCF
                                        jmp 0x5cbf;
                                        // Block 0x5CBF
                                        les bx, ptr [bp + 8];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5ca3;
                                        // Block 0x5CA3
                                        $1 = $2;
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                }
                            } else {
                                // Block 0x5D89
                                $1 = $2;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x68ed;
                                // Block 0x5D9D
                                $1 += $2;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x5dc4
                                    // Block 0x5DC4
                                    les bx, ptr [bp + 8];
                                    test word ptr es:[bx + 2], 0x200;
                                    if (a != b) {  // jne 0x5dd2
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5DCF
                                        jmp 0x5cbf;
                                        // Block 0x5CBF
                                        les bx, ptr [bp + 8];
                                        or word ptr es:[bx + 2], 0x10;
                                        jmp 0x5ca3;
                                        // Block 0x5CA3
                                        $1 = $2;
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                } else {
                                    // Block 0x5DA5
                                    $1 = $2;
                                    push($1);
                                    push($1);
                                    $1 = $2;
                                    push($1);
                                    les bx, ptr [bp + 8];
                                    $1 = $2;
                                    cwde ;
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x68ed;
                                    // Block 0x5DBC
                                    $1 += $2;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x5dd2
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5DC4
                                        les bx, ptr [bp + 8];
                                        test word ptr es:[bx + 2], 0x200;
                                        if (a != b) {  // jne 0x5dd2
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        } else {
                                            // Block 0x5DCF
                                            jmp 0x5cbf;
                                            // Block 0x5CBF
                                            les bx, ptr [bp + 8];
                                            or word ptr es:[bx + 2], 0x10;
                                            jmp 0x5ca3;
                                            // Block 0x5CA3
                                            $1 = $2;
                                            goto $1;
                                            jmp 0x5dd2;
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0x5D5C
                        $1 = $2;
                        push($1);
                        $1 = 0;
                        $1 = 0;
                        push($1);
                        push($1);
                        $1 = $2;
                        $1 = $2;
                        cwde ;
                        push($1);
                        nop ;
                        push($1);
                        call 0x3001;
                        // Block 0x5D74
                        add sp, 8;
                    }
                } else {
                    // Block 0x5CD9
                    cmp word ptr es:[bx], 0;
                    if (a == b) {  // je 0x5cee
                        // Block 0x5CEE
                        les bx, ptr [bp + 8];
                        $1 = $2;
                        neg ax;
                        mov word ptr es:[bx], ax;
                        $1 = $2;
                        $1 = $2;
                        $1++;
                        $1 = $2;
                        $1 = $2;
                        mov byte ptr es:[si], dl;
                        $1 = $2;
                        test word ptr es:[bx + 2], 8;
                        if (a != b) {  // jne 0x5d1d
                            // Block 0x5D1D
                            cmp byte ptr [0x8792], 0xa;
                            if (a == b) {  // je 0x5d2e
                                // Block 0x5D2E
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x4fb3;
                                // Block 0x5D39
                                $1 = pop();
                                $1 = pop();
                                or ax, ax;
                                if (a != b) {  // jne 0x5d42
                                    // Block 0x5D42
                                    goto $1;
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                } else {
                                    // Block 0x5D3F
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                }
                            } else {
                                // Block 0x5D24
                                cmp byte ptr [0x8792], 0xd;
                                if (a == b) {  // je 0x5d2e
                                    // Block 0x5D2E
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4fb3;
                                    // Block 0x5D39
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a != b) {  // jne 0x5d42
                                        // Block 0x5D42
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5D3F
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                } else {
                                    // Block 0x5D2B
                                    jmp 0x5dd2;
                                    // Block 0x5DD2
                                    $1 = $2;
                                    mov ah, 0;
                                }
                            }
                        } else {
                            // Block 0x5D1A
                            jmp 0x5dd2;
                            // Block 0x5DD2
                            $1 = $2;
                            mov ah, 0;
                        }
                    } else {
                        // Block 0x5CDF
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x4fb3;
                        // Block 0x5CE8
                        $1 = pop();
                        $1 = pop();
                        or ax, ax;
                        if (a != b) {  // jne 0x5ca3
                            // Block 0x5CA3
                            $1 = $2;
                            goto $1;
                            jmp 0x5dd2;
                            // Block 0x5DD2
                            $1 = $2;
                            mov ah, 0;
                        } else {
                            // Block 0x5CEE
                            les bx, ptr [bp + 8];
                            $1 = $2;
                            neg ax;
                            mov word ptr es:[bx], ax;
                            $1 = $2;
                            $1 = $2;
                            $1++;
                            $1 = $2;
                            $1 = $2;
                            mov byte ptr es:[si], dl;
                            $1 = $2;
                            test word ptr es:[bx + 2], 8;
                            if (a != b) {  // jne 0x5d1d
                                // Block 0x5D1D
                                cmp byte ptr [0x8792], 0xa;
                                if (a == b) {  // je 0x5d2e
                                    // Block 0x5D2E
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x4fb3;
                                    // Block 0x5D39
                                    $1 = pop();
                                    $1 = pop();
                                    or ax, ax;
                                    if (a != b) {  // jne 0x5d42
                                        // Block 0x5D42
                                        goto $1;
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    } else {
                                        // Block 0x5D3F
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                } else {
                                    // Block 0x5D24
                                    cmp byte ptr [0x8792], 0xd;
                                    if (a == b) {  // je 0x5d2e
                                        // Block 0x5D2E
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x4fb3;
                                        // Block 0x5D39
                                        $1 = pop();
                                        $1 = pop();
                                        or ax, ax;
                                        if (a != b) {  // jne 0x5d42
                                            // Block 0x5D42
                                            goto $1;
                                            jmp 0x5dd2;
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        } else {
                                            // Block 0x5D3F
                                            jmp 0x5dd2;
                                            // Block 0x5DD2
                                            $1 = $2;
                                            mov ah, 0;
                                        }
                                    } else {
                                        // Block 0x5D2B
                                        jmp 0x5dd2;
                                        // Block 0x5DD2
                                        $1 = $2;
                                        mov ah, 0;
                                    }
                                }
                            } else {
                                // Block 0x5D1A
                                jmp 0x5dd2;
                                // Block 0x5DD2
                                $1 = $2;
                                mov ah, 0;
                            }
                        }
                    }
                }
            } else {
                // Block 0x5CBF
                les bx, ptr [bp + 8];
                or word ptr es:[bx + 2], 0x10;
                jmp 0x5ca3;
                // Block 0x5CA3
                $1 = $2;
                goto $1;
                jmp 0x5dd2;
                // Block 0x5DD2
                $1 = $2;
                mov ah, 0;
            }
        }
    } else {
        // Block 0x5C58
        $1++;
        $1 = $2;
        $1 = $2;
        $1++;
        $1 = $2;
        $1 = $2;
        mov byte ptr es:[si], dl;
        $1 = $2;
        test word ptr es:[bx + 2], 8;
        if (a != b) {  // jne 0x5c7e
            // Block 0x5C7E
            cmp byte ptr [0x8792], 0xa;
            if (a == b) {  // je 0x5c8f
                // Block 0x5C8F
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x4fb3;
                // Block 0x5C9A
                $1 = pop();
                $1 = pop();
                or ax, ax;
                if (a != b) {  // jne 0x5ca3
                    // Block 0x5CA3
                    $1 = $2;
                    goto $1;
                    jmp 0x5dd2;
                    // Block 0x5DD2
                    $1 = $2;
                    mov ah, 0;
                } else {
                    // Block 0x5CA0
                    jmp 0x5dd2;
                    // Block 0x5DD2
                    $1 = $2;
                    mov ah, 0;
                }
            } else {
                // Block 0x5C85
                cmp byte ptr [0x8792], 0xd;
                if (a == b) {  // je 0x5c8f
                    // Block 0x5C8F
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x4fb3;
                    // Block 0x5C9A
                    $1 = pop();
                    $1 = pop();
                    or ax, ax;
                    if (a != b) {  // jne 0x5ca3
                        // Block 0x5CA3
                        $1 = $2;
                        goto $1;
                        jmp 0x5dd2;
                        // Block 0x5DD2
                        $1 = $2;
                        mov ah, 0;
                    } else {
                        // Block 0x5CA0
                        jmp 0x5dd2;
                        // Block 0x5DD2
                        $1 = $2;
                        mov ah, 0;
                    }
                } else {
                    // Block 0x5C8C
                    jmp 0x5dd2;
                    // Block 0x5DD2
                    $1 = $2;
                    mov ah, 0;
                }
            }
        } else {
            // Block 0x5C7B
            jmp 0x5dd2;
            // Block 0x5DD2
            $1 = $2;
            mov ah, 0;
        }
    }

    // Function calls:
    sub_4FB3();
    sub_4FB3();
    sub_4FB3();
    sub_3001();
    sub_68ED();
    sub_68ED();
    sub_5C45();
}

void sub_5DEE() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 loops
    // - 20 if statements

    // Block 0x5DEE
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    *($1) = $2;
    les bx, ptr [bp + 4];
    test word ptr es:[bx + 2], 8;
    if (a == b) {  // je 0x5e35
        // Block 0x5E35
        les bx, ptr [bp + 4];
        test word ptr es:[bx + 2], 0x40;
        if (a != b) {  // jne 0x5e43
            // Block 0x5E43
            cmp word ptr es:[bx + 6], 0;
            if (a != b) {  // jne 0x5e4d
                // Block 0x5E4D
                cmp word ptr es:[bx + 6], di;
                if (a >= b (unsigned)) {  // jae 0x5ebc
                    // Block 0x5EBC
                    les bx, ptr [bp + 4];
                    $1 = $2;
                    $1 += $2;
                    if (a < b) {  // jl 0x5eec
                        // Block 0x5EEC
                        push($1);
                        push($1);
                        push($1);
                        les bx, ptr [bp + 4];
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x59ff;
                        // Block 0x5F03
                        $1 += $2;
                        les bx, ptr [bp + 4];
                        $1 = $2;
                        $1 += $2;
                        mov word ptr es:[bx], ax;
                        add word ptr es:[bx + 0xc], di;
                        jmp 0x5fe6;
                        // Block 0x5FE6
                        mov ax, word ptr [bp - 2];
                    } else {
                        // Block 0x5EC6
                        cmp word ptr es:[bx], 0;
                        if (a != b) {  // jne 0x5ed8
                            // Block 0x5ED8
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x4fb3;
                            // Block 0x5EE3
                            $1 = pop();
                            $1 = pop();
                            or ax, ax;
                            if (a == b) {  // je 0x5eec
                                // Block 0x5EEC
                                push($1);
                                push($1);
                                push($1);
                                les bx, ptr [bp + 4];
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x59ff;
                                // Block 0x5F03
                                $1 += $2;
                                les bx, ptr [bp + 4];
                                $1 = $2;
                                $1 += $2;
                                mov word ptr es:[bx], ax;
                                add word ptr es:[bx + 0xc], di;
                                jmp 0x5fe6;
                                // Block 0x5FE6
                                mov ax, word ptr [bp - 2];
                            } else {
                                // Block 0x5EE9
                                jmp 0x5e26;
                                // Block 0x5E26
                                $1 = 0;
                                jmp 0x5fe9;
                                // Block 0x5FE9
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // ret 0xa
                            }
                        } else {
                            // Block 0x5ECC
                            $1 = $2;
                            $1 -= $2;
                            mov word ptr es:[bx], ax;
                            jmp 0x5eec;
                            // Block 0x5EEC
                            push($1);
                            push($1);
                            push($1);
                            les bx, ptr [bp + 4];
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x59ff;
                            // Block 0x5F03
                            $1 += $2;
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            $1 += $2;
                            mov word ptr es:[bx], ax;
                            add word ptr es:[bx + 0xc], di;
                            jmp 0x5fe6;
                            // Block 0x5FE6
                            mov ax, word ptr [bp - 2];
                        }
                    }
                } else {
                    // Block 0x5E53
                    cmp word ptr es:[bx], 0;
                    if (a == b) {  // je 0x5e68
                        // Block 0x5E68
                        les bx, ptr [bp + 4];
                        $1 = $2;
                        cwde ;
                        shl ax, 1;
                        $1 = $2;
                        test word ptr [bx + 0x74d2], 0x800;
                        if (a == b) {  // je 0x5e97
                            // Block 0x5E97
                            push($1);
                            push($1);
                            push($1);
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x68ed;
                            // Block 0x5EAC
                            $1 += $2;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x5eb6
                                // Block 0x5EB6
                                goto $1;
                                jmp 0x5fe6;
                                // Block 0x5FE6
                                mov ax, word ptr [bp - 2];
                            } else {
                                // Block 0x5EB3
                                jmp 0x5fe6;
                                // Block 0x5FE6
                                mov ax, word ptr [bp - 2];
                            }
                        } else {
                            // Block 0x5E7C
                            $1 = $2;
                            push($1);
                            $1 = 0;
                            $1 = 0;
                            push($1);
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            cwde ;
                            push($1);
                            nop ;
                            push($1);
                            call 0x3001;
                            // Block 0x5E94
                            add sp, 8;
                        }
                    } else {
                        // Block 0x5E59
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x4fb3;
                        // Block 0x5E62
                        $1 = pop();
                        $1 = pop();
                        or ax, ax;
                        if (a != b) {  // jne 0x5e26
                            // Block 0x5E26
                            $1 = 0;
                            jmp 0x5fe9;
                            // Block 0x5FE9
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 0xa
                        } else {
                            // Block 0x5E68
                            les bx, ptr [bp + 4];
                            $1 = $2;
                            cwde ;
                            shl ax, 1;
                            $1 = $2;
                            test word ptr [bx + 0x74d2], 0x800;
                            if (a == b) {  // je 0x5e97
                                // Block 0x5E97
                                push($1);
                                push($1);
                                push($1);
                                les bx, ptr [bp + 4];
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x68ed;
                                // Block 0x5EAC
                                $1 += $2;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x5eb6
                                    // Block 0x5EB6
                                    goto $1;
                                    jmp 0x5fe6;
                                    // Block 0x5FE6
                                    mov ax, word ptr [bp - 2];
                                } else {
                                    // Block 0x5EB3
                                    jmp 0x5fe6;
                                    // Block 0x5FE6
                                    mov ax, word ptr [bp - 2];
                                }
                            } else {
                                // Block 0x5E7C
                                $1 = $2;
                                push($1);
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                cwde ;
                                push($1);
                                nop ;
                                push($1);
                                call 0x3001;
                                // Block 0x5E94
                                add sp, 8;
                            }
                        }
                    }
                }
            } else {
                // Block 0x5E4A
                jmp 0x5f18;
                // Block 0x5F18
                les bx, ptr [bp + 4];
                $1 = $2;
                cwde ;
                shl ax, 1;
                $1 = $2;
                test word ptr [bx + 0x74d2], 0x800;
                if (a == b) {  // je 0x5f47
                    // Block 0x5F47
                    push($1);
                    push($1);
                    push($1);
                    les bx, ptr [bp + 4];
                    $1 = $2;
                    cwde ;
                    push($1);
                    nop ;
                    push($1);
                    call 0x68ed;
                    // Block 0x5F5C
                    $1 += $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x5f66
                        // Block 0x5F66
                        goto $1;
                        jmp 0x5fe6;
                        // Block 0x5FE6
                        mov ax, word ptr [bp - 2];
                    } else {
                        // Block 0x5F63
                        jmp 0x5fe6;
                        // Block 0x5FE6
                        mov ax, word ptr [bp - 2];
                    }
                } else {
                    // Block 0x5F2C
                    $1 = $2;
                    push($1);
                    $1 = 0;
                    $1 = 0;
                    push($1);
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    cwde ;
                    push($1);
                    nop ;
                    push($1);
                    call 0x3001;
                    // Block 0x5F44
                    add sp, 8;
                }
            }
        } else {
            // Block 0x5E40
            jmp 0x5f6b;
            // Block 0x5F6B
            les bx, ptr [bp + 4];
            cmp word ptr es:[bx + 6], 0;
            if (a == b) {  // je 0x5fc7
                // Block 0x5FC7
                push($1);
                push($1);
                push($1);
                les bx, ptr [bp + 4];
                $1 = $2;
                cwde ;
                push($1);
                nop ;
                push($1);
                call 0x679c;
                // Block 0x5FDC
                $1 += $2;
                // Compare $1 with $2
                if (a == b) {  // je 0x5fe6
                    // Block 0x5FE6
                    mov ax, word ptr [bp - 2];
                } else {
                    // Block 0x5FE3
                    jmp 0x5e26;
                    // Block 0x5E26
                    $1 = 0;
                    jmp 0x5fe9;
                    // Block 0x5FE9
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // ret 0xa
                }
            } else {
                // Block 0x5F75
                jmp 0x5fbe;
                // Block 0x5FBE
                $1 = $2;
                $1--;
                or ax, ax;
                if (a != b) {  // jne 0x5f77
                    // Block 0x5F77
                    les bx, ptr [bp + 4];
                    $1++;
                    if (a >= b) {  // jge 0x5f9f
                        // Block 0x5F9F
                        push($1);
                        push($1);
                        les bx, ptr [bp + 0xa];
                        $1++;
                        $1 = $2;
                        push($1);
                        push($1);
                        call 0x5c29;
                        // Block 0x5FB3
                        add sp, 6;
                    } else {
                        // Block 0x5F7F
                        $1 = $2;
                        $1 = $2;
                        $1++;
                        les bx, ptr [bp + 0xa];
                        $1++;
                        $1 = $2;
                        $1 = $2;
                        mov byte ptr es:[si], dl;
                        $1 = $2;
                        $1 = $2;
                        jmp 0x5fb6;
                        // Block 0x5FB6
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x5fbe
                            // Jump to block at 0x5FBE
                        } else {
                            // Block 0x5FBB
                            jmp 0x5e26;
                            // Block 0x5E26
                            $1 = 0;
                            jmp 0x5fe9;
                            // Block 0x5FE9
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // ret 0xa
                        }
                    }
                } else {
                    // Block 0x5FC5
                    jmp 0x5fe6;
                    // Block 0x5FE6
                    mov ax, word ptr [bp - 2];
                }
            }
        }
    } else {
        // Block 0x5E07
        jmp 0x5e2b;
        // Block 0x5E2B
        $1 = $2;
        $1--;
        or ax, ax;
        if (a != b) {  // jne 0x5e09
            // Block 0x5E09
            push($1);
            push($1);
            les bx, ptr [bp + 0xa];
            $1++;
            $1 = $2;
            cwde ;
            push($1);
            push($1);
            call 0x5c45;
            // Block 0x5E1E
            $1 += $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x5e2b
                // Jump to block at 0x5E2B
            } else {
                // Block 0x5E26
                $1 = 0;
                jmp 0x5fe9;
                // Block 0x5FE9
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // ret 0xa
            }
        } else {
            // Block 0x5E32
            jmp 0x5fe6;
            // Block 0x5FE6
            mov ax, word ptr [bp - 2];
        }
    }

    // Function calls:
    sub_5C45();
    sub_4FB3();
    sub_3001();
    sub_68ED();
    sub_4FB3();
    sub_59FF();
    sub_3001();
    sub_68ED();
    sub_5C29();
    sub_679C();
}

void sub_5FF1() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 loops
    // - 8 if statements

    // Block 0x5FF1
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x600c
        // Block 0x600C
        $1 = $2;
        $1++;
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x6022
            // Block 0x6022
            $1 = 0;
            jmp 0x60bc;
            // Block 0x60BC
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x6015
            $1 = $2;
            shl bx, 1;
            test word ptr [bx + 0x74d2], 0x200;
            if (a == b) {  // je 0x6027
                // Block 0x6027
                push($1);
                push($1);
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x3118;
                // Block 0x6038
                $1 += $2;
                *($1) = $2;
                $1++;
                // Compare $1 with $2
                if (a < b (unsigned)) {  // jb 0x6051
                    // Block 0x6051
                    $1 = $2;
                    jmp 0x60bc;
                    // Block 0x60BC
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x6044
                    $1 = $2;
                    shl bx, 1;
                    test word ptr [bx + 0x74d2], 0x4000;
                    if (a != b) {  // jne 0x6056
                        // Block 0x6056
                        $1 = $2;
                        les si, ptr [bp + 8];
                        $1 = $2;
                        $1 = $2;
                        cld ;
                        lodsb al, byte ptr es:[si];
                        // Compare $1 with $2
                        if (a == b) {  // je 0x6097
                            // Block 0x6097
                            push($1);
                            $1 = $2;
                            push($1);
                            neg cx;
                            sbb ax, ax;
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x3001;
                            // Block 0x60AA
                            $1 += $2;
                            $1 = $2;
                            shl bx, 1;
                            or word ptr [bx + 0x74d2], 0x200;
                            pop bx;
                        } else {
                            // Block 0x6067
                            // Compare $1 with $2
                            if (a == b) {  // je 0x6070
                                // Block 0x6070
                                loop 0x6061;
                                push($1);
                                push($1);
                                $1 = $2;
                                push($1);
                                lea ax, [bp - 3];
                                push($1);
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x3118;
                                // Block 0x6085
                                $1 += $2;
                                $1 = pop();
                                $1 = pop();
                                cld ;
                                $1 = $2;
                                stosb byte ptr es:[di], al;
                            } else {
                                // Block 0x606B
                                stosb byte ptr es:[di], al;
                                loop 0x6061;
                                jmp 0x608f;
                                // Block 0x608F
                                // Compare $1 with $2
                                if (a != b) {  // jne 0x6095
                                    // Block 0x6095
                                    jmp 0x60b9;
                                    // Block 0x60B9
                                    $1 -= $2;
                                    xchg di, ax;
                                } else {
                                    // Block 0x6093
                                    jmp 0x6027;
                                }
                            }
                        }
                    } else {
                        // Block 0x6051
                        $1 = $2;
                        jmp 0x60bc;
                        // Block 0x60BC
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0x6022
                $1 = 0;
                jmp 0x60bc;
                // Block 0x60BC
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        }
    } else {
        // Block 0x6002
        $1 = $2;
        push($1);
        call 0x2d44;
        // Block 0x6009
        jmp 0x60bc;
        // Block 0x60BC
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
    sub_3118();
    sub_3118();
    sub_3001();
}

void sub_60C5() {
    // Variable declarations
    int var_7334;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x60C5
    push($1);
    $1 = $2;
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les bx, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0x60e7
        // Block 0x60E7
        $1 = $2;
        jmp 0x61de;
        // Block 0x61DE
        $1 = pop();
        $1 = pop();
        $1 = pop();
        return;  // retf 
    } else {
        // Block 0x60DC
        // Compare $1 with $2
        if (a > b) {  // jg 0x60e7
            // Block 0x60E7
            $1 = $2;
            jmp 0x61de;
            // Block 0x61DE
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x60E1
            // Compare $1 with $2
            if (a <= b (unsigned)) {  // jbe 0x60ed
                // Block 0x60ED
                cmp word ptr [0x76ae], 0;
                if (a != b) {  // jne 0x6103
                    // Block 0x6103
                    cmp word ptr [0x76ac], 0;
                    if (a != b) {  // jne 0x6117
                        // Block 0x6117
                        les bx, ptr [bp + 6];
                        cmp word ptr es:[bx], 0;
                        if (a == b) {  // je 0x6136
                            // Block 0x6136
                            les bx, ptr [bp + 6];
                            test word ptr es:[bx + 2], 4;
                            if (a == b) {  // je 0x6150
                                // Block 0x6150
                                les bx, ptr [bp + 6];
                                and word ptr es:[bx + 2], 0xfff3;
                                mov word ptr es:[bx + 6], 0;
                                $1 = $2;
                                $1 = $2;
                                $1 += $2;
                                mov word ptr es:[bx + 0xa], ax;
                                mov word ptr es:[bx + 8], dx;
                                mov word ptr es:[bx + 0xe], ax;
                                mov word ptr es:[bx + 0xc], dx;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x61dc
                                    // Block 0x61DC
                                    xor ax, ax;
                                } else {
                                    // Block 0x617C
                                    or si, si;
                                    if (a <= b (unsigned)) {  // jbe 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x6180
                                        mov word ptr [0x7336], 0;
                                        mov word ptr [0x7334], 0x4d69;
                                        $1 = $2;
                                        or ax, word ptr [bp + 0xc];
                                        if (a != b) {  // jne 0x61b5
                                            // Block 0x61B5
                                            les bx, ptr [bp + 6];
                                            $1 = $2;
                                            $1 = $2;
                                            mov word ptr es:[bx + 0xe], ax;
                                            mov word ptr es:[bx + 0xc], dx;
                                            mov word ptr es:[bx + 0xa], ax;
                                            mov word ptr es:[bx + 8], dx;
                                            mov word ptr es:[bx + 6], si;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0x61dc
                                                // Block 0x61DC
                                                xor ax, ax;
                                            } else {
                                                // Block 0x61D7
                                                or word ptr es:[bx + 2], 8;
                                            }
                                        } else {
                                            // Block 0x6194
                                            push($1);
                                            nop ;
                                            push($1);
                                            call 0x4302;
                                            // Block 0x619A
                                            $1 = pop();
                                            *($1) = $2;
                                            *($1) = $2;
                                            or ax, dx;
                                            if (a != b) {  // jne 0x61a8
                                                // Block 0x61A8
                                                les bx, ptr [bp + 6];
                                                or word ptr es:[bx + 2], 4;
                                                goto $1;
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0x61A5
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x6141
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x41f8;
                                // Block 0x614E
                                $1 = pop();
                                pop cx;
                            }
                        } else {
                            // Block 0x6120
                            $1 = $2;
                            push($1);
                            $1 = 0;
                            $1 = 0;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x554e;
                            // Block 0x6133
                            add sp, 0xa;
                        }
                    } else {
                        // Block 0x610A
                        cmp word ptr [bp + 6], 0x7340;
                        if (a != b) {  // jne 0x6117
                            // Block 0x6117
                            les bx, ptr [bp + 6];
                            cmp word ptr es:[bx], 0;
                            if (a == b) {  // je 0x6136
                                // Block 0x6136
                                les bx, ptr [bp + 6];
                                test word ptr es:[bx + 2], 4;
                                if (a == b) {  // je 0x6150
                                    // Block 0x6150
                                    les bx, ptr [bp + 6];
                                    and word ptr es:[bx + 2], 0xfff3;
                                    mov word ptr es:[bx + 6], 0;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 += $2;
                                    mov word ptr es:[bx + 0xa], ax;
                                    mov word ptr es:[bx + 8], dx;
                                    mov word ptr es:[bx + 0xe], ax;
                                    mov word ptr es:[bx + 0xc], dx;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x617C
                                        or si, si;
                                        if (a <= b (unsigned)) {  // jbe 0x61dc
                                            // Block 0x61DC
                                            xor ax, ax;
                                        } else {
                                            // Block 0x6180
                                            mov word ptr [0x7336], 0;
                                            mov word ptr [0x7334], 0x4d69;
                                            $1 = $2;
                                            or ax, word ptr [bp + 0xc];
                                            if (a != b) {  // jne 0x61b5
                                                // Block 0x61B5
                                                les bx, ptr [bp + 6];
                                                $1 = $2;
                                                $1 = $2;
                                                mov word ptr es:[bx + 0xe], ax;
                                                mov word ptr es:[bx + 0xc], dx;
                                                mov word ptr es:[bx + 0xa], ax;
                                                mov word ptr es:[bx + 8], dx;
                                                mov word ptr es:[bx + 6], si;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x61dc
                                                    // Block 0x61DC
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x61D7
                                                    or word ptr es:[bx + 2], 8;
                                                }
                                            } else {
                                                // Block 0x6194
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4302;
                                                // Block 0x619A
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                or ax, dx;
                                                if (a != b) {  // jne 0x61a8
                                                    // Block 0x61A8
                                                    les bx, ptr [bp + 6];
                                                    or word ptr es:[bx + 2], 4;
                                                    goto $1;
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0x61A5
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x6141
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x41f8;
                                    // Block 0x614E
                                    $1 = pop();
                                    pop cx;
                                }
                            } else {
                                // Block 0x6120
                                $1 = $2;
                                push($1);
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x554e;
                                // Block 0x6133
                                add sp, 0xa;
                            }
                        } else {
                            // Block 0x6111
                            mov word ptr [0x76ac], 1;
                        }
                    }
                } else {
                    // Block 0x60F4
                    cmp word ptr [bp + 6], 0x7354;
                    if (a != b) {  // jne 0x6103
                        // Block 0x6103
                        cmp word ptr [0x76ac], 0;
                        if (a != b) {  // jne 0x6117
                            // Block 0x6117
                            les bx, ptr [bp + 6];
                            cmp word ptr es:[bx], 0;
                            if (a == b) {  // je 0x6136
                                // Block 0x6136
                                les bx, ptr [bp + 6];
                                test word ptr es:[bx + 2], 4;
                                if (a == b) {  // je 0x6150
                                    // Block 0x6150
                                    les bx, ptr [bp + 6];
                                    and word ptr es:[bx + 2], 0xfff3;
                                    mov word ptr es:[bx + 6], 0;
                                    $1 = $2;
                                    $1 = $2;
                                    $1 += $2;
                                    mov word ptr es:[bx + 0xa], ax;
                                    mov word ptr es:[bx + 8], dx;
                                    mov word ptr es:[bx + 0xe], ax;
                                    mov word ptr es:[bx + 0xc], dx;
                                    // Compare $1 with $2
                                    if (a == b) {  // je 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x617C
                                        or si, si;
                                        if (a <= b (unsigned)) {  // jbe 0x61dc
                                            // Block 0x61DC
                                            xor ax, ax;
                                        } else {
                                            // Block 0x6180
                                            mov word ptr [0x7336], 0;
                                            mov word ptr [0x7334], 0x4d69;
                                            $1 = $2;
                                            or ax, word ptr [bp + 0xc];
                                            if (a != b) {  // jne 0x61b5
                                                // Block 0x61B5
                                                les bx, ptr [bp + 6];
                                                $1 = $2;
                                                $1 = $2;
                                                mov word ptr es:[bx + 0xe], ax;
                                                mov word ptr es:[bx + 0xc], dx;
                                                mov word ptr es:[bx + 0xa], ax;
                                                mov word ptr es:[bx + 8], dx;
                                                mov word ptr es:[bx + 6], si;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0x61dc
                                                    // Block 0x61DC
                                                    xor ax, ax;
                                                } else {
                                                    // Block 0x61D7
                                                    or word ptr es:[bx + 2], 8;
                                                }
                                            } else {
                                                // Block 0x6194
                                                push($1);
                                                nop ;
                                                push($1);
                                                call 0x4302;
                                                // Block 0x619A
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                or ax, dx;
                                                if (a != b) {  // jne 0x61a8
                                                    // Block 0x61A8
                                                    les bx, ptr [bp + 6];
                                                    or word ptr es:[bx + 2], 4;
                                                    goto $1;
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0x61A5
                                                    jmp 0x60e7;
                                                    // Block 0x60E7
                                                    $1 = $2;
                                                    jmp 0x61de;
                                                    // Block 0x61DE
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x6141
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x41f8;
                                    // Block 0x614E
                                    $1 = pop();
                                    pop cx;
                                }
                            } else {
                                // Block 0x6120
                                $1 = $2;
                                push($1);
                                $1 = 0;
                                $1 = 0;
                                push($1);
                                push($1);
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x554e;
                                // Block 0x6133
                                add sp, 0xa;
                            }
                        } else {
                            // Block 0x610A
                            cmp word ptr [bp + 6], 0x7340;
                            if (a != b) {  // jne 0x6117
                                // Block 0x6117
                                les bx, ptr [bp + 6];
                                cmp word ptr es:[bx], 0;
                                if (a == b) {  // je 0x6136
                                    // Block 0x6136
                                    les bx, ptr [bp + 6];
                                    test word ptr es:[bx + 2], 4;
                                    if (a == b) {  // je 0x6150
                                        // Block 0x6150
                                        les bx, ptr [bp + 6];
                                        and word ptr es:[bx + 2], 0xfff3;
                                        mov word ptr es:[bx + 6], 0;
                                        $1 = $2;
                                        $1 = $2;
                                        $1 += $2;
                                        mov word ptr es:[bx + 0xa], ax;
                                        mov word ptr es:[bx + 8], dx;
                                        mov word ptr es:[bx + 0xe], ax;
                                        mov word ptr es:[bx + 0xc], dx;
                                        // Compare $1 with $2
                                        if (a == b) {  // je 0x61dc
                                            // Block 0x61DC
                                            xor ax, ax;
                                        } else {
                                            // Block 0x617C
                                            or si, si;
                                            if (a <= b (unsigned)) {  // jbe 0x61dc
                                                // Block 0x61DC
                                                xor ax, ax;
                                            } else {
                                                // Block 0x6180
                                                mov word ptr [0x7336], 0;
                                                mov word ptr [0x7334], 0x4d69;
                                                $1 = $2;
                                                or ax, word ptr [bp + 0xc];
                                                if (a != b) {  // jne 0x61b5
                                                    // Block 0x61B5
                                                    les bx, ptr [bp + 6];
                                                    $1 = $2;
                                                    $1 = $2;
                                                    mov word ptr es:[bx + 0xe], ax;
                                                    mov word ptr es:[bx + 0xc], dx;
                                                    mov word ptr es:[bx + 0xa], ax;
                                                    mov word ptr es:[bx + 8], dx;
                                                    mov word ptr es:[bx + 6], si;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0x61dc
                                                        // Block 0x61DC
                                                        xor ax, ax;
                                                    } else {
                                                        // Block 0x61D7
                                                        or word ptr es:[bx + 2], 8;
                                                    }
                                                } else {
                                                    // Block 0x6194
                                                    push($1);
                                                    nop ;
                                                    push($1);
                                                    call 0x4302;
                                                    // Block 0x619A
                                                    $1 = pop();
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    or ax, dx;
                                                    if (a != b) {  // jne 0x61a8
                                                        // Block 0x61A8
                                                        les bx, ptr [bp + 6];
                                                        or word ptr es:[bx + 2], 4;
                                                        goto $1;
                                                        jmp 0x60e7;
                                                        // Block 0x60E7
                                                        $1 = $2;
                                                        jmp 0x61de;
                                                        // Block 0x61DE
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0x61A5
                                                        jmp 0x60e7;
                                                        // Block 0x60E7
                                                        $1 = $2;
                                                        jmp 0x61de;
                                                        // Block 0x61DE
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0x6141
                                        push($1);
                                        push($1);
                                        nop ;
                                        push($1);
                                        call 0x41f8;
                                        // Block 0x614E
                                        $1 = pop();
                                        pop cx;
                                    }
                                } else {
                                    // Block 0x6120
                                    $1 = $2;
                                    push($1);
                                    $1 = 0;
                                    $1 = 0;
                                    push($1);
                                    push($1);
                                    push($1);
                                    push($1);
                                    nop ;
                                    push($1);
                                    call 0x554e;
                                    // Block 0x6133
                                    add sp, 0xa;
                                }
                            } else {
                                // Block 0x6111
                                mov word ptr [0x76ac], 1;
                            }
                        }
                    } else {
                        // Block 0x60FB
                        mov word ptr [0x76ae], 1;
                        jmp 0x6117;
                        // Block 0x6117
                        les bx, ptr [bp + 6];
                        cmp word ptr es:[bx], 0;
                        if (a == b) {  // je 0x6136
                            // Block 0x6136
                            les bx, ptr [bp + 6];
                            test word ptr es:[bx + 2], 4;
                            if (a == b) {  // je 0x6150
                                // Block 0x6150
                                les bx, ptr [bp + 6];
                                and word ptr es:[bx + 2], 0xfff3;
                                mov word ptr es:[bx + 6], 0;
                                $1 = $2;
                                $1 = $2;
                                $1 += $2;
                                mov word ptr es:[bx + 0xa], ax;
                                mov word ptr es:[bx + 8], dx;
                                mov word ptr es:[bx + 0xe], ax;
                                mov word ptr es:[bx + 0xc], dx;
                                // Compare $1 with $2
                                if (a == b) {  // je 0x61dc
                                    // Block 0x61DC
                                    xor ax, ax;
                                } else {
                                    // Block 0x617C
                                    or si, si;
                                    if (a <= b (unsigned)) {  // jbe 0x61dc
                                        // Block 0x61DC
                                        xor ax, ax;
                                    } else {
                                        // Block 0x6180
                                        mov word ptr [0x7336], 0;
                                        mov word ptr [0x7334], 0x4d69;
                                        $1 = $2;
                                        or ax, word ptr [bp + 0xc];
                                        if (a != b) {  // jne 0x61b5
                                            // Block 0x61B5
                                            les bx, ptr [bp + 6];
                                            $1 = $2;
                                            $1 = $2;
                                            mov word ptr es:[bx + 0xe], ax;
                                            mov word ptr es:[bx + 0xc], dx;
                                            mov word ptr es:[bx + 0xa], ax;
                                            mov word ptr es:[bx + 8], dx;
                                            mov word ptr es:[bx + 6], si;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0x61dc
                                                // Block 0x61DC
                                                xor ax, ax;
                                            } else {
                                                // Block 0x61D7
                                                or word ptr es:[bx + 2], 8;
                                            }
                                        } else {
                                            // Block 0x6194
                                            push($1);
                                            nop ;
                                            push($1);
                                            call 0x4302;
                                            // Block 0x619A
                                            $1 = pop();
                                            *($1) = $2;
                                            *($1) = $2;
                                            or ax, dx;
                                            if (a != b) {  // jne 0x61a8
                                                // Block 0x61A8
                                                les bx, ptr [bp + 6];
                                                or word ptr es:[bx + 2], 4;
                                                goto $1;
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0x61A5
                                                jmp 0x60e7;
                                                // Block 0x60E7
                                                $1 = $2;
                                                jmp 0x61de;
                                                // Block 0x61DE
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Block 0x6141
                                push($1);
                                push($1);
                                nop ;
                                push($1);
                                call 0x41f8;
                                // Block 0x614E
                                $1 = pop();
                                pop cx;
                            }
                        } else {
                            // Block 0x6120
                            $1 = $2;
                            push($1);
                            $1 = 0;
                            $1 = 0;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x554e;
                            // Block 0x6133
                            add sp, 0xa;
                        }
                    }
                }
            } else {
                // Block 0x60E7
                $1 = $2;
                jmp 0x61de;
                // Block 0x61DE
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            }
        }
    }

    // Function calls:
    sub_554E();
    sub_41F8();
    sub_4302();
}

void sub_61E2() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x61E2
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (a == b) {  // je 0x6236
        // Block 0x6236
        $1 = pop();
        $1 = pop();
        return;  // ret 0xa
    } else {
        // Block 0x61F1
        push($1);
        push($1);
        nop ;
        push($1);
        call 0x6661;
        // Block 0x61FC
        $1 = pop();
        $1 = pop();
        // Compare $1 with $2
        if (a < b (unsigned)) {  // jb 0x6222
            // Block 0x6222
            push($1);
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x65f7;
            // Block 0x6233
            add sp, 8;
        } else {
            // Block 0x6202
            push($1);
            push($1);
            push($1);
            push($1);
            push($1);
            nop ;
            push($1);
            call 0x6680;
            // Block 0x6214
            $1 += $2;
            les bx, ptr [bp + 0xa];
            $1 += $2;
            mov byte ptr es:[bx], 0;
            jmp 0x6236;
            // Block 0x6236
            $1 = pop();
            $1 = pop();
            return;  // ret 0xa
        }
    }

    // Function calls:
    sub_6661();
    sub_6680();
    sub_65F7();
}

void sub_623B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x623B
    push($1);
    $1 = $2;
    $1 -= $2;
    les bx, ptr [bp + 4];
    cmp byte ptr es:[bx - 1], 0x2e;
    if (a != b) {  // jne 0x624e
        // Block 0x624E
        $1--;
        les bx, ptr [bp + 4];
        $1 = $2;
        cwde ;
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        // Compare $1 with $2
        if (a == b) {  // je 0x6270
            // Block 0x6270
            goto $1;
            les bx, ptr [bp + 4];
            cmp byte ptr es:[bx - 2], 0;
            if (a != b) {  // jne 0x6283
                // Block 0x6283
                xor ax, ax;
            } else {
                // Block 0x627E
                $1 = $2;
                jmp 0x6285;
                // Block 0x6285
                $1 = $2;
                $1 = pop();
                return;  // ret 4
            }
        } else {
            // Block 0x6269
            $1 += $2;
            loop 0x6261;
            jmp 0x6283;
            // Block 0x6283
            xor ax, ax;
        }
    } else {
        // Block 0x624B
        dec word ptr [bp + 4];
    }
}

void sub_629B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 25 if statements

    // Block 0x629B
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = 0;
    $1 = $2;
    or ax, word ptr [bp + 0xc];
    if (a == b) {  // je 0x62b4
        // Block 0x62B4
        $1 = $2;
        or ax, word ptr [bp + 0x10];
        if (a == b) {  // je 0x62c3
            // Block 0x62C3
            $1 = $2;
            or ax, word ptr [bp + 0x14];
            if (a == b) {  // je 0x62d2
                // Block 0x62D2
                $1 = $2;
                or ax, word ptr [bp + 0x18];
                if (a == b) {  // je 0x62e1
                    // Block 0x62E1
                    lea ax, [bp - 0x58];
                    *($1) = $2;
                    *($1) = $2;
                    jmp 0x62ef;
                    // Block 0x62EF
                    les bx, ptr [bp + 6];
                    cmp byte ptr es:[bx], 0x20;
                    if (a == b) {  // je 0x62ec
                        // Block 0x62EC
                        inc word ptr [bp + 6];
                    } else {
                        // Block 0x62F8
                        push($1);
                        push($1);
                        nop ;
                        push($1);
                        call 0x6661;
                        // Block 0x6301
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        // Compare $1 with $2
                        if (a <= b) {  // jle 0x630d
                            // Block 0x630D
                            les bx, ptr [bp - 4];
                            mov byte ptr es:[bx], 0;
                            $1++;
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            push($1);
                            nop ;
                            push($1);
                            call 0x6680;
                            // Block 0x6329
                            $1 += $2;
                            add word ptr [bp - 4], si;
                            les bx, ptr [bp - 4];
                            mov byte ptr es:[bx], 0;
                            xor si, si;
                        } else {
                            // Block 0x630A
                            mov si, 0x50;
                        }
                    }
                } else {
                    // Block 0x62DA
                    les bx, ptr [bp + 0x16];
                    mov byte ptr es:[bx], 0;
                }
            } else {
                // Block 0x62CB
                les bx, ptr [bp + 0x12];
                mov byte ptr es:[bx], 0;
            }
        } else {
            // Block 0x62BC
            les bx, ptr [bp + 0xe];
            mov byte ptr es:[bx], 0;
        }
    } else {
        // Block 0x62AD
        les bx, ptr [bp + 0xa];
        mov byte ptr es:[bx], 0;
    }

    // Function calls:
    sub_6661();
    sub_6680();
    sub_623B();
    sub_61E2();
    sub_61E2();
    sub_61E2();
    sub_61E2();
    sub_629B();
    sub_59FF();
    sub_3935();
    sub_3935();
    sub_3147();
    sub_3147();
}

void sub_65B8() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x65B8
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    push($1);
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    push($1);
    lea si, [di - 1];
    les di, ptr [bp + 0xa];
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    $1 -= $2;
    push($1);
    $1 = pop();
    $1 = pop();
    xchg di, si;
    test si, 1;
    if (a == b) {  // je 0x65e8
        // Block 0x65E8
        shr cx, 1;
        rep movsw word ptr es:[di], word ptr [si];
        if (a >= b (unsigned)) {  // jae 0x65ef
            // Block 0x65EF
            xchg dx, ax;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x65EE
            movsb byte ptr es:[di], byte ptr [si];
        }
    } else {
        // Block 0x65E6
        movsb byte ptr es:[di], byte ptr [si];
        dec cx;
    }
}

void sub_65F7() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x65F7
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    not cx;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    return;  // retf 
}

void sub_6661() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x6661
    push($1);
    $1 = $2;
    push($1);
    les di, ptr [bp + 6];
    $1 = 0;
    // Compare $1 with $2
    if (a != b) {  // jne 0x6673
        // Block 0x6673
        cld ;
        $1 = $2;
        repne scasb al, byte ptr es:[di];
        xchg cx, ax;
        not ax;
        dec ax;
    } else {
        // Block 0x666F
        // Compare $1 with $2
        if (a == b) {  // je 0x667d
            // Block 0x667D
            $1 = pop();
            $1 = pop();
            return;  // retf 
        } else {
            // Block 0x6673
            cld ;
            $1 = $2;
            repne scasb al, byte ptr es:[di];
            xchg cx, ax;
            not ax;
            dec ax;
        }
    }
}

void sub_6680() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x6680
    push($1);
    $1 = $2;
    push($1);
    push($1);
    cld ;
    les di, ptr [bp + 0xa];
    $1 = $2;
    $1 = 0;
    $1 = $2;
    $1 = $2;
    repne scasb al, byte ptr es:[di];
    $1 -= $2;
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    xchg bx, cx;
    rep movsb byte ptr es:[di], byte ptr [si];
    $1 = $2;
    rep stosb byte ptr es:[di], al;
    $1 = pop();
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    return;  // retf 
}

void sub_679C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0x679C
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0x67b8
        // Block 0x67B8
        $1 = $2;
        $1++;
        // Compare $1 with $2
        if (a >= b (unsigned)) {  // jae 0x67c6
            // Block 0x67C6
            $1 = $2;
            shl bx, 1;
            test word ptr [bx + 0x74d2], 0x800;
            if (a == b) {  // je 0x67e5
                // Block 0x67E5
                $1 = $2;
                shl bx, 1;
                test word ptr [bx + 0x74d2], 0x4000;
                if (a != b) {  // jne 0x6806
                    // Block 0x6806
                    $1 = $2;
                    shl bx, 1;
                    and word ptr [bx + 0x74d2], 0xfdff;
                    $1 = $2;
                    $1 = $2;
                    *($1) = $2;
                    *($1) = $2;
                    $1 = $2;
                    *($1) = $2;
                    jmp 0x6899;
                    // Block 0x6899
                    lea ax, [bp - 0x8e];
                    *($1) = $2;
                    mov word ptr [bp - 4], ax;
                } else {
                    // Block 0x67F1
                    push($1);
                    push($1);
                    push($1);
                    push($1);
                    nop ;
                    push($1);
                    call 0x68ed;
                    // Block 0x6800
                    $1 += $2;
                    jmp 0x68e7;
                    // Block 0x68E7
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0x67D2
                $1 = $2;
                push($1);
                $1 = 0;
                $1 = 0;
                push($1);
                push($1);
                push($1);
                nop ;
                push($1);
                call 0x3001;
                // Block 0x67E2
                add sp, 8;
            }
        } else {
            // Block 0x67C1
            $1 = 0;
            jmp 0x68e7;
            // Block 0x68E7
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x67AE
        $1 = $2;
        push($1);
        call 0x2d44;
        // Block 0x67B5
        jmp 0x68e7;
        // Block 0x68E7
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
    sub_3001();
    sub_68ED();
    sub_68ED();
    sub_68ED();
}

void sub_68ED() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 54 if statements

    // Block 0x68ED
    push($1);
    $1 = $2;
    $1 = $2;
    shl bx, 1;
    test word ptr [bx + 0x74d2], 1;
    if (a == b) {  // je 0x6903
        // Block 0x6903
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        lds dx, ptr [bp + 8];
        DOS_WriteFile();  // int 0x21
        $1 = pop();
        if (a < b (unsigned)) {  // jb 0x6923
            // Block 0x6923
            push ax;
        } else {
            // Block 0x6914
            push($1);
            $1 = $2;
            shl bx, 1;
            or word ptr [bx + 0x74d2], 0x1000;
            $1 = pop();
            jmp 0x6927;
            // Block 0x6927
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0x68FD
        $1 = $2;
        push($1);
        jmp 0x6924;
        // Block 0x6924
        call 0x2d44;
        // Block 0x6927
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_2D44();
    sub_4EFB();
    sub_4FB3();
}

void sub_70A0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0x70A0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov ax, word ptr [bp + 6];

    // Function calls:
    sub_70A0();
}

void sub_715E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0x715E
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    pushf ;
    cmp word ptr [0x54d2], -1;
    if (a != b) {  // jne 0x7187
        // Block 0x7187
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = $2;
        cli ;
        $1 = $2;
        $1 = $2;
        sti ;
        cmp word ptr [0x54d2], 0;
        if (a != b) {  // jne 0x71a8
            // Block 0x71A8
            push($1);
            $1 = 0;
            out 0x43, al;
            in al, 0x40;
            xchg al, ah;
            in al, 0x40;
            xchg al, ah;
            not ax;
            *($1) = $2;
            $1 = pop();
            // Compare $1 with $2
            if (a == b) {  // je 0x71d0
                // Block 0x71D0
                cmp word ptr [0x54ce], dx;
                if (a > b (unsigned)) {  // ja 0x71de
                    // Block 0x71DE
                    $1 += $2;
                    adc dx, 0x18;
                } else {
                    // Block 0x71D6
                    if (a < b (unsigned)) {  // jb 0x71e4
                        // Block 0x71E4
                        $1 -= $2;
                        sbb dx, word ptr [0x54ce];
                        $1 = $2;
                        lcall 0x7ff, 8;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        push($1);
                        push($1);
                        $1 = $2;
                        mul word ptr [bp - 4];
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = pop();
                        $1 += $2;
                        $1 = pop();
                        adc dx, bx;
                        *($1) = $2;
                        popf ;
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x71D8
                        cmp word ptr [0x54cc], ax;
                        if (a <= b (unsigned)) {  // jbe 0x71e4
                            // Block 0x71E4
                            $1 -= $2;
                            sbb dx, word ptr [0x54ce];
                            $1 = $2;
                            lcall 0x7ff, 8;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            push($1);
                            push($1);
                            $1 = $2;
                            mul word ptr [bp - 4];
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = pop();
                            $1 += $2;
                            $1 = pop();
                            adc dx, bx;
                            *($1) = $2;
                            popf ;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0x71DE
                            $1 += $2;
                            adc dx, 0x18;
                        }
                    }
                }
            } else {
                // Block 0x71C0
                cmp word ptr [bp - 4], 0x8000;
                if (a > b (unsigned)) {  // ja 0x71d0
                    // Block 0x71D0
                    cmp word ptr [0x54ce], dx;
                    if (a > b (unsigned)) {  // ja 0x71de
                        // Block 0x71DE
                        $1 += $2;
                        adc dx, 0x18;
                    } else {
                        // Block 0x71D6
                        if (a < b (unsigned)) {  // jb 0x71e4
                            // Block 0x71E4
                            $1 -= $2;
                            sbb dx, word ptr [0x54ce];
                            $1 = $2;
                            lcall 0x7ff, 8;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            push($1);
                            push($1);
                            $1 = $2;
                            mul word ptr [bp - 4];
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = $2;
                            lcall 0x7ff, 0x32;
                            $1 = pop();
                            $1 += $2;
                            $1 = pop();
                            adc dx, bx;
                            *($1) = $2;
                            popf ;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0x71D8
                            cmp word ptr [0x54cc], ax;
                            if (a <= b (unsigned)) {  // jbe 0x71e4
                                // Block 0x71E4
                                $1 -= $2;
                                sbb dx, word ptr [0x54ce];
                                $1 = $2;
                                lcall 0x7ff, 8;
                                $1 = $2;
                                lcall 0x7ff, 0x32;
                                push($1);
                                push($1);
                                $1 = $2;
                                mul word ptr [bp - 4];
                                $1 = $2;
                                lcall 0x7ff, 0x32;
                                $1 = $2;
                                lcall 0x7ff, 0x32;
                                $1 = pop();
                                $1 += $2;
                                $1 = pop();
                                adc dx, bx;
                                *($1) = $2;
                                popf ;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0x71DE
                                $1 += $2;
                                adc dx, 0x18;
                            }
                        }
                    }
                } else {
                    // Block 0x71C7
                    cli ;
                    $1 = $2;
                    $1 = $2;
                    sti ;
                }
            }
        } else {
            // Block 0x71A1
            mov word ptr [bp - 4], 0;
            jmp 0x71d0;
            // Block 0x71D0
            cmp word ptr [0x54ce], dx;
            if (a > b (unsigned)) {  // ja 0x71de
                // Block 0x71DE
                $1 += $2;
                adc dx, 0x18;
            } else {
                // Block 0x71D6
                if (a < b (unsigned)) {  // jb 0x71e4
                    // Block 0x71E4
                    $1 -= $2;
                    sbb dx, word ptr [0x54ce];
                    $1 = $2;
                    lcall 0x7ff, 8;
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    push($1);
                    push($1);
                    $1 = $2;
                    mul word ptr [bp - 4];
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    $1 = pop();
                    $1 += $2;
                    $1 = pop();
                    adc dx, bx;
                    *($1) = $2;
                    popf ;
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0x71D8
                    cmp word ptr [0x54cc], ax;
                    if (a <= b (unsigned)) {  // jbe 0x71e4
                        // Block 0x71E4
                        $1 -= $2;
                        sbb dx, word ptr [0x54ce];
                        $1 = $2;
                        lcall 0x7ff, 8;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        push($1);
                        push($1);
                        $1 = $2;
                        mul word ptr [bp - 4];
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        $1 = pop();
                        $1 += $2;
                        $1 = pop();
                        adc dx, bx;
                        *($1) = $2;
                        popf ;
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0x71DE
                        $1 += $2;
                        adc dx, 0x18;
                    }
                }
            }
        }
    } else {
        // Block 0x7175
        cli ;
        $1 = $2;
        out 0x43, al;
        $1 = 0;
        out 0x40, al;
        out 0x40, al;
        sti ;
        mov word ptr [0x54d2], 1;
    }
}

void sub_7229() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 12 if statements

    // Block 0x7229
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    call 0x715e;
    // Block 0x723C
    cmp word ptr [bp + 8], dx;
    if (a > b (unsigned)) {  // ja 0x7248
        // Block 0x7248
        $1 += $2;
        adc dx, 0x526;
    } else {
        // Block 0x7241
        if (a < b (unsigned)) {  // jb 0x724f
            // Block 0x724F
            $1 -= $2;
            sbb dx, word ptr [bp + 8];
            *($1) = $2;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        } else {
            // Block 0x7243
            cmp word ptr [bp + 6], ax;
            if (a <= b (unsigned)) {  // jbe 0x724f
                // Block 0x724F
                $1 -= $2;
                sbb dx, word ptr [bp + 8];
                *($1) = $2;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            } else {
                // Block 0x7248
                $1 += $2;
                adc dx, 0x526;
            }
        }
    }

    // Function calls:
    sub_715E();
    sub_715E();
    sub_70A0();
    sub_7229();
}

void sub_731C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x731C
    push($1);
    push($1);
    $1 = $2;
    xor bx, bx;
}

void sub_7353() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x7353
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    and cl, 0x3f;
    and dx, 0x3f3f;
    $1 = $2;
    // Compare $1 with $2
    if (a == b) {  // je 0x7386
        // Block 0x7386
        $1 = $2;
        $1 = $2;
        call 0x731c;
        // Block 0x738E
        jmp 0x7398;
        // Block 0x7398
        $1 = 0;
        mov word ptr [bp - 2], ax;
    } else {
        // Block 0x737A
        // Compare $1 with $2
        if (a == b) {  // je 0x7390
            // Block 0x7390
            $1 = 0;
            $1 = $2;
            call 0x731c;
            // Block 0x7398
            $1 = 0;
            mov word ptr [bp - 2], ax;
        } else {
            // Block 0x737F
            mov word ptr [bp - 2], 0xfff7;
            jmp 0x739d;
            // Block 0x739D
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 8
        }
    }

    // Function calls:
    sub_731C();
    sub_731C();
    sub_731C();
}

void sub_7426() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0x7426
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    lodsb al, byte ptr [si];
    $1 = 0;
    $1 = $2;
    shl bx, 1;
    $1 += $2;
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 += $2;
    $1 = $2;
    rep movsb byte ptr es:[di], byte ptr [si];
    lds si, ptr [bp + 0xa];
    $1 = $2;
    and bl, 3;
    $1 = $2;
    $1 = $2;
    for (bl = 0; bl < $2_2; bl++) {
    cmp bl, 0;
    if (a == b) {  // je 0x747c
        // Block 0x747C
        $1 = $2;
        rep movsb byte ptr es:[di], byte ptr [si];
        mov word ptr [bp - 2], 0;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 8
    } else {
        // Block 0x7469
        for (bl = 1; bl < $2_2; bl++) {
        cmp bl, 1;
        if (a == b) {  // je 0x747c
            // Block 0x747C
            $1 = $2;
            rep movsb byte ptr es:[di], byte ptr [si];
            mov word ptr [bp - 2], 0;
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 8
        } else {
            // Block 0x7471
            for (bl = 2; bl < $2_2; bl++) {
            cmp bl, 2;
            if (a == b) {  // je 0x747c
                // Block 0x747C
                $1 = $2;
                rep movsb byte ptr es:[di], byte ptr [si];
                mov word ptr [bp - 2], 0;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 8
            } else {
                // Block 0x7479
                mov si, 0x3ad3;
            }
        }
    }
}

void sub_74D9() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 11 if statements

    // Block 0x74D9
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    or cx, cx;
    if (a != b) {  // jne 0x74fc
        // Block 0x74FC
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x7504
            // Block 0x7504
            lodsb al, byte ptr [si];
            $1 = $2;
            and dh, al;
            $1 = $2;
            and dl, al;
            $1 = $2;
            and ah, al;
            $1 = 0;
            or dh, dh;
            if (a == b) {  // je 0x7527
                // Block 0x7527
                stosb byte ptr es:[di], al;
                $1 = 0;
                or dl, dl;
                if (a == b) {  // je 0x753e
                    // Block 0x753E
                    stosb byte ptr es:[di], al;
                    $1 = 0;
                    or ah, ah;
                    if (a == b) {  // je 0x7555
                        // Block 0x7555
                        stosb byte ptr es:[di], al;
                        loop 0x7504;
                        mov word ptr [bp - 2], 0;
                    } else {
                        // Block 0x7545
                        for (ah = 8; ah < $2_2; ah++) {
                        cmp ah, 8;
                        if (a == b) {  // je 0x7555
                            // Block 0x7555
                            stosb byte ptr es:[di], al;
                            loop 0x7504;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x754C
                            for (ah = 1; ah < $2_2; ah++) {
                            cmp ah, 1;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7553
                                mov al, 0x3f;
                            }
                        }
                    }
                } else {
                    // Block 0x752E
                    for (dl = 0x10; dl < $2_2; dl++) {
                    cmp dl, 0x10;
                    if (a == b) {  // je 0x753e
                        // Block 0x753E
                        stosb byte ptr es:[di], al;
                        $1 = 0;
                        or ah, ah;
                        if (a == b) {  // je 0x7555
                            // Block 0x7555
                            stosb byte ptr es:[di], al;
                            loop 0x7504;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x7545
                            for (ah = 8; ah < $2_2; ah++) {
                            cmp ah, 8;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x754C
                                for (ah = 1; ah < $2_2; ah++) {
                                cmp ah, 1;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7553
                                    mov al, 0x3f;
                                }
                            }
                        }
                    } else {
                        // Block 0x7535
                        for (dl = 2; dl < $2_2; dl++) {
                        cmp dl, 2;
                        if (a == b) {  // je 0x753e
                            // Block 0x753E
                            stosb byte ptr es:[di], al;
                            $1 = 0;
                            or ah, ah;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7545
                                for (ah = 8; ah < $2_2; ah++) {
                                cmp ah, 8;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x754C
                                    for (ah = 1; ah < $2_2; ah++) {
                                    cmp ah, 1;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7553
                                        mov al, 0x3f;
                                    }
                                }
                            }
                        } else {
                            // Block 0x753C
                            mov al, 0x3f;
                        }
                    }
                }
            } else {
                // Block 0x7517
                for (dh = 0x20; dh < $2_2; dh++) {
                cmp dh, 0x20;
                if (a == b) {  // je 0x7527
                    // Block 0x7527
                    stosb byte ptr es:[di], al;
                    $1 = 0;
                    or dl, dl;
                    if (a == b) {  // je 0x753e
                        // Block 0x753E
                        stosb byte ptr es:[di], al;
                        $1 = 0;
                        or ah, ah;
                        if (a == b) {  // je 0x7555
                            // Block 0x7555
                            stosb byte ptr es:[di], al;
                            loop 0x7504;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0x7545
                            for (ah = 8; ah < $2_2; ah++) {
                            cmp ah, 8;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x754C
                                for (ah = 1; ah < $2_2; ah++) {
                                cmp ah, 1;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7553
                                    mov al, 0x3f;
                                }
                            }
                        }
                    } else {
                        // Block 0x752E
                        for (dl = 0x10; dl < $2_2; dl++) {
                        cmp dl, 0x10;
                        if (a == b) {  // je 0x753e
                            // Block 0x753E
                            stosb byte ptr es:[di], al;
                            $1 = 0;
                            or ah, ah;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7545
                                for (ah = 8; ah < $2_2; ah++) {
                                cmp ah, 8;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x754C
                                    for (ah = 1; ah < $2_2; ah++) {
                                    cmp ah, 1;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7553
                                        mov al, 0x3f;
                                    }
                                }
                            }
                        } else {
                            // Block 0x7535
                            for (dl = 2; dl < $2_2; dl++) {
                            cmp dl, 2;
                            if (a == b) {  // je 0x753e
                                // Block 0x753E
                                stosb byte ptr es:[di], al;
                                $1 = 0;
                                or ah, ah;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7545
                                    for (ah = 8; ah < $2_2; ah++) {
                                    cmp ah, 8;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x754C
                                        for (ah = 1; ah < $2_2; ah++) {
                                        cmp ah, 1;
                                        if (a == b) {  // je 0x7555
                                            // Block 0x7555
                                            stosb byte ptr es:[di], al;
                                            loop 0x7504;
                                            mov word ptr [bp - 2], 0;
                                        } else {
                                            // Block 0x7553
                                            mov al, 0x3f;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x753C
                                mov al, 0x3f;
                            }
                        }
                    }
                } else {
                    // Block 0x751E
                    for (dh = 4; dh < $2_2; dh++) {
                    cmp dh, 4;
                    if (a == b) {  // je 0x7527
                        // Block 0x7527
                        stosb byte ptr es:[di], al;
                        $1 = 0;
                        or dl, dl;
                        if (a == b) {  // je 0x753e
                            // Block 0x753E
                            stosb byte ptr es:[di], al;
                            $1 = 0;
                            or ah, ah;
                            if (a == b) {  // je 0x7555
                                // Block 0x7555
                                stosb byte ptr es:[di], al;
                                loop 0x7504;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7545
                                for (ah = 8; ah < $2_2; ah++) {
                                cmp ah, 8;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x754C
                                    for (ah = 1; ah < $2_2; ah++) {
                                    cmp ah, 1;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7553
                                        mov al, 0x3f;
                                    }
                                }
                            }
                        } else {
                            // Block 0x752E
                            for (dl = 0x10; dl < $2_2; dl++) {
                            cmp dl, 0x10;
                            if (a == b) {  // je 0x753e
                                // Block 0x753E
                                stosb byte ptr es:[di], al;
                                $1 = 0;
                                or ah, ah;
                                if (a == b) {  // je 0x7555
                                    // Block 0x7555
                                    stosb byte ptr es:[di], al;
                                    loop 0x7504;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7545
                                    for (ah = 8; ah < $2_2; ah++) {
                                    cmp ah, 8;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x754C
                                        for (ah = 1; ah < $2_2; ah++) {
                                        cmp ah, 1;
                                        if (a == b) {  // je 0x7555
                                            // Block 0x7555
                                            stosb byte ptr es:[di], al;
                                            loop 0x7504;
                                            mov word ptr [bp - 2], 0;
                                        } else {
                                            // Block 0x7553
                                            mov al, 0x3f;
                                        }
                                    }
                                }
                            } else {
                                // Block 0x7535
                                for (dl = 2; dl < $2_2; dl++) {
                                cmp dl, 2;
                                if (a == b) {  // je 0x753e
                                    // Block 0x753E
                                    stosb byte ptr es:[di], al;
                                    $1 = 0;
                                    or ah, ah;
                                    if (a == b) {  // je 0x7555
                                        // Block 0x7555
                                        stosb byte ptr es:[di], al;
                                        loop 0x7504;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7545
                                        for (ah = 8; ah < $2_2; ah++) {
                                        cmp ah, 8;
                                        if (a == b) {  // je 0x7555
                                            // Block 0x7555
                                            stosb byte ptr es:[di], al;
                                            loop 0x7504;
                                            mov word ptr [bp - 2], 0;
                                        } else {
                                            // Block 0x754C
                                            for (ah = 1; ah < $2_2; ah++) {
                                            cmp ah, 1;
                                            if (a == b) {  // je 0x7555
                                                // Block 0x7555
                                                stosb byte ptr es:[di], al;
                                                loop 0x7504;
                                                mov word ptr [bp - 2], 0;
                                            } else {
                                                // Block 0x7553
                                                mov al, 0x3f;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0x753C
                                    mov al, 0x3f;
                                }
                            }
                        }
                    } else {
                        // Block 0x7525
                        mov al, 0x3f;
                    }
                }
            }
        } else {
            // Block 0x7501
            mov cx, 0x10;
        }
    } else {
        // Block 0x74F5
        mov word ptr [bp - 2], 0xfff6;
        jmp 0x755d;
        // Block 0x755D
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_756A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0x756A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xa];
    cmp word ptr [bp + 0xe], 0;
    if (a != b) {  // jne 0x758a
        // Block 0x758A
        $1 = $2;
        push($1);
        lodsb al, byte ptr [si];
        push($1);
        lodsb al, byte ptr [si];
        push($1);
        lodsb al, byte ptr [si];
        push($1);
        push($1);
        call 0x7353;
        // Block 0x7598
        *($1) = $2;
        $1--;
        if (a != b) {  // jne 0x75a3
            // Block 0x75A3
            $1 = 0;
            cmp word ptr [bp + 0xe], 3;
            if (a <= b (unsigned)) {  // jbe 0x75b0
                // Block 0x75B0
                $1 = $2;
                $1 = $2;
                for (cx = 0; cx < $2_2; cx++) {
                cmp cx, 0;
                if (a == b) {  // je 0x75d0
                    // Block 0x75D0
                    push($1);
                    push($1);
                    push($1);
                    $1 = 0;
                    mov word ptr [bp - 6], 0xffff;
                } else {
                    // Block 0x75BD
                    for (cx = 1; cx < $2_2; cx++) {
                    cmp cx, 1;
                    if (a == b) {  // je 0x75d0
                        // Block 0x75D0
                        push($1);
                        push($1);
                        push($1);
                        $1 = 0;
                        mov word ptr [bp - 6], 0xffff;
                    } else {
                        // Block 0x75C5
                        for (cx = 2; cx < $2_2; cx++) {
                        cmp cx, 2;
                        if (a == b) {  // je 0x75d0
                            // Block 0x75D0
                            push($1);
                            push($1);
                            push($1);
                            $1 = 0;
                            mov word ptr [bp - 6], 0xffff;
                        } else {
                            // Block 0x75CD
                            mov di, 0x3ad3;
                        }
                    }
                }
            } else {
                // Block 0x75AB
                mov word ptr [bp + 0xe], 3;
            }
        } else {
            // Block 0x75A0
            jmp 0x762d;
            // Block 0x762D
            mov word ptr [bp - 2], 0;
        }
    } else {
        // Block 0x7582
        mov word ptr [bp - 2], 0xfff6;
        jmp 0x7632;
        // Block 0x7632
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }

    // Function calls:
    sub_7353();
    sub_7353();
}

void sub_7678() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0x7678
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 6], 0;
    mov byte ptr [bp - 5], 8;
    mov byte ptr [bp - 4], 1;
    mov byte ptr [bp - 3], 9;
    lds si, ptr [bp + 0xa];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = 0;
    or cx, cx;
    if (a != b) {  // jne 0x76ad
        // Block 0x76AD
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0x76b5
            // Block 0x76B5
            lodsb al, byte ptr [si];
            $1 = $2;
            lodsb al, byte ptr [si];
            $1 = $2;
            lodsb al, byte ptr [si];
            $1 = $2;
            push($1);
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = 0;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            shl al, 1;
            shl al, 1;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            shl dh, 1;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            or al, dh;
            or al, dl;
            $1 = pop();
            $1 = pop();
            stosb byte ptr es:[di], al;
            loop 0x76b5;
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0x76B2
            mov cx, 0x10;
        }
    } else {
        // Block 0x76A6
        mov word ptr [bp - 2], 0xfff6;
        jmp 0x76fd;
        // Block 0x76FD
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_770A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 31 if statements

    // Block 0x770A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0xc];
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    mov ch, 0xb;

    // Function calls:
    sub_770A();
    sub_74D9();
    sub_731C();
    sub_7678();
    sub_770A();
    sub_731C();
    sub_7426();
    sub_74D9();
    sub_731C();
    sub_731C();
    sub_731C();
    sub_731C();
    sub_756A();
    sub_7678();
}

void sub_7A56() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 96 if statements

    // Block 0x7A56
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffe8;
    les di, ptr [bp + 0x10];
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x7a80
        // Block 0x7A80
        $1 = $2;
        $1 = $2;
        mov word ptr es:[di], 0xca00;
        mov byte ptr es:[di + 2], 2;
        mov byte ptr es:[di + 3], 2;
        $1 = $2;
        mov word ptr es:[di + 4], ax;
        $1 = 0;
        mov word ptr es:[di + 6], ax;
        mov word ptr es:[di + 8], ax;
        $1 = $2;
        mov word ptr es:[di + 0x2c], ax;
        $1--;
        mov word ptr es:[di + 0xa], ax;
        $1 = $2;
        mov word ptr es:[di + 0x2e], ax;
        $1--;
        mov word ptr es:[di + 0xc], ax;
        $1 = 0;
        $1 = $2;
        mov byte ptr es:[di + 0x12], al;
        mul word ptr [bp + 6];
        mov word ptr es:[di + 0x34], ax;
        $1 = $2;
        mov word ptr es:[di + 0xe], ax;
        $1 = $2;
        mov word ptr es:[di + 0x10], ax;
        $1 = 0;
        $1 = $2;
        mov byte ptr es:[di + 0x13], al;
        mul word ptr [bp + 8];
        $1 = $2;
        div bx;
        or dx, dx;
        if (a == b) {  // je 0x7af0
            // Block 0x7AF0
            mov word ptr es:[di + 0x30], ax;
            test ax, 1;
            if (a == b) {  // je 0x7afa
                // Block 0x7AFA
                mov word ptr es:[di + 0x14], ax;
                $1 = $2;
                xor cl, 7;
                $1++;
                and cl, 7;
                $1 = $2;
                shl ch, cl;
                $1 = $2;
                not ch;
                mov word ptr es:[di + 0x32], cx;
                mov word ptr es:[di + 0x28], 0;
                mov word ptr es:[di + 0x2a], 4;
                $1 = $2;
                mov word ptr es:[di + 0x16], ax;
                // Compare $1 with $2
                if (a != b) {  // jne 0x7b35
                    // Block 0x7B35
                    // Compare $1 with $2
                    if (a != b) {  // jne 0x7b64
                        // Block 0x7B64
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x7b99
                            // Block 0x7B99
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x7bf3
                                // Block 0x7BF3
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0x10
                            } else {
                                // Block 0x7B9E
                                $1 = $2;
                                mov word ptr es:[di + 0x22], dx;
                                $1 = $2;
                                push($1);
                                lcall 0x620, 0x219;
                                or ax, ax;
                                if (a != b) {  // jne 0x7bc7
                                    // Block 0x7BC7
                                    *($1) = $2;
                                    jmp 0x7bf3;
                                    // Block 0x7BF3
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0x10
                                } else {
                                    // Block 0x7BB1
                                    mov word ptr es:[di + 0x24], bx;
                                    mov word ptr es:[di + 0x26], 0;
                                    $1 = $2;
                                    push($1);
                                    lcall 0x620, 0x219;
                                    or ax, ax;
                                    if (a == b) {  // je 0x7bcc
                                        // Block 0x7BCC
                                        mov word ptr es:[di + 0x1a], bx;
                                        mov word ptr es:[di + 0x18], ax;
                                        $1 = $2;
                                        mov word ptr es:[di + 0x1c], ax;
                                        $1 = 0;
                                        mov word ptr es:[di + 0x1e], ax;
                                        mov word ptr es:[di + 0x20], ax;
                                        $1 = $2;
                                        $1 = 0;
                                        mov word ptr es:[di + 0x74], ax;
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0x7BC7
                                        *($1) = $2;
                                        jmp 0x7bf3;
                                        // Block 0x7BF3
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 0x10
                                    }
                                }
                            }
                        } else {
                            // Block 0x7B69
                            $1 = $2;
                            mov word ptr es:[di + 0x22], dx;
                            $1 = $2;
                            push($1);
                            lcall 0xb95, 0x179;
                            or ax, ax;
                            if (a != b) {  // jne 0x7b92
                                // Block 0x7B92
                                mov word ptr [bp - 2], 0xffdb;
                                jmp 0x7bf3;
                                // Block 0x7BF3
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0x10
                            } else {
                                // Block 0x7B7C
                                mov word ptr es:[di + 0x24], bx;
                                mov word ptr es:[di + 0x26], 0;
                                $1 = $2;
                                push($1);
                                lcall 0xb95, 0x179;
                                or ax, ax;
                                if (a == b) {  // je 0x7bcc
                                    // Block 0x7BCC
                                    mov word ptr es:[di + 0x1a], bx;
                                    mov word ptr es:[di + 0x18], ax;
                                    $1 = $2;
                                    mov word ptr es:[di + 0x1c], ax;
                                    $1 = 0;
                                    mov word ptr es:[di + 0x1e], ax;
                                    mov word ptr es:[di + 0x20], ax;
                                    $1 = $2;
                                    $1 = 0;
                                    mov word ptr es:[di + 0x74], ax;
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0x7B92
                                    mov word ptr [bp - 2], 0xffdb;
                                    jmp 0x7bf3;
                                    // Block 0x7BF3
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 0x10
                                }
                            }
                        }
                    } else {
                        // Block 0x7B3A
                        $1 = $2;
                        mov word ptr es:[di + 0x22], dx;
                        $1 = $2;
                        int 0x67;
                        or ah, ah;
                        if (a != b) {  // jne 0x7b5c
                            // Block 0x7B5C
                            mov word ptr [bp - 2], 0xffea;
                            jmp 0x7bf3;
                            // Block 0x7BF3
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0x10
                        } else {
                            // Block 0x7B49
                            mov word ptr es:[di + 0x24], bx;
                            mov word ptr es:[di + 0x26], 0;
                            $1 = $2;
                            int 0x67;
                            and ax, 0xff00;
                            if (a == b) {  // je 0x7bcc
                                // Block 0x7BCC
                                mov word ptr es:[di + 0x1a], bx;
                                mov word ptr es:[di + 0x18], ax;
                                $1 = $2;
                                mov word ptr es:[di + 0x1c], ax;
                                $1 = 0;
                                mov word ptr es:[di + 0x1e], ax;
                                mov word ptr es:[di + 0x20], ax;
                                $1 = $2;
                                $1 = 0;
                                mov word ptr es:[di + 0x74], ax;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0x7B5C
                                mov word ptr [bp - 2], 0xffea;
                                jmp 0x7bf3;
                                // Block 0x7BF3
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0x10
                            }
                        }
                    }
                } else {
                    // Block 0x7B2C
                    $1 = $2;
                    $1 = $2;
                    jmp 0x7bcc;
                    // Block 0x7BCC
                    mov word ptr es:[di + 0x1a], bx;
                    mov word ptr es:[di + 0x18], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x1c], ax;
                    $1 = 0;
                    mov word ptr es:[di + 0x1e], ax;
                    mov word ptr es:[di + 0x20], ax;
                    $1 = $2;
                    $1 = 0;
                    mov word ptr es:[di + 0x74], ax;
                    mov word ptr [bp - 2], 0;
                }
            } else {
                // Block 0x7AF9
                inc ax;
            }
        } else {
            // Block 0x7AEF
            inc ax;
        }
    } else {
        // Block 0x7A78
        mov word ptr [bp - 2], 0xfc19;
        jmp 0x7bf3;
        // Block 0x7BF3
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0x10
    }

    // Function calls:
    sub_7A56();
}

void sub_8346() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0x8346
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lcall 0x98e, 0x12a;
    if (a >= b (unsigned)) {  // jae 0x8364
        // Block 0x8364
        $1 = $2;
        $1 = $2;
        $1 = $2;
        mov word ptr [bp - 2], ax;
    } else {
        // Block 0x835F
        *($1) = $2;
        jmp 0x836f;
        // Block 0x836F
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_8346();
    sub_85ED();
    sub_8346();
    sub_8791();
    sub_8346();
    sub_85ED();
    sub_8346();
    sub_8791();
    sub_8346();
    sub_85ED();
    sub_8346();
    sub_8791();
}

void sub_85ED() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 19 if statements

    // Block 0x85ED
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 6];
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    $1 = $2;
    $1 += $2;
    *($1) = $2;
    cmp word ptr [bp + 0xa], 0;
    if (a != b) {  // jne 0x861a
        // Block 0x861A
        cmp word ptr [bp + 0xe], 0;
        if (a != b) {  // jne 0x8623
            // Block 0x8623
            cmp word ptr [bp + 0xe], 1;
            if (a != b) {  // jne 0x866b
                // Block 0x866B
                cmp word ptr [bp + 0xe], 2;
                if (a != b) {  // jne 0x867e
                    // Block 0x867E
                    cmp word ptr [bp + 0xe], 3;
                    if (a != b) {  // jne 0x86c2
                        // Block 0x86C2
                        cmp word ptr [bp + 0xe], 4;
                        if (a != b) {  // jne 0x8721
                            // Block 0x8721
                            cmp word ptr [bp + 0xe], 5;
                            if (a != b) {  // jne 0x877f
                                // Block 0x877F
                                mov word ptr [bp - 2], 0xfff7;
                            } else {
                                // Block 0x8727
                                $1 = $2;
                                $1 += $2;
                                // Compare $1 with $2
                                if (a <= b (unsigned)) {  // jbe 0x8735
                                    // Block 0x8735
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    inc dx;
                                } else {
                                    // Block 0x8733
                                    jmp 0x877f;
                                    // Block 0x877F
                                    mov word ptr [bp - 2], 0xfff7;
                                }
                            }
                        } else {
                            // Block 0x86C8
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 += $2;
                            // Compare $1 with $2
                            if (a <= b (unsigned)) {  // jbe 0x86da
                                // Block 0x86DA
                                mov dx, word ptr [bp - 4];
                            } else {
                                // Block 0x86D7
                                jmp 0x877f;
                                // Block 0x877F
                                mov word ptr [bp - 2], 0xfff7;
                            }
                        }
                    } else {
                        // Block 0x8684
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        // Compare $1 with $2
                        if (a <= b (unsigned)) {  // jbe 0x8696
                            // Block 0x8696
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0x86ae
                                // Block 0x86AE
                                push($1);
                                push($1);
                                $1 = $2;
                                $1 = 0;
                                push($1);
                                $1 = $2;
                                INT_10_AH10();  // int 0x10
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1++;
                                loop 0x86ae;
                                jmp 0x8778;
                                // Block 0x8778
                                mov word ptr [bp - 2], 0;
                                jmp 0x8784;
                                // Block 0x8784
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            } else {
                                // Block 0x869B
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = pop();
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH10();  // int 0x10
                                $1 = pop();
                                jmp 0x8778;
                                // Block 0x8778
                                mov word ptr [bp - 2], 0;
                                jmp 0x8784;
                                // Block 0x8784
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x8693
                            jmp 0x877f;
                            // Block 0x877F
                            mov word ptr [bp - 2], 0xfff7;
                        }
                    }
                } else {
                    // Block 0x8671
                    $1 = $2;
                    $1 = 0;
                    push($1);
                    $1 = $2;
                    INT_10_AH0B();  // int 0x10
                    $1 = pop();
                    jmp 0x8778;
                    // Block 0x8778
                    mov word ptr [bp - 2], 0;
                    jmp 0x8784;
                    // Block 0x8784
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                }
            } else {
                // Block 0x8629
                $1 = $2;
                $1 = $2;
                // Compare $1 with $2
                if (a < b) {  // jl 0x8634
                    // Block 0x8634
                    or al, al;
                    if (a != b) {  // jne 0x863c
                        // Block 0x863C
                        // Compare $1 with $2
                        if (a != b) {  // jne 0x8647
                            // Block 0x8647
                            // Compare $1 with $2
                            if (a != b) {  // jne 0x864f
                                // Block 0x864F
                                $1 = $2;
                                or dh, 0x10;
                            } else {
                                // Block 0x864B
                                $1 = $2;
                                jmp 0x8654;
                                // Block 0x8654
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH0B();  // int 0x10
                                $1 = pop();
                                $1 = 0;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH0B();  // int 0x10
                                $1 = pop();
                                jmp 0x8778;
                                // Block 0x8778
                                mov word ptr [bp - 2], 0;
                                jmp 0x8784;
                                // Block 0x8784
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            }
                        } else {
                            // Block 0x8640
                            $1 = 0;
                            or dh, 0x10;
                            jmp 0x8654;
                            // Block 0x8654
                            $1 = $2;
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH0B();  // int 0x10
                            $1 = pop();
                            $1 = 0;
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH0B();  // int 0x10
                            $1 = pop();
                            jmp 0x8778;
                            // Block 0x8778
                            mov word ptr [bp - 2], 0;
                            jmp 0x8784;
                            // Block 0x8784
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        }
                    } else {
                        // Block 0x8638
                        $1 = 0;
                        jmp 0x8654;
                        // Block 0x8654
                        $1 = $2;
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        INT_10_AH0B();  // int 0x10
                        $1 = pop();
                        $1 = 0;
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        INT_10_AH0B();  // int 0x10
                        $1 = pop();
                        jmp 0x8778;
                        // Block 0x8778
                        mov word ptr [bp - 2], 0;
                        jmp 0x8784;
                        // Block 0x8784
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 0xa
                    }
                } else {
                    // Block 0x8632
                    sub al, 4;
                }
            }
        } else {
            // Block 0x8620
            jmp 0x877f;
            // Block 0x877F
            mov word ptr [bp - 2], 0xfff7;
        }
    } else {
        // Block 0x8617
        jmp 0x8778;
        // Block 0x8778
        mov word ptr [bp - 2], 0;
        jmp 0x8784;
        // Block 0x8784
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xa
    }
}

void sub_8791() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 15 if statements

    // Block 0x8791
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 6];
    cmp word ptr [bp + 0xe], 0;
    if (a != b) {  // jne 0x87ac
        // Block 0x87AC
        cmp word ptr [bp + 0xe], 1;
        if (a == b) {  // je 0x87ba
            // Block 0x87BA
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 = $2;
            and bl, 0xf;
            mov byte ptr es:[di], bl;
            $1 = $2;
            and bl, 0x20;
            $1 = $2;
            shr bl, cl;
            $1 = $2;
            $1 = $2;
            and bl, 0x10;
            $1 = $2;
            shr bl, cl;
            $1 += $2;
            mov byte ptr es:[di + 1], bl;
            jmp 0x88d8;
            // Block 0x88D8
            mov word ptr [bp - 2], 0;
            jmp 0x88e4;
            // Block 0x88E4
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 0xa
        } else {
            // Block 0x87B2
            cmp word ptr [bp + 0xe], 2;
            if (a == b) {  // je 0x87ba
                // Block 0x87BA
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                $1 = $2;
                $1 = $2;
                $1 = $2;
                and bl, 0xf;
                mov byte ptr es:[di], bl;
                $1 = $2;
                and bl, 0x20;
                $1 = $2;
                shr bl, cl;
                $1 = $2;
                $1 = $2;
                and bl, 0x10;
                $1 = $2;
                shr bl, cl;
                $1 += $2;
                mov byte ptr es:[di + 1], bl;
                jmp 0x88d8;
                // Block 0x88D8
                mov word ptr [bp - 2], 0;
                jmp 0x88e4;
                // Block 0x88E4
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xa
            } else {
                // Block 0x87B8
                jmp 0x87eb;
                // Block 0x87EB
                cmp word ptr [bp + 0xe], 3;
                if (a != b) {  // jne 0x8859
                    // Block 0x8859
                    cmp word ptr [bp + 0xe], 4;
                    if (a != b) {  // jne 0x88b7
                        // Block 0x88B7
                        cmp word ptr [bp + 0xe], 5;
                        if (a != b) {  // jne 0x88df
                            // Block 0x88DF
                            mov word ptr [bp - 2], 0xfff7;
                        } else {
                            // Block 0x88BD
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 += $2;
                            // Compare $1 with $2
                            if (a <= b (unsigned)) {  // jbe 0x88ce
                                // Block 0x88CE
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                INT_10_AH10();  // int 0x10
                                pop bp;
                            } else {
                                // Block 0x88CC
                                jmp 0x88df;
                                // Block 0x88DF
                                mov word ptr [bp - 2], 0xfff7;
                            }
                        }
                    } else {
                        // Block 0x885F
                        $1 = $2;
                        push($1);
                        $1 = $2;
                        INT_10_AH10();  // int 0x10
                        $1 = pop();
                        $1 = $2;
                        shl bl, 1;
                        $1 -= $2;
                        $1 = $2;
                        shl bl, cl;
                        $1 = $2;
                        shl bh, cl;
                        not bh;
                        *($1) = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 += $2;
                        // Compare $1 with $2
                        if (a <= b (unsigned)) {  // jbe 0x888b
                            // Block 0x888B
                            push($1);
                            push($1);
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH10();  // int 0x10
                            $1 = pop();
                            $1 = $2;
                            and bh, ah;
                            or bh, al;
                            $1 = $2;
                            $1 = 0;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            push($1);
                            $1 = $2;
                            INT_10_AH10();  // int 0x10
                            $1 = pop();
                            $1 += $2;
                            $1 = pop();
                            $1 = pop();
                            $1++;
                            loop 0x888b;
                            jmp 0x88d8;
                            // Block 0x88D8
                            mov word ptr [bp - 2], 0;
                            jmp 0x88e4;
                            // Block 0x88E4
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 0xa
                        } else {
                            // Block 0x8889
                            jmp 0x88df;
                            // Block 0x88DF
                            mov word ptr [bp - 2], 0xfff7;
                        }
                    }
                } else {
                    // Block 0x87F1
                    lcall 0x98e, 0x35e;
                    *($1) = $2;
                    $1 = $2;
                    $1 += $2;
                    // Compare $1 with $2
                    if (a <= b (unsigned)) {  // jbe 0x8807
                        // Block 0x8807
                        push($1);
                        $1 = $2;
                        $1 = $2;
                        $1 = pop();
                        lds si, ptr [0xa8];
                        lds si, ptr [si + 4];
                        $1 = $2;
                        or ax, si;
                        if (a != b) {  // jne 0x8848
                            // Block 0x8848
                            $1 = $2;
                            $1 += $2;
                            rep movsb byte ptr es:[di], byte ptr [si];
                            cmp word ptr [bp + 0xa], 0x10;
                            if (a != b) {  // jne 0x8857
                                // Block 0x8857
                                jmp 0x88d8;
                                // Block 0x88D8
                                mov word ptr [bp - 2], 0;
                                jmp 0x88e4;
                                // Block 0x88E4
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 0xa
                            } else {
                                // Block 0x8856
                                movsb byte ptr es:[di], byte ptr [si];
                            }
                        } else {
                            // Block 0x881B
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            $1 = pop();
                            lea si, [bp - 0x18];
                            xor bx, bx;
                        }
                    } else {
                        // Block 0x8804
                        jmp 0x88df;
                        // Block 0x88DF
                        mov word ptr [bp - 2], 0xfff7;
                    }
                }
            }
        }
    } else {
        // Block 0x87A9
        jmp 0x88df;
        // Block 0x88DF
        mov word ptr [bp - 2], 0xfff7;
    }
}

void sub_893A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 73 if statements

    // Block 0x893A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov byte ptr [bp - 0x36], 0x78;
    mov byte ptr [bp - 0x35], 0x7e;
    mov byte ptr [bp - 0x34], 0x28;
    mov byte ptr [bp - 0x33], 0x28;
    mov byte ptr [bp - 0x32], 0x28;
    mov byte ptr [bp - 0x31], 0x28;
    mov byte ptr [bp - 0x30], 0x18;
    mov byte ptr [bp - 0x2f], 8;
    mov byte ptr [bp - 0x2e], 0x18;
    mov byte ptr [bp - 0x2d], 7;
    mov byte ptr [bp - 0x2c], 8;
    mov byte ptr [bp - 0x2b], 8;
    mov byte ptr [bp - 0x2a], 8;
    mov byte ptr [bp - 0x29], 8;
    mov byte ptr [bp - 0x28], 8;
    mov byte ptr [bp - 0x27], 8;
    mov byte ptr [bp - 0x26], 8;
    mov byte ptr [bp - 0x25], 8;
    mov byte ptr [bp - 0x24], 8;
    mov byte ptr [bp - 0x23], 8;
    mov byte ptr [bp - 0x22], 8;
    mov byte ptr [bp - 0x21], 8;
    mov byte ptr [bp - 0x20], 8;
    mov byte ptr [bp - 0x1f], 8;
    mov byte ptr [bp - 0x1e], 8;
    mov byte ptr [bp - 0x1d], 8;
    mov byte ptr [bp - 0x1c], 8;
    mov byte ptr [bp - 0x1b], 8;
    mov byte ptr [bp - 0x1a], 8;
    mov byte ptr [bp - 0x19], 8;
    mov byte ptr [bp - 0x18], 8;
    mov byte ptr [bp - 0x17], 8;
    mov byte ptr [bp - 0x16], 8;
    mov byte ptr [bp - 0x15], 8;
    mov byte ptr [bp - 0x14], 8;
    mov byte ptr [bp - 0x13], 8;
    mov byte ptr [bp - 0x12], 8;
    mov byte ptr [bp - 0x11], 8;
    mov byte ptr [bp - 0x10], 8;
    mov byte ptr [bp - 0xf], 8;
    mov byte ptr [bp - 0xe], 8;
    mov byte ptr [bp - 0x60], 0x78;
    mov byte ptr [bp - 0x5f], 0x78;
    mov byte ptr [bp - 0x5e], 0x38;
    mov byte ptr [bp - 0x5d], 0x38;
    mov byte ptr [bp - 0x5c], 0x98;
    mov byte ptr [bp - 0x5b], 0x38;
    mov byte ptr [bp - 0x5a], 0x18;
    mov byte ptr [bp - 0x59], 0x18;
    mov byte ptr [bp - 0x58], 0x18;
    mov byte ptr [bp - 0x57], 0xa0;
    mov byte ptr [bp - 0x56], 0x18;
    mov byte ptr [bp - 0x55], 0x18;
    mov byte ptr [bp - 0x54], 0x18;
    mov byte ptr [bp - 0x53], 0x18;
    mov byte ptr [bp - 0x52], 0x18;
    mov byte ptr [bp - 0x51], 0x98;
    mov byte ptr [bp - 0x50], 0x18;
    mov byte ptr [bp - 0x4f], 0x18;
    mov byte ptr [bp - 0x4e], 0x18;
    mov byte ptr [bp - 0x4d], 0x18;
    mov byte ptr [bp - 0x4c], 0x18;
    mov byte ptr [bp - 0x4b], 0x18;
    mov byte ptr [bp - 0x4a], 0x18;
    mov byte ptr [bp - 0x49], 0x18;
    mov byte ptr [bp - 0x48], 0x18;
    mov byte ptr [bp - 0x47], 0x18;
    mov byte ptr [bp - 0x46], 0x18;
    mov byte ptr [bp - 0x45], 0x18;
    mov byte ptr [bp - 0x44], 0x18;
    mov byte ptr [bp - 0x43], 0x18;
    mov byte ptr [bp - 0x42], 0x18;
    mov byte ptr [bp - 0x41], 0x18;
    mov byte ptr [bp - 0x40], 0x18;
    mov byte ptr [bp - 0x3f], 0x18;
    mov byte ptr [bp - 0x3e], 0x18;
    mov byte ptr [bp - 0x3d], 0x18;
    mov byte ptr [bp - 0x3c], 0x18;
    mov byte ptr [bp - 0x3b], 0x18;
    mov byte ptr [bp - 0x3a], 0x18;
    mov byte ptr [bp - 0x39], 0x18;
    mov byte ptr [bp - 0x38], 0x18;
    mov byte ptr [bp - 0x80], 0x88;
    mov byte ptr [bp - 0x7f], 0x88;
    mov byte ptr [bp - 0x7e], 0x88;
    mov byte ptr [bp - 0x7d], 0x88;
    mov byte ptr [bp - 0x7c], 0x40;
    mov byte ptr [bp - 0x7b], 0x40;
    mov byte ptr [bp - 0x7a], 0x40;
    mov byte ptr [bp - 0x79], 0x40;
    mov byte ptr [bp - 0x78], 0x20;
    mov byte ptr [bp - 0x77], 0x20;
    mov byte ptr [bp - 0x76], 0x20;
    mov byte ptr [bp - 0x75], 0x20;
    mov byte ptr [bp - 0x74], 0x10;
    mov byte ptr [bp - 0x73], 0x10;
    mov byte ptr [bp - 0x72], 0x10;
    mov byte ptr [bp - 0x71], 0x10;
    mov byte ptr [bp - 0x70], 8;
    mov byte ptr [bp - 0x6f], 0x40;
    mov byte ptr [bp - 0x6e], 0x40;
    mov byte ptr [bp - 0x6d], 0x20;
    mov byte ptr [bp - 0x6c], 0x10;
    mov byte ptr [bp - 0x6b], 4;
    mov byte ptr [bp - 0x6a], 4;
    mov byte ptr [bp - 0x69], 4;
    mov byte ptr [bp - 0x68], 4;
    mov byte ptr [bp - 0x67], 4;
    mov byte ptr [bp - 0x66], 0xfc;
    mov byte ptr [bp - 0x65], 0xfc;
    mov byte ptr [bp - 0x64], 0xfc;
    mov byte ptr [bp - 0x63], 0xfc;
    mov byte ptr [bp - 0x62], 0xfc;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0x8b19
        // Block 0x8B19
        push($1);
        lea ax, [bp - 6];
        push($1);
        lcall 0xae3, 0;
        or ax, ax;
        if (a == b) {  // je 0x8b2d
            // Block 0x8B2D
            // Compare $1 with $2
            if (a == b) {  // je 0x8b37
                // Block 0x8B37
                cmp byte ptr [bp - 4], 0;
                if (a == b) {  // je 0x8b40
                    // Block 0x8B40
                    cmp byte ptr [bp - 6], 0x80;
                    if (a < b (unsigned)) {  // jb 0x8b4a
                        // Block 0x8B4A
                        $1 = $2;
                        $1 = $2;
                        clc ;
                        shl al, cl;
                        if (a < b (unsigned)) {  // jb 0x8b58
                            // Block 0x8B58
                            $1 = $2;
                            $1 = $2;
                            clc ;
                            shl al, cl;
                            if (a < b (unsigned)) {  // jb 0x8b66
                                // Block 0x8B66
                                // Compare $1 with $2
                                if (a >= b (unsigned)) {  // jae 0x8b6e
                                    // Block 0x8B6E
                                    lcall 0x921, 0x1a5;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x8bb9
                                        // Block 0x8BB9
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0x8bca
                                            // Block 0x8BCA
                                            push($1);
                                            push($1);
                                            lea ax, [bp - 0xc];
                                            push($1);
                                            lcall 0x921, 0x1fc;
                                            or ax, ax;
                                            if (a == b) {  // je 0x8bde
                                                // Block 0x8BDE
                                                $1 = $2;
                                                $1 = $2;
                                                clc ;
                                                shl al, cl;
                                                if (a < b (unsigned)) {  // jb 0x8bec
                                                    // Block 0x8BEC
                                                    // Compare $1 with $2
                                                    if (a < b (unsigned)) {  // jb 0x8c05
                                                        // Block 0x8C05
                                                        // Compare $1 with $2
                                                        if (a > b (unsigned)) {  // ja 0x8c11
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        } else {
                                                            // Block 0x8C0A
                                                            mov word ptr [bp - 2], 0;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    } else {
                                                        // Block 0x8BF1
                                                        push($1);
                                                        push($1);
                                                        lcall 0x98e, 0xc;
                                                        $1 = $2;
                                                        or si, si;
                                                        if (a >= b) {  // jge 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8C00
                                                            *($1) = $2;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x8BEA
                                                    jmp 0x8c11;
                                                    // Block 0x8C11
                                                    mov word ptr [bp - 2], 0xfffa;
                                                }
                                            } else {
                                                // Block 0x8BD9
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8BBE
                                            lcall 0x921, 0x55;
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0x8bca
                                                // Block 0x8BCA
                                                push($1);
                                                push($1);
                                                lea ax, [bp - 0xc];
                                                push($1);
                                                lcall 0x921, 0x1fc;
                                                or ax, ax;
                                                if (a == b) {  // je 0x8bde
                                                    // Block 0x8BDE
                                                    $1 = $2;
                                                    $1 = $2;
                                                    clc ;
                                                    shl al, cl;
                                                    if (a < b (unsigned)) {  // jb 0x8bec
                                                        // Block 0x8BEC
                                                        // Compare $1 with $2
                                                        if (a < b (unsigned)) {  // jb 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8BF1
                                                            push($1);
                                                            push($1);
                                                            lcall 0x98e, 0xc;
                                                            $1 = $2;
                                                            or si, si;
                                                            if (a >= b) {  // jge 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8C00
                                                                *($1) = $2;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x8BEA
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BD9
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8BC8
                                                jmp 0x8c11;
                                                // Block 0x8C11
                                                mov word ptr [bp - 2], 0xfffa;
                                            }
                                        }
                                    } else {
                                        // Block 0x8B78
                                        // Compare $1 with $2
                                        if (a >= b (unsigned)) {  // jae 0x8b80
                                            // Block 0x8B80
                                            push($1);
                                            lcall 0x98e, 0xdf;
                                            if (a >= b (unsigned)) {  // jae 0x8b8e
                                                // Block 0x8B8E
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                INT_10_AH4F();  // int 0x10
                                                // Compare $1 with $2
                                                if (a == b) {  // je 0x8bb0
                                                    // Block 0x8BB0
                                                    test word ptr es:[di], 1;
                                                    if (a != b) {  // jne 0x8c0a
                                                        // Block 0x8C0A
                                                        mov word ptr [bp - 2], 0;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    } else {
                                                        // Block 0x8BB7
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BA9
                                                    mov word ptr [bp - 2], 0xffd8;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8B88
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8B7D
                                            jmp 0x8c11;
                                            // Block 0x8C11
                                            mov word ptr [bp - 2], 0xfffa;
                                        }
                                    }
                                } else {
                                    // Block 0x8B6B
                                    jmp 0x8c0a;
                                    // Block 0x8C0A
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x8c16;
                                    // Block 0x8C16
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 2
                                }
                            } else {
                                // Block 0x8B63
                                jmp 0x8c11;
                                // Block 0x8C11
                                mov word ptr [bp - 2], 0xfffa;
                            }
                        } else {
                            // Block 0x8B55
                            jmp 0x8c11;
                            // Block 0x8C11
                            mov word ptr [bp - 2], 0xfffa;
                        }
                    } else {
                        // Block 0x8B46
                        sub byte ptr [bp - 6], 0x7a;
                    }
                } else {
                    // Block 0x8B3D
                    jmp 0x8c11;
                    // Block 0x8C11
                    mov word ptr [bp - 2], 0xfffa;
                }
            } else {
                // Block 0x8B32
                // Compare $1 with $2
                if (a != b) {  // jne 0x8b40
                    // Block 0x8B40
                    cmp byte ptr [bp - 6], 0x80;
                    if (a < b (unsigned)) {  // jb 0x8b4a
                        // Block 0x8B4A
                        $1 = $2;
                        $1 = $2;
                        clc ;
                        shl al, cl;
                        if (a < b (unsigned)) {  // jb 0x8b58
                            // Block 0x8B58
                            $1 = $2;
                            $1 = $2;
                            clc ;
                            shl al, cl;
                            if (a < b (unsigned)) {  // jb 0x8b66
                                // Block 0x8B66
                                // Compare $1 with $2
                                if (a >= b (unsigned)) {  // jae 0x8b6e
                                    // Block 0x8B6E
                                    lcall 0x921, 0x1a5;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0x8bb9
                                        // Block 0x8BB9
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0x8bca
                                            // Block 0x8BCA
                                            push($1);
                                            push($1);
                                            lea ax, [bp - 0xc];
                                            push($1);
                                            lcall 0x921, 0x1fc;
                                            or ax, ax;
                                            if (a == b) {  // je 0x8bde
                                                // Block 0x8BDE
                                                $1 = $2;
                                                $1 = $2;
                                                clc ;
                                                shl al, cl;
                                                if (a < b (unsigned)) {  // jb 0x8bec
                                                    // Block 0x8BEC
                                                    // Compare $1 with $2
                                                    if (a < b (unsigned)) {  // jb 0x8c05
                                                        // Block 0x8C05
                                                        // Compare $1 with $2
                                                        if (a > b (unsigned)) {  // ja 0x8c11
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        } else {
                                                            // Block 0x8C0A
                                                            mov word ptr [bp - 2], 0;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    } else {
                                                        // Block 0x8BF1
                                                        push($1);
                                                        push($1);
                                                        lcall 0x98e, 0xc;
                                                        $1 = $2;
                                                        or si, si;
                                                        if (a >= b) {  // jge 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8C00
                                                            *($1) = $2;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        }
                                                    }
                                                } else {
                                                    // Block 0x8BEA
                                                    jmp 0x8c11;
                                                    // Block 0x8C11
                                                    mov word ptr [bp - 2], 0xfffa;
                                                }
                                            } else {
                                                // Block 0x8BD9
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8BBE
                                            lcall 0x921, 0x55;
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0x8bca
                                                // Block 0x8BCA
                                                push($1);
                                                push($1);
                                                lea ax, [bp - 0xc];
                                                push($1);
                                                lcall 0x921, 0x1fc;
                                                or ax, ax;
                                                if (a == b) {  // je 0x8bde
                                                    // Block 0x8BDE
                                                    $1 = $2;
                                                    $1 = $2;
                                                    clc ;
                                                    shl al, cl;
                                                    if (a < b (unsigned)) {  // jb 0x8bec
                                                        // Block 0x8BEC
                                                        // Compare $1 with $2
                                                        if (a < b (unsigned)) {  // jb 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8BF1
                                                            push($1);
                                                            push($1);
                                                            lcall 0x98e, 0xc;
                                                            $1 = $2;
                                                            or si, si;
                                                            if (a >= b) {  // jge 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8C00
                                                                *($1) = $2;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x8BEA
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BD9
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8BC8
                                                jmp 0x8c11;
                                                // Block 0x8C11
                                                mov word ptr [bp - 2], 0xfffa;
                                            }
                                        }
                                    } else {
                                        // Block 0x8B78
                                        // Compare $1 with $2
                                        if (a >= b (unsigned)) {  // jae 0x8b80
                                            // Block 0x8B80
                                            push($1);
                                            lcall 0x98e, 0xdf;
                                            if (a >= b (unsigned)) {  // jae 0x8b8e
                                                // Block 0x8B8E
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                $1 = $2;
                                                INT_10_AH4F();  // int 0x10
                                                // Compare $1 with $2
                                                if (a == b) {  // je 0x8bb0
                                                    // Block 0x8BB0
                                                    test word ptr es:[di], 1;
                                                    if (a != b) {  // jne 0x8c0a
                                                        // Block 0x8C0A
                                                        mov word ptr [bp - 2], 0;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    } else {
                                                        // Block 0x8BB7
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BA9
                                                    mov word ptr [bp - 2], 0xffd8;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8B88
                                                *($1) = $2;
                                                jmp 0x8c16;
                                                // Block 0x8C16
                                                $1 = $2;
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = pop();
                                                $1 = $2;
                                                $1 = pop();
                                                return;  // retf 2
                                            }
                                        } else {
                                            // Block 0x8B7D
                                            jmp 0x8c11;
                                            // Block 0x8C11
                                            mov word ptr [bp - 2], 0xfffa;
                                        }
                                    }
                                } else {
                                    // Block 0x8B6B
                                    jmp 0x8c0a;
                                    // Block 0x8C0A
                                    mov word ptr [bp - 2], 0;
                                    jmp 0x8c16;
                                    // Block 0x8C16
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 2
                                }
                            } else {
                                // Block 0x8B63
                                jmp 0x8c11;
                                // Block 0x8C11
                                mov word ptr [bp - 2], 0xfffa;
                            }
                        } else {
                            // Block 0x8B55
                            jmp 0x8c11;
                            // Block 0x8C11
                            mov word ptr [bp - 2], 0xfffa;
                        }
                    } else {
                        // Block 0x8B46
                        sub byte ptr [bp - 6], 0x7a;
                    }
                } else {
                    // Block 0x8B37
                    cmp byte ptr [bp - 4], 0;
                    if (a == b) {  // je 0x8b40
                        // Block 0x8B40
                        cmp byte ptr [bp - 6], 0x80;
                        if (a < b (unsigned)) {  // jb 0x8b4a
                            // Block 0x8B4A
                            $1 = $2;
                            $1 = $2;
                            clc ;
                            shl al, cl;
                            if (a < b (unsigned)) {  // jb 0x8b58
                                // Block 0x8B58
                                $1 = $2;
                                $1 = $2;
                                clc ;
                                shl al, cl;
                                if (a < b (unsigned)) {  // jb 0x8b66
                                    // Block 0x8B66
                                    // Compare $1 with $2
                                    if (a >= b (unsigned)) {  // jae 0x8b6e
                                        // Block 0x8B6E
                                        lcall 0x921, 0x1a5;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0x8bb9
                                            // Block 0x8BB9
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0x8bca
                                                // Block 0x8BCA
                                                push($1);
                                                push($1);
                                                lea ax, [bp - 0xc];
                                                push($1);
                                                lcall 0x921, 0x1fc;
                                                or ax, ax;
                                                if (a == b) {  // je 0x8bde
                                                    // Block 0x8BDE
                                                    $1 = $2;
                                                    $1 = $2;
                                                    clc ;
                                                    shl al, cl;
                                                    if (a < b (unsigned)) {  // jb 0x8bec
                                                        // Block 0x8BEC
                                                        // Compare $1 with $2
                                                        if (a < b (unsigned)) {  // jb 0x8c05
                                                            // Block 0x8C05
                                                            // Compare $1 with $2
                                                            if (a > b (unsigned)) {  // ja 0x8c11
                                                                // Block 0x8C11
                                                                mov word ptr [bp - 2], 0xfffa;
                                                            } else {
                                                                // Block 0x8C0A
                                                                mov word ptr [bp - 2], 0;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        } else {
                                                            // Block 0x8BF1
                                                            push($1);
                                                            push($1);
                                                            lcall 0x98e, 0xc;
                                                            $1 = $2;
                                                            or si, si;
                                                            if (a >= b) {  // jge 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8C00
                                                                *($1) = $2;
                                                                jmp 0x8c16;
                                                                // Block 0x8C16
                                                                $1 = $2;
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = pop();
                                                                $1 = $2;
                                                                $1 = pop();
                                                                return;  // retf 2
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0x8BEA
                                                        jmp 0x8c11;
                                                        // Block 0x8C11
                                                        mov word ptr [bp - 2], 0xfffa;
                                                    }
                                                } else {
                                                    // Block 0x8BD9
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8BBE
                                                lcall 0x921, 0x55;
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0x8bca
                                                    // Block 0x8BCA
                                                    push($1);
                                                    push($1);
                                                    lea ax, [bp - 0xc];
                                                    push($1);
                                                    lcall 0x921, 0x1fc;
                                                    or ax, ax;
                                                    if (a == b) {  // je 0x8bde
                                                        // Block 0x8BDE
                                                        $1 = $2;
                                                        $1 = $2;
                                                        clc ;
                                                        shl al, cl;
                                                        if (a < b (unsigned)) {  // jb 0x8bec
                                                            // Block 0x8BEC
                                                            // Compare $1 with $2
                                                            if (a < b (unsigned)) {  // jb 0x8c05
                                                                // Block 0x8C05
                                                                // Compare $1 with $2
                                                                if (a > b (unsigned)) {  // ja 0x8c11
                                                                    // Block 0x8C11
                                                                    mov word ptr [bp - 2], 0xfffa;
                                                                } else {
                                                                    // Block 0x8C0A
                                                                    mov word ptr [bp - 2], 0;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            } else {
                                                                // Block 0x8BF1
                                                                push($1);
                                                                push($1);
                                                                lcall 0x98e, 0xc;
                                                                $1 = $2;
                                                                or si, si;
                                                                if (a >= b) {  // jge 0x8c05
                                                                    // Block 0x8C05
                                                                    // Compare $1 with $2
                                                                    if (a > b (unsigned)) {  // ja 0x8c11
                                                                        // Block 0x8C11
                                                                        mov word ptr [bp - 2], 0xfffa;
                                                                    } else {
                                                                        // Block 0x8C0A
                                                                        mov word ptr [bp - 2], 0;
                                                                        jmp 0x8c16;
                                                                        // Block 0x8C16
                                                                        $1 = $2;
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        $1 = $2;
                                                                        $1 = pop();
                                                                        return;  // retf 2
                                                                    }
                                                                } else {
                                                                    // Block 0x8C00
                                                                    *($1) = $2;
                                                                    jmp 0x8c16;
                                                                    // Block 0x8C16
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    $1 = $2;
                                                                    $1 = pop();
                                                                    return;  // retf 2
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0x8BEA
                                                            jmp 0x8c11;
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        }
                                                    } else {
                                                        // Block 0x8BD9
                                                        *($1) = $2;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    }
                                                } else {
                                                    // Block 0x8BC8
                                                    jmp 0x8c11;
                                                    // Block 0x8C11
                                                    mov word ptr [bp - 2], 0xfffa;
                                                }
                                            }
                                        } else {
                                            // Block 0x8B78
                                            // Compare $1 with $2
                                            if (a >= b (unsigned)) {  // jae 0x8b80
                                                // Block 0x8B80
                                                push($1);
                                                lcall 0x98e, 0xdf;
                                                if (a >= b (unsigned)) {  // jae 0x8b8e
                                                    // Block 0x8B8E
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    $1 = $2;
                                                    INT_10_AH4F();  // int 0x10
                                                    // Compare $1 with $2
                                                    if (a == b) {  // je 0x8bb0
                                                        // Block 0x8BB0
                                                        test word ptr es:[di], 1;
                                                        if (a != b) {  // jne 0x8c0a
                                                            // Block 0x8C0A
                                                            mov word ptr [bp - 2], 0;
                                                            jmp 0x8c16;
                                                            // Block 0x8C16
                                                            $1 = $2;
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = pop();
                                                            $1 = $2;
                                                            $1 = pop();
                                                            return;  // retf 2
                                                        } else {
                                                            // Block 0x8BB7
                                                            jmp 0x8c11;
                                                            // Block 0x8C11
                                                            mov word ptr [bp - 2], 0xfffa;
                                                        }
                                                    } else {
                                                        // Block 0x8BA9
                                                        mov word ptr [bp - 2], 0xffd8;
                                                        jmp 0x8c16;
                                                        // Block 0x8C16
                                                        $1 = $2;
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = pop();
                                                        $1 = $2;
                                                        $1 = pop();
                                                        return;  // retf 2
                                                    }
                                                } else {
                                                    // Block 0x8B88
                                                    *($1) = $2;
                                                    jmp 0x8c16;
                                                    // Block 0x8C16
                                                    $1 = $2;
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = pop();
                                                    $1 = $2;
                                                    $1 = pop();
                                                    return;  // retf 2
                                                }
                                            } else {
                                                // Block 0x8B7D
                                                jmp 0x8c11;
                                                // Block 0x8C11
                                                mov word ptr [bp - 2], 0xfffa;
                                            }
                                        }
                                    } else {
                                        // Block 0x8B6B
                                        jmp 0x8c0a;
                                        // Block 0x8C0A
                                        mov word ptr [bp - 2], 0;
                                        jmp 0x8c16;
                                        // Block 0x8C16
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 2
                                    }
                                } else {
                                    // Block 0x8B63
                                    jmp 0x8c11;
                                    // Block 0x8C11
                                    mov word ptr [bp - 2], 0xfffa;
                                }
                            } else {
                                // Block 0x8B55
                                jmp 0x8c11;
                                // Block 0x8C11
                                mov word ptr [bp - 2], 0xfffa;
                            }
                        } else {
                            // Block 0x8B46
                            sub byte ptr [bp - 6], 0x7a;
                        }
                    } else {
                        // Block 0x8B3D
                        jmp 0x8c11;
                        // Block 0x8C11
                        mov word ptr [bp - 2], 0xfffa;
                    }
                }
            }
        } else {
            // Block 0x8B27
            *($1) = $2;
            jmp 0x8c16;
            // Block 0x8C16
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    } else {
        // Block 0x8B16
        jmp 0x8c11;
        // Block 0x8C11
        mov word ptr [bp - 2], 0xfffa;
    }

    // Function calls:
    sub_893A();
    sub_893A();
    sub_893A();
    sub_893A();
    sub_901A();
}

void sub_901A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 107 if statements

    // Block 0x901A
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x312;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x5ab;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x637;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x43c;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov word ptr [bx + 0x30], 0x76e;
    $1 += $2;
    mov byte ptr [0x55f3], 1;
    return;  // retf 

    // Function calls:
    sub_987E();
}

void sub_987E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 50 if statements

    // Block 0x987E
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x1e6;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x2dd;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x31e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x251;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov word ptr [bx + 0x2c], 0x38e;
    $1 += $2;
    mov byte ptr [0x55f1], 1;
    return;  // retf 

    // Function calls:
    sub_9EBD();
}

void sub_9EBD() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0x9EBD
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 8];
    cmp byte ptr es:[di], 1;
    if (a == b) {  // je 0x9ee3
        // Block 0x9EE3
        $1 = $2;
        // Compare $1 with $2
        if (a != b) {  // jne 0x9eee
            // Block 0x9EEE
            // Compare $1 with $2
            if (a <= b (unsigned)) {  // jbe 0x9efb
                // Block 0x9EFB
                $1 = $2;
                $1 -= $2;
                if (condition_jns) {  // jns 0x9f07
                    // Block 0x9F07
                    // Compare $1 with $2
                    if (a < b (unsigned)) {  // jb 0x9f0d
                        // Block 0x9F0D
                        *($1) = $2;
                        $1 = $2;
                        mul bx;
                        $1 += $2;
                        adc dx, word ptr es:[di + 0x48];
                        $1 += $2;
                        adc dx, 0;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        DOS_MoveFilePointer();  // int 0x21
                        $1 = $2;
                        // Compare $1 with $2
                        if (a < b (unsigned)) {  // jb 0x9f3f
                            // Block 0x9F3F
                            $1 = $2;
                            mul bx;
                            lds si, ptr es:[di + 0x50];
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_ReadFile();  // int 0x21
                            if (a >= b (unsigned)) {  // jae 0x9f5d
                                // Block 0x9F5D
                                $1 = $2;
                                mov word ptr es:[di + 0x4a], ax;
                                $1 = $2;
                                mov word ptr es:[di + 0x4c], ax;
                            } else {
                                // Block 0x9F56
                                mov word ptr [bp - 2], 0xfffd;
                                jmp 0x9f70;
                                // Block 0x9F70
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            }
                        } else {
                            // Block 0x9F3B
                            mov ax, word ptr es:[di + 0x44];
                        }
                    } else {
                        // Block 0x9F0B
                        mov ax, bx;
                    }
                } else {
                    // Block 0x9F05
                    xor bx, bx;
                }
            } else {
                // Block 0x9EF4
                mov word ptr [bp - 2], 0xfc19;
                jmp 0x9f70;
                // Block 0x9F70
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 6
            }
        } else {
            // Block 0x9EEC
            jmp 0x9f6b;
            // Block 0x9F6B
            mov word ptr [bp - 2], 0;
        }
    } else {
        // Block 0x9ED5
        cmp byte ptr es:[di], 2;
        if (a == b) {  // je 0x9ee3
            // Block 0x9EE3
            $1 = $2;
            // Compare $1 with $2
            if (a != b) {  // jne 0x9eee
                // Block 0x9EEE
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0x9efb
                    // Block 0x9EFB
                    $1 = $2;
                    $1 -= $2;
                    if (condition_jns) {  // jns 0x9f07
                        // Block 0x9F07
                        // Compare $1 with $2
                        if (a < b (unsigned)) {  // jb 0x9f0d
                            // Block 0x9F0D
                            *($1) = $2;
                            $1 = $2;
                            mul bx;
                            $1 += $2;
                            adc dx, word ptr es:[di + 0x48];
                            $1 += $2;
                            adc dx, 0;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            DOS_MoveFilePointer();  // int 0x21
                            $1 = $2;
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0x9f3f
                                // Block 0x9F3F
                                $1 = $2;
                                mul bx;
                                lds si, ptr es:[di + 0x50];
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                DOS_ReadFile();  // int 0x21
                                if (a >= b (unsigned)) {  // jae 0x9f5d
                                    // Block 0x9F5D
                                    $1 = $2;
                                    mov word ptr es:[di + 0x4a], ax;
                                    $1 = $2;
                                    mov word ptr es:[di + 0x4c], ax;
                                } else {
                                    // Block 0x9F56
                                    mov word ptr [bp - 2], 0xfffd;
                                    jmp 0x9f70;
                                    // Block 0x9F70
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 6
                                }
                            } else {
                                // Block 0x9F3B
                                mov ax, word ptr es:[di + 0x44];
                            }
                        } else {
                            // Block 0x9F0B
                            mov ax, bx;
                        }
                    } else {
                        // Block 0x9F05
                        xor bx, bx;
                    }
                } else {
                    // Block 0x9EF4
                    mov word ptr [bp - 2], 0xfc19;
                    jmp 0x9f70;
                    // Block 0x9F70
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 6
                }
            } else {
                // Block 0x9EEC
                jmp 0x9f6b;
                // Block 0x9F6B
                mov word ptr [bp - 2], 0;
            }
        } else {
            // Block 0x9EDB
            mov word ptr [bp - 2], 0xfff4;
            jmp 0x9f70;
            // Block 0x9F70
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 6
        }
    }
}

void sub_9F7D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 65 if statements

    // Block 0x9F7D
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    lds si, ptr [bp + 0x10];
    cmp byte ptr [si], 0;
    if (a == b) {  // je 0x9faa
        // Block 0x9FAA
        $1 = $2;
        INT_21();  // int 0x21
        $1 = $2;
        *($1) = $2;
        *($1) = $2;
        push($1);
        $1 = $2;
        $1 = $2;
        lea dx, [bp - 0x96];
        $1 = $2;
        INT_21_AH1A();  // int 0x21
        $1 = pop();
        cmp word ptr [bp + 6], -1;
        if (a == b) {  // je 0x9fde
            // Block 0x9FDE
            $1 = $2;
            $1 = $2;
            push($1);
            cld ;
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 -= $2;
            *($1) = $2;
            mov word ptr [bp + 0xc], di;
        } else {
            // Block 0x9FCA
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            INT_21_AH1A();  // int 0x21
            $1 = pop();
            cmp word ptr [bp + 6], 1;
            if (a == b) {  // je 0xa024
                // Block 0xA024
                $1 = $2;
                INT_21();  // int 0x21
                if (a >= b (unsigned)) {  // jae 0xa031
                    // Block 0xA031
                    $1 = $2;
                    INT_21();  // int 0x21
                    push($1);
                    $1 = $2;
                    $1 = $2;
                    $1 = pop();
                    $1 = $2;
                    les di, ptr [bp + 8];
                    mov byte ptr es:[di], 0;
                    $1 = 0;
                    mov word ptr es:[di + 0xe], ax;
                    mov word ptr es:[di + 0x10], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x12], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x14], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x16], ax;
                    $1 = $2;
                    mov word ptr es:[di + 0x18], ax;
                    $1 += $2;
                    $1 += $2;
                    $1 = $2;
                    cmp byte ptr [si], 0;
                    if (a == b) {  // je 0xa08e
                        // Block 0xA08E
                        mov byte ptr es:[di], 0x20;
                        $1++;
                        loop 0xa08e;
                    } else {
                        // Block 0xA078
                        cmp byte ptr [si], 0x2e;
                        if (a != b) {  // jne 0xa089
                            // Block 0xA089
                            movsb byte ptr es:[di], byte ptr [si];
                            loop 0xa073;
                            jmp 0xa095;
                            // Block 0xA095
                            mov byte ptr es:[di - 4], 0x2e;
                            mov byte ptr es:[di], 0;
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0xA07D
                            // Compare $1 with $2
                            if (a == b) {  // je 0xa089
                                // Block 0xA089
                                movsb byte ptr es:[di], byte ptr [si];
                                loop 0xa073;
                                jmp 0xa095;
                                // Block 0xA095
                                mov byte ptr es:[di - 4], 0x2e;
                                mov byte ptr es:[di], 0;
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xA082
                                mov byte ptr es:[di], 0x20;
                                $1++;
                                loop 0xa07d;
                            }
                        }
                    }
                } else {
                    // Block 0xA02A
                    mov word ptr [bp - 2], 0xfff2;
                    jmp 0xa0a3;
                    // Block 0xA0A3
                    lds dx, ptr [bp - 8];
                    $1 = $2;
                    INT_21_AH1A();  // int 0x21
                    jmp 0xa21f;
                    // Block 0xA21F
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xe
                }
            } else {
                // Block 0x9FDE
                $1 = $2;
                $1 = $2;
                push($1);
                cld ;
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                $1 = $2;
                $1 = $2;
                $1 -= $2;
                *($1) = $2;
                mov word ptr [bp + 0xc], di;
            }
        }
    } else {
        // Block 0x9F95
        cmp byte ptr [si], 1;
        if (a == b) {  // je 0x9fa7
            // Block 0x9FA7
            jmp 0xa0ad;
            // Block 0xA0AD
            push($1);
            cld ;
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            push($1);
            $1 = $2;
            $1 = $2;
            $1 = pop();
            $1 = $2;
            $1 = $2;
            $1 -= $2;
            *($1) = $2;
            mov word ptr [bp + 0xc], di;
        } else {
            // Block 0x9F9A
            cmp byte ptr [si], 2;
            if (a == b) {  // je 0x9fa7
                // Block 0x9FA7
                jmp 0xa0ad;
                // Block 0xA0AD
                push($1);
                cld ;
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                push($1);
                $1 = $2;
                $1 = $2;
                $1 = pop();
                $1 = $2;
                $1 = $2;
                $1 -= $2;
                *($1) = $2;
                mov word ptr [bp + 0xc], di;
            } else {
                // Block 0x9F9F
                mov word ptr [bp - 2], 0xfff4;
                jmp 0xa21f;
                // Block 0xA21F
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 0xe
            }
        }
    }

    // Function calls:
    sub_9EBD();
    sub_9F7D();
    sub_A70D();
}

void sub_A70D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 76 if statements

    // Block 0xA70D
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x1b5;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x4ba;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x548;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x318;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov word ptr [bx + 0x2a], 0x6e4;
    $1 += $2;
    mov byte ptr [0x55f0], 1;
    return;  // retf 
}

void sub_AE16() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0xAE16
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0xffd9;
    les di, ptr [bp + 6];
    $1 = $2;
    $1 = $2;
    INT_10_AH4F();  // int 0x10
    // Compare $1 with $2
    if (a != b) {  // jne 0xae58
        // Block 0xAE58
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    } else {
        // Block 0xAE38
        cmp byte ptr es:[di], 0x56;
        if (a != b) {  // jne 0xae58
            // Block 0xAE58
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        } else {
            // Block 0xAE3E
            cmp byte ptr es:[di + 1], 0x45;
            if (a != b) {  // jne 0xae58
                // Block 0xAE58
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            } else {
                // Block 0xAE45
                cmp byte ptr es:[di + 2], 0x53;
                if (a != b) {  // jne 0xae58
                    // Block 0xAE58
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                } else {
                    // Block 0xAE4C
                    cmp byte ptr es:[di + 3], 0x41;
                    if (a != b) {  // jne 0xae58
                        // Block 0xAE58
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 4
                    } else {
                        // Block 0xAE53
                        mov word ptr [bp - 2], 0;
                    }
                }
            }
        }
    }
}

void sub_AE65() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0xAE65
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    lea ax, [bp - 6];
    push($1);
    lcall 0xae3, 0;
    cmp byte ptr [bp - 6], 5;
    if (a == b) {  // je 0xae87
        // Block 0xAE87
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = $2;
        cmp byte ptr es:[di], 0x33;
        if (a != b) {  // jne 0xaea6
            // Block 0xAEA6
            $1 = 0;
            push($1);
            $1 = $2;
            INT_10_AH6F();  // int 0x10
            $1 = pop();
            // Compare $1 with $2
            if (a != b) {  // jne 0xaebc
                // Block 0xAEBC
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1++;
                $1 = $2;
                out dx, al;
                $1--;
                $1 = $2;
                out dx, al;
                $1++;
                in al, dx;
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1 = 0;
                in al, dx;
                // Compare $1 with $2
                if (a != b) {  // jne 0xaeec
                    // Block 0xAEEC
                    $1 = $2;
                    in al, dx;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    in al, dx;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xaf4a
                        // Block 0xAF4A
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        test al, 0xe;
                        if (a == b) {  // je 0xaf5d
                            // Block 0xAF5D
                            mov word ptr [bp - 2], 0;
                        } else {
                            // Block 0xAF56
                            mov word ptr [bp - 2], 6;
                            jmp 0xaf62;
                            // Block 0xAF62
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xAEFA
                        $1 = $2;
                        out dx, al;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaf4a
                            // Block 0xAF4A
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            test al, 0xe;
                            if (a == b) {  // je 0xaf5d
                                // Block 0xAF5D
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xAF56
                                mov word ptr [bp - 2], 6;
                                jmp 0xaf62;
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xAF02
                            $1 = $2;
                            out dx, al;
                            mov word ptr [bp - 2], 1;
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            $1 = pop();
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            $1 = $2;
                            $1--;
                            $1 = $2;
                            out dx, ax;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            and al, 0xf;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf62
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xAF2D
                                $1--;
                                $1 = $2;
                                out dx, ax;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                and al, 0xf;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf62
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xAF3D
                                    $1--;
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, ax;
                                    mov word ptr [bp - 2], 5;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            }
                        }
                    }
                } else {
                    // Block 0xAED8
                    $1 = $2;
                    out dx, al;
                    $1 = 0;
                    in al, dx;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xaeec
                        // Block 0xAEEC
                        $1 = $2;
                        in al, dx;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaf4a
                            // Block 0xAF4A
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            test al, 0xe;
                            if (a == b) {  // je 0xaf5d
                                // Block 0xAF5D
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xAF56
                                mov word ptr [bp - 2], 6;
                                jmp 0xaf62;
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xAEFA
                            $1 = $2;
                            out dx, al;
                            in al, dx;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf4a
                                // Block 0xAF4A
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                test al, 0xe;
                                if (a == b) {  // je 0xaf5d
                                    // Block 0xAF5D
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0xAF56
                                    mov word ptr [bp - 2], 6;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xAF02
                                $1 = $2;
                                out dx, al;
                                mov word ptr [bp - 2], 1;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = pop();
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                $1 = $2;
                                $1--;
                                $1 = $2;
                                out dx, ax;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                and al, 0xf;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf62
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xAF2D
                                    $1--;
                                    $1 = $2;
                                    out dx, ax;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    and al, 0xf;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xaf62
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xAF3D
                                        $1--;
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, ax;
                                        mov word ptr [bp - 2], 5;
                                        jmp 0xaf62;
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xAEE2
                        $1 = $2;
                        out dx, al;
                        mov word ptr [bp - 2], 2;
                        jmp 0xaf62;
                        // Block 0xAF62
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 
                    }
                }
            } else {
                // Block 0xAEB4
                mov word ptr [bp - 2], 3;
                jmp 0xaf62;
                // Block 0xAF62
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        } else {
            // Block 0xAE97
            cmp byte ptr es:[di + 1], 0x31;
            if (a != b) {  // jne 0xaea6
                // Block 0xAEA6
                $1 = 0;
                push($1);
                $1 = $2;
                INT_10_AH6F();  // int 0x10
                $1 = pop();
                // Compare $1 with $2
                if (a != b) {  // jne 0xaebc
                    // Block 0xAEBC
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    $1 = $2;
                    out dx, al;
                    $1--;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1 = 0;
                    in al, dx;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xaeec
                        // Block 0xAEEC
                        $1 = $2;
                        in al, dx;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaf4a
                            // Block 0xAF4A
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            test al, 0xe;
                            if (a == b) {  // je 0xaf5d
                                // Block 0xAF5D
                                mov word ptr [bp - 2], 0;
                            } else {
                                // Block 0xAF56
                                mov word ptr [bp - 2], 6;
                                jmp 0xaf62;
                                // Block 0xAF62
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xAEFA
                            $1 = $2;
                            out dx, al;
                            in al, dx;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf4a
                                // Block 0xAF4A
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                test al, 0xe;
                                if (a == b) {  // je 0xaf5d
                                    // Block 0xAF5D
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0xAF56
                                    mov word ptr [bp - 2], 6;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xAF02
                                $1 = $2;
                                out dx, al;
                                mov word ptr [bp - 2], 1;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                $1 = pop();
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                $1 = $2;
                                $1--;
                                $1 = $2;
                                out dx, ax;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                and al, 0xf;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf62
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xAF2D
                                    $1--;
                                    $1 = $2;
                                    out dx, ax;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    and al, 0xf;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xaf62
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xAF3D
                                        $1--;
                                        $1 = $2;
                                        $1 = $2;
                                        out dx, ax;
                                        mov word ptr [bp - 2], 5;
                                        jmp 0xaf62;
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xAED8
                        $1 = $2;
                        out dx, al;
                        $1 = 0;
                        in al, dx;
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xaeec
                            // Block 0xAEEC
                            $1 = $2;
                            in al, dx;
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            in al, dx;
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xaf4a
                                // Block 0xAF4A
                                $1 = $2;
                                $1 = $2;
                                out dx, al;
                                $1++;
                                in al, dx;
                                test al, 0xe;
                                if (a == b) {  // je 0xaf5d
                                    // Block 0xAF5D
                                    mov word ptr [bp - 2], 0;
                                } else {
                                    // Block 0xAF56
                                    mov word ptr [bp - 2], 6;
                                    jmp 0xaf62;
                                    // Block 0xAF62
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xAEFA
                                $1 = $2;
                                out dx, al;
                                in al, dx;
                                // Compare $1 with $2
                                if (a != b) {  // jne 0xaf4a
                                    // Block 0xAF4A
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    test al, 0xe;
                                    if (a == b) {  // je 0xaf5d
                                        // Block 0xAF5D
                                        mov word ptr [bp - 2], 0;
                                    } else {
                                        // Block 0xAF56
                                        mov word ptr [bp - 2], 6;
                                        jmp 0xaf62;
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                } else {
                                    // Block 0xAF02
                                    $1 = $2;
                                    out dx, al;
                                    mov word ptr [bp - 2], 1;
                                    push($1);
                                    $1 = $2;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    $1 = $2;
                                    $1--;
                                    $1 = $2;
                                    out dx, ax;
                                    $1 = $2;
                                    out dx, al;
                                    $1++;
                                    in al, dx;
                                    and al, 0xf;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xaf62
                                        // Block 0xAF62
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xAF2D
                                        $1--;
                                        $1 = $2;
                                        out dx, ax;
                                        $1 = $2;
                                        out dx, al;
                                        $1++;
                                        in al, dx;
                                        and al, 0xf;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xaf62
                                            // Block 0xAF62
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xAF3D
                                            $1--;
                                            $1 = $2;
                                            $1 = $2;
                                            out dx, ax;
                                            mov word ptr [bp - 2], 5;
                                            jmp 0xaf62;
                                            // Block 0xAF62
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0xAEE2
                            $1 = $2;
                            out dx, al;
                            mov word ptr [bp - 2], 2;
                            jmp 0xaf62;
                            // Block 0xAF62
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0xAEB4
                    mov word ptr [bp - 2], 3;
                    jmp 0xaf62;
                    // Block 0xAF62
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0xAE9E
                mov word ptr [bp - 2], 4;
                jmp 0xaf62;
                // Block 0xAF62
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 
            }
        }
    } else {
        // Block 0xAE84
        jmp 0xaf5d;
        // Block 0xAF5D
        mov word ptr [bp - 2], 0;
    }

    // Function calls:
    sub_AE16();
}

void sub_AFB5() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xAFB5
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_AFB5();
    sub_AE65();
    sub_B00C();
}

void sub_B00C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 39 if statements

    // Block 0xB00C
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 2], 0;
    les di, ptr [bp + 6];
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0xb034
        // Block 0xB034
        // Compare $1 with $2
        if (a != b) {  // jne 0xb060
            // Block 0xB060
            // Compare $1 with $2
            if (a != b) {  // jne 0xb08c
                // Block 0xB08C
                // Compare $1 with $2
                if (a != b) {  // jne 0xb0dd
                    // Block 0xB0DD
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xb110
                        // Block 0xB110
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xb143
                            // Block 0xB143
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xb17b
                                // Block 0xB17B
                                mov word ptr [bp - 2], 0xffde;
                                $1 = $2;
                                *($1) = $2;
                                $1 = 0;
                                mov cx, 0xffff;
                            } else {
                                // Block 0xB148
                                $1 = $2;
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                push($1);
                                push($1);
                                call 0xae16;
                                // Block 0xB156
                                or ax, ax;
                                if (a != b) {  // jne 0xb17b
                                    // Block 0xB17B
                                    mov word ptr [bp - 2], 0xffde;
                                    $1 = $2;
                                    *($1) = $2;
                                    $1 = 0;
                                    mov cx, 0xffff;
                                } else {
                                    // Block 0xB15A
                                    $1 = $2;
                                    $1 = $2;
                                    for (ax = 0x10; ax < $2_2; ax++) {
                                    cmp ax, 0x10;
                                    if (a >= b (unsigned)) {  // jae 0xb179
                                        // Block 0xB179
                                        jmp 0xb18b;
                                        // Block 0xB18B
                                        $1 = $2;
                                        mov word ptr es:[di], ax;
                                        mov word ptr es:[di + 2], bx;
                                        mov word ptr es:[di + 4], cx;
                                        $1 = $2;
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = pop();
                                        $1 = $2;
                                        $1 = pop();
                                        return;  // retf 6
                                    } else {
                                        // Block 0xB168
                                        $1 = $2;
                                        for (ax = 8; ax < $2_2; ax++) {
                                        cmp ax, 8;
                                        if (a >= b (unsigned)) {  // jae 0xb179
                                            // Block 0xB179
                                            jmp 0xb18b;
                                            // Block 0xB18B
                                            $1 = $2;
                                            mov word ptr es:[di], ax;
                                            mov word ptr es:[di + 2], bx;
                                            mov word ptr es:[di + 4], cx;
                                            $1 = $2;
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = pop();
                                            $1 = $2;
                                            $1 = pop();
                                            return;  // retf 6
                                        } else {
                                            // Block 0xB173
                                            $1 = $2;
                                            mov cx, 0x24;
                                        }
                                    }
                                }
                            }
                        } else {
                            // Block 0xB115
                            push($1);
                            $1 = $2;
                            $1 = $2;
                            $1 = pop();
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            and al, 3;
                            $1 = $2;
                            for (al = 3; al < $2_2; al++) {
                            cmp al, 3;
                            if (a == b) {  // je 0xb141
                                // Block 0xB141
                                jmp 0xb18b;
                                // Block 0xB18B
                                $1 = $2;
                                mov word ptr es:[di], ax;
                                mov word ptr es:[di + 2], bx;
                                mov word ptr es:[di + 4], cx;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            } else {
                                // Block 0xB131
                                $1 = $2;
                                for (al = 1; al < $2_2; al++) {
                                cmp al, 1;
                                if (a == b) {  // je 0xb141
                                    // Block 0xB141
                                    jmp 0xb18b;
                                    // Block 0xB18B
                                    $1 = $2;
                                    mov word ptr es:[di], ax;
                                    mov word ptr es:[di + 2], bx;
                                    mov word ptr es:[di + 4], cx;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 6
                                } else {
                                    // Block 0xB13B
                                    $1 = $2;
                                    mov cx, 0x20;
                                }
                            }
                        }
                    } else {
                        // Block 0xB0E2
                        push($1);
                        $1 = $2;
                        $1 = $2;
                        $1 = pop();
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        and al, 3;
                        $1 = $2;
                        for (al = 3; al < $2_2; al++) {
                        cmp al, 3;
                        if (a == b) {  // je 0xb10e
                            // Block 0xB10E
                            jmp 0xb18b;
                            // Block 0xB18B
                            $1 = $2;
                            mov word ptr es:[di], ax;
                            mov word ptr es:[di + 2], bx;
                            mov word ptr es:[di + 4], cx;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 6
                        } else {
                            // Block 0xB0FE
                            $1 = $2;
                            for (al = 2; al < $2_2; al++) {
                            cmp al, 2;
                            if (a == b) {  // je 0xb10e
                                // Block 0xB10E
                                jmp 0xb18b;
                                // Block 0xB18B
                                $1 = $2;
                                mov word ptr es:[di], ax;
                                mov word ptr es:[di + 2], bx;
                                mov word ptr es:[di + 4], cx;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            } else {
                                // Block 0xB108
                                $1 = $2;
                                mov cx, 0xb;
                            }
                        }
                    }
                } else {
                    // Block 0xB091
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    $1 = $2;
                    for (bl = 0x33; bl < $2_2; bl++) {
                    cmp bl, 0x33;
                    if (a >= b (unsigned)) {  // jae 0xb0ba
                        // Block 0xB0BA
                        cli ;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        sti ;
                        test al, 0x10;
                        if (a == b) {  // je 0xb0ca
                            // Block 0xB0CA
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0xb0d8
                                // Block 0xB0D8
                                $1 = 0;
                                jmp 0xb18b;
                                // Block 0xB18B
                                $1 = $2;
                                mov word ptr es:[di], ax;
                                mov word ptr es:[di + 2], bx;
                                mov word ptr es:[di + 4], cx;
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 6
                            } else {
                                // Block 0xB0CF
                                test al, 8;
                                if (a == b) {  // je 0xb0d8
                                    // Block 0xB0D8
                                    $1 = 0;
                                    jmp 0xb18b;
                                    // Block 0xB18B
                                    $1 = $2;
                                    mov word ptr es:[di], ax;
                                    mov word ptr es:[di + 2], bx;
                                    mov word ptr es:[di + 4], cx;
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 6
                                } else {
                                    // Block 0xB0D3
                                    $1 = $2;
                                    mov cx, 0x1e;
                                }
                            }
                        } else {
                            // Block 0xB0C5
                            $1 = $2;
                            mov cx, 0x19;
                        }
                    } else {
                        // Block 0xB0A8
                        cli ;
                        $1 = $2;
                        out dx, al;
                        $1++;
                        in al, dx;
                        sti ;
                        test al, 0x20;
                        if (a == b) {  // je 0xb0d8
                            // Block 0xB0D8
                            $1 = 0;
                            jmp 0xb18b;
                            // Block 0xB18B
                            $1 = $2;
                            mov word ptr es:[di], ax;
                            mov word ptr es:[di + 2], bx;
                            mov word ptr es:[di + 4], cx;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 6
                        } else {
                            // Block 0xB0B3
                            $1 = $2;
                            $1 = $2;
                            jmp 0xb0d8;
                            // Block 0xB0D8
                            $1 = 0;
                            jmp 0xb18b;
                            // Block 0xB18B
                            $1 = $2;
                            mov word ptr es:[di], ax;
                            mov word ptr es:[di + 2], bx;
                            mov word ptr es:[di + 4], cx;
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 6
                        }
                    }
                }
            } else {
                // Block 0xB065
                $1 = $2;
                INT_10();  // int 0x10
                and ah, 0x7f;
                $1 = $2;
                for (ah = 4; ah < $2_2; ah++) {
                cmp ah, 4;
                if (a >= b (unsigned)) {  // jae 0xb089
                    // Block 0xB089
                    jmp 0xb18b;
                    // Block 0xB18B
                    $1 = $2;
                    mov word ptr es:[di], ax;
                    mov word ptr es:[di + 2], bx;
                    mov word ptr es:[di + 4], cx;
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 6
                } else {
                    // Block 0xB078
                    $1 = $2;
                    for (ah = 2; ah < $2_2; ah++) {
                    cmp ah, 2;
                    if (a >= b (unsigned)) {  // jae 0xb089
                        // Block 0xB089
                        jmp 0xb18b;
                        // Block 0xB18B
                        $1 = $2;
                        mov word ptr es:[di], ax;
                        mov word ptr es:[di + 2], bx;
                        mov word ptr es:[di + 4], cx;
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 6
                    } else {
                        // Block 0xB083
                        $1 = $2;
                        mov cx, 0x13;
                    }
                }
            }
        } else {
            // Block 0xB039
            $1 = $2;
            $1 = $2;
            out dx, al;
            $1++;
            in al, dx;
            and al, 0xc0;
            $1 = $2;
            for (al = 0xc0; al < $2_2; al++) {
            cmp al, 0xc0;
            if (a == b) {  // je 0xb05d
                // Block 0xB05D
                jmp 0xb18b;
                // Block 0xB18B
                $1 = $2;
                mov word ptr es:[di], ax;
                mov word ptr es:[di + 2], bx;
                mov word ptr es:[di + 4], cx;
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 6
            } else {
                // Block 0xB04D
                $1 = $2;
                for (al = 0x80; al < $2_2; al++) {
                cmp al, 0x80;
                if (a == b) {  // je 0xb05d
                    // Block 0xB05D
                    jmp 0xb18b;
                    // Block 0xB18B
                    $1 = $2;
                    mov word ptr es:[di], ax;
                    mov word ptr es:[di + 2], bx;
                    mov word ptr es:[di + 4], cx;
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 6
                } else {
                    // Block 0xB057
                    $1 = $2;
                    mov cx, 0x10;
                }
            }
        }
    } else {
        // Block 0xB02B
        $1 = $2;
        $1 = $2;
        jmp 0xb18b;
        // Block 0xB18B
        $1 = $2;
        mov word ptr es:[di], ax;
        mov word ptr es:[di + 2], bx;
        mov word ptr es:[di + 4], cx;
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 6
    }

    // Function calls:
    sub_AE16();
}

void sub_B316() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Block 0xB316
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    les di, ptr [bp + 0xa];
    $1 = $2;
    mov word ptr es:[di + 2], ax;
    $1 = $2;
    mov word ptr es:[di], ax;
    les di, ptr [bp + 6];
    $1 = $2;
    mov word ptr es:[di], ax;
    mov word ptr [bp - 2], 0;
    $1 = $2;
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = pop();
    $1 = $2;
    $1 = pop();
    return;  // retf 8
}

void sub_B350() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xB350
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    cmp word ptr [0x54c6], -1;
    if (a != b) {  // jne 0xb371
        // Block 0xB371
        les di, ptr [0x54c1];
        $1 = $2;
        $1 -= $2;
        add word ptr [0x54ca], ax;
        adc word ptr [0x54c8], 0;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_MoveFilePointer();  // int 0x21
        $1 = $2;
        $1 = $2;
        $1 = $2;
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = $2;
        DOS_ReadFile();  // int 0x21
        $1 = pop();
        mov word ptr [bp - 2], di;
    } else {
        // Block 0xB369
        stc ;
        mov word ptr [bp - 2], 0xffff;
        jmp 0xb3ac;
        // Block 0xB3AC
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_B316();
    sub_B350();
}

void sub_B4EC() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xB4EC
    in al, dx;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a < b (unsigned)) {  // jb 0xb508
        // Block 0xB508
        mov word ptr [bp - 2], 0xfffa;
        jmp 0xb535;
        // Block 0xB535
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    } else {
        // Block 0xB503
        // Compare $1 with $2
        if (a <= b (unsigned)) {  // jbe 0xb50f
            // Block 0xB50F
            $1 = $2;
            $1 = $2;
            for (bl = byte; bl < $2_2; bl++) {
            cmp bl, byte ptr [si + 1];
            if (a != b) {  // jne 0xb52b
                // Block 0xB52B
                $1 += $2;
                loop 0xb518;
                mov word ptr [bp - 2], 0xfffa;
            } else {
                // Block 0xB51D
                // Compare $1 with $2
                if (a != b) {  // jne 0xb52b
                    // Block 0xB52B
                    $1 += $2;
                    loop 0xb518;
                    mov word ptr [bp - 2], 0xfffa;
                } else {
                    // Block 0xB522
                    $1 = $2;
                    $1 = 0;
                    *($1) = $2;
                    jmp 0xb535;
                    // Block 0xB535
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                }
            }
        } else {
            // Block 0xB508
            mov word ptr [bp - 2], 0xfffa;
            jmp 0xb535;
            // Block 0xB535
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        }
    }

    // Function calls:
    sub_B5BF();
}

void sub_B586() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xB586
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    call 0xb5bf;
    // Block 0xB59C
    if (a >= b (unsigned)) {  // jae 0xb5a5
        // Block 0xB5A5
        $1 = $2;
        $1 = $2;
        $1 = $2;
        $1 = 0;
        mov word ptr [bp - 2], ax;
    } else {
        // Block 0xB59E
        mov word ptr [bp - 2], 0xfc19;
        jmp 0xb5b2;
        // Block 0xB5B2
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_B5BF();
}

void sub_B5BF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0xB5BF
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0xb5de
        // Block 0xB5DE
        $1 = $2;
        for (al = byte; al < $2_2; al++) {
        cmp al, byte ptr [si];
        if (a == b) {  // je 0xb5f5
            // Block 0xB5F5
            $1 = $2;
            $1 = $2;
            *($1) = $2;
            clc ;
        } else {
            // Block 0xB5E8
            $1 += $2;
            loop 0xb5e4;
            mov word ptr [bp - 2], 0xfc19;
            stc ;
            jmp 0xb5fd;
            // Block 0xB5FD
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    } else {
        // Block 0xB5D6
        mov word ptr [bp - 2], 0xfffa;
        stc ;
        jmp 0xb5fd;
        // Block 0xB5FD
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }
}

void sub_B60A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 3 if statements

    // Block 0xB60A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a <= b (unsigned)) {  // jbe 0xb629
        // Block 0xB629
        push($1);
        push($1);
        call 0xb5bf;
        // Block 0xB62E
        if (a >= b (unsigned)) {  // jae 0xb636
            // Block 0xB636
            $1 = $2;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            mul byte ptr es:[di + 3];
            $1 += $2;
            $1 = $2;
            // Compare $1 with $2
            if (a == b) {  // je 0xb655
                // Block 0xB655
                $1 = $2;
                $1 = $2;
                *($1) = $2;
                clc ;
            } else {
                // Block 0xB64D
                mov word ptr [bp - 2], 0xfc19;
                stc ;
                jmp 0xb65d;
                // Block 0xB65D
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            }
        } else {
            // Block 0xB630
            *($1) = $2;
            stc ;
            jmp 0xb65d;
            // Block 0xB65D
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    } else {
        // Block 0xB621
        mov word ptr [bp - 2], 0xfffa;
        stc ;
        jmp 0xb65d;
        // Block 0xB65D
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 2
    }

    // Function calls:
    sub_B5BF();
}

void sub_B66A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 2 if statements

    // Block 0xB66A
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cmp word ptr [0x43b9], 7;
    if (a != b) {  // jne 0xb691
        // Block 0xB691
        push($1);
        $1 = $2;
        INT_10_AH0F();  // int 0x10
        $1 = pop();
        and ax, 0x7f;
    } else {
        // Block 0xB680
        $1 = $2;
        $1 = $2;
        INT_10();  // int 0x10
        xchg bx, ax;
        // Compare $1 with $2
        if (a == b) {  // je 0xb69a
            // Block 0xB69A
            mov word ptr [bp - 2], ax;
        } else {
            // Block 0xB68C
            $1 = $2;
            jmp 0xb69d;
            // Block 0xB69D
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    }
}

void sub_B6A8() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 29 if statements

    // Block 0xB6A8
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    or ah, ah;
    if (a == b) {  // je 0xb6e0
        // Block 0xB6E0
        push($1);
        $1 = $2;
        VIDEO_SetVideoMode();  // int 0x10
        pop bp;
    } else {
        // Block 0xB6BE
        cmp word ptr [0x43b9], 7;
        if (a == b) {  // je 0xb6cc
            // Block 0xB6CC
            $1 = $2;
            $1 = $2;
            $1 = $2;
            INT_10_AH4F();  // int 0x10
            // Compare $1 with $2
            if (a == b) {  // je 0xb6e6
                // Block 0xB6E6
                mov word ptr [bp - 2], 0;
            } else {
                // Block 0xB6D9
                mov word ptr [bp - 2], 0xffd8;
                jmp 0xb6eb;
                // Block 0xB6EB
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 2
            }
        } else {
            // Block 0xB6C5
            mov word ptr [bp - 2], 0xfffa;
            jmp 0xb6eb;
            // Block 0xB6EB
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 2
        }
    }

    // Function calls:
    sub_B4EC();
    sub_B5BF();
    sub_B60A();
    sub_B586();
    sub_B60A();
    sub_B4EC();
    sub_B5BF();
    sub_B66A();
    sub_B6A8();
    sub_B66A();
    sub_B995();
    sub_B6A8();
    sub_B995();
}

void sub_B995() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 58 if statements

    // Block 0xB995
    push($1);
    // Compare $1 with $2
    if (a == b) {  // je 0xb9a7
        // Block 0xB9A7
        $1 = $2;
        $1 = 0;
        push($1);
        $1 = $2;
        push bx;
    } else {
        // Block 0xB99A
        $1 = $2;
        $1 = $2;
        push($1);
        $1 = $2;
        push($1);
        jmp 0xb9b1;
        // Block 0xB9B1
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1 = $2;
        $1 = 0;
        cld ;
        $1 = $2;
        $1 = $2;
        out dx, al;
        lodsb al, byte ptr [si];
        $1 = $2;
        $1 = $2;
        $1 = $2;
        out dx, al;
        $1++;
        loop 0xb9bf;
        $1 = pop();
        push($1);
        $1 = $2;
        $1 = $2;
        $1 = pop();
        $1 = 0;
        $1 = pop();
        rep stosw word ptr es:[di], ax;
        $1 = pop();
        $1 += $2;
        $1 = $2;
        $1 = $2;
        out dx, al;
        return;  // retf 
    }

    // Function calls:
    sub_BFC3();
}

void sub_BFC3() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 35 if statements

    // Block 0xBFC3
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    push($1);
    push($1);
    push($1);
    mov word ptr [bp - 2], 0;
    $1 = $2;
    // Compare $1 with $2
    if (a != b) {  // jne 0xbff8
        // Block 0xBFF8
        // Compare $1 with $2
        if (a != b) {  // jne 0xc011
            // Block 0xC011
            // Compare $1 with $2
            if (a != b) {  // jne 0xc05e
                // Block 0xC05E
                // Compare $1 with $2
                if (a != b) {  // jne 0xc083
                    // Block 0xC083
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xc0ac
                        // Block 0xC0AC
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xc0c9
                            // Block 0xC0C9
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xc0f0
                                // Block 0xC0F0
                                mov word ptr [bp - 2], 0xffde;
                            } else {
                                // Block 0xC0CE
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                mul bl;
                                $1 = $2;
                                $1 = $2;
                                push($1);
                                $1 = $2;
                                $1 = $2;
                                INT_10_AH4F();  // int 0x10
                                $1 = pop();
                                $1 = 0;
                                $1 = $2;
                                $1 = $2;
                                INT_10_AH4F();  // int 0x10
                                $1 = pop();
                                jmp 0xc0f5;
                                // Block 0xC0F5
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 4
                            }
                        } else {
                            // Block 0xC0B1
                            $1 = $2;
                            and al, 0xf;
                            xor al, 2;
                            $1 = $2;
                            $1 = $2;
                            $1 = $2;
                            out dx, al;
                            $1++;
                            in al, dx;
                            and al, 0xf0;
                            or al, ah;
                            out dx, al;
                            jmp 0xc0f5;
                            // Block 0xC0F5
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 4
                        }
                    } else {
                        // Block 0xC088
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        $1 = $2;
                        $1 = $2;
                        out dx, al;
                        and ah, 0xf;
                        $1 = $2;
                        shl al, 1;
                        shl al, 1;
                        shl al, 1;
                        shl al, 1;
                        or al, ah;
                        $1 = $2;
                        out dx, al;
                        jmp 0xc0f5;
                        // Block 0xC0F5
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = pop();
                        $1 = $2;
                        $1 = pop();
                        return;  // retf 4
                    }
                } else {
                    // Block 0xC063
                    push($1);
                    $1 = $2;
                    cli ;
                    $1 = $2;
                    $1 = $2;
                    out dx, al;
                    $1++;
                    in al, dx;
                    $1 = $2;
                    and ah, 0xe1;
                    shl ch, 1;
                    or ah, ch;
                    $1--;
                    $1 = $2;
                    out dx, ax;
                    sti ;
                    $1 = pop();
                    jmp 0xc0f5;
                    // Block 0xC0F5
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 4
                }
            } else {
                // Block 0xC016
                push($1);
                $1 = $2;
                $1 = $2;
                and bl, 1;
                $1 = $2;
                $1 = $2;
                $1 = $2;
                out dx, ax;
                $1 = $2;
                and bl, 2;
                shl bl, 1;
                shl bl, 1;
                shl bl, 1;
                shl bl, 1;
                $1 = $2;
                in al, dx;
                and al, 0xdf;
                or bl, al;
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1 = $2;
                $1 = $2;
                out dx, al;
                $1++;
                in al, dx;
                and al, 0xf0;
                and bh, 0xc;
                $1 = $2;
                shr bl, 1;
                shr bl, 1;
                or al, bh;
                or al, bl;
                out dx, al;
                $1 = pop();
                jmp 0xc0f5;
                // Block 0xC0F5
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = $2;
                $1 = pop();
                return;  // retf 4
            }
        } else {
            // Block 0xBFFD
            push($1);
            $1 = $2;
            $1 = $2;
            shl ch, cl;
            $1 = $2;
            $1 = $2;
            $1 = $2;
            out dx, ax;
            $1 = pop();
            jmp 0xc0f5;
            // Block 0xC0F5
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 4
        }
    } else {
        // Block 0xBFE2
        $1 = $2;
        $1 = $2;
        shl ah, 1;
        shl ah, 1;
        shl ah, 1;
        or al, ah;
        or al, 0x40;
        $1 = $2;
        out dx, al;
        jmp 0xc0f5;
        // Block 0xC0F5
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 4
    }

    // Function calls:
    sub_BFC3();
    sub_C3B3();
}

void sub_C3B3() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 99 if statements

    // Block 0xC3B3
    $1 = 0;
    push($1);
    lcall 0x98e, 0x12a;
    $1 = $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x32b;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x639;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x6ce;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x478;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov word ptr [bx + 0x2e], 0x829;
    $1 += $2;
    mov byte ptr [0x55f2], 1;
    return;  // retf 

    // Function calls:
    sub_CA9B();
    sub_CB80();
    sub_CBCF();
    sub_CBE1();
    sub_CC40();
}

void sub_CA9B() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 14 if statements

    // Block 0xCA9B
    $1 = 0;
    push($1);
    $1 = $2;
    INT_10_AH1A();  // int 0x10
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0xcaaa
        // Block 0xCAAA
        mov cx, 2;
    } else {
        // Block 0xCAA7
        jmp 0xcb7f;
        // Block 0xCB7F
        return;  // retf 
    }
}

void sub_CB80() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0xCB80
    $1 = $2;
    push($1);
    $1 = $2;
    INT_10_AH12();  // int 0x10
    $1 = pop();
    // Compare $1 with $2
    if (a == b) {  // je 0xcbce
        // Block 0xCBCE
        return;  // retf 
    } else {
        // Block 0xCB8D
        $1 = $2;
        // Compare $1 with $2
        if (a > b (unsigned)) {  // ja 0xcb97
            // Block 0xCB97
            // Compare $1 with $2
            if (a > b (unsigned)) {  // ja 0xcb9f
                // Block 0xCB9F
                // Compare $1 with $2
                if (a > b (unsigned)) {  // ja 0xcba7
                    // Block 0xCBA7
                    // Compare $1 with $2
                    if (a > b (unsigned)) {  // ja 0xcbaf
                        // Block 0xCBAF
                        // Compare $1 with $2
                        if (a > b (unsigned)) {  // ja 0xcbb7
                            // Block 0xCBB7
                            mov ah, 1;
                        } else {
                            // Block 0xCBB3
                            $1 = $2;
                            jmp 0xcbb9;
                            // Block 0xCBB9
                            $1 = $2;
                            push($1);
                            call 0xcc7a;
                            // Block 0xCBBF
                            // Compare $1 with $2
                            if (a == b) {  // je 0xcbca
                                // Block 0xCBCA
                                mov byte ptr [bp - 0xa], 0;
                            } else {
                                // Block 0xCBC4
                                mov byte ptr [bp - 8], 0;
                                jmp 0xcbce;
                                // Block 0xCBCE
                                return;  // retf 
                            }
                        }
                    } else {
                        // Block 0xCBAB
                        $1 = $2;
                        jmp 0xcbb9;
                        // Block 0xCBB9
                        $1 = $2;
                        push($1);
                        call 0xcc7a;
                        // Block 0xCBBF
                        // Compare $1 with $2
                        if (a == b) {  // je 0xcbca
                            // Block 0xCBCA
                            mov byte ptr [bp - 0xa], 0;
                        } else {
                            // Block 0xCBC4
                            mov byte ptr [bp - 8], 0;
                            jmp 0xcbce;
                            // Block 0xCBCE
                            return;  // retf 
                        }
                    }
                } else {
                    // Block 0xCBA3
                    $1 = $2;
                    jmp 0xcbb9;
                    // Block 0xCBB9
                    $1 = $2;
                    push($1);
                    call 0xcc7a;
                    // Block 0xCBBF
                    // Compare $1 with $2
                    if (a == b) {  // je 0xcbca
                        // Block 0xCBCA
                        mov byte ptr [bp - 0xa], 0;
                    } else {
                        // Block 0xCBC4
                        mov byte ptr [bp - 8], 0;
                        jmp 0xcbce;
                        // Block 0xCBCE
                        return;  // retf 
                    }
                }
            } else {
                // Block 0xCB9B
                $1 = $2;
                jmp 0xcbb9;
                // Block 0xCBB9
                $1 = $2;
                push($1);
                call 0xcc7a;
                // Block 0xCBBF
                // Compare $1 with $2
                if (a == b) {  // je 0xcbca
                    // Block 0xCBCA
                    mov byte ptr [bp - 0xa], 0;
                } else {
                    // Block 0xCBC4
                    mov byte ptr [bp - 8], 0;
                    jmp 0xcbce;
                    // Block 0xCBCE
                    return;  // retf 
                }
            }
        } else {
            // Block 0xCB93
            $1 = $2;
            jmp 0xcbb9;
            // Block 0xCBB9
            $1 = $2;
            push($1);
            call 0xcc7a;
            // Block 0xCBBF
            // Compare $1 with $2
            if (a == b) {  // je 0xcbca
                // Block 0xCBCA
                mov byte ptr [bp - 0xa], 0;
            } else {
                // Block 0xCBC4
                mov byte ptr [bp - 8], 0;
                jmp 0xcbce;
                // Block 0xCBCE
                return;  // retf 
            }
        }
    }

    // Function calls:
    sub_CC7A();
}

void sub_CBCF() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xCBCF
    $1 = $2;
    push($1);
    call 0xcc23;
    // Block 0xCBD6
    if (a < b (unsigned)) {  // jb 0xcbe0
        // Block 0xCBE0
        return;  // retf 
    } else {
        // Block 0xCBD8
        $1 = $2;
        $1 = $2;
        push($1);
        call 0xcc7a;
        // Block 0xCBE0
        return;  // retf 
    }

    // Function calls:
    sub_CC23();
    sub_CC7A();
}

void sub_CBE1() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0xCBE1
    $1 = $2;
    push($1);
    call 0xcc23;
    // Block 0xCBE8
    if (a < b (unsigned)) {  // jb 0xcc22
        // Block 0xCC22
        return;  // retf 
    } else {
        // Block 0xCBEA
        $1 = $2;
        in al, dx;
        and al, 0x80;
        $1 = $2;
        $1 = $2;
        in al, dx;
        and al, 0x80;
        // Compare $1 with $2
        loope 0xcbf5;
        if (a != b) {  // jne 0xcc04
            // Block 0xCC04
            in al, dx;
            $1 = $2;
            and dl, 0x70;
            $1 = $2;
            for (dl = 0x10; dl < $2_2; dl++) {
            cmp dl, 0x10;
            if (a == b) {  // je 0xcc1e
                // Block 0xCC1E
                push($1);
                call 0xcc7a;
                // Block 0xCC22
                return;  // retf 
            } else {
                // Block 0xCC13
                for (dl = 0x50; dl < $2_2; dl++) {
                cmp dl, 0x50;
                if (a != b) {  // jne 0xcc1e
                    // Block 0xCC1E
                    push($1);
                    call 0xcc7a;
                    // Block 0xCC22
                    return;  // retf 
                } else {
                    // Block 0xCC1A
                    $1 = $2;
                    mov ah, 3;
                }
            }
        } else {
            // Block 0xCBFE
            $1 = $2;
            $1 = $2;
            jmp 0xcc1e;
            // Block 0xCC1E
            push($1);
            call 0xcc7a;
            // Block 0xCC22
            return;  // retf 
        }
    }

    // Function calls:
    sub_CC23();
    sub_CC7A();
}

void sub_CC23() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xCC23
    $1 = $2;
    out dx, al;
    $1++;
    in al, dx;
    $1 = $2;
    $1 = $2;
    out dx, al;
    $1 = $2;
    loop 0xcc30;
    in al, dx;
    xchg al, ah;
    out dx, al;
    // Compare $1 with $2
    if (a == b) {  // je 0xcc3e
        // Block 0xCC3E
        clc ;
    } else {
        // Block 0xCC3B
        stc ;
        jmp 0xcc3f;
        // Block 0xCC3F
        return;  // retf 
    }
}

void sub_CC40() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xCC40
    cmp byte ptr es:[di + 2], 0;
    if (a == b) {  // je 0xcc79
        // Block 0xCC79
        return;  // retf 
    } else {
        // Block 0xCC47
        cmp byte ptr es:[di], 4;
        if (a >= b) {  // jge 0xcc79
            // Block 0xCC79
            return;  // retf 
        } else {
            // Block 0xCC4D
            cmp byte ptr es:[di + 2], 4;
            if (a >= b) {  // jge 0xcc79
                // Block 0xCC79
                return;  // retf 
            } else {
                // Block 0xCC54
                lcall 0x98e, 0x18a;
                and al, 7;
                // Compare $1 with $2
                if (a == b) {  // je 0xcc68
                    // Block 0xCC68
                    cmp byte ptr es:[di + 1], 1;
                    if (a == b) {  // je 0xcc79
                        // Block 0xCC79
                        return;  // retf 
                    } else {
                        // Block 0xCC6F
                        $1 = $2;
                        xchg word ptr es:[di + 2], ax;
                        mov word ptr es:[di], ax;
                    }
                } else {
                    // Block 0xCC5F
                    cmp byte ptr es:[di + 1], 1;
                    if (a != b) {  // jne 0xcc79
                        // Block 0xCC79
                        return;  // retf 
                    } else {
                        // Block 0xCC66
                        jmp 0xcc6f;
                        // Block 0xCC6F
                        $1 = $2;
                        xchg word ptr es:[di + 2], ax;
                        mov word ptr es:[di], ax;
                    }
                }
            }
        }
    }
}

void sub_CC7A() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 109 if statements

    // Block 0xCC7A
    cmp byte ptr es:[di], 0;
    if (a != b) {  // jne 0xcc85
        // Block 0xCC85
        mov word ptr es:[di + 2], ax;
    } else {
        // Block 0xCC80
        mov word ptr es:[di], ax;
        jmp 0xcc89;
        // Block 0xCC89
        return;  // retf 
    }
}

void sub_D552() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 50 if statements

    // Block 0xD552
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    int 0x2f;
    // Compare $1 with $2
    if (a == b) {  // je 0xd571
        // Block 0xD571
        $1 = $2;
        int 0x2f;
        *($1) = $2;
        *($1) = $2;
        $1 = $2;
        lcall [0x5ab2];
        // Compare $1 with $2
        if (a >= b (unsigned)) {  // jae 0xd590
            // Block 0xD590
            mov word ptr [bp - 2], 0;
        } else {
            // Block 0xD589
            mov word ptr [bp - 2], 0xffdc;
            jmp 0xd595;
            // Block 0xD595
            $1 = $2;
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = pop();
            $1 = $2;
            $1 = pop();
            return;  // retf 
        }
    } else {
        // Block 0xD56A
        mov word ptr [bp - 2], 0xffdc;
        jmp 0xd595;
        // Block 0xD595
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 
    }

    // Function calls:
    sub_D552();
    sub_D552();
    sub_DA6E();
}

void sub_DA6E() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 16 if statements

    // Block 0xDA6E
    $1 = $2;
    mov word ptr [bx + 0xa], 0x275;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x335;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x576;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x61a;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x3e9;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x4cd;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x677;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    $1 = $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov word ptr [bx + 0xa], 0x703;
    mov word ptr [bx + 0xc], 0xbd7;
    $1 += $2;
    mov byte ptr [0x6d35], 1;
    return;  // retf 
}

void sub_DE14() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 10 if statements

    // Block 0xDE14
    push($1);
    $1 = $2;
    push($1);
    $1 = $2;
    mul dx;
    $1 = pop();
    shr bx, 1;
    shr bx, 1;
    shr bx, 1;
    $1 += $2;
    $1 = $2;
    $1 += $2;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    and cl, 7;
    xor cl, 7;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_DE14();
    sub_DE14();
}

void sub_DFD5() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 34 if statements

    // Block 0xDFD5
    $1 = $2;
    mul dx;
    $1 += $2;
    adc dx, 0;
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = pop();
    return;  // retf 

    // Function calls:
    sub_DFD5();
}

void sub_E3A5() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 4 if statements

    // Block 0xE3A5
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    $1 = pop();
    // Compare $1 with $2
    if (a < b) {  // jl 0xe3c8
        // Block 0xE3C8
        stc ;
    } else {
        // Block 0xE3B6
        // Compare $1 with $2
        if (a < b) {  // jl 0xe3c8
            // Block 0xE3C8
            stc ;
        } else {
            // Block 0xE3BB
            // Compare $1 with $2
            if (a > b) {  // jg 0xe3c8
                // Block 0xE3C8
                stc ;
            } else {
                // Block 0xE3C0
                // Compare $1 with $2
                if (a > b) {  // jg 0xe3c8
                    // Block 0xE3C8
                    stc ;
                } else {
                    // Block 0xE3C5
                    clc ;
                    jmp 0xe3c9;
                    // Block 0xE3C9
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            }
        }
    }
}

void sub_E3CC() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0xE3CC
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    mov si, 0x6cda;

    // Function calls:
    sub_E58D();
}

void sub_E4E0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0xE4E0
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    mov word ptr [bp - 6], 0;
    mov si, 0x6cda;

    // Function calls:
    sub_E58D();
}

void sub_E58D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 24 if statements

    // Block 0xE58D
    $1 = 0;
    $1 = $2;
    $1 = $2;
    // Compare $1 with $2
    if (a >= b) {  // jge 0xe59c
        // Block 0xE59C
        // Compare $1 with $2
        if (a >= b) {  // jge 0xe5a3
            // Block 0xE5A3
            // Compare $1 with $2
            if (a <= b) {  // jle 0xe5aa
                // Block 0xE5AA
                // Compare $1 with $2
                if (a <= b) {  // jle 0xe5b1
                    // Block 0xE5B1
                    $1 = $2;
                    $1 = $2;
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xe5bf
                        // Block 0xE5BF
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0xe5c7
                            // Block 0xE5C7
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0xe5cf
                                // Block 0xE5CF
                                // Compare $1 with $2
                                if (a <= b) {  // jle 0xe5d7
                                    // Block 0xE5D7
                                    return;  // retf 
                                } else {
                                    // Block 0xE5D4
                                    or ah, 8;
                                }
                            } else {
                                // Block 0xE5CC
                                or ah, 4;
                            }
                        } else {
                            // Block 0xE5C4
                            or ah, 2;
                        }
                    } else {
                        // Block 0xE5BC
                        or ah, 1;
                    }
                } else {
                    // Block 0xE5AF
                    or al, 8;
                }
            } else {
                // Block 0xE5A8
                or al, 4;
            }
        } else {
            // Block 0xE5A1
            or al, 2;
        }
    } else {
        // Block 0xE59A
        or al, 1;
    }

    // Function calls:
    sub_E3A5();
    sub_E3CC();
    sub_E4E0();
    sub_ECFD();
    sub_ECFD();
    sub_E9D0();
    sub_E9D0();
    sub_ED84();
}

void sub_E9D0() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 55 if statements

    // Block 0xE9D0
    push($1);
    push($1);
    // Compare $1 with $2
    if (a != b) {  // jne 0xe9da
        // Block 0xE9DA
        or cx, cx;
        if (a != b) {  // jne 0xe9e1
            // Block 0xE9E1
            push($1);
            call 0xed11;
            // Block 0xE9E5
            // Compare $1 with $2
            if (a < b) {  // jl 0xea2d
                // Block 0xEA2D
                $1 = pop();
                $1 = pop();
                push($1);
                push($1);
                neg bx;
                push($1);
                call 0xed11;
                // Block 0xEA37
                // Compare $1 with $2
                if (a < b) {  // jl 0xea7f
                    // Block 0xEA7F
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xea8b
                        // Block 0xEA8B
                        neg cx;
                        push($1);
                        call 0xed11;
                        // Block 0xEA91
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xead9
                            // Block 0xEAD9
                            $1 = pop();
                            $1 = pop();
                            push($1);
                            push($1);
                            neg bx;
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEAE5
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xeb2d
                                // Block 0xEB2D
                                jmp 0xec72;
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xEAEA
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEF
                                    // Compare $1 with $2
                                    if (a >= b) {  // jge 0xeaff
                                        // Block 0xEAFF
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xeb0f
                                            // Block 0xEB0F
                                            $1 = $2;
                                            $1 += $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xeb26
                                                // Block 0xEB26
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            } else {
                                                // Block 0xEB1F
                                                lcall 0xc6c, 0xe5;
                                                if (a < b (unsigned)) {  // jb 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                }
                                            }
                                        } else {
                                            // Block 0xEB04
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEAF4
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                }
                            }
                        } else {
                            // Block 0xEA96
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xead9
                                // Block 0xEAD9
                                $1 = pop();
                                $1 = pop();
                                push($1);
                                push($1);
                                neg bx;
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEAE5
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEA
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEF
                                        // Compare $1 with $2
                                        if (a >= b) {  // jge 0xeaff
                                            // Block 0xEAFF
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xeb0f
                                                // Block 0xEB0F
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xeb26
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEB1F
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEB04
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAF4
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA9B
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xeaab
                                    // Block 0xEAAB
                                    // Compare $1 with $2
                                    if (a <= b) {  // jle 0xeabb
                                        // Block 0xEABB
                                        $1 = $2;
                                        $1 += $2;
                                        $1 = $2;
                                        $1 += $2;
                                        cmp word ptr [bp - 0x28], 1;
                                        if (a != b) {  // jne 0xead2
                                            // Block 0xEAD2
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        } else {
                                            // Block 0xEACB
                                            lcall 0xc6c, 0xe5;
                                            if (a < b (unsigned)) {  // jb 0xead9
                                                // Block 0xEAD9
                                                $1 = pop();
                                                $1 = pop();
                                                push($1);
                                                push($1);
                                                neg bx;
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEAE5
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEAEA
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEF
                                                        // Compare $1 with $2
                                                        if (a >= b) {  // jge 0xeaff
                                                            // Block 0xEAFF
                                                            // Compare $1 with $2
                                                            if (a < b) {  // jl 0xeb0f
                                                                // Block 0xEB0F
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xeb26
                                                                    // Block 0xEB26
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEB1F
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEB04
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAF4
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEAD2
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            }
                                        }
                                    } else {
                                        // Block 0xEAB0
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af8], cx;
                                    }
                                } else {
                                    // Block 0xEAA0
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af4], cx;
                                }
                            }
                        }
                    } else {
                        // Block 0xEA88
                        jmp 0xec72;
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0xEA3C
                    // Compare $1 with $2
                    if (a > b) {  // jg 0xea7f
                        // Block 0xEA7F
                        $1 = pop();
                        $1 = pop();
                        push($1);
                        push($1);
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xea8b
                            // Block 0xEA8B
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEA91
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xead9
                                // Block 0xEAD9
                                $1 = pop();
                                $1 = pop();
                                push($1);
                                push($1);
                                neg bx;
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEAE5
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEA
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEF
                                        // Compare $1 with $2
                                        if (a >= b) {  // jge 0xeaff
                                            // Block 0xEAFF
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xeb0f
                                                // Block 0xEB0F
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xeb26
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEB1F
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEB04
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAF4
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA96
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xead9
                                    // Block 0xEAD9
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    neg cx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEAE5
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEA
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEF
                                            // Compare $1 with $2
                                            if (a >= b) {  // jge 0xeaff
                                                // Block 0xEAFF
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb0f
                                                    // Block 0xEB0F
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xeb26
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEB1F
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEB04
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEAF4
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA9B
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeaab
                                        // Block 0xEAAB
                                        // Compare $1 with $2
                                        if (a <= b) {  // jle 0xeabb
                                            // Block 0xEABB
                                            $1 = $2;
                                            $1 += $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xead2
                                                // Block 0xEAD2
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            } else {
                                                // Block 0xEACB
                                                lcall 0xc6c, 0xe5;
                                                if (a < b (unsigned)) {  // jb 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEAD2
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                }
                                            }
                                        } else {
                                            // Block 0xEAB0
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEAA0
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                }
                            }
                        } else {
                            // Block 0xEA88
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEA41
                        // Compare $1 with $2
                        if (a > b) {  // jg 0xea51
                            // Block 0xEA51
                            // Compare $1 with $2
                            if (a <= b) {  // jle 0xea61
                                // Block 0xEA61
                                $1 = $2;
                                $1 += $2;
                                $1 = $2;
                                $1 += $2;
                                cmp word ptr [bp - 0x28], 1;
                                if (a != b) {  // jne 0xea78
                                    // Block 0xEA78
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                } else {
                                    // Block 0xEA71
                                    lcall 0xc6c, 0xe5;
                                    if (a < b (unsigned)) {  // jb 0xea7f
                                        // Block 0xEA7F
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xea8b
                                            // Block 0xEA8B
                                            neg cx;
                                            push($1);
                                            call 0xed11;
                                            // Block 0xEA91
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xead9
                                                // Block 0xEAD9
                                                $1 = pop();
                                                $1 = pop();
                                                push($1);
                                                push($1);
                                                neg bx;
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEAE5
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEAEA
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEF
                                                        // Compare $1 with $2
                                                        if (a >= b) {  // jge 0xeaff
                                                            // Block 0xEAFF
                                                            // Compare $1 with $2
                                                            if (a < b) {  // jl 0xeb0f
                                                                // Block 0xEB0F
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xeb26
                                                                    // Block 0xEB26
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEB1F
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEB04
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAF4
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA96
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA9B
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeaab
                                                        // Block 0xEAAB
                                                        // Compare $1 with $2
                                                        if (a <= b) {  // jle 0xeabb
                                                            // Block 0xEABB
                                                            $1 = $2;
                                                            $1 += $2;
                                                            $1 = $2;
                                                            $1 += $2;
                                                            cmp word ptr [bp - 0x28], 1;
                                                            if (a != b) {  // jne 0xead2
                                                                // Block 0xEAD2
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            } else {
                                                                // Block 0xEACB
                                                                lcall 0xc6c, 0xe5;
                                                                if (a < b (unsigned)) {  // jb 0xead9
                                                                    // Block 0xEAD9
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    push($1);
                                                                    push($1);
                                                                    neg bx;
                                                                    neg cx;
                                                                    push($1);
                                                                    call 0xed11;
                                                                    // Block 0xEAE5
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEAEA
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEF
                                                                            // Compare $1 with $2
                                                                            if (a >= b) {  // jge 0xeaff
                                                                                // Block 0xEAFF
                                                                                // Compare $1 with $2
                                                                                if (a < b) {  // jl 0xeb0f
                                                                                    // Block 0xEB0F
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    cmp word ptr [bp - 0x28], 1;
                                                                                    if (a != b) {  // jne 0xeb26
                                                                                        // Block 0xEB26
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    } else {
                                                                                        // Block 0xEB1F
                                                                                        lcall 0xc6c, 0xe5;
                                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEB04
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af8], cx;
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAF4
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af4], cx;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0xEAB0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af8], cx;
                                                        }
                                                    } else {
                                                        // Block 0xEAA0
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af4], cx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0xEA88
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    } else {
                                        // Block 0xEA78
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    }
                                }
                            } else {
                                // Block 0xEA56
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af8], cx;
                            }
                        } else {
                            // Block 0xEA46
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af4], cx;
                        }
                    }
                }
            } else {
                // Block 0xE9EA
                // Compare $1 with $2
                if (a > b) {  // jg 0xea2d
                    // Block 0xEA2D
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    neg bx;
                    push($1);
                    call 0xed11;
                    // Block 0xEA37
                    // Compare $1 with $2
                    if (a < b) {  // jl 0xea7f
                        // Block 0xEA7F
                        $1 = pop();
                        $1 = pop();
                        push($1);
                        push($1);
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xea8b
                            // Block 0xEA8B
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEA91
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xead9
                                // Block 0xEAD9
                                $1 = pop();
                                $1 = pop();
                                push($1);
                                push($1);
                                neg bx;
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEAE5
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xeb2d
                                    // Block 0xEB2D
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEAEA
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEF
                                        // Compare $1 with $2
                                        if (a >= b) {  // jge 0xeaff
                                            // Block 0xEAFF
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xeb0f
                                                // Block 0xEB0F
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xeb26
                                                    // Block 0xEB26
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEB1F
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEB04
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAF4
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA96
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xead9
                                    // Block 0xEAD9
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    neg cx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEAE5
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEA
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEF
                                            // Compare $1 with $2
                                            if (a >= b) {  // jge 0xeaff
                                                // Block 0xEAFF
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb0f
                                                    // Block 0xEB0F
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xeb26
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEB1F
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEB04
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEAF4
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA9B
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xeaab
                                        // Block 0xEAAB
                                        // Compare $1 with $2
                                        if (a <= b) {  // jle 0xeabb
                                            // Block 0xEABB
                                            $1 = $2;
                                            $1 += $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xead2
                                                // Block 0xEAD2
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            } else {
                                                // Block 0xEACB
                                                lcall 0xc6c, 0xe5;
                                                if (a < b (unsigned)) {  // jb 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEAD2
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                }
                                            }
                                        } else {
                                            // Block 0xEAB0
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEAA0
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                }
                            }
                        } else {
                            // Block 0xEA88
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEA3C
                        // Compare $1 with $2
                        if (a > b) {  // jg 0xea7f
                            // Block 0xEA7F
                            $1 = pop();
                            $1 = pop();
                            push($1);
                            push($1);
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xea8b
                                // Block 0xEA8B
                                neg cx;
                                push($1);
                                call 0xed11;
                                // Block 0xEA91
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xead9
                                    // Block 0xEAD9
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    neg cx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEAE5
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xeb2d
                                        // Block 0xEB2D
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEAEA
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEF
                                            // Compare $1 with $2
                                            if (a >= b) {  // jge 0xeaff
                                                // Block 0xEAFF
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb0f
                                                    // Block 0xEB0F
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xeb26
                                                        // Block 0xEB26
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEB1F
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEB04
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEAF4
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA96
                                    // Compare $1 with $2
                                    if (a > b) {  // jg 0xead9
                                        // Block 0xEAD9
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        neg bx;
                                        neg cx;
                                        push($1);
                                        call 0xed11;
                                        // Block 0xEAE5
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xeb2d
                                            // Block 0xEB2D
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEAEA
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0xeb2d
                                                // Block 0xEB2D
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEAEF
                                                // Compare $1 with $2
                                                if (a >= b) {  // jge 0xeaff
                                                    // Block 0xEAFF
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb0f
                                                        // Block 0xEB0F
                                                        $1 = $2;
                                                        $1 += $2;
                                                        $1 = $2;
                                                        $1 += $2;
                                                        cmp word ptr [bp - 0x28], 1;
                                                        if (a != b) {  // jne 0xeb26
                                                            // Block 0xEB26
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        } else {
                                                            // Block 0xEB1F
                                                            lcall 0xc6c, 0xe5;
                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEB26
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEB04
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af8], cx;
                                                    }
                                                } else {
                                                    // Block 0xEAF4
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af4], cx;
                                                }
                                            }
                                        }
                                    } else {
                                        // Block 0xEA9B
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xeaab
                                            // Block 0xEAAB
                                            // Compare $1 with $2
                                            if (a <= b) {  // jle 0xeabb
                                                // Block 0xEABB
                                                $1 = $2;
                                                $1 += $2;
                                                $1 = $2;
                                                $1 += $2;
                                                cmp word ptr [bp - 0x28], 1;
                                                if (a != b) {  // jne 0xead2
                                                    // Block 0xEAD2
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                } else {
                                                    // Block 0xEACB
                                                    lcall 0xc6c, 0xe5;
                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                        // Block 0xEAD9
                                                        $1 = pop();
                                                        $1 = pop();
                                                        push($1);
                                                        push($1);
                                                        neg bx;
                                                        neg cx;
                                                        push($1);
                                                        call 0xed11;
                                                        // Block 0xEAE5
                                                        // Compare $1 with $2
                                                        if (a < b) {  // jl 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEA
                                                            // Compare $1 with $2
                                                            if (a > b) {  // jg 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEAEF
                                                                // Compare $1 with $2
                                                                if (a >= b) {  // jge 0xeaff
                                                                    // Block 0xEAFF
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb0f
                                                                        // Block 0xEB0F
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        cmp word ptr [bp - 0x28], 1;
                                                                        if (a != b) {  // jne 0xeb26
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        } else {
                                                                            // Block 0xEB1F
                                                                            lcall 0xc6c, 0xe5;
                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEB26
                                                                                push($1);
                                                                                push($1);
                                                                                push($1);
                                                                                lcall [si];
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEB04
                                                                        *($1) = $2;
                                                                        *($1) = $2;
                                                                        mov word ptr [0x5af8], cx;
                                                                    }
                                                                } else {
                                                                    // Block 0xEAF4
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af4], cx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEAD2
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    }
                                                }
                                            } else {
                                                // Block 0xEAB0
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af8], cx;
                                            }
                                        } else {
                                            // Block 0xEAA0
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af4], cx;
                                        }
                                    }
                                }
                            } else {
                                // Block 0xEA88
                                jmp 0xec72;
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xEA41
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xea51
                                // Block 0xEA51
                                // Compare $1 with $2
                                if (a <= b) {  // jle 0xea61
                                    // Block 0xEA61
                                    $1 = $2;
                                    $1 += $2;
                                    $1 = $2;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x28], 1;
                                    if (a != b) {  // jne 0xea78
                                        // Block 0xEA78
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    } else {
                                        // Block 0xEA71
                                        lcall 0xc6c, 0xe5;
                                        if (a < b (unsigned)) {  // jb 0xea7f
                                            // Block 0xEA7F
                                            $1 = pop();
                                            $1 = pop();
                                            push($1);
                                            push($1);
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xea8b
                                                // Block 0xEA8B
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEA91
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA96
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xead9
                                                        // Block 0xEAD9
                                                        $1 = pop();
                                                        $1 = pop();
                                                        push($1);
                                                        push($1);
                                                        neg bx;
                                                        neg cx;
                                                        push($1);
                                                        call 0xed11;
                                                        // Block 0xEAE5
                                                        // Compare $1 with $2
                                                        if (a < b) {  // jl 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEA
                                                            // Compare $1 with $2
                                                            if (a > b) {  // jg 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEAEF
                                                                // Compare $1 with $2
                                                                if (a >= b) {  // jge 0xeaff
                                                                    // Block 0xEAFF
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb0f
                                                                        // Block 0xEB0F
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        cmp word ptr [bp - 0x28], 1;
                                                                        if (a != b) {  // jne 0xeb26
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        } else {
                                                                            // Block 0xEB1F
                                                                            lcall 0xc6c, 0xe5;
                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEB26
                                                                                push($1);
                                                                                push($1);
                                                                                push($1);
                                                                                lcall [si];
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEB04
                                                                        *($1) = $2;
                                                                        *($1) = $2;
                                                                        mov word ptr [0x5af8], cx;
                                                                    }
                                                                } else {
                                                                    // Block 0xEAF4
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af4], cx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEA9B
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeaab
                                                            // Block 0xEAAB
                                                            // Compare $1 with $2
                                                            if (a <= b) {  // jle 0xeabb
                                                                // Block 0xEABB
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xead2
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEACB
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                                        // Block 0xEAD9
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        push($1);
                                                                        push($1);
                                                                        neg bx;
                                                                        neg cx;
                                                                        push($1);
                                                                        call 0xed11;
                                                                        // Block 0xEAE5
                                                                        // Compare $1 with $2
                                                                        if (a < b) {  // jl 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEA
                                                                            // Compare $1 with $2
                                                                            if (a > b) {  // jg 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEAEF
                                                                                // Compare $1 with $2
                                                                                if (a >= b) {  // jge 0xeaff
                                                                                    // Block 0xEAFF
                                                                                    // Compare $1 with $2
                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                        // Block 0xEB0F
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                        if (a != b) {  // jne 0xeb26
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        } else {
                                                                                            // Block 0xEB1F
                                                                                            lcall 0xc6c, 0xe5;
                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEB26
                                                                                                push($1);
                                                                                                push($1);
                                                                                                push($1);
                                                                                                lcall [si];
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEB04
                                                                                        *($1) = $2;
                                                                                        *($1) = $2;
                                                                                        mov word ptr [0x5af8], cx;
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEAF4
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af4], cx;
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEAD2
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEAB0
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAA0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA88
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        } else {
                                            // Block 0xEA78
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        }
                                    }
                                } else {
                                    // Block 0xEA56
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af8], cx;
                                }
                            } else {
                                // Block 0xEA46
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af4], cx;
                            }
                        }
                    }
                } else {
                    // Block 0xE9EF
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xe9ff
                        // Block 0xE9FF
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xea0f
                            // Block 0xEA0F
                            $1 = $2;
                            $1 += $2;
                            $1 = $2;
                            $1 += $2;
                            cmp word ptr [bp - 0x28], 1;
                            if (a != b) {  // jne 0xea26
                                // Block 0xEA26
                                push($1);
                                push($1);
                                push($1);
                                lcall [si];
                            } else {
                                // Block 0xEA1F
                                lcall 0xc6c, 0xe5;
                                if (a < b (unsigned)) {  // jb 0xea2d
                                    // Block 0xEA2D
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    neg bx;
                                    push($1);
                                    call 0xed11;
                                    // Block 0xEA37
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xea7f
                                        // Block 0xEA7F
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xea8b
                                            // Block 0xEA8B
                                            neg cx;
                                            push($1);
                                            call 0xed11;
                                            // Block 0xEA91
                                            // Compare $1 with $2
                                            if (a < b) {  // jl 0xead9
                                                // Block 0xEAD9
                                                $1 = pop();
                                                $1 = pop();
                                                push($1);
                                                push($1);
                                                neg bx;
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEAE5
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xeb2d
                                                    // Block 0xEB2D
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEAEA
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEF
                                                        // Compare $1 with $2
                                                        if (a >= b) {  // jge 0xeaff
                                                            // Block 0xEAFF
                                                            // Compare $1 with $2
                                                            if (a < b) {  // jl 0xeb0f
                                                                // Block 0xEB0F
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xeb26
                                                                    // Block 0xEB26
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEB1F
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEB04
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAF4
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA96
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA9B
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xeaab
                                                        // Block 0xEAAB
                                                        // Compare $1 with $2
                                                        if (a <= b) {  // jle 0xeabb
                                                            // Block 0xEABB
                                                            $1 = $2;
                                                            $1 += $2;
                                                            $1 = $2;
                                                            $1 += $2;
                                                            cmp word ptr [bp - 0x28], 1;
                                                            if (a != b) {  // jne 0xead2
                                                                // Block 0xEAD2
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            } else {
                                                                // Block 0xEACB
                                                                lcall 0xc6c, 0xe5;
                                                                if (a < b (unsigned)) {  // jb 0xead9
                                                                    // Block 0xEAD9
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    push($1);
                                                                    push($1);
                                                                    neg bx;
                                                                    neg cx;
                                                                    push($1);
                                                                    call 0xed11;
                                                                    // Block 0xEAE5
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEAEA
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEF
                                                                            // Compare $1 with $2
                                                                            if (a >= b) {  // jge 0xeaff
                                                                                // Block 0xEAFF
                                                                                // Compare $1 with $2
                                                                                if (a < b) {  // jl 0xeb0f
                                                                                    // Block 0xEB0F
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    cmp word ptr [bp - 0x28], 1;
                                                                                    if (a != b) {  // jne 0xeb26
                                                                                        // Block 0xEB26
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    } else {
                                                                                        // Block 0xEB1F
                                                                                        lcall 0xc6c, 0xe5;
                                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEB04
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af8], cx;
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAF4
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af4], cx;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                }
                                                            }
                                                        } else {
                                                            // Block 0xEAB0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af8], cx;
                                                        }
                                                    } else {
                                                        // Block 0xEAA0
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af4], cx;
                                                    }
                                                }
                                            }
                                        } else {
                                            // Block 0xEA88
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    } else {
                                        // Block 0xEA3C
                                        // Compare $1 with $2
                                        if (a > b) {  // jg 0xea7f
                                            // Block 0xEA7F
                                            $1 = pop();
                                            $1 = pop();
                                            push($1);
                                            push($1);
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xea8b
                                                // Block 0xEA8B
                                                neg cx;
                                                push($1);
                                                call 0xed11;
                                                // Block 0xEA91
                                                // Compare $1 with $2
                                                if (a < b) {  // jl 0xead9
                                                    // Block 0xEAD9
                                                    $1 = pop();
                                                    $1 = pop();
                                                    push($1);
                                                    push($1);
                                                    neg bx;
                                                    neg cx;
                                                    push($1);
                                                    call 0xed11;
                                                    // Block 0xEAE5
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xeb2d
                                                        // Block 0xEB2D
                                                        jmp 0xec72;
                                                        // Block 0xEC72
                                                        $1 = pop();
                                                        $1 = pop();
                                                        return;  // retf 
                                                    } else {
                                                        // Block 0xEAEA
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEF
                                                            // Compare $1 with $2
                                                            if (a >= b) {  // jge 0xeaff
                                                                // Block 0xEAFF
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xeb0f
                                                                    // Block 0xEB0F
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    $1 = $2;
                                                                    $1 += $2;
                                                                    cmp word ptr [bp - 0x28], 1;
                                                                    if (a != b) {  // jne 0xeb26
                                                                        // Block 0xEB26
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    } else {
                                                                        // Block 0xEB1F
                                                                        lcall 0xc6c, 0xe5;
                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEB04
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af8], cx;
                                                                }
                                                            } else {
                                                                // Block 0xEAF4
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af4], cx;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA96
                                                    // Compare $1 with $2
                                                    if (a > b) {  // jg 0xead9
                                                        // Block 0xEAD9
                                                        $1 = pop();
                                                        $1 = pop();
                                                        push($1);
                                                        push($1);
                                                        neg bx;
                                                        neg cx;
                                                        push($1);
                                                        call 0xed11;
                                                        // Block 0xEAE5
                                                        // Compare $1 with $2
                                                        if (a < b) {  // jl 0xeb2d
                                                            // Block 0xEB2D
                                                            jmp 0xec72;
                                                            // Block 0xEC72
                                                            $1 = pop();
                                                            $1 = pop();
                                                            return;  // retf 
                                                        } else {
                                                            // Block 0xEAEA
                                                            // Compare $1 with $2
                                                            if (a > b) {  // jg 0xeb2d
                                                                // Block 0xEB2D
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEAEF
                                                                // Compare $1 with $2
                                                                if (a >= b) {  // jge 0xeaff
                                                                    // Block 0xEAFF
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb0f
                                                                        // Block 0xEB0F
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        $1 = $2;
                                                                        $1 += $2;
                                                                        cmp word ptr [bp - 0x28], 1;
                                                                        if (a != b) {  // jne 0xeb26
                                                                            // Block 0xEB26
                                                                            push($1);
                                                                            push($1);
                                                                            push($1);
                                                                            lcall [si];
                                                                        } else {
                                                                            // Block 0xEB1F
                                                                            lcall 0xc6c, 0xe5;
                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEB26
                                                                                push($1);
                                                                                push($1);
                                                                                push($1);
                                                                                lcall [si];
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEB04
                                                                        *($1) = $2;
                                                                        *($1) = $2;
                                                                        mov word ptr [0x5af8], cx;
                                                                    }
                                                                } else {
                                                                    // Block 0xEAF4
                                                                    *($1) = $2;
                                                                    *($1) = $2;
                                                                    mov word ptr [0x5af4], cx;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEA9B
                                                        // Compare $1 with $2
                                                        if (a > b) {  // jg 0xeaab
                                                            // Block 0xEAAB
                                                            // Compare $1 with $2
                                                            if (a <= b) {  // jle 0xeabb
                                                                // Block 0xEABB
                                                                $1 = $2;
                                                                $1 += $2;
                                                                $1 = $2;
                                                                $1 += $2;
                                                                cmp word ptr [bp - 0x28], 1;
                                                                if (a != b) {  // jne 0xead2
                                                                    // Block 0xEAD2
                                                                    push($1);
                                                                    push($1);
                                                                    push($1);
                                                                    lcall [si];
                                                                } else {
                                                                    // Block 0xEACB
                                                                    lcall 0xc6c, 0xe5;
                                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                                        // Block 0xEAD9
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        push($1);
                                                                        push($1);
                                                                        neg bx;
                                                                        neg cx;
                                                                        push($1);
                                                                        call 0xed11;
                                                                        // Block 0xEAE5
                                                                        // Compare $1 with $2
                                                                        if (a < b) {  // jl 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEA
                                                                            // Compare $1 with $2
                                                                            if (a > b) {  // jg 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEAEF
                                                                                // Compare $1 with $2
                                                                                if (a >= b) {  // jge 0xeaff
                                                                                    // Block 0xEAFF
                                                                                    // Compare $1 with $2
                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                        // Block 0xEB0F
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                        if (a != b) {  // jne 0xeb26
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        } else {
                                                                                            // Block 0xEB1F
                                                                                            lcall 0xc6c, 0xe5;
                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEB26
                                                                                                push($1);
                                                                                                push($1);
                                                                                                push($1);
                                                                                                lcall [si];
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEB04
                                                                                        *($1) = $2;
                                                                                        *($1) = $2;
                                                                                        mov word ptr [0x5af8], cx;
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEAF4
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af4], cx;
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEAD2
                                                                        push($1);
                                                                        push($1);
                                                                        push($1);
                                                                        lcall [si];
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEAB0
                                                                *($1) = $2;
                                                                *($1) = $2;
                                                                mov word ptr [0x5af8], cx;
                                                            }
                                                        } else {
                                                            // Block 0xEAA0
                                                            *($1) = $2;
                                                            *($1) = $2;
                                                            mov word ptr [0x5af4], cx;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Block 0xEA88
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            }
                                        } else {
                                            // Block 0xEA41
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0xea51
                                                // Block 0xEA51
                                                // Compare $1 with $2
                                                if (a <= b) {  // jle 0xea61
                                                    // Block 0xEA61
                                                    $1 = $2;
                                                    $1 += $2;
                                                    $1 = $2;
                                                    $1 += $2;
                                                    cmp word ptr [bp - 0x28], 1;
                                                    if (a != b) {  // jne 0xea78
                                                        // Block 0xEA78
                                                        push($1);
                                                        push($1);
                                                        push($1);
                                                        lcall [si];
                                                    } else {
                                                        // Block 0xEA71
                                                        lcall 0xc6c, 0xe5;
                                                        if (a < b (unsigned)) {  // jb 0xea7f
                                                            // Block 0xEA7F
                                                            $1 = pop();
                                                            $1 = pop();
                                                            push($1);
                                                            push($1);
                                                            // Compare $1 with $2
                                                            if (a != b) {  // jne 0xea8b
                                                                // Block 0xEA8B
                                                                neg cx;
                                                                push($1);
                                                                call 0xed11;
                                                                // Block 0xEA91
                                                                // Compare $1 with $2
                                                                if (a < b) {  // jl 0xead9
                                                                    // Block 0xEAD9
                                                                    $1 = pop();
                                                                    $1 = pop();
                                                                    push($1);
                                                                    push($1);
                                                                    neg bx;
                                                                    neg cx;
                                                                    push($1);
                                                                    call 0xed11;
                                                                    // Block 0xEAE5
                                                                    // Compare $1 with $2
                                                                    if (a < b) {  // jl 0xeb2d
                                                                        // Block 0xEB2D
                                                                        jmp 0xec72;
                                                                        // Block 0xEC72
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        return;  // retf 
                                                                    } else {
                                                                        // Block 0xEAEA
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEF
                                                                            // Compare $1 with $2
                                                                            if (a >= b) {  // jge 0xeaff
                                                                                // Block 0xEAFF
                                                                                // Compare $1 with $2
                                                                                if (a < b) {  // jl 0xeb0f
                                                                                    // Block 0xEB0F
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    $1 = $2;
                                                                                    $1 += $2;
                                                                                    cmp word ptr [bp - 0x28], 1;
                                                                                    if (a != b) {  // jne 0xeb26
                                                                                        // Block 0xEB26
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    } else {
                                                                                        // Block 0xEB1F
                                                                                        lcall 0xc6c, 0xe5;
                                                                                        if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEB04
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af8], cx;
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAF4
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af4], cx;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // Block 0xEA96
                                                                    // Compare $1 with $2
                                                                    if (a > b) {  // jg 0xead9
                                                                        // Block 0xEAD9
                                                                        $1 = pop();
                                                                        $1 = pop();
                                                                        push($1);
                                                                        push($1);
                                                                        neg bx;
                                                                        neg cx;
                                                                        push($1);
                                                                        call 0xed11;
                                                                        // Block 0xEAE5
                                                                        // Compare $1 with $2
                                                                        if (a < b) {  // jl 0xeb2d
                                                                            // Block 0xEB2D
                                                                            jmp 0xec72;
                                                                            // Block 0xEC72
                                                                            $1 = pop();
                                                                            $1 = pop();
                                                                            return;  // retf 
                                                                        } else {
                                                                            // Block 0xEAEA
                                                                            // Compare $1 with $2
                                                                            if (a > b) {  // jg 0xeb2d
                                                                                // Block 0xEB2D
                                                                                jmp 0xec72;
                                                                                // Block 0xEC72
                                                                                $1 = pop();
                                                                                $1 = pop();
                                                                                return;  // retf 
                                                                            } else {
                                                                                // Block 0xEAEF
                                                                                // Compare $1 with $2
                                                                                if (a >= b) {  // jge 0xeaff
                                                                                    // Block 0xEAFF
                                                                                    // Compare $1 with $2
                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                        // Block 0xEB0F
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        $1 = $2;
                                                                                        $1 += $2;
                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                        if (a != b) {  // jne 0xeb26
                                                                                            // Block 0xEB26
                                                                                            push($1);
                                                                                            push($1);
                                                                                            push($1);
                                                                                            lcall [si];
                                                                                        } else {
                                                                                            // Block 0xEB1F
                                                                                            lcall 0xc6c, 0xe5;
                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEB26
                                                                                                push($1);
                                                                                                push($1);
                                                                                                push($1);
                                                                                                lcall [si];
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEB04
                                                                                        *($1) = $2;
                                                                                        *($1) = $2;
                                                                                        mov word ptr [0x5af8], cx;
                                                                                    }
                                                                                } else {
                                                                                    // Block 0xEAF4
                                                                                    *($1) = $2;
                                                                                    *($1) = $2;
                                                                                    mov word ptr [0x5af4], cx;
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // Block 0xEA9B
                                                                        // Compare $1 with $2
                                                                        if (a > b) {  // jg 0xeaab
                                                                            // Block 0xEAAB
                                                                            // Compare $1 with $2
                                                                            if (a <= b) {  // jle 0xeabb
                                                                                // Block 0xEABB
                                                                                $1 = $2;
                                                                                $1 += $2;
                                                                                $1 = $2;
                                                                                $1 += $2;
                                                                                cmp word ptr [bp - 0x28], 1;
                                                                                if (a != b) {  // jne 0xead2
                                                                                    // Block 0xEAD2
                                                                                    push($1);
                                                                                    push($1);
                                                                                    push($1);
                                                                                    lcall [si];
                                                                                } else {
                                                                                    // Block 0xEACB
                                                                                    lcall 0xc6c, 0xe5;
                                                                                    if (a < b (unsigned)) {  // jb 0xead9
                                                                                        // Block 0xEAD9
                                                                                        $1 = pop();
                                                                                        $1 = pop();
                                                                                        push($1);
                                                                                        push($1);
                                                                                        neg bx;
                                                                                        neg cx;
                                                                                        push($1);
                                                                                        call 0xed11;
                                                                                        // Block 0xEAE5
                                                                                        // Compare $1 with $2
                                                                                        if (a < b) {  // jl 0xeb2d
                                                                                            // Block 0xEB2D
                                                                                            jmp 0xec72;
                                                                                            // Block 0xEC72
                                                                                            $1 = pop();
                                                                                            $1 = pop();
                                                                                            return;  // retf 
                                                                                        } else {
                                                                                            // Block 0xEAEA
                                                                                            // Compare $1 with $2
                                                                                            if (a > b) {  // jg 0xeb2d
                                                                                                // Block 0xEB2D
                                                                                                jmp 0xec72;
                                                                                                // Block 0xEC72
                                                                                                $1 = pop();
                                                                                                $1 = pop();
                                                                                                return;  // retf 
                                                                                            } else {
                                                                                                // Block 0xEAEF
                                                                                                // Compare $1 with $2
                                                                                                if (a >= b) {  // jge 0xeaff
                                                                                                    // Block 0xEAFF
                                                                                                    // Compare $1 with $2
                                                                                                    if (a < b) {  // jl 0xeb0f
                                                                                                        // Block 0xEB0F
                                                                                                        $1 = $2;
                                                                                                        $1 += $2;
                                                                                                        $1 = $2;
                                                                                                        $1 += $2;
                                                                                                        cmp word ptr [bp - 0x28], 1;
                                                                                                        if (a != b) {  // jne 0xeb26
                                                                                                            // Block 0xEB26
                                                                                                            push($1);
                                                                                                            push($1);
                                                                                                            push($1);
                                                                                                            lcall [si];
                                                                                                        } else {
                                                                                                            // Block 0xEB1F
                                                                                                            lcall 0xc6c, 0xe5;
                                                                                                            if (a < b (unsigned)) {  // jb 0xeb2d
                                                                                                                // Block 0xEB2D
                                                                                                                jmp 0xec72;
                                                                                                                // Block 0xEC72
                                                                                                                $1 = pop();
                                                                                                                $1 = pop();
                                                                                                                return;  // retf 
                                                                                                            } else {
                                                                                                                // Block 0xEB26
                                                                                                                push($1);
                                                                                                                push($1);
                                                                                                                push($1);
                                                                                                                lcall [si];
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        // Block 0xEB04
                                                                                                        *($1) = $2;
                                                                                                        *($1) = $2;
                                                                                                        mov word ptr [0x5af8], cx;
                                                                                                    }
                                                                                                } else {
                                                                                                    // Block 0xEAF4
                                                                                                    *($1) = $2;
                                                                                                    *($1) = $2;
                                                                                                    mov word ptr [0x5af4], cx;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // Block 0xEAD2
                                                                                        push($1);
                                                                                        push($1);
                                                                                        push($1);
                                                                                        lcall [si];
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                // Block 0xEAB0
                                                                                *($1) = $2;
                                                                                *($1) = $2;
                                                                                mov word ptr [0x5af8], cx;
                                                                            }
                                                                        } else {
                                                                            // Block 0xEAA0
                                                                            *($1) = $2;
                                                                            *($1) = $2;
                                                                            mov word ptr [0x5af4], cx;
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                // Block 0xEA88
                                                                jmp 0xec72;
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            }
                                                        } else {
                                                            // Block 0xEA78
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        }
                                                    }
                                                } else {
                                                    // Block 0xEA56
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af8], cx;
                                                }
                                            } else {
                                                // Block 0xEA46
                                                *($1) = $2;
                                                *($1) = $2;
                                                mov word ptr [0x5af4], cx;
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEA26
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                }
                            }
                        } else {
                            // Block 0xEA04
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af8], cx;
                        }
                    } else {
                        // Block 0xE9F4
                        *($1) = $2;
                        *($1) = $2;
                        mov word ptr [0x5af4], cx;
                    }
                }
            }
        } else {
            // Block 0xE9DE
            jmp 0xebd4;
            // Block 0xEBD4
            push($1);
            call 0xed11;
            // Block 0xEBD8
            // Compare $1 with $2
            if (a < b) {  // jl 0xec1e
                // Block 0xEC1E
                $1 = pop();
                $1 = pop();
                push($1);
                push($1);
                or bx, bx;
                if (a == b) {  // je 0xec72
                    // Block 0xEC72
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0xEC26
                    neg bx;
                    push($1);
                    call 0xed11;
                    // Block 0xEC2C
                    // Compare $1 with $2
                    if (a < b) {  // jl 0xec72
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0xEC31
                        // Compare $1 with $2
                        if (a > b) {  // jg 0xec72
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0xEC36
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xec46
                                // Block 0xEC46
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xec56
                                    // Block 0xEC56
                                    $1 = $2;
                                    $1 += $2;
                                    $1 = $2;
                                    cmp word ptr [bp - 0x28], 1;
                                    if (a != b) {  // jne 0xec6b
                                        // Block 0xEC6B
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    } else {
                                        // Block 0xEC64
                                        lcall 0xc6c, 0xe5;
                                        if (a < b (unsigned)) {  // jb 0xec72
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEC6B
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        }
                                    }
                                } else {
                                    // Block 0xEC4B
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af8], cx;
                                }
                            } else {
                                // Block 0xEC3B
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af4], cx;
                            }
                        }
                    }
                }
            } else {
                // Block 0xEBDD
                // Compare $1 with $2
                if (a > b) {  // jg 0xec1e
                    // Block 0xEC1E
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    or bx, bx;
                    if (a == b) {  // je 0xec72
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    } else {
                        // Block 0xEC26
                        neg bx;
                        push($1);
                        call 0xed11;
                        // Block 0xEC2C
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xec72
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        } else {
                            // Block 0xEC31
                            // Compare $1 with $2
                            if (a > b) {  // jg 0xec72
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xEC36
                                // Compare $1 with $2
                                if (a > b) {  // jg 0xec46
                                    // Block 0xEC46
                                    // Compare $1 with $2
                                    if (a < b) {  // jl 0xec56
                                        // Block 0xEC56
                                        $1 = $2;
                                        $1 += $2;
                                        $1 = $2;
                                        cmp word ptr [bp - 0x28], 1;
                                        if (a != b) {  // jne 0xec6b
                                            // Block 0xEC6B
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                        } else {
                                            // Block 0xEC64
                                            lcall 0xc6c, 0xe5;
                                            if (a < b (unsigned)) {  // jb 0xec72
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEC6B
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                            }
                                        }
                                    } else {
                                        // Block 0xEC4B
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af8], cx;
                                    }
                                } else {
                                    // Block 0xEC3B
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af4], cx;
                                }
                            }
                        }
                    }
                } else {
                    // Block 0xEBE2
                    // Compare $1 with $2
                    if (a > b) {  // jg 0xebf2
                        // Block 0xEBF2
                        // Compare $1 with $2
                        if (a < b) {  // jl 0xec02
                            // Block 0xEC02
                            $1 = $2;
                            $1 += $2;
                            $1 = $2;
                            cmp word ptr [bp - 0x28], 1;
                            if (a != b) {  // jne 0xec17
                                // Block 0xEC17
                                push($1);
                                push($1);
                                push($1);
                                lcall [si];
                            } else {
                                // Block 0xEC10
                                lcall 0xc6c, 0xe5;
                                if (a < b (unsigned)) {  // jb 0xec1e
                                    // Block 0xEC1E
                                    $1 = pop();
                                    $1 = pop();
                                    push($1);
                                    push($1);
                                    or bx, bx;
                                    if (a == b) {  // je 0xec72
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEC26
                                        neg bx;
                                        push($1);
                                        call 0xed11;
                                        // Block 0xEC2C
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xec72
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEC31
                                            // Compare $1 with $2
                                            if (a > b) {  // jg 0xec72
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEC36
                                                // Compare $1 with $2
                                                if (a > b) {  // jg 0xec46
                                                    // Block 0xEC46
                                                    // Compare $1 with $2
                                                    if (a < b) {  // jl 0xec56
                                                        // Block 0xEC56
                                                        $1 = $2;
                                                        $1 += $2;
                                                        $1 = $2;
                                                        cmp word ptr [bp - 0x28], 1;
                                                        if (a != b) {  // jne 0xec6b
                                                            // Block 0xEC6B
                                                            push($1);
                                                            push($1);
                                                            push($1);
                                                            lcall [si];
                                                        } else {
                                                            // Block 0xEC64
                                                            lcall 0xc6c, 0xe5;
                                                            if (a < b (unsigned)) {  // jb 0xec72
                                                                // Block 0xEC72
                                                                $1 = pop();
                                                                $1 = pop();
                                                                return;  // retf 
                                                            } else {
                                                                // Block 0xEC6B
                                                                push($1);
                                                                push($1);
                                                                push($1);
                                                                lcall [si];
                                                            }
                                                        }
                                                    } else {
                                                        // Block 0xEC4B
                                                        *($1) = $2;
                                                        *($1) = $2;
                                                        mov word ptr [0x5af8], cx;
                                                    }
                                                } else {
                                                    // Block 0xEC3B
                                                    *($1) = $2;
                                                    *($1) = $2;
                                                    mov word ptr [0x5af4], cx;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xEC17
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                }
                            }
                        } else {
                            // Block 0xEBF7
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af8], cx;
                        }
                    } else {
                        // Block 0xEBE7
                        *($1) = $2;
                        *($1) = $2;
                        mov word ptr [0x5af4], cx;
                    }
                }
            }
        }
    } else {
        // Block 0xE9D7
        jmp 0xeb30;
        // Block 0xEB30
        push($1);
        call 0xed11;
        // Block 0xEB34
        // Compare $1 with $2
        if (a < b) {  // jl 0xeb70
            // Block 0xEB70
            $1 = pop();
            $1 = pop();
            push($1);
            push($1);
            // Compare $1 with $2
            if (a != b) {  // jne 0xeb7c
                // Block 0xEB7C
                neg cx;
                push($1);
                call 0xed11;
                // Block 0xEB82
                // Compare $1 with $2
                if (a >= b) {  // jge 0xeb8a
                    // Block 0xEB8A
                    // Compare $1 with $2
                    if (a <= b) {  // jle 0xeb92
                        // Block 0xEB92
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0xeba2
                            // Block 0xEBA2
                            // Compare $1 with $2
                            if (a < b) {  // jl 0xebb2
                                // Block 0xEBB2
                                $1 = $2;
                                $1 = $2;
                                $1 += $2;
                                cmp word ptr [bp - 0x28], 1;
                                if (a != b) {  // jne 0xebca
                                    // Block 0xEBCA
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xEBC0
                                    lcall 0xc6c, 0xe5;
                                    if (a >= b (unsigned)) {  // jae 0xebca
                                        // Block 0xEBCA
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEBC7
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    }
                                }
                            } else {
                                // Block 0xEBA7
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af8], cx;
                            }
                        } else {
                            // Block 0xEB97
                            *($1) = $2;
                            *($1) = $2;
                            mov word ptr [0x5af4], cx;
                        }
                    } else {
                        // Block 0xEB8F
                        jmp 0xec72;
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0xEB87
                    jmp 0xec72;
                    // Block 0xEC72
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0xEB79
                jmp 0xec72;
                // Block 0xEC72
                $1 = pop();
                $1 = pop();
                return;  // retf 
            }
        } else {
            // Block 0xEB39
            // Compare $1 with $2
            if (a > b) {  // jg 0xeb70
                // Block 0xEB70
                $1 = pop();
                $1 = pop();
                push($1);
                push($1);
                // Compare $1 with $2
                if (a != b) {  // jne 0xeb7c
                    // Block 0xEB7C
                    neg cx;
                    push($1);
                    call 0xed11;
                    // Block 0xEB82
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xeb8a
                        // Block 0xEB8A
                        // Compare $1 with $2
                        if (a <= b) {  // jle 0xeb92
                            // Block 0xEB92
                            // Compare $1 with $2
                            if (a >= b) {  // jge 0xeba2
                                // Block 0xEBA2
                                // Compare $1 with $2
                                if (a < b) {  // jl 0xebb2
                                    // Block 0xEBB2
                                    $1 = $2;
                                    $1 = $2;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x28], 1;
                                    if (a != b) {  // jne 0xebca
                                        // Block 0xEBCA
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                        jmp 0xec72;
                                        // Block 0xEC72
                                        $1 = pop();
                                        $1 = pop();
                                        return;  // retf 
                                    } else {
                                        // Block 0xEBC0
                                        lcall 0xc6c, 0xe5;
                                        if (a >= b (unsigned)) {  // jae 0xebca
                                            // Block 0xEBCA
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        } else {
                                            // Block 0xEBC7
                                            jmp 0xec72;
                                            // Block 0xEC72
                                            $1 = pop();
                                            $1 = pop();
                                            return;  // retf 
                                        }
                                    }
                                } else {
                                    // Block 0xEBA7
                                    *($1) = $2;
                                    *($1) = $2;
                                    mov word ptr [0x5af8], cx;
                                }
                            } else {
                                // Block 0xEB97
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [0x5af4], cx;
                            }
                        } else {
                            // Block 0xEB8F
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEB87
                        jmp 0xec72;
                        // Block 0xEC72
                        $1 = pop();
                        $1 = pop();
                        return;  // retf 
                    }
                } else {
                    // Block 0xEB79
                    jmp 0xec72;
                    // Block 0xEC72
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            } else {
                // Block 0xEB3E
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                *($1) = $2;
                $1 = $2;
                $1 = $2;
                $1 += $2;
                cmp word ptr [bp - 0x28], 1;
                if (a != b) {  // jne 0xeb69
                    // Block 0xEB69
                    push($1);
                    push($1);
                    push($1);
                    lcall [si];
                } else {
                    // Block 0xEB62
                    lcall 0xc6c, 0xe5;
                    if (a < b (unsigned)) {  // jb 0xeb70
                        // Block 0xEB70
                        $1 = pop();
                        $1 = pop();
                        push($1);
                        push($1);
                        // Compare $1 with $2
                        if (a != b) {  // jne 0xeb7c
                            // Block 0xEB7C
                            neg cx;
                            push($1);
                            call 0xed11;
                            // Block 0xEB82
                            // Compare $1 with $2
                            if (a >= b) {  // jge 0xeb8a
                                // Block 0xEB8A
                                // Compare $1 with $2
                                if (a <= b) {  // jle 0xeb92
                                    // Block 0xEB92
                                    // Compare $1 with $2
                                    if (a >= b) {  // jge 0xeba2
                                        // Block 0xEBA2
                                        // Compare $1 with $2
                                        if (a < b) {  // jl 0xebb2
                                            // Block 0xEBB2
                                            $1 = $2;
                                            $1 = $2;
                                            $1 += $2;
                                            cmp word ptr [bp - 0x28], 1;
                                            if (a != b) {  // jne 0xebca
                                                // Block 0xEBCA
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                                jmp 0xec72;
                                                // Block 0xEC72
                                                $1 = pop();
                                                $1 = pop();
                                                return;  // retf 
                                            } else {
                                                // Block 0xEBC0
                                                lcall 0xc6c, 0xe5;
                                                if (a >= b (unsigned)) {  // jae 0xebca
                                                    // Block 0xEBCA
                                                    push($1);
                                                    push($1);
                                                    push($1);
                                                    lcall [si];
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                } else {
                                                    // Block 0xEBC7
                                                    jmp 0xec72;
                                                    // Block 0xEC72
                                                    $1 = pop();
                                                    $1 = pop();
                                                    return;  // retf 
                                                }
                                            }
                                        } else {
                                            // Block 0xEBA7
                                            *($1) = $2;
                                            *($1) = $2;
                                            mov word ptr [0x5af8], cx;
                                        }
                                    } else {
                                        // Block 0xEB97
                                        *($1) = $2;
                                        *($1) = $2;
                                        mov word ptr [0x5af4], cx;
                                    }
                                } else {
                                    // Block 0xEB8F
                                    jmp 0xec72;
                                    // Block 0xEC72
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                }
                            } else {
                                // Block 0xEB87
                                jmp 0xec72;
                                // Block 0xEC72
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            }
                        } else {
                            // Block 0xEB79
                            jmp 0xec72;
                            // Block 0xEC72
                            $1 = pop();
                            $1 = pop();
                            return;  // retf 
                        }
                    } else {
                        // Block 0xEB69
                        push($1);
                        push($1);
                        push($1);
                        lcall [si];
                    }
                }
            }
        }
    }

    // Function calls:
    sub_ED11();
    sub_ED11();
    sub_ED11();
    sub_ED11();
    sub_ED11();
    sub_ED11();
    sub_ED11();
    sub_ED11();
}

void sub_ECFD() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 1 if statements

    // Block 0xECFD
    push($1);
    $1 = $2;
    mul cx;
    or dx, dx;
    if (a == b) {  // je 0xed0a
        // Block 0xED0A
        xchg cx, ax;
        $1 = pop();
        mul dx;
        add dx, cx;
    } else {
        // Block 0xED06
        $1 = pop();
        stc ;
        jmp 0xed10;
        // Block 0xED10
        return;  // retf 
    }
}

void sub_ED11() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 9 if statements

    // Block 0xED11
    push($1);
    push($1);
    push($1);
    push($1);
    neg cx;
    // Compare $1 with $2
    if (a < b) {  // jl 0xed26
        // Block 0xED26
        $1 = $2;
        jmp 0xed2e;
        // Block 0xED2E
        push($1);
        // Compare $1 with $2
        if (a != b) {  // jne 0xed40
            // Block 0xED40
            $1 = $2;
            $1 = 0;
            xor cx, bx;
            if (a >= b) {  // jge 0xed49
                // Block 0xED49
                push($1);
                // Compare $1 with $2
                if (a >= b) {  // jge 0xed51
                    // Block 0xED51
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xed58
                        // Block 0xED58
                        $1 = $2;
                        mul dx;
                        div bx;
                        $1 = $2;
                        for (ax = word; ax < $2_2; ax++) {
                        cmp ax, word ptr [si];
                        if (a <= b (unsigned)) {  // jbe 0xed6d
                            // Block 0xED6D
                            $1 = $2;
                            $1 -= $2;
                            shr ax, 1;
                            $1 = pop();
                            // Compare $1 with $2
                            if (a >= b) {  // jge 0xed7c
                                // Block 0xED7C
                                $1 = pop();
                                $1 += $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                return;  // retf 
                            } else {
                                // Block 0xED7A
                                neg ax;
                            }
                        } else {
                            // Block 0xED69
                            $1++;
                            $1++;
                            loop 0xed65;
                        }
                    } else {
                        // Block 0xED56
                        neg bx;
                    }
                } else {
                    // Block 0xED4F
                    neg ax;
                }
            } else {
                // Block 0xED48
                dec dx;
            }
        } else {
            // Block 0xED34
            for (cx = 0; cx < $2_2; cx++) {
            cmp cx, 0;
            if (a >= b) {  // jge 0xed7c
                // Block 0xED7C
                $1 = pop();
                $1 += $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            } else {
                // Block 0xED3C
                neg ax;
                jmp 0xed7c;
                // Block 0xED7C
                $1 = pop();
                $1 += $2;
                $1 = pop();
                $1 = pop();
                $1 = pop();
                $1 = pop();
                return;  // retf 
            }
        }
    } else {
        // Block 0xED1C
        // Compare $1 with $2
        if (a < b) {  // jl 0xed2b
            // Block 0xED2B
            mov dx, 0x168;
        } else {
            // Block 0xED21
            $1 = $2;
            jmp 0xed2e;
            // Block 0xED2E
            push($1);
            // Compare $1 with $2
            if (a != b) {  // jne 0xed40
                // Block 0xED40
                $1 = $2;
                $1 = 0;
                xor cx, bx;
                if (a >= b) {  // jge 0xed49
                    // Block 0xED49
                    push($1);
                    // Compare $1 with $2
                    if (a >= b) {  // jge 0xed51
                        // Block 0xED51
                        // Compare $1 with $2
                        if (a >= b) {  // jge 0xed58
                            // Block 0xED58
                            $1 = $2;
                            mul dx;
                            div bx;
                            $1 = $2;
                            for (ax = word; ax < $2_2; ax++) {
                            cmp ax, word ptr [si];
                            if (a <= b (unsigned)) {  // jbe 0xed6d
                                // Block 0xED6D
                                $1 = $2;
                                $1 -= $2;
                                shr ax, 1;
                                $1 = pop();
                                // Compare $1 with $2
                                if (a >= b) {  // jge 0xed7c
                                    // Block 0xED7C
                                    $1 = pop();
                                    $1 += $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    return;  // retf 
                                } else {
                                    // Block 0xED7A
                                    neg ax;
                                }
                            } else {
                                // Block 0xED69
                                $1++;
                                $1++;
                                loop 0xed65;
                            }
                        } else {
                            // Block 0xED56
                            neg bx;
                        }
                    } else {
                        // Block 0xED4F
                        neg ax;
                    }
                } else {
                    // Block 0xED48
                    dec dx;
                }
            } else {
                // Block 0xED34
                for (cx = 0; cx < $2_2; cx++) {
                cmp cx, 0;
                if (a >= b) {  // jge 0xed7c
                    // Block 0xED7C
                    $1 = pop();
                    $1 += $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                } else {
                    // Block 0xED3C
                    neg ax;
                    jmp 0xed7c;
                    // Block 0xED7C
                    $1 = pop();
                    $1 += $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    return;  // retf 
                }
            }
        }
    }
}

void sub_ED84() {
    // Variable declarations
    int var_5AF2;
    int var_5AF4;
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 8 if statements

    // Block 0xED84
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    $1 = $2;
    $1 = $2;
    *($1) = $2;
    shr ax, 1;
    shr ax, 1;
    $1 -= $2;
    if (a >= b) {  // jge 0xedbb
        // Block 0xEDBB
        *($1) = $2;
        mov word ptr [bp - 0x14], 0;
        $1 = $2;
        cmp word ptr [si + 0x3c], 1;
        if (a != b) {  // jne 0xedf8
            // Block 0xEDF8
            $1 = $2;
            // Compare $1 with $2
            if (a >= b) {  // jge 0xee06
                // Block 0xEE06
                $1 = $2;
                // Compare $1 with $2
                if (a >= b) {  // jge 0xee14
                    // Block 0xEE14
                    $1 = $2;
                    *($1) = $2;
                    add word ptr [bp + 0x12], ax;
                    add word ptr [bp + 0xe], ax;
                    $1 = $2;
                    *($1) = $2;
                    add word ptr [bp + 0x10], ax;
                    add word ptr [bp + 0xc], ax;
                    mov word ptr [si + 0x30], 0;
                    mov word ptr [si + 0x32], 0;
                    $1 = $2;
                    *($1) = $2;
                    mov word ptr [si + 0x3c], 0;
                    $1 = $2;
                    $1 -= $2;
                    $1++;
                    shr ax, 1;
                    *($1) = $2;
                    $1 += $2;
                    *($1) = $2;
                    $1 = $2;
                    $1 -= $2;
                    $1++;
                    shr ax, 1;
                    *($1) = $2;
                    $1 += $2;
                    *($1) = $2;
                    $1 = $2;
                    $1 = $2;
                    imul dx;
                    $1 = $2;
                    lcall 0x7ff, 0x32;
                    *($1) = $2;
                    $1 = $2;
                    // Compare $1 with $2
                    if (a > b) {  // jg 0xee83
                        // Block 0xEE83
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        *($1) = $2;
                        $1 -= $2;
                        *($1) = $2;
                        $1 = $2;
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        lcall 0x7ff, 0x32;
                        push($1);
                        call 0xeffc;
                        // Block 0xEEAD
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        $1 = 0;
                        lcall 0x7ff, 0x50;
                        $1 += $2;
                        *($1) = $2;
                        stosw word ptr es:[di], ax;
                        $1 = pop();
                        call 0xf03c;
                        // Block 0xEEC7
                        $1 = $2;
                        imul dx;
                        $1 = $2;
                        $1 = 0;
                        lcall 0x7ff, 0x50;
                        $1 += $2;
                        *($1) = $2;
                        stosw word ptr es:[di], ax;
                        inc word ptr [bp - 0x14];
                    } else {
                        // Block 0xEE80
                        add ax, 0x168;
                    }
                } else {
                    // Block 0xEE0E
                    xchg word ptr [bp + 0x12], ax;
                    mov word ptr [bp + 0xe], ax;
                }
            } else {
                // Block 0xEE00
                xchg word ptr [bp + 0x10], ax;
                mov word ptr [bp + 0xc], ax;
            }
        } else {
            // Block 0xEDCC
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            mov word ptr [bp + 0xc], ax;
        }
    } else {
        // Block 0xEDB3
        mov word ptr [bp - 2], 0xfffe;
        jmp 0xefef;
        // Block 0xEFEF
        $1 = $2;
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = pop();
        $1 = $2;
        $1 = pop();
        return;  // retf 0xe
    }

    // Function calls:
    sub_EFFC();
    sub_F03C();
    sub_EFFC();
    sub_F03C();
    sub_EFFC();
    sub_F03C();
}

void sub_EFFC() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 5 if statements

    // Block 0xEFFC
    // Compare $1 with $2
    if (a < b) {  // jl 0xf004
        // Block 0xF004
        // Compare $1 with $2
        if (a <= b) {  // jle 0xf012
            // Block 0xF012
            // Compare $1 with $2
            if (a <= b) {  // jle 0xf02b
                // Block 0xF02B
                xor dx, dx;
            } else {
                // Block 0xF017
                for (ax = 0xb4; ax < $2_2; ax++) {
                cmp ax, 0xb4;
                if (a <= b) {  // jle 0xf024
                    // Block 0xF024
                    $1 -= $2;
                    neg ax;
                    jmp 0xf02d;
                    // Block 0xF02D
                    $1 = $2;
                    shl bx, 1;
                    $1 = $2;
                    or dx, dx;
                    if (a == b) {  // je 0xf03b
                        // Block 0xF03B
                        return;  // ret 
                    } else {
                        // Block 0xF039
                        neg ax;
                    }
                } else {
                    // Block 0xF01F
                    $1 -= $2;
                    jmp 0xf02d;
                    // Block 0xF02D
                    $1 = $2;
                    shl bx, 1;
                    $1 = $2;
                    or dx, dx;
                    if (a == b) {  // je 0xf03b
                        // Block 0xF03B
                        return;  // ret 
                    } else {
                        // Block 0xF039
                        neg ax;
                    }
                }
            }
        } else {
            // Block 0xF009
            $1 = 0;
            $1 -= $2;
            neg ax;
            jmp 0xf02d;
            // Block 0xF02D
            $1 = $2;
            shl bx, 1;
            $1 = $2;
            or dx, dx;
            if (a == b) {  // je 0xf03b
                // Block 0xF03B
                return;  // ret 
            } else {
                // Block 0xF039
                neg ax;
            }
        }
    } else {
        // Block 0xF001
        sub ax, 0x168;
    }
}

void sub_F03C() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 6 if statements

    // Block 0xF03C
    // Compare $1 with $2
    if (a < b) {  // jl 0xf044
        // Block 0xF044
        // Compare $1 with $2
        if (a <= b) {  // jle 0xf05c
            // Block 0xF05C
            for (ax = 0x5a; ax < $2_2; ax++) {
            cmp ax, 0x5a;
            if (a <= b) {  // jle 0xf069
                // Block 0xF069
                $1 = $2;
                $1 -= $2;
                shl bx, 1;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0xf07a
                    // Block 0xF07A
                    return;  // ret 
                } else {
                    // Block 0xF078
                    neg ax;
                }
            } else {
                // Block 0xF064
                $1 -= $2;
                neg ax;
            }
        } else {
            // Block 0xF049
            $1 = 0;
            // Compare $1 with $2
            if (a <= b) {  // jle 0xf057
                // Block 0xF057
                $1 -= $2;
                jmp 0xf069;
                // Block 0xF069
                $1 = $2;
                $1 -= $2;
                shl bx, 1;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0xf07a
                    // Block 0xF07A
                    return;  // ret 
                } else {
                    // Block 0xF078
                    neg ax;
                }
            } else {
                // Block 0xF050
                $1 -= $2;
                neg ax;
                jmp 0xf069;
                // Block 0xF069
                $1 = $2;
                $1 -= $2;
                shl bx, 1;
                $1 = $2;
                or dx, dx;
                if (a == b) {  // je 0xf07a
                    // Block 0xF07A
                    return;  // ret 
                } else {
                    // Block 0xF078
                    neg ax;
                }
            }
        }
    } else {
        // Block 0xF041
        sub ax, 0x168;
    }

    // Function calls:
    sub_F100();
}

void sub_F100() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 13 if statements

    // Block 0xF100
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    $1 = $2;
    cmp word ptr [si + 0x3c], 1;
    if (a != b) {  // jne 0xf144
        // Block 0xF144
        $1 = $2;
        *($1) = $2;
        $1 = $2;
        $1 = $2;
        add word ptr [bp + 0xe], ax;
        add word ptr [bp + 0xc], bx;
        $1 = $2;
        and dx, 2;
        if (a == b) {  // je 0xf1a0
            // Block 0xF1A0
            cmp word ptr [si], 1;
            if (a != b) {  // jne 0xf1ad
                // Block 0xF1AD
                $1 = $2;
                $1 = $2;
                // Compare $1 with $2
                if (a <= b (unsigned)) {  // jbe 0xf1c0
                    // Block 0xF1C0
                    shl ax, 1;
                    shl ax, 1;
                    $1 += $2;
                    lcall 0xc6c, 0x3e;
                    mov word ptr [bp - 0x24], ax;
                } else {
                    // Block 0xF1B8
                    mov word ptr [bp - 2], 0xfffa;
                    jmp 0xf400;
                    // Block 0xF400
                    $1 = $2;
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = pop();
                    $1 = $2;
                    $1 = pop();
                    return;  // retf 0xa
                }
            } else {
                // Block 0xF1A5
                $1 = $2;
                $1 = $2;
                jmp 0xf1c0;
                // Block 0xF1C0
                shl ax, 1;
                shl ax, 1;
                $1 += $2;
                lcall 0xc6c, 0x3e;
                mov word ptr [bp - 0x24], ax;
            }
        } else {
            // Block 0xF15E
            $1 = $2;
            *($1) = $2;
            mov word ptr [si + 0x3c], 0;
            *($1) = $2;
            *($1) = $2;
            mov word ptr [si + 0x30], 0;
            mov word ptr [si + 0x32], 0;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            $1 = $2;
            *($1) = $2;
            mov word ptr [si + 0x2a], 1;
            $1 = $2;
            $1 = $2;
            mul bx;
            $1 = $2;
            $1 += $2;
            mov word ptr [bp - 0x32], di;
        }
    } else {
        // Block 0xF118
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x26c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x21c;
        *($1) = $2;
        push($1);
        lcall 0x1214, 0x2cf;
        mov word ptr [bp + 8], ax;
    }

    // Function calls:
    sub_F5DB();
    sub_F5DB();
    sub_F40D();
    sub_F40D();
    sub_F40D();
}

void sub_F40D() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 21 if statements

    // Block 0xF40D
    push($1);
    push($1);
    cmp word ptr [bp + 6], 2;
    if (a >= b) {  // jge 0xf418
        // Block 0xF418
        // Compare $1 with $2
        if (a != b) {  // jne 0xf420
            // Block 0xF420
            $1 = $2;
            cmp word ptr [bx + 0x26], 1;
            if (a == b) {  // je 0xf488
                // Block 0xF488
                $1 = $2;
                $1 = $2;
                $1 -= $2;
                push($1);
                $1 = $2;
                $1 += $2;
                push($1);
                $1 = $2;
                $1 += $2;
                push($1);
                push($1);
                and cx, 7;
                and bx, 7;
                $1 = $2;
                $1 = $2;
                rol ax, cl;
                $1 = $2;
                *($1) = $2;
                lcall 0xd9f, 0x178;
                $1 = $2;
                $1 += $2;
                $1 = $2;
                $1 -= $2;
                // Compare $1 with $2
                if (a != b) {  // jne 0xf4cb
                    // Block 0xF4CB
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    push($1);
                    and cx, 7;
                    and bx, 7;
                    $1 = $2;
                    $1 = $2;
                    rol ax, cl;
                    $1 = $2;
                    *($1) = $2;
                    lcall 0xd9f, 0x178;
                    jmp 0xf5d2;
                    // Block 0xF5D2
                    $1 = pop();
                    $1 = pop();
                    *($1) = $2;
                    *($1) = $2;
                    return;  // retf 
                } else {
                    // Block 0xF4C8
                    jmp 0xf5d2;
                    // Block 0xF5D2
                    $1 = pop();
                    $1 = pop();
                    *($1) = $2;
                    *($1) = $2;
                    return;  // retf 
                }
            } else {
                // Block 0xF429
                cmp word ptr [bx + 0x22], 0;
                if (a == b) {  // je 0xf488
                    // Block 0xF488
                    $1 = $2;
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    push($1);
                    and cx, 7;
                    and bx, 7;
                    $1 = $2;
                    $1 = $2;
                    rol ax, cl;
                    $1 = $2;
                    *($1) = $2;
                    lcall 0xd9f, 0x178;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    $1 -= $2;
                    // Compare $1 with $2
                    if (a != b) {  // jne 0xf4cb
                        // Block 0xF4CB
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 += $2;
                        push($1);
                        push($1);
                        and cx, 7;
                        and bx, 7;
                        $1 = $2;
                        $1 = $2;
                        rol ax, cl;
                        $1 = $2;
                        *($1) = $2;
                        lcall 0xd9f, 0x178;
                        jmp 0xf5d2;
                        // Block 0xF5D2
                        $1 = pop();
                        $1 = pop();
                        *($1) = $2;
                        *($1) = $2;
                        return;  // retf 
                    } else {
                        // Block 0xF4C8
                        jmp 0xf5d2;
                        // Block 0xF5D2
                        $1 = pop();
                        $1 = pop();
                        *($1) = $2;
                        *($1) = $2;
                        return;  // retf 
                    }
                } else {
                    // Block 0xF42F
                    mov word ptr [bx + 0x28], 0xffff;
                    $1 = $2;
                    *($1) = $2;
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    $1 = $2;
                    $1 += $2;
                    push($1);
                    push($1);
                    lcall 0xd9f, 0x178;
                    $1 = $2;
                    $1 += $2;
                    $1 = $2;
                    $1 -= $2;
                    // Compare $1 with $2
                    if (a == b) {  // je 0xf481
                        // Block 0xF481
                        $1 = pop();
                        $1 = $2;
                        mov word ptr [bx + 0xc], ax;
                    } else {
                        // Block 0xF466
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 -= $2;
                        push($1);
                        $1 = $2;
                        $1 += $2;
                        push($1);
                        push($1);
                        lcall 0xd9f, 0x178;
                    }
                }
            }
        } else {
            // Block 0xF41D
            jmp 0xf5d2;
            // Block 0xF5D2
            $1 = pop();
            $1 = pop();
            *($1) = $2;
            *($1) = $2;
            return;  // retf 
        }
    } else {
        // Block 0xF415
        jmp 0xf4fb;
        // Block 0xF4FB
        // Compare $1 with $2
        if (a != b) {  // jne 0xf503
            // Block 0xF503
            $1 = $2;
            $1 += $2;
            $1 = $2;
            $1 += $2;
            cmp word ptr [bp - 0x24], 1;
            if (a != b) {  // jne 0xf51a
                // Block 0xF51A
                push($1);
                push($1);
                push($1);
                lcall [si];
            } else {
                // Block 0xF513
                lcall 0xc6c, 0xe5;
                if (a < b (unsigned)) {  // jb 0xf521
                    // Block 0xF521
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    $1 = $2;
                    $1 -= $2;
                    $1 = $2;
                    $1 += $2;
                    cmp word ptr [bp - 0x24], 1;
                    if (a != b) {  // jne 0xf53c
                        // Block 0xF53C
                        push($1);
                        push($1);
                        push($1);
                        lcall [si];
                    } else {
                        // Block 0xF535
                        lcall 0xc6c, 0xe5;
                        if (a < b (unsigned)) {  // jb 0xf543
                            // Block 0xF543
                            $1 = pop();
                            $1 = pop();
                            push($1);
                            push($1);
                            // Compare $1 with $2
                            if (a != b) {  // jne 0xf54f
                                // Block 0xF54F
                                $1 = $2;
                                $1 += $2;
                                $1 = $2;
                                $1 -= $2;
                                cmp word ptr [bp - 0x24], 1;
                                if (a != b) {  // jne 0xf566
                                    // Block 0xF566
                                    push($1);
                                    push($1);
                                    push($1);
                                    lcall [si];
                                } else {
                                    // Block 0xF55F
                                    lcall 0xc6c, 0xe5;
                                    if (a < b (unsigned)) {  // jb 0xf56d
                                        // Block 0xF56D
                                        $1 = pop();
                                        $1 = pop();
                                        push($1);
                                        push($1);
                                        $1 = $2;
                                        $1 -= $2;
                                        $1 = $2;
                                        $1 -= $2;
                                        cmp word ptr [bp - 0x24], 1;
                                        if (a != b) {  // jne 0xf588
                                            // Block 0xF588
                                            push($1);
                                            push($1);
                                            push($1);
                                            lcall [si];
                                            jmp 0xf5d2;
                                            // Block 0xF5D2
                                            $1 = pop();
                                            $1 = pop();
                                            *($1) = $2;
                                            *($1) = $2;
                                            return;  // retf 
                                        } else {
                                            // Block 0xF581
                                            lcall 0xc6c, 0xe5;
                                            if (a < b (unsigned)) {  // jb 0xf5d2
                                                // Block 0xF5D2
                                                $1 = pop();
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                return;  // retf 
                                            } else {
                                                // Block 0xF588
                                                push($1);
                                                push($1);
                                                push($1);
                                                lcall [si];
                                                jmp 0xf5d2;
                                                // Block 0xF5D2
                                                $1 = pop();
                                                $1 = pop();
                                                *($1) = $2;
                                                *($1) = $2;
                                                return;  // retf 
                                            }
                                        }
                                    } else {
                                        // Block 0xF566
                                        push($1);
                                        push($1);
                                        push($1);
                                        lcall [si];
                                    }
                                }
                            } else {
                                // Block 0xF54C
                                jmp 0xf5d2;
                                // Block 0xF5D2
                                $1 = pop();
                                $1 = pop();
                                *($1) = $2;
                                *($1) = $2;
                                return;  // retf 
                            }
                        } else {
                            // Block 0xF53C
                            push($1);
                            push($1);
                            push($1);
                            lcall [si];
                        }
                    }
                } else {
                    // Block 0xF51A
                    push($1);
                    push($1);
                    push($1);
                    lcall [si];
                }
            }
        } else {
            // Block 0xF500
            jmp 0xf591;
            // Block 0xF591
            $1 = $2;
            $1 = $2;
            $1 += $2;
            cmp word ptr [bp - 0x24], 1;
            if (a != b) {  // jne 0xf5a6
                // Block 0xF5A6
                push($1);
                push($1);
                push($1);
                lcall [si];
            } else {
                // Block 0xF59F
                lcall 0xc6c, 0xe5;
                if (a < b (unsigned)) {  // jb 0xf5ad
                    // Block 0xF5AD
                    $1 = pop();
                    $1 = pop();
                    push($1);
                    push($1);
                    // Compare $1 with $2
                    if (a == b) {  // je 0xf5d2
                        // Block 0xF5D2
                        $1 = pop();
                        $1 = pop();
                        *($1) = $2;
                        *($1) = $2;
                        return;  // retf 
                    } else {
                        // Block 0xF5B6
                        $1 = $2;
                        $1 = $2;
                        $1 -= $2;
                        cmp word ptr [bp - 0x24], 1;
                        if (a != b) {  // jne 0xf5cb
                            // Block 0xF5CB
                            push($1);
                            push($1);
                            push($1);
                            lcall [si];
                        } else {
                            // Block 0xF5C4
                            lcall 0xc6c, 0xe5;
                            if (a < b (unsigned)) {  // jb 0xf5d2
                                // Block 0xF5D2
                                $1 = pop();
                                $1 = pop();
                                *($1) = $2;
                                *($1) = $2;
                                return;  // retf 
                            } else {
                                // Block 0xF5CB
                                push($1);
                                push($1);
                                push($1);
                                lcall [si];
                            }
                        }
                    }
                } else {
                    // Block 0xF5A6
                    push($1);
                    push($1);
                    push($1);
                    lcall [si];
                }
            }
        }
    }
}

void sub_F5DB() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 7 if statements

    // Block 0xF5DB
    push($1);
    $1 = $2;
    mul cx;
    or dx, dx;
    if (a == b) {  // je 0xf5e8
        // Block 0xF5E8
        xchg cx, ax;
        $1 = pop();
        mul dx;
        add dx, cx;
    } else {
        // Block 0xF5E4
        $1 = pop();
        stc ;
        jmp 0xf5ee;
        // Block 0xF5EE
        return;  // retf 
    }

    // Function calls:
    sub_F768();
    sub_F768();
}

void sub_F768() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 15 if statements

    // Block 0xF768
    push($1);
    $1 = $2;
    $1 -= $2;
    push($1);
    push($1);
    push($1);
    push($1);
    $1 = $2;
    $1 = $2;
    cld ;
    cmp byte ptr [0x6d33], 1;
    if (a == b) {  // je 0xf783
        // Block 0xF783
        mov byte ptr [bp - 0x4e], 0;
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        cmp word ptr [si + 0x3c], 1;
        if (a != b) {  // jne 0xf7c2
            // Block 0xF7C2
            $1 = $2;
            $1 = $2;
            or bx, word ptr [si + 0x32];
            if (a == b) {  // je 0xf7db
                // Block 0xF7DB
                $1 = $2;
                // Compare $1 with $2
                if (a <= b) {  // jle 0xf7f6
                    // Block 0xF7F6
                    cmp word ptr [si + 0x18], 1;
                    if (a != b) {  // jne 0xf835
                        // Block 0xF835
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        shr ax, 1;
                        *($1) = $2;
                        cmp word ptr [si], 1;
                        if (a != b) {  // jne 0xf85c
                            // Block 0xF85C
                            $1 = $2;
                            $1 = $2;
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0xf86d
                                // Block 0xF86D
                                mov word ptr [bp - 2], 0xfffa;
                                jmp 0xf8b4;
                                // Block 0xF8B4
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 8
                            } else {
                                // Block 0xF868
                                // Compare $1 with $2
                                if (a <= b (unsigned)) {  // jbe 0xf874
                                    // Block 0xF874
                                    $1 = $2;
                                    mul dx;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x2c], 0;
                                    if (a != b) {  // jne 0xf8a7
                                        // Block 0xF8A7
                                        nop ;
                                        nop ;
                                        jmp 0xf9de;
                                        // Block 0xF9DE
                                    } else {
                                        // Block 0xF881
                                        cmp word ptr [bp - 0x2a], -1;
                                        if (a == b) {  // je 0xf89e
                                            // Block 0xF89E
                                            $1 = $2;
                                            *($1) = $2;
                                            ljmp [si + 4];
                                        } else {
                                            // Block 0xF887
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF88F
                                                $1 = $2;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0xf8ac
                                                    // Block 0xF8AC
                                                    nop ;
                                                    nop ;
                                                    goto $1;
                                                    mov word ptr [bp - 2], ax;
                                                    // Block 0xFBCF
                                                } else {
                                                    // Block 0xF897
                                                    $1 = $2;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0xf8ac
                                                        // Block 0xF8AC
                                                        nop ;
                                                        nop ;
                                                        goto $1;
                                                        mov word ptr [bp - 2], ax;
                                                        // Block 0xFBCF
                                                    } else {
                                                        // Block 0xF89E
                                                        $1 = $2;
                                                        *($1) = $2;
                                                        ljmp [si + 4];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xF86D
                                    mov word ptr [bp - 2], 0xfffa;
                                    jmp 0xf8b4;
                                    // Block 0xF8B4
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 8
                                }
                            }
                        } else {
                            // Block 0xF854
                            $1 = $2;
                            $1 = $2;
                            jmp 0xf874;
                            // Block 0xF874
                            $1 = $2;
                            mul dx;
                            $1 += $2;
                            cmp word ptr [bp - 0x2c], 0;
                            if (a != b) {  // jne 0xf8a7
                                // Block 0xF8A7
                                nop ;
                                nop ;
                                jmp 0xf9de;
                                // Block 0xF9DE
                            } else {
                                // Block 0xF881
                                cmp word ptr [bp - 0x2a], -1;
                                if (a == b) {  // je 0xf89e
                                    // Block 0xF89E
                                    $1 = $2;
                                    *($1) = $2;
                                    ljmp [si + 4];
                                } else {
                                    // Block 0xF887
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xf8ac
                                        // Block 0xF8AC
                                        nop ;
                                        nop ;
                                        goto $1;
                                        mov word ptr [bp - 2], ax;
                                        // Block 0xFBCF
                                    } else {
                                        // Block 0xF88F
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xf8ac
                                            // Block 0xF8AC
                                            nop ;
                                            nop ;
                                            goto $1;
                                            mov word ptr [bp - 2], ax;
                                            // Block 0xFBCF
                                        } else {
                                            // Block 0xF897
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF89E
                                                $1 = $2;
                                                *($1) = $2;
                                                ljmp [si + 4];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xF7FC
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        lcall 0xc6c, 0x10c;
                        if (a >= b (unsigned)) {  // jae 0xf817
                            // Block 0xF817
                            // Compare $1 with $2
                            if (a == b) {  // je 0xf829
                                // Block 0xF829
                                *($1) = $2;
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [bp + 6], dx;
                            } else {
                                // Block 0xF81C
                                push($1);
                                $1 = $2;
                                $1 -= $2;
                                and cl, 7;
                                ror word ptr [bp - 0x2a], cl;
                                pop cx;
                            }
                        } else {
                            // Block 0xF80F
                            mov word ptr [bp - 2], 0;
                            jmp 0xf8b4;
                            // Block 0xF8B4
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    }
                } else {
                    // Block 0xF7E3
                    xchg word ptr [bp + 8], ax;
                    *($1) = $2;
                    $1 = $2;
                    xchg word ptr [bp + 6], ax;
                    *($1) = $2;
                    mov byte ptr [bp - 0x4e], 1;
                }
            } else {
                // Block 0xF7CC
                $1 = $2;
                add word ptr [bp + 0xc], ax;
                add word ptr [bp + 0xa], bx;
                add word ptr [bp + 8], ax;
                add word ptr [bp + 6], bx;
            }
        } else {
            // Block 0xF796
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            mov word ptr [bp + 6], ax;
        }
    } else {
        // Block 0xF77F
        push($1);
        call 0xf8c1;
        // Block 0xF783
        mov byte ptr [bp - 0x4e], 0;
        $1 = $2;
        $1 = $2;
        *($1) = $2;
        cmp word ptr [si + 0x3c], 1;
        if (a != b) {  // jne 0xf7c2
            // Block 0xF7C2
            $1 = $2;
            $1 = $2;
            or bx, word ptr [si + 0x32];
            if (a == b) {  // je 0xf7db
                // Block 0xF7DB
                $1 = $2;
                // Compare $1 with $2
                if (a <= b) {  // jle 0xf7f6
                    // Block 0xF7F6
                    cmp word ptr [si + 0x18], 1;
                    if (a != b) {  // jne 0xf835
                        // Block 0xF835
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        *($1) = $2;
                        $1 = $2;
                        shr ax, 1;
                        *($1) = $2;
                        cmp word ptr [si], 1;
                        if (a != b) {  // jne 0xf85c
                            // Block 0xF85C
                            $1 = $2;
                            $1 = $2;
                            // Compare $1 with $2
                            if (a < b (unsigned)) {  // jb 0xf86d
                                // Block 0xF86D
                                mov word ptr [bp - 2], 0xfffa;
                                jmp 0xf8b4;
                                // Block 0xF8B4
                                $1 = $2;
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = pop();
                                $1 = $2;
                                $1 = pop();
                                return;  // retf 8
                            } else {
                                // Block 0xF868
                                // Compare $1 with $2
                                if (a <= b (unsigned)) {  // jbe 0xf874
                                    // Block 0xF874
                                    $1 = $2;
                                    mul dx;
                                    $1 += $2;
                                    cmp word ptr [bp - 0x2c], 0;
                                    if (a != b) {  // jne 0xf8a7
                                        // Block 0xF8A7
                                        nop ;
                                        nop ;
                                        jmp 0xf9de;
                                        // Block 0xF9DE
                                    } else {
                                        // Block 0xF881
                                        cmp word ptr [bp - 0x2a], -1;
                                        if (a == b) {  // je 0xf89e
                                            // Block 0xF89E
                                            $1 = $2;
                                            *($1) = $2;
                                            ljmp [si + 4];
                                        } else {
                                            // Block 0xF887
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF88F
                                                $1 = $2;
                                                // Compare $1 with $2
                                                if (a != b) {  // jne 0xf8ac
                                                    // Block 0xF8AC
                                                    nop ;
                                                    nop ;
                                                    goto $1;
                                                    mov word ptr [bp - 2], ax;
                                                    // Block 0xFBCF
                                                } else {
                                                    // Block 0xF897
                                                    $1 = $2;
                                                    // Compare $1 with $2
                                                    if (a != b) {  // jne 0xf8ac
                                                        // Block 0xF8AC
                                                        nop ;
                                                        nop ;
                                                        goto $1;
                                                        mov word ptr [bp - 2], ax;
                                                        // Block 0xFBCF
                                                    } else {
                                                        // Block 0xF89E
                                                        $1 = $2;
                                                        *($1) = $2;
                                                        ljmp [si + 4];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    // Block 0xF86D
                                    mov word ptr [bp - 2], 0xfffa;
                                    jmp 0xf8b4;
                                    // Block 0xF8B4
                                    $1 = $2;
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = pop();
                                    $1 = $2;
                                    $1 = pop();
                                    return;  // retf 8
                                }
                            }
                        } else {
                            // Block 0xF854
                            $1 = $2;
                            $1 = $2;
                            jmp 0xf874;
                            // Block 0xF874
                            $1 = $2;
                            mul dx;
                            $1 += $2;
                            cmp word ptr [bp - 0x2c], 0;
                            if (a != b) {  // jne 0xf8a7
                                // Block 0xF8A7
                                nop ;
                                nop ;
                                jmp 0xf9de;
                                // Block 0xF9DE
                            } else {
                                // Block 0xF881
                                cmp word ptr [bp - 0x2a], -1;
                                if (a == b) {  // je 0xf89e
                                    // Block 0xF89E
                                    $1 = $2;
                                    *($1) = $2;
                                    ljmp [si + 4];
                                } else {
                                    // Block 0xF887
                                    $1 = $2;
                                    // Compare $1 with $2
                                    if (a != b) {  // jne 0xf8ac
                                        // Block 0xF8AC
                                        nop ;
                                        nop ;
                                        goto $1;
                                        mov word ptr [bp - 2], ax;
                                        // Block 0xFBCF
                                    } else {
                                        // Block 0xF88F
                                        $1 = $2;
                                        // Compare $1 with $2
                                        if (a != b) {  // jne 0xf8ac
                                            // Block 0xF8AC
                                            nop ;
                                            nop ;
                                            goto $1;
                                            mov word ptr [bp - 2], ax;
                                            // Block 0xFBCF
                                        } else {
                                            // Block 0xF897
                                            $1 = $2;
                                            // Compare $1 with $2
                                            if (a != b) {  // jne 0xf8ac
                                                // Block 0xF8AC
                                                nop ;
                                                nop ;
                                                goto $1;
                                                mov word ptr [bp - 2], ax;
                                                // Block 0xFBCF
                                            } else {
                                                // Block 0xF89E
                                                $1 = $2;
                                                *($1) = $2;
                                                ljmp [si + 4];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Block 0xF7FC
                        push($1);
                        push($1);
                        push($1);
                        push($1);
                        lcall 0xc6c, 0x10c;
                        if (a >= b (unsigned)) {  // jae 0xf817
                            // Block 0xF817
                            // Compare $1 with $2
                            if (a == b) {  // je 0xf829
                                // Block 0xF829
                                *($1) = $2;
                                *($1) = $2;
                                *($1) = $2;
                                mov word ptr [bp + 6], dx;
                            } else {
                                // Block 0xF81C
                                push($1);
                                $1 = $2;
                                $1 -= $2;
                                and cl, 7;
                                ror word ptr [bp - 0x2a], cl;
                                pop cx;
                            }
                        } else {
                            // Block 0xF80F
                            mov word ptr [bp - 2], 0;
                            jmp 0xf8b4;
                            // Block 0xF8B4
                            $1 = $2;
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = pop();
                            $1 = $2;
                            $1 = pop();
                            return;  // retf 8
                        }
                    }
                } else {
                    // Block 0xF7E3
                    xchg word ptr [bp + 8], ax;
                    *($1) = $2;
                    $1 = $2;
                    xchg word ptr [bp + 6], ax;
                    *($1) = $2;
                    mov byte ptr [bp - 0x4e], 1;
                }
            } else {
                // Block 0xF7CC
                $1 = $2;
                add word ptr [bp + 0xc], ax;
                add word ptr [bp + 0xa], bx;
                add word ptr [bp + 8], ax;
                add word ptr [bp + 6], bx;
            }
        } else {
            // Block 0xF796
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x21c;
            *($1) = $2;
            push($1);
            lcall 0x1214, 0x26c;
            mov word ptr [bp + 6], ax;
        }
    }

    // Function calls:
    sub_F8C1();
}

void sub_F8C1() {
    // Variable declarations
    int reg_ax;
    int reg_bx;
    int reg_cx;
    int reg_dx;
    int reg_si;
    int reg_di;
    int reg_bp;
    char dos_cmd_line_len;
    // Unknown type: dos_cmd_line
    struct dos_fcb1;
    struct dos_fcb2;
    int dos_env_segment;

    // Control flow structures identified:
    // - 96 if statements

    // Block 0xF8C1
    $1 = $2;
    mov word ptr [bx + 4], 0x7b9;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x968;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xe74;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xff1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xb0f;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0xcea;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x10e1;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    $1 = $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov word ptr [bx + 4], 0x129e;
    mov word ptr [bx + 6], 0xd9f;
    $1 += $2;
    mov byte ptr [0x6d33], 1;
    return;  // retf 

    // Function calls:
    sub_F768();
    sub_F768();
    sub_F768();
    sub_F768();
    sub_F768();
}
